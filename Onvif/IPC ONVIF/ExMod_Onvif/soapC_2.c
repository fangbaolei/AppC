/* soapC.c
   Generated by gSOAP 2.8.0 from onvif.h
   Copyright(C) 2000-2010, Robert van Engelen, Genivia Inc. All Rights Reserved.
   The generated code is released under one of the following licenses:
   GPL, the gSOAP public license, or Genivia's license for commercial use.
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "soapH.h"

SOAP_FMAC3 struct _trt__GetCompatibleAudioDecoderConfigurationsResponse * SOAP_FMAC4 soap_in__trt__GetCompatibleAudioDecoderConfigurationsResponse(struct soap *soap, const char *tag, struct _trt__GetCompatibleAudioDecoderConfigurationsResponse *a, const char *type)
{
	struct soap_blist *soap_blist_Configurations = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trt__GetCompatibleAudioDecoderConfigurationsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetCompatibleAudioDecoderConfigurationsResponse, sizeof(struct _trt__GetCompatibleAudioDecoderConfigurationsResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__GetCompatibleAudioDecoderConfigurationsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "trt:Configurations", 1, NULL))
			{	if (a->Configurations == NULL)
				{	if (soap_blist_Configurations == NULL)
						soap_blist_Configurations = soap_new_block(soap);
					a->Configurations = (struct tt__AudioDecoderConfiguration *)soap_push_block(soap, soap_blist_Configurations, sizeof(struct tt__AudioDecoderConfiguration));
					if (a->Configurations == NULL)
						return NULL;
					soap_default_tt__AudioDecoderConfiguration(soap, a->Configurations);
				}
				soap_revert(soap);
				if (soap_in_tt__AudioDecoderConfiguration(soap, "trt:Configurations", a->Configurations, "tt:AudioDecoderConfiguration"))
				{	a->__sizeConfigurations++;
					a->Configurations = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizeConfigurations");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Configurations)
			soap_pop_block(soap, soap_blist_Configurations);
		if (a->__sizeConfigurations)
			a->Configurations = (struct tt__AudioDecoderConfiguration *)soap_save_block(soap, soap_blist_Configurations, NULL, 1);
		else
		{	a->Configurations = NULL;
			if (soap_blist_Configurations)
				soap_end_block(soap, soap_blist_Configurations);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trt__GetCompatibleAudioDecoderConfigurationsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetCompatibleAudioDecoderConfigurationsResponse, 0, sizeof(struct _trt__GetCompatibleAudioDecoderConfigurationsResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__GetCompatibleAudioDecoderConfigurationsResponse(struct soap *soap, const struct _trt__GetCompatibleAudioDecoderConfigurationsResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__trt__GetCompatibleAudioDecoderConfigurationsResponse);
	if (soap_out__trt__GetCompatibleAudioDecoderConfigurationsResponse(soap, tag?tag:"trt:GetCompatibleAudioDecoderConfigurationsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetCompatibleAudioDecoderConfigurationsResponse * SOAP_FMAC4 soap_get__trt__GetCompatibleAudioDecoderConfigurationsResponse(struct soap *soap, struct _trt__GetCompatibleAudioDecoderConfigurationsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__GetCompatibleAudioDecoderConfigurationsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__GetCompatibleAudioDecoderConfigurations(struct soap *soap, struct _trt__GetCompatibleAudioDecoderConfigurations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ProfileToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__GetCompatibleAudioDecoderConfigurations(struct soap *soap, const struct _trt__GetCompatibleAudioDecoderConfigurations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_tt__ReferenceToken(soap, &a->ProfileToken);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__GetCompatibleAudioDecoderConfigurations(struct soap *soap, const char *tag, int id, const struct _trt__GetCompatibleAudioDecoderConfigurations *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__GetCompatibleAudioDecoderConfigurations), type))
		return soap->error;
	if (a->ProfileToken)
	{	if (soap_out_tt__ReferenceToken(soap, "trt:ProfileToken", -1, &a->ProfileToken, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "trt:ProfileToken"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__GetCompatibleAudioDecoderConfigurations * SOAP_FMAC4 soap_in__trt__GetCompatibleAudioDecoderConfigurations(struct soap *soap, const char *tag, struct _trt__GetCompatibleAudioDecoderConfigurations *a, const char *type)
{
	size_t soap_flag_ProfileToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trt__GetCompatibleAudioDecoderConfigurations *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetCompatibleAudioDecoderConfigurations, sizeof(struct _trt__GetCompatibleAudioDecoderConfigurations), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__GetCompatibleAudioDecoderConfigurations(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "trt:ProfileToken", &a->ProfileToken, "tt:ReferenceToken"))
				{	soap_flag_ProfileToken--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trt__GetCompatibleAudioDecoderConfigurations *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetCompatibleAudioDecoderConfigurations, 0, sizeof(struct _trt__GetCompatibleAudioDecoderConfigurations), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ProfileToken > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__GetCompatibleAudioDecoderConfigurations(struct soap *soap, const struct _trt__GetCompatibleAudioDecoderConfigurations *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__trt__GetCompatibleAudioDecoderConfigurations);
	if (soap_out__trt__GetCompatibleAudioDecoderConfigurations(soap, tag?tag:"trt:GetCompatibleAudioDecoderConfigurations", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetCompatibleAudioDecoderConfigurations * SOAP_FMAC4 soap_get__trt__GetCompatibleAudioDecoderConfigurations(struct soap *soap, struct _trt__GetCompatibleAudioDecoderConfigurations *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__GetCompatibleAudioDecoderConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__GetCompatibleAudioOutputConfigurationsResponse(struct soap *soap, struct _trt__GetCompatibleAudioOutputConfigurationsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeConfigurations = 0;
	a->Configurations = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__GetCompatibleAudioOutputConfigurationsResponse(struct soap *soap, const struct _trt__GetCompatibleAudioOutputConfigurationsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->Configurations)
	{	int i;
		for (i = 0; i < a->__sizeConfigurations; i++)
		{
			soap_embedded(soap, a->Configurations + i, SOAP_TYPE_tt__AudioOutputConfiguration);
			soap_serialize_tt__AudioOutputConfiguration(soap, a->Configurations + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__GetCompatibleAudioOutputConfigurationsResponse(struct soap *soap, const char *tag, int id, const struct _trt__GetCompatibleAudioOutputConfigurationsResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__GetCompatibleAudioOutputConfigurationsResponse), type))
		return soap->error;
	soap_element_result(soap, "-sizeConfigurations");
	if (a->Configurations)
	{	int i;
		for (i = 0; i < a->__sizeConfigurations; i++)
			if (soap_out_tt__AudioOutputConfiguration(soap, "trt:Configurations", -1, a->Configurations + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__GetCompatibleAudioOutputConfigurationsResponse * SOAP_FMAC4 soap_in__trt__GetCompatibleAudioOutputConfigurationsResponse(struct soap *soap, const char *tag, struct _trt__GetCompatibleAudioOutputConfigurationsResponse *a, const char *type)
{
	struct soap_blist *soap_blist_Configurations = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trt__GetCompatibleAudioOutputConfigurationsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetCompatibleAudioOutputConfigurationsResponse, sizeof(struct _trt__GetCompatibleAudioOutputConfigurationsResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__GetCompatibleAudioOutputConfigurationsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "trt:Configurations", 1, NULL))
			{	if (a->Configurations == NULL)
				{	if (soap_blist_Configurations == NULL)
						soap_blist_Configurations = soap_new_block(soap);
					a->Configurations = (struct tt__AudioOutputConfiguration *)soap_push_block(soap, soap_blist_Configurations, sizeof(struct tt__AudioOutputConfiguration));
					if (a->Configurations == NULL)
						return NULL;
					soap_default_tt__AudioOutputConfiguration(soap, a->Configurations);
				}
				soap_revert(soap);
				if (soap_in_tt__AudioOutputConfiguration(soap, "trt:Configurations", a->Configurations, "tt:AudioOutputConfiguration"))
				{	a->__sizeConfigurations++;
					a->Configurations = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizeConfigurations");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Configurations)
			soap_pop_block(soap, soap_blist_Configurations);
		if (a->__sizeConfigurations)
			a->Configurations = (struct tt__AudioOutputConfiguration *)soap_save_block(soap, soap_blist_Configurations, NULL, 1);
		else
		{	a->Configurations = NULL;
			if (soap_blist_Configurations)
				soap_end_block(soap, soap_blist_Configurations);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trt__GetCompatibleAudioOutputConfigurationsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetCompatibleAudioOutputConfigurationsResponse, 0, sizeof(struct _trt__GetCompatibleAudioOutputConfigurationsResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__GetCompatibleAudioOutputConfigurationsResponse(struct soap *soap, const struct _trt__GetCompatibleAudioOutputConfigurationsResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__trt__GetCompatibleAudioOutputConfigurationsResponse);
	if (soap_out__trt__GetCompatibleAudioOutputConfigurationsResponse(soap, tag?tag:"trt:GetCompatibleAudioOutputConfigurationsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetCompatibleAudioOutputConfigurationsResponse * SOAP_FMAC4 soap_get__trt__GetCompatibleAudioOutputConfigurationsResponse(struct soap *soap, struct _trt__GetCompatibleAudioOutputConfigurationsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__GetCompatibleAudioOutputConfigurationsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__GetCompatibleAudioOutputConfigurations(struct soap *soap, struct _trt__GetCompatibleAudioOutputConfigurations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ProfileToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__GetCompatibleAudioOutputConfigurations(struct soap *soap, const struct _trt__GetCompatibleAudioOutputConfigurations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_tt__ReferenceToken(soap, &a->ProfileToken);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__GetCompatibleAudioOutputConfigurations(struct soap *soap, const char *tag, int id, const struct _trt__GetCompatibleAudioOutputConfigurations *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__GetCompatibleAudioOutputConfigurations), type))
		return soap->error;
	if (a->ProfileToken)
	{	if (soap_out_tt__ReferenceToken(soap, "trt:ProfileToken", -1, &a->ProfileToken, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "trt:ProfileToken"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__GetCompatibleAudioOutputConfigurations * SOAP_FMAC4 soap_in__trt__GetCompatibleAudioOutputConfigurations(struct soap *soap, const char *tag, struct _trt__GetCompatibleAudioOutputConfigurations *a, const char *type)
{
	size_t soap_flag_ProfileToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trt__GetCompatibleAudioOutputConfigurations *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetCompatibleAudioOutputConfigurations, sizeof(struct _trt__GetCompatibleAudioOutputConfigurations), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__GetCompatibleAudioOutputConfigurations(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "trt:ProfileToken", &a->ProfileToken, "tt:ReferenceToken"))
				{	soap_flag_ProfileToken--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trt__GetCompatibleAudioOutputConfigurations *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetCompatibleAudioOutputConfigurations, 0, sizeof(struct _trt__GetCompatibleAudioOutputConfigurations), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ProfileToken > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__GetCompatibleAudioOutputConfigurations(struct soap *soap, const struct _trt__GetCompatibleAudioOutputConfigurations *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__trt__GetCompatibleAudioOutputConfigurations);
	if (soap_out__trt__GetCompatibleAudioOutputConfigurations(soap, tag?tag:"trt:GetCompatibleAudioOutputConfigurations", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetCompatibleAudioOutputConfigurations * SOAP_FMAC4 soap_get__trt__GetCompatibleAudioOutputConfigurations(struct soap *soap, struct _trt__GetCompatibleAudioOutputConfigurations *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__GetCompatibleAudioOutputConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__GetCompatibleMetadataConfigurationsResponse(struct soap *soap, struct _trt__GetCompatibleMetadataConfigurationsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeConfigurations = 0;
	a->Configurations = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__GetCompatibleMetadataConfigurationsResponse(struct soap *soap, const struct _trt__GetCompatibleMetadataConfigurationsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->Configurations)
	{	int i;
		for (i = 0; i < a->__sizeConfigurations; i++)
		{
			soap_embedded(soap, a->Configurations + i, SOAP_TYPE_tt__MetadataConfiguration);
			soap_serialize_tt__MetadataConfiguration(soap, a->Configurations + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__GetCompatibleMetadataConfigurationsResponse(struct soap *soap, const char *tag, int id, const struct _trt__GetCompatibleMetadataConfigurationsResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__GetCompatibleMetadataConfigurationsResponse), type))
		return soap->error;
	soap_element_result(soap, "-sizeConfigurations");
	if (a->Configurations)
	{	int i;
		for (i = 0; i < a->__sizeConfigurations; i++)
			if (soap_out_tt__MetadataConfiguration(soap, "trt:Configurations", -1, a->Configurations + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__GetCompatibleMetadataConfigurationsResponse * SOAP_FMAC4 soap_in__trt__GetCompatibleMetadataConfigurationsResponse(struct soap *soap, const char *tag, struct _trt__GetCompatibleMetadataConfigurationsResponse *a, const char *type)
{
	struct soap_blist *soap_blist_Configurations = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trt__GetCompatibleMetadataConfigurationsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetCompatibleMetadataConfigurationsResponse, sizeof(struct _trt__GetCompatibleMetadataConfigurationsResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__GetCompatibleMetadataConfigurationsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "trt:Configurations", 1, NULL))
			{	if (a->Configurations == NULL)
				{	if (soap_blist_Configurations == NULL)
						soap_blist_Configurations = soap_new_block(soap);
					a->Configurations = (struct tt__MetadataConfiguration *)soap_push_block(soap, soap_blist_Configurations, sizeof(struct tt__MetadataConfiguration));
					if (a->Configurations == NULL)
						return NULL;
					soap_default_tt__MetadataConfiguration(soap, a->Configurations);
				}
				soap_revert(soap);
				if (soap_in_tt__MetadataConfiguration(soap, "trt:Configurations", a->Configurations, "tt:MetadataConfiguration"))
				{	a->__sizeConfigurations++;
					a->Configurations = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizeConfigurations");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Configurations)
			soap_pop_block(soap, soap_blist_Configurations);
		if (a->__sizeConfigurations)
			a->Configurations = (struct tt__MetadataConfiguration *)soap_save_block(soap, soap_blist_Configurations, NULL, 1);
		else
		{	a->Configurations = NULL;
			if (soap_blist_Configurations)
				soap_end_block(soap, soap_blist_Configurations);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trt__GetCompatibleMetadataConfigurationsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetCompatibleMetadataConfigurationsResponse, 0, sizeof(struct _trt__GetCompatibleMetadataConfigurationsResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__GetCompatibleMetadataConfigurationsResponse(struct soap *soap, const struct _trt__GetCompatibleMetadataConfigurationsResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__trt__GetCompatibleMetadataConfigurationsResponse);
	if (soap_out__trt__GetCompatibleMetadataConfigurationsResponse(soap, tag?tag:"trt:GetCompatibleMetadataConfigurationsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetCompatibleMetadataConfigurationsResponse * SOAP_FMAC4 soap_get__trt__GetCompatibleMetadataConfigurationsResponse(struct soap *soap, struct _trt__GetCompatibleMetadataConfigurationsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__GetCompatibleMetadataConfigurationsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__GetCompatibleMetadataConfigurations(struct soap *soap, struct _trt__GetCompatibleMetadataConfigurations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ProfileToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__GetCompatibleMetadataConfigurations(struct soap *soap, const struct _trt__GetCompatibleMetadataConfigurations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_tt__ReferenceToken(soap, &a->ProfileToken);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__GetCompatibleMetadataConfigurations(struct soap *soap, const char *tag, int id, const struct _trt__GetCompatibleMetadataConfigurations *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__GetCompatibleMetadataConfigurations), type))
		return soap->error;
	if (a->ProfileToken)
	{	if (soap_out_tt__ReferenceToken(soap, "trt:ProfileToken", -1, &a->ProfileToken, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "trt:ProfileToken"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__GetCompatibleMetadataConfigurations * SOAP_FMAC4 soap_in__trt__GetCompatibleMetadataConfigurations(struct soap *soap, const char *tag, struct _trt__GetCompatibleMetadataConfigurations *a, const char *type)
{
	size_t soap_flag_ProfileToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trt__GetCompatibleMetadataConfigurations *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetCompatibleMetadataConfigurations, sizeof(struct _trt__GetCompatibleMetadataConfigurations), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__GetCompatibleMetadataConfigurations(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "trt:ProfileToken", &a->ProfileToken, "tt:ReferenceToken"))
				{	soap_flag_ProfileToken--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trt__GetCompatibleMetadataConfigurations *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetCompatibleMetadataConfigurations, 0, sizeof(struct _trt__GetCompatibleMetadataConfigurations), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ProfileToken > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__GetCompatibleMetadataConfigurations(struct soap *soap, const struct _trt__GetCompatibleMetadataConfigurations *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__trt__GetCompatibleMetadataConfigurations);
	if (soap_out__trt__GetCompatibleMetadataConfigurations(soap, tag?tag:"trt:GetCompatibleMetadataConfigurations", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetCompatibleMetadataConfigurations * SOAP_FMAC4 soap_get__trt__GetCompatibleMetadataConfigurations(struct soap *soap, struct _trt__GetCompatibleMetadataConfigurations *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__GetCompatibleMetadataConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__GetCompatibleVideoAnalyticsConfigurationsResponse(struct soap *soap, struct _trt__GetCompatibleVideoAnalyticsConfigurationsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeConfigurations = 0;
	a->Configurations = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__GetCompatibleVideoAnalyticsConfigurationsResponse(struct soap *soap, const struct _trt__GetCompatibleVideoAnalyticsConfigurationsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->Configurations)
	{	int i;
		for (i = 0; i < a->__sizeConfigurations; i++)
		{
			soap_embedded(soap, a->Configurations + i, SOAP_TYPE_tt__VideoAnalyticsConfiguration);
			soap_serialize_tt__VideoAnalyticsConfiguration(soap, a->Configurations + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__GetCompatibleVideoAnalyticsConfigurationsResponse(struct soap *soap, const char *tag, int id, const struct _trt__GetCompatibleVideoAnalyticsConfigurationsResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__GetCompatibleVideoAnalyticsConfigurationsResponse), type))
		return soap->error;
	soap_element_result(soap, "-sizeConfigurations");
	if (a->Configurations)
	{	int i;
		for (i = 0; i < a->__sizeConfigurations; i++)
			if (soap_out_tt__VideoAnalyticsConfiguration(soap, "trt:Configurations", -1, a->Configurations + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__GetCompatibleVideoAnalyticsConfigurationsResponse * SOAP_FMAC4 soap_in__trt__GetCompatibleVideoAnalyticsConfigurationsResponse(struct soap *soap, const char *tag, struct _trt__GetCompatibleVideoAnalyticsConfigurationsResponse *a, const char *type)
{
	struct soap_blist *soap_blist_Configurations = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trt__GetCompatibleVideoAnalyticsConfigurationsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetCompatibleVideoAnalyticsConfigurationsResponse, sizeof(struct _trt__GetCompatibleVideoAnalyticsConfigurationsResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__GetCompatibleVideoAnalyticsConfigurationsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "trt:Configurations", 1, NULL))
			{	if (a->Configurations == NULL)
				{	if (soap_blist_Configurations == NULL)
						soap_blist_Configurations = soap_new_block(soap);
					a->Configurations = (struct tt__VideoAnalyticsConfiguration *)soap_push_block(soap, soap_blist_Configurations, sizeof(struct tt__VideoAnalyticsConfiguration));
					if (a->Configurations == NULL)
						return NULL;
					soap_default_tt__VideoAnalyticsConfiguration(soap, a->Configurations);
				}
				soap_revert(soap);
				if (soap_in_tt__VideoAnalyticsConfiguration(soap, "trt:Configurations", a->Configurations, "tt:VideoAnalyticsConfiguration"))
				{	a->__sizeConfigurations++;
					a->Configurations = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizeConfigurations");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Configurations)
			soap_pop_block(soap, soap_blist_Configurations);
		if (a->__sizeConfigurations)
			a->Configurations = (struct tt__VideoAnalyticsConfiguration *)soap_save_block(soap, soap_blist_Configurations, NULL, 1);
		else
		{	a->Configurations = NULL;
			if (soap_blist_Configurations)
				soap_end_block(soap, soap_blist_Configurations);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trt__GetCompatibleVideoAnalyticsConfigurationsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetCompatibleVideoAnalyticsConfigurationsResponse, 0, sizeof(struct _trt__GetCompatibleVideoAnalyticsConfigurationsResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__GetCompatibleVideoAnalyticsConfigurationsResponse(struct soap *soap, const struct _trt__GetCompatibleVideoAnalyticsConfigurationsResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__trt__GetCompatibleVideoAnalyticsConfigurationsResponse);
	if (soap_out__trt__GetCompatibleVideoAnalyticsConfigurationsResponse(soap, tag?tag:"trt:GetCompatibleVideoAnalyticsConfigurationsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetCompatibleVideoAnalyticsConfigurationsResponse * SOAP_FMAC4 soap_get__trt__GetCompatibleVideoAnalyticsConfigurationsResponse(struct soap *soap, struct _trt__GetCompatibleVideoAnalyticsConfigurationsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__GetCompatibleVideoAnalyticsConfigurationsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__GetCompatibleVideoAnalyticsConfigurations(struct soap *soap, struct _trt__GetCompatibleVideoAnalyticsConfigurations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ProfileToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__GetCompatibleVideoAnalyticsConfigurations(struct soap *soap, const struct _trt__GetCompatibleVideoAnalyticsConfigurations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_tt__ReferenceToken(soap, &a->ProfileToken);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__GetCompatibleVideoAnalyticsConfigurations(struct soap *soap, const char *tag, int id, const struct _trt__GetCompatibleVideoAnalyticsConfigurations *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__GetCompatibleVideoAnalyticsConfigurations), type))
		return soap->error;
	if (a->ProfileToken)
	{	if (soap_out_tt__ReferenceToken(soap, "trt:ProfileToken", -1, &a->ProfileToken, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "trt:ProfileToken"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__GetCompatibleVideoAnalyticsConfigurations * SOAP_FMAC4 soap_in__trt__GetCompatibleVideoAnalyticsConfigurations(struct soap *soap, const char *tag, struct _trt__GetCompatibleVideoAnalyticsConfigurations *a, const char *type)
{
	size_t soap_flag_ProfileToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trt__GetCompatibleVideoAnalyticsConfigurations *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetCompatibleVideoAnalyticsConfigurations, sizeof(struct _trt__GetCompatibleVideoAnalyticsConfigurations), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__GetCompatibleVideoAnalyticsConfigurations(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "trt:ProfileToken", &a->ProfileToken, "tt:ReferenceToken"))
				{	soap_flag_ProfileToken--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trt__GetCompatibleVideoAnalyticsConfigurations *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetCompatibleVideoAnalyticsConfigurations, 0, sizeof(struct _trt__GetCompatibleVideoAnalyticsConfigurations), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ProfileToken > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__GetCompatibleVideoAnalyticsConfigurations(struct soap *soap, const struct _trt__GetCompatibleVideoAnalyticsConfigurations *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__trt__GetCompatibleVideoAnalyticsConfigurations);
	if (soap_out__trt__GetCompatibleVideoAnalyticsConfigurations(soap, tag?tag:"trt:GetCompatibleVideoAnalyticsConfigurations", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetCompatibleVideoAnalyticsConfigurations * SOAP_FMAC4 soap_get__trt__GetCompatibleVideoAnalyticsConfigurations(struct soap *soap, struct _trt__GetCompatibleVideoAnalyticsConfigurations *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__GetCompatibleVideoAnalyticsConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__GetCompatibleAudioSourceConfigurationsResponse(struct soap *soap, struct _trt__GetCompatibleAudioSourceConfigurationsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeConfigurations = 0;
	a->Configurations = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__GetCompatibleAudioSourceConfigurationsResponse(struct soap *soap, const struct _trt__GetCompatibleAudioSourceConfigurationsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->Configurations)
	{	int i;
		for (i = 0; i < a->__sizeConfigurations; i++)
		{
			soap_embedded(soap, a->Configurations + i, SOAP_TYPE_tt__AudioSourceConfiguration);
			soap_serialize_tt__AudioSourceConfiguration(soap, a->Configurations + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__GetCompatibleAudioSourceConfigurationsResponse(struct soap *soap, const char *tag, int id, const struct _trt__GetCompatibleAudioSourceConfigurationsResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__GetCompatibleAudioSourceConfigurationsResponse), type))
		return soap->error;
	soap_element_result(soap, "-sizeConfigurations");
	if (a->Configurations)
	{	int i;
		for (i = 0; i < a->__sizeConfigurations; i++)
			if (soap_out_tt__AudioSourceConfiguration(soap, "trt:Configurations", -1, a->Configurations + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__GetCompatibleAudioSourceConfigurationsResponse * SOAP_FMAC4 soap_in__trt__GetCompatibleAudioSourceConfigurationsResponse(struct soap *soap, const char *tag, struct _trt__GetCompatibleAudioSourceConfigurationsResponse *a, const char *type)
{
	struct soap_blist *soap_blist_Configurations = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trt__GetCompatibleAudioSourceConfigurationsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetCompatibleAudioSourceConfigurationsResponse, sizeof(struct _trt__GetCompatibleAudioSourceConfigurationsResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__GetCompatibleAudioSourceConfigurationsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "trt:Configurations", 1, NULL))
			{	if (a->Configurations == NULL)
				{	if (soap_blist_Configurations == NULL)
						soap_blist_Configurations = soap_new_block(soap);
					a->Configurations = (struct tt__AudioSourceConfiguration *)soap_push_block(soap, soap_blist_Configurations, sizeof(struct tt__AudioSourceConfiguration));
					if (a->Configurations == NULL)
						return NULL;
					soap_default_tt__AudioSourceConfiguration(soap, a->Configurations);
				}
				soap_revert(soap);
				if (soap_in_tt__AudioSourceConfiguration(soap, "trt:Configurations", a->Configurations, "tt:AudioSourceConfiguration"))
				{	a->__sizeConfigurations++;
					a->Configurations = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizeConfigurations");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Configurations)
			soap_pop_block(soap, soap_blist_Configurations);
		if (a->__sizeConfigurations)
			a->Configurations = (struct tt__AudioSourceConfiguration *)soap_save_block(soap, soap_blist_Configurations, NULL, 1);
		else
		{	a->Configurations = NULL;
			if (soap_blist_Configurations)
				soap_end_block(soap, soap_blist_Configurations);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trt__GetCompatibleAudioSourceConfigurationsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetCompatibleAudioSourceConfigurationsResponse, 0, sizeof(struct _trt__GetCompatibleAudioSourceConfigurationsResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__GetCompatibleAudioSourceConfigurationsResponse(struct soap *soap, const struct _trt__GetCompatibleAudioSourceConfigurationsResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__trt__GetCompatibleAudioSourceConfigurationsResponse);
	if (soap_out__trt__GetCompatibleAudioSourceConfigurationsResponse(soap, tag?tag:"trt:GetCompatibleAudioSourceConfigurationsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetCompatibleAudioSourceConfigurationsResponse * SOAP_FMAC4 soap_get__trt__GetCompatibleAudioSourceConfigurationsResponse(struct soap *soap, struct _trt__GetCompatibleAudioSourceConfigurationsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__GetCompatibleAudioSourceConfigurationsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__GetCompatibleAudioSourceConfigurations(struct soap *soap, struct _trt__GetCompatibleAudioSourceConfigurations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ProfileToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__GetCompatibleAudioSourceConfigurations(struct soap *soap, const struct _trt__GetCompatibleAudioSourceConfigurations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_tt__ReferenceToken(soap, &a->ProfileToken);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__GetCompatibleAudioSourceConfigurations(struct soap *soap, const char *tag, int id, const struct _trt__GetCompatibleAudioSourceConfigurations *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__GetCompatibleAudioSourceConfigurations), type))
		return soap->error;
	if (a->ProfileToken)
	{	if (soap_out_tt__ReferenceToken(soap, "trt:ProfileToken", -1, &a->ProfileToken, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "trt:ProfileToken"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__GetCompatibleAudioSourceConfigurations * SOAP_FMAC4 soap_in__trt__GetCompatibleAudioSourceConfigurations(struct soap *soap, const char *tag, struct _trt__GetCompatibleAudioSourceConfigurations *a, const char *type)
{
	size_t soap_flag_ProfileToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trt__GetCompatibleAudioSourceConfigurations *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetCompatibleAudioSourceConfigurations, sizeof(struct _trt__GetCompatibleAudioSourceConfigurations), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__GetCompatibleAudioSourceConfigurations(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "trt:ProfileToken", &a->ProfileToken, "tt:ReferenceToken"))
				{	soap_flag_ProfileToken--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trt__GetCompatibleAudioSourceConfigurations *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetCompatibleAudioSourceConfigurations, 0, sizeof(struct _trt__GetCompatibleAudioSourceConfigurations), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ProfileToken > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__GetCompatibleAudioSourceConfigurations(struct soap *soap, const struct _trt__GetCompatibleAudioSourceConfigurations *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__trt__GetCompatibleAudioSourceConfigurations);
	if (soap_out__trt__GetCompatibleAudioSourceConfigurations(soap, tag?tag:"trt:GetCompatibleAudioSourceConfigurations", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetCompatibleAudioSourceConfigurations * SOAP_FMAC4 soap_get__trt__GetCompatibleAudioSourceConfigurations(struct soap *soap, struct _trt__GetCompatibleAudioSourceConfigurations *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__GetCompatibleAudioSourceConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__GetCompatibleAudioEncoderConfigurationsResponse(struct soap *soap, struct _trt__GetCompatibleAudioEncoderConfigurationsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeConfigurations = 0;
	a->Configurations = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__GetCompatibleAudioEncoderConfigurationsResponse(struct soap *soap, const struct _trt__GetCompatibleAudioEncoderConfigurationsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->Configurations)
	{	int i;
		for (i = 0; i < a->__sizeConfigurations; i++)
		{
			soap_embedded(soap, a->Configurations + i, SOAP_TYPE_tt__AudioEncoderConfiguration);
			soap_serialize_tt__AudioEncoderConfiguration(soap, a->Configurations + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__GetCompatibleAudioEncoderConfigurationsResponse(struct soap *soap, const char *tag, int id, const struct _trt__GetCompatibleAudioEncoderConfigurationsResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__GetCompatibleAudioEncoderConfigurationsResponse), type))
		return soap->error;
	soap_element_result(soap, "-sizeConfigurations");
	if (a->Configurations)
	{	int i;
		for (i = 0; i < a->__sizeConfigurations; i++)
			if (soap_out_tt__AudioEncoderConfiguration(soap, "trt:Configurations", -1, a->Configurations + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__GetCompatibleAudioEncoderConfigurationsResponse * SOAP_FMAC4 soap_in__trt__GetCompatibleAudioEncoderConfigurationsResponse(struct soap *soap, const char *tag, struct _trt__GetCompatibleAudioEncoderConfigurationsResponse *a, const char *type)
{
	struct soap_blist *soap_blist_Configurations = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trt__GetCompatibleAudioEncoderConfigurationsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetCompatibleAudioEncoderConfigurationsResponse, sizeof(struct _trt__GetCompatibleAudioEncoderConfigurationsResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__GetCompatibleAudioEncoderConfigurationsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "trt:Configurations", 1, NULL))
			{	if (a->Configurations == NULL)
				{	if (soap_blist_Configurations == NULL)
						soap_blist_Configurations = soap_new_block(soap);
					a->Configurations = (struct tt__AudioEncoderConfiguration *)soap_push_block(soap, soap_blist_Configurations, sizeof(struct tt__AudioEncoderConfiguration));
					if (a->Configurations == NULL)
						return NULL;
					soap_default_tt__AudioEncoderConfiguration(soap, a->Configurations);
				}
				soap_revert(soap);
				if (soap_in_tt__AudioEncoderConfiguration(soap, "trt:Configurations", a->Configurations, "tt:AudioEncoderConfiguration"))
				{	a->__sizeConfigurations++;
					a->Configurations = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizeConfigurations");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Configurations)
			soap_pop_block(soap, soap_blist_Configurations);
		if (a->__sizeConfigurations)
			a->Configurations = (struct tt__AudioEncoderConfiguration *)soap_save_block(soap, soap_blist_Configurations, NULL, 1);
		else
		{	a->Configurations = NULL;
			if (soap_blist_Configurations)
				soap_end_block(soap, soap_blist_Configurations);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trt__GetCompatibleAudioEncoderConfigurationsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetCompatibleAudioEncoderConfigurationsResponse, 0, sizeof(struct _trt__GetCompatibleAudioEncoderConfigurationsResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__GetCompatibleAudioEncoderConfigurationsResponse(struct soap *soap, const struct _trt__GetCompatibleAudioEncoderConfigurationsResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__trt__GetCompatibleAudioEncoderConfigurationsResponse);
	if (soap_out__trt__GetCompatibleAudioEncoderConfigurationsResponse(soap, tag?tag:"trt:GetCompatibleAudioEncoderConfigurationsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetCompatibleAudioEncoderConfigurationsResponse * SOAP_FMAC4 soap_get__trt__GetCompatibleAudioEncoderConfigurationsResponse(struct soap *soap, struct _trt__GetCompatibleAudioEncoderConfigurationsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__GetCompatibleAudioEncoderConfigurationsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__GetCompatibleAudioEncoderConfigurations(struct soap *soap, struct _trt__GetCompatibleAudioEncoderConfigurations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ProfileToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__GetCompatibleAudioEncoderConfigurations(struct soap *soap, const struct _trt__GetCompatibleAudioEncoderConfigurations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_tt__ReferenceToken(soap, &a->ProfileToken);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__GetCompatibleAudioEncoderConfigurations(struct soap *soap, const char *tag, int id, const struct _trt__GetCompatibleAudioEncoderConfigurations *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__GetCompatibleAudioEncoderConfigurations), type))
		return soap->error;
	if (a->ProfileToken)
	{	if (soap_out_tt__ReferenceToken(soap, "trt:ProfileToken", -1, &a->ProfileToken, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "trt:ProfileToken"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__GetCompatibleAudioEncoderConfigurations * SOAP_FMAC4 soap_in__trt__GetCompatibleAudioEncoderConfigurations(struct soap *soap, const char *tag, struct _trt__GetCompatibleAudioEncoderConfigurations *a, const char *type)
{
	size_t soap_flag_ProfileToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trt__GetCompatibleAudioEncoderConfigurations *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetCompatibleAudioEncoderConfigurations, sizeof(struct _trt__GetCompatibleAudioEncoderConfigurations), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__GetCompatibleAudioEncoderConfigurations(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "trt:ProfileToken", &a->ProfileToken, "tt:ReferenceToken"))
				{	soap_flag_ProfileToken--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trt__GetCompatibleAudioEncoderConfigurations *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetCompatibleAudioEncoderConfigurations, 0, sizeof(struct _trt__GetCompatibleAudioEncoderConfigurations), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ProfileToken > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__GetCompatibleAudioEncoderConfigurations(struct soap *soap, const struct _trt__GetCompatibleAudioEncoderConfigurations *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__trt__GetCompatibleAudioEncoderConfigurations);
	if (soap_out__trt__GetCompatibleAudioEncoderConfigurations(soap, tag?tag:"trt:GetCompatibleAudioEncoderConfigurations", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetCompatibleAudioEncoderConfigurations * SOAP_FMAC4 soap_get__trt__GetCompatibleAudioEncoderConfigurations(struct soap *soap, struct _trt__GetCompatibleAudioEncoderConfigurations *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__GetCompatibleAudioEncoderConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__GetCompatibleVideoSourceConfigurationsResponse(struct soap *soap, struct _trt__GetCompatibleVideoSourceConfigurationsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeConfigurations = 0;
	a->Configurations = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__GetCompatibleVideoSourceConfigurationsResponse(struct soap *soap, const struct _trt__GetCompatibleVideoSourceConfigurationsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->Configurations)
	{	int i;
		for (i = 0; i < a->__sizeConfigurations; i++)
		{
			soap_embedded(soap, a->Configurations + i, SOAP_TYPE_tt__VideoSourceConfiguration);
			soap_serialize_tt__VideoSourceConfiguration(soap, a->Configurations + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__GetCompatibleVideoSourceConfigurationsResponse(struct soap *soap, const char *tag, int id, const struct _trt__GetCompatibleVideoSourceConfigurationsResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__GetCompatibleVideoSourceConfigurationsResponse), type))
		return soap->error;
	soap_element_result(soap, "-sizeConfigurations");
	if (a->Configurations)
	{	int i;
		for (i = 0; i < a->__sizeConfigurations; i++)
			if (soap_out_tt__VideoSourceConfiguration(soap, "trt:Configurations", -1, a->Configurations + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__GetCompatibleVideoSourceConfigurationsResponse * SOAP_FMAC4 soap_in__trt__GetCompatibleVideoSourceConfigurationsResponse(struct soap *soap, const char *tag, struct _trt__GetCompatibleVideoSourceConfigurationsResponse *a, const char *type)
{
	struct soap_blist *soap_blist_Configurations = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trt__GetCompatibleVideoSourceConfigurationsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetCompatibleVideoSourceConfigurationsResponse, sizeof(struct _trt__GetCompatibleVideoSourceConfigurationsResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__GetCompatibleVideoSourceConfigurationsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "trt:Configurations", 1, NULL))
			{	if (a->Configurations == NULL)
				{	if (soap_blist_Configurations == NULL)
						soap_blist_Configurations = soap_new_block(soap);
					a->Configurations = (struct tt__VideoSourceConfiguration *)soap_push_block(soap, soap_blist_Configurations, sizeof(struct tt__VideoSourceConfiguration));
					if (a->Configurations == NULL)
						return NULL;
					soap_default_tt__VideoSourceConfiguration(soap, a->Configurations);
				}
				soap_revert(soap);
				if (soap_in_tt__VideoSourceConfiguration(soap, "trt:Configurations", a->Configurations, "tt:VideoSourceConfiguration"))
				{	a->__sizeConfigurations++;
					a->Configurations = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizeConfigurations");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Configurations)
			soap_pop_block(soap, soap_blist_Configurations);
		if (a->__sizeConfigurations)
			a->Configurations = (struct tt__VideoSourceConfiguration *)soap_save_block(soap, soap_blist_Configurations, NULL, 1);
		else
		{	a->Configurations = NULL;
			if (soap_blist_Configurations)
				soap_end_block(soap, soap_blist_Configurations);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trt__GetCompatibleVideoSourceConfigurationsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetCompatibleVideoSourceConfigurationsResponse, 0, sizeof(struct _trt__GetCompatibleVideoSourceConfigurationsResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__GetCompatibleVideoSourceConfigurationsResponse(struct soap *soap, const struct _trt__GetCompatibleVideoSourceConfigurationsResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__trt__GetCompatibleVideoSourceConfigurationsResponse);
	if (soap_out__trt__GetCompatibleVideoSourceConfigurationsResponse(soap, tag?tag:"trt:GetCompatibleVideoSourceConfigurationsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetCompatibleVideoSourceConfigurationsResponse * SOAP_FMAC4 soap_get__trt__GetCompatibleVideoSourceConfigurationsResponse(struct soap *soap, struct _trt__GetCompatibleVideoSourceConfigurationsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__GetCompatibleVideoSourceConfigurationsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__GetCompatibleVideoSourceConfigurations(struct soap *soap, struct _trt__GetCompatibleVideoSourceConfigurations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ProfileToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__GetCompatibleVideoSourceConfigurations(struct soap *soap, const struct _trt__GetCompatibleVideoSourceConfigurations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_tt__ReferenceToken(soap, &a->ProfileToken);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__GetCompatibleVideoSourceConfigurations(struct soap *soap, const char *tag, int id, const struct _trt__GetCompatibleVideoSourceConfigurations *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__GetCompatibleVideoSourceConfigurations), type))
		return soap->error;
	if (a->ProfileToken)
	{	if (soap_out_tt__ReferenceToken(soap, "trt:ProfileToken", -1, &a->ProfileToken, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "trt:ProfileToken"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__GetCompatibleVideoSourceConfigurations * SOAP_FMAC4 soap_in__trt__GetCompatibleVideoSourceConfigurations(struct soap *soap, const char *tag, struct _trt__GetCompatibleVideoSourceConfigurations *a, const char *type)
{
	size_t soap_flag_ProfileToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trt__GetCompatibleVideoSourceConfigurations *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetCompatibleVideoSourceConfigurations, sizeof(struct _trt__GetCompatibleVideoSourceConfigurations), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__GetCompatibleVideoSourceConfigurations(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "trt:ProfileToken", &a->ProfileToken, "tt:ReferenceToken"))
				{	soap_flag_ProfileToken--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trt__GetCompatibleVideoSourceConfigurations *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetCompatibleVideoSourceConfigurations, 0, sizeof(struct _trt__GetCompatibleVideoSourceConfigurations), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ProfileToken > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__GetCompatibleVideoSourceConfigurations(struct soap *soap, const struct _trt__GetCompatibleVideoSourceConfigurations *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__trt__GetCompatibleVideoSourceConfigurations);
	if (soap_out__trt__GetCompatibleVideoSourceConfigurations(soap, tag?tag:"trt:GetCompatibleVideoSourceConfigurations", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetCompatibleVideoSourceConfigurations * SOAP_FMAC4 soap_get__trt__GetCompatibleVideoSourceConfigurations(struct soap *soap, struct _trt__GetCompatibleVideoSourceConfigurations *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__GetCompatibleVideoSourceConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__GetCompatibleVideoEncoderConfigurationsResponse(struct soap *soap, struct _trt__GetCompatibleVideoEncoderConfigurationsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeConfigurations = 0;
	a->Configurations = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__GetCompatibleVideoEncoderConfigurationsResponse(struct soap *soap, const struct _trt__GetCompatibleVideoEncoderConfigurationsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->Configurations)
	{	int i;
		for (i = 0; i < a->__sizeConfigurations; i++)
		{
			soap_embedded(soap, a->Configurations + i, SOAP_TYPE_tt__VideoEncoderConfiguration);
			soap_serialize_tt__VideoEncoderConfiguration(soap, a->Configurations + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__GetCompatibleVideoEncoderConfigurationsResponse(struct soap *soap, const char *tag, int id, const struct _trt__GetCompatibleVideoEncoderConfigurationsResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__GetCompatibleVideoEncoderConfigurationsResponse), type))
		return soap->error;
	soap_element_result(soap, "-sizeConfigurations");
	if (a->Configurations)
	{	int i;
		for (i = 0; i < a->__sizeConfigurations; i++)
			if (soap_out_tt__VideoEncoderConfiguration(soap, "trt:Configurations", -1, a->Configurations + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__GetCompatibleVideoEncoderConfigurationsResponse * SOAP_FMAC4 soap_in__trt__GetCompatibleVideoEncoderConfigurationsResponse(struct soap *soap, const char *tag, struct _trt__GetCompatibleVideoEncoderConfigurationsResponse *a, const char *type)
{
	struct soap_blist *soap_blist_Configurations = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trt__GetCompatibleVideoEncoderConfigurationsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetCompatibleVideoEncoderConfigurationsResponse, sizeof(struct _trt__GetCompatibleVideoEncoderConfigurationsResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__GetCompatibleVideoEncoderConfigurationsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "trt:Configurations", 1, NULL))
			{	if (a->Configurations == NULL)
				{	if (soap_blist_Configurations == NULL)
						soap_blist_Configurations = soap_new_block(soap);
					a->Configurations = (struct tt__VideoEncoderConfiguration *)soap_push_block(soap, soap_blist_Configurations, sizeof(struct tt__VideoEncoderConfiguration));
					if (a->Configurations == NULL)
						return NULL;
					soap_default_tt__VideoEncoderConfiguration(soap, a->Configurations);
				}
				soap_revert(soap);
				if (soap_in_tt__VideoEncoderConfiguration(soap, "trt:Configurations", a->Configurations, "tt:VideoEncoderConfiguration"))
				{	a->__sizeConfigurations++;
					a->Configurations = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizeConfigurations");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Configurations)
			soap_pop_block(soap, soap_blist_Configurations);
		if (a->__sizeConfigurations)
			a->Configurations = (struct tt__VideoEncoderConfiguration *)soap_save_block(soap, soap_blist_Configurations, NULL, 1);
		else
		{	a->Configurations = NULL;
			if (soap_blist_Configurations)
				soap_end_block(soap, soap_blist_Configurations);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trt__GetCompatibleVideoEncoderConfigurationsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetCompatibleVideoEncoderConfigurationsResponse, 0, sizeof(struct _trt__GetCompatibleVideoEncoderConfigurationsResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__GetCompatibleVideoEncoderConfigurationsResponse(struct soap *soap, const struct _trt__GetCompatibleVideoEncoderConfigurationsResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__trt__GetCompatibleVideoEncoderConfigurationsResponse);
	if (soap_out__trt__GetCompatibleVideoEncoderConfigurationsResponse(soap, tag?tag:"trt:GetCompatibleVideoEncoderConfigurationsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetCompatibleVideoEncoderConfigurationsResponse * SOAP_FMAC4 soap_get__trt__GetCompatibleVideoEncoderConfigurationsResponse(struct soap *soap, struct _trt__GetCompatibleVideoEncoderConfigurationsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__GetCompatibleVideoEncoderConfigurationsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__GetCompatibleVideoEncoderConfigurations(struct soap *soap, struct _trt__GetCompatibleVideoEncoderConfigurations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ProfileToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__GetCompatibleVideoEncoderConfigurations(struct soap *soap, const struct _trt__GetCompatibleVideoEncoderConfigurations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_tt__ReferenceToken(soap, &a->ProfileToken);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__GetCompatibleVideoEncoderConfigurations(struct soap *soap, const char *tag, int id, const struct _trt__GetCompatibleVideoEncoderConfigurations *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__GetCompatibleVideoEncoderConfigurations), type))
		return soap->error;
	if (a->ProfileToken)
	{	if (soap_out_tt__ReferenceToken(soap, "trt:ProfileToken", -1, &a->ProfileToken, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "trt:ProfileToken"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__GetCompatibleVideoEncoderConfigurations * SOAP_FMAC4 soap_in__trt__GetCompatibleVideoEncoderConfigurations(struct soap *soap, const char *tag, struct _trt__GetCompatibleVideoEncoderConfigurations *a, const char *type)
{
	size_t soap_flag_ProfileToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trt__GetCompatibleVideoEncoderConfigurations *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetCompatibleVideoEncoderConfigurations, sizeof(struct _trt__GetCompatibleVideoEncoderConfigurations), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__GetCompatibleVideoEncoderConfigurations(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "trt:ProfileToken", &a->ProfileToken, "tt:ReferenceToken"))
				{	soap_flag_ProfileToken--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trt__GetCompatibleVideoEncoderConfigurations *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetCompatibleVideoEncoderConfigurations, 0, sizeof(struct _trt__GetCompatibleVideoEncoderConfigurations), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ProfileToken > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__GetCompatibleVideoEncoderConfigurations(struct soap *soap, const struct _trt__GetCompatibleVideoEncoderConfigurations *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__trt__GetCompatibleVideoEncoderConfigurations);
	if (soap_out__trt__GetCompatibleVideoEncoderConfigurations(soap, tag?tag:"trt:GetCompatibleVideoEncoderConfigurations", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetCompatibleVideoEncoderConfigurations * SOAP_FMAC4 soap_get__trt__GetCompatibleVideoEncoderConfigurations(struct soap *soap, struct _trt__GetCompatibleVideoEncoderConfigurations *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__GetCompatibleVideoEncoderConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__GetAudioDecoderConfigurationResponse(struct soap *soap, struct _trt__GetAudioDecoderConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Configuration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__GetAudioDecoderConfigurationResponse(struct soap *soap, const struct _trt__GetAudioDecoderConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTott__AudioDecoderConfiguration(soap, &a->Configuration);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__GetAudioDecoderConfigurationResponse(struct soap *soap, const char *tag, int id, const struct _trt__GetAudioDecoderConfigurationResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__GetAudioDecoderConfigurationResponse), type))
		return soap->error;
	if (a->Configuration)
		soap_element_result(soap, "trt:Configuration");
	if (a->Configuration)
	{	if (soap_out_PointerTott__AudioDecoderConfiguration(soap, "trt:Configuration", -1, &a->Configuration, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "trt:Configuration"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__GetAudioDecoderConfigurationResponse * SOAP_FMAC4 soap_in__trt__GetAudioDecoderConfigurationResponse(struct soap *soap, const char *tag, struct _trt__GetAudioDecoderConfigurationResponse *a, const char *type)
{
	size_t soap_flag_Configuration = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trt__GetAudioDecoderConfigurationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetAudioDecoderConfigurationResponse, sizeof(struct _trt__GetAudioDecoderConfigurationResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__GetAudioDecoderConfigurationResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Configuration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__AudioDecoderConfiguration(soap, "trt:Configuration", &a->Configuration, "tt:AudioDecoderConfiguration"))
				{	soap_flag_Configuration--;
					continue;
				}
			soap_check_result(soap, "trt:Configuration");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trt__GetAudioDecoderConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetAudioDecoderConfigurationResponse, 0, sizeof(struct _trt__GetAudioDecoderConfigurationResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Configuration > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__GetAudioDecoderConfigurationResponse(struct soap *soap, const struct _trt__GetAudioDecoderConfigurationResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__trt__GetAudioDecoderConfigurationResponse);
	if (soap_out__trt__GetAudioDecoderConfigurationResponse(soap, tag?tag:"trt:GetAudioDecoderConfigurationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetAudioDecoderConfigurationResponse * SOAP_FMAC4 soap_get__trt__GetAudioDecoderConfigurationResponse(struct soap *soap, struct _trt__GetAudioDecoderConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__GetAudioDecoderConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__GetAudioDecoderConfiguration(struct soap *soap, struct _trt__GetAudioDecoderConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ConfigurationToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__GetAudioDecoderConfiguration(struct soap *soap, const struct _trt__GetAudioDecoderConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_tt__ReferenceToken(soap, &a->ConfigurationToken);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__GetAudioDecoderConfiguration(struct soap *soap, const char *tag, int id, const struct _trt__GetAudioDecoderConfiguration *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__GetAudioDecoderConfiguration), type))
		return soap->error;
	if (a->ConfigurationToken)
	{	if (soap_out_tt__ReferenceToken(soap, "trt:ConfigurationToken", -1, &a->ConfigurationToken, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "trt:ConfigurationToken"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__GetAudioDecoderConfiguration * SOAP_FMAC4 soap_in__trt__GetAudioDecoderConfiguration(struct soap *soap, const char *tag, struct _trt__GetAudioDecoderConfiguration *a, const char *type)
{
	size_t soap_flag_ConfigurationToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trt__GetAudioDecoderConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetAudioDecoderConfiguration, sizeof(struct _trt__GetAudioDecoderConfiguration), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__GetAudioDecoderConfiguration(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ConfigurationToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "trt:ConfigurationToken", &a->ConfigurationToken, "tt:ReferenceToken"))
				{	soap_flag_ConfigurationToken--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trt__GetAudioDecoderConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetAudioDecoderConfiguration, 0, sizeof(struct _trt__GetAudioDecoderConfiguration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ConfigurationToken > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__GetAudioDecoderConfiguration(struct soap *soap, const struct _trt__GetAudioDecoderConfiguration *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__trt__GetAudioDecoderConfiguration);
	if (soap_out__trt__GetAudioDecoderConfiguration(soap, tag?tag:"trt:GetAudioDecoderConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetAudioDecoderConfiguration * SOAP_FMAC4 soap_get__trt__GetAudioDecoderConfiguration(struct soap *soap, struct _trt__GetAudioDecoderConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__GetAudioDecoderConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__GetAudioOutputConfigurationResponse(struct soap *soap, struct _trt__GetAudioOutputConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Configuration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__GetAudioOutputConfigurationResponse(struct soap *soap, const struct _trt__GetAudioOutputConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTott__AudioOutputConfiguration(soap, &a->Configuration);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__GetAudioOutputConfigurationResponse(struct soap *soap, const char *tag, int id, const struct _trt__GetAudioOutputConfigurationResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__GetAudioOutputConfigurationResponse), type))
		return soap->error;
	if (a->Configuration)
		soap_element_result(soap, "trt:Configuration");
	if (a->Configuration)
	{	if (soap_out_PointerTott__AudioOutputConfiguration(soap, "trt:Configuration", -1, &a->Configuration, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "trt:Configuration"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__GetAudioOutputConfigurationResponse * SOAP_FMAC4 soap_in__trt__GetAudioOutputConfigurationResponse(struct soap *soap, const char *tag, struct _trt__GetAudioOutputConfigurationResponse *a, const char *type)
{
	size_t soap_flag_Configuration = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trt__GetAudioOutputConfigurationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetAudioOutputConfigurationResponse, sizeof(struct _trt__GetAudioOutputConfigurationResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__GetAudioOutputConfigurationResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Configuration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__AudioOutputConfiguration(soap, "trt:Configuration", &a->Configuration, "tt:AudioOutputConfiguration"))
				{	soap_flag_Configuration--;
					continue;
				}
			soap_check_result(soap, "trt:Configuration");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trt__GetAudioOutputConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetAudioOutputConfigurationResponse, 0, sizeof(struct _trt__GetAudioOutputConfigurationResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Configuration > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__GetAudioOutputConfigurationResponse(struct soap *soap, const struct _trt__GetAudioOutputConfigurationResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__trt__GetAudioOutputConfigurationResponse);
	if (soap_out__trt__GetAudioOutputConfigurationResponse(soap, tag?tag:"trt:GetAudioOutputConfigurationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetAudioOutputConfigurationResponse * SOAP_FMAC4 soap_get__trt__GetAudioOutputConfigurationResponse(struct soap *soap, struct _trt__GetAudioOutputConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__GetAudioOutputConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__GetAudioOutputConfiguration(struct soap *soap, struct _trt__GetAudioOutputConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ConfigurationToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__GetAudioOutputConfiguration(struct soap *soap, const struct _trt__GetAudioOutputConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_tt__ReferenceToken(soap, &a->ConfigurationToken);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__GetAudioOutputConfiguration(struct soap *soap, const char *tag, int id, const struct _trt__GetAudioOutputConfiguration *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__GetAudioOutputConfiguration), type))
		return soap->error;
	if (a->ConfigurationToken)
	{	if (soap_out_tt__ReferenceToken(soap, "trt:ConfigurationToken", -1, &a->ConfigurationToken, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "trt:ConfigurationToken"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__GetAudioOutputConfiguration * SOAP_FMAC4 soap_in__trt__GetAudioOutputConfiguration(struct soap *soap, const char *tag, struct _trt__GetAudioOutputConfiguration *a, const char *type)
{
	size_t soap_flag_ConfigurationToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trt__GetAudioOutputConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetAudioOutputConfiguration, sizeof(struct _trt__GetAudioOutputConfiguration), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__GetAudioOutputConfiguration(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ConfigurationToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "trt:ConfigurationToken", &a->ConfigurationToken, "tt:ReferenceToken"))
				{	soap_flag_ConfigurationToken--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trt__GetAudioOutputConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetAudioOutputConfiguration, 0, sizeof(struct _trt__GetAudioOutputConfiguration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ConfigurationToken > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__GetAudioOutputConfiguration(struct soap *soap, const struct _trt__GetAudioOutputConfiguration *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__trt__GetAudioOutputConfiguration);
	if (soap_out__trt__GetAudioOutputConfiguration(soap, tag?tag:"trt:GetAudioOutputConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetAudioOutputConfiguration * SOAP_FMAC4 soap_get__trt__GetAudioOutputConfiguration(struct soap *soap, struct _trt__GetAudioOutputConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__GetAudioOutputConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__GetMetadataConfigurationResponse(struct soap *soap, struct _trt__GetMetadataConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Configuration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__GetMetadataConfigurationResponse(struct soap *soap, const struct _trt__GetMetadataConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTott__MetadataConfiguration(soap, &a->Configuration);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__GetMetadataConfigurationResponse(struct soap *soap, const char *tag, int id, const struct _trt__GetMetadataConfigurationResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__GetMetadataConfigurationResponse), type))
		return soap->error;
	if (a->Configuration)
		soap_element_result(soap, "trt:Configuration");
	if (a->Configuration)
	{	if (soap_out_PointerTott__MetadataConfiguration(soap, "trt:Configuration", -1, &a->Configuration, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "trt:Configuration"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__GetMetadataConfigurationResponse * SOAP_FMAC4 soap_in__trt__GetMetadataConfigurationResponse(struct soap *soap, const char *tag, struct _trt__GetMetadataConfigurationResponse *a, const char *type)
{
	size_t soap_flag_Configuration = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trt__GetMetadataConfigurationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetMetadataConfigurationResponse, sizeof(struct _trt__GetMetadataConfigurationResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__GetMetadataConfigurationResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Configuration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__MetadataConfiguration(soap, "trt:Configuration", &a->Configuration, "tt:MetadataConfiguration"))
				{	soap_flag_Configuration--;
					continue;
				}
			soap_check_result(soap, "trt:Configuration");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trt__GetMetadataConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetMetadataConfigurationResponse, 0, sizeof(struct _trt__GetMetadataConfigurationResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Configuration > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__GetMetadataConfigurationResponse(struct soap *soap, const struct _trt__GetMetadataConfigurationResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__trt__GetMetadataConfigurationResponse);
	if (soap_out__trt__GetMetadataConfigurationResponse(soap, tag?tag:"trt:GetMetadataConfigurationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetMetadataConfigurationResponse * SOAP_FMAC4 soap_get__trt__GetMetadataConfigurationResponse(struct soap *soap, struct _trt__GetMetadataConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__GetMetadataConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__GetMetadataConfiguration(struct soap *soap, struct _trt__GetMetadataConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ConfigurationToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__GetMetadataConfiguration(struct soap *soap, const struct _trt__GetMetadataConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_tt__ReferenceToken(soap, &a->ConfigurationToken);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__GetMetadataConfiguration(struct soap *soap, const char *tag, int id, const struct _trt__GetMetadataConfiguration *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__GetMetadataConfiguration), type))
		return soap->error;
	if (a->ConfigurationToken)
	{	if (soap_out_tt__ReferenceToken(soap, "trt:ConfigurationToken", -1, &a->ConfigurationToken, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "trt:ConfigurationToken"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__GetMetadataConfiguration * SOAP_FMAC4 soap_in__trt__GetMetadataConfiguration(struct soap *soap, const char *tag, struct _trt__GetMetadataConfiguration *a, const char *type)
{
	size_t soap_flag_ConfigurationToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trt__GetMetadataConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetMetadataConfiguration, sizeof(struct _trt__GetMetadataConfiguration), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__GetMetadataConfiguration(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ConfigurationToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "trt:ConfigurationToken", &a->ConfigurationToken, "tt:ReferenceToken"))
				{	soap_flag_ConfigurationToken--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trt__GetMetadataConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetMetadataConfiguration, 0, sizeof(struct _trt__GetMetadataConfiguration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ConfigurationToken > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__GetMetadataConfiguration(struct soap *soap, const struct _trt__GetMetadataConfiguration *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__trt__GetMetadataConfiguration);
	if (soap_out__trt__GetMetadataConfiguration(soap, tag?tag:"trt:GetMetadataConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetMetadataConfiguration * SOAP_FMAC4 soap_get__trt__GetMetadataConfiguration(struct soap *soap, struct _trt__GetMetadataConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__GetMetadataConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__GetVideoAnalyticsConfigurationResponse(struct soap *soap, struct _trt__GetVideoAnalyticsConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Configuration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__GetVideoAnalyticsConfigurationResponse(struct soap *soap, const struct _trt__GetVideoAnalyticsConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTott__VideoAnalyticsConfiguration(soap, &a->Configuration);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__GetVideoAnalyticsConfigurationResponse(struct soap *soap, const char *tag, int id, const struct _trt__GetVideoAnalyticsConfigurationResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__GetVideoAnalyticsConfigurationResponse), type))
		return soap->error;
	if (a->Configuration)
		soap_element_result(soap, "trt:Configuration");
	if (a->Configuration)
	{	if (soap_out_PointerTott__VideoAnalyticsConfiguration(soap, "trt:Configuration", -1, &a->Configuration, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "trt:Configuration"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__GetVideoAnalyticsConfigurationResponse * SOAP_FMAC4 soap_in__trt__GetVideoAnalyticsConfigurationResponse(struct soap *soap, const char *tag, struct _trt__GetVideoAnalyticsConfigurationResponse *a, const char *type)
{
	size_t soap_flag_Configuration = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trt__GetVideoAnalyticsConfigurationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetVideoAnalyticsConfigurationResponse, sizeof(struct _trt__GetVideoAnalyticsConfigurationResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__GetVideoAnalyticsConfigurationResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Configuration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__VideoAnalyticsConfiguration(soap, "trt:Configuration", &a->Configuration, "tt:VideoAnalyticsConfiguration"))
				{	soap_flag_Configuration--;
					continue;
				}
			soap_check_result(soap, "trt:Configuration");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trt__GetVideoAnalyticsConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetVideoAnalyticsConfigurationResponse, 0, sizeof(struct _trt__GetVideoAnalyticsConfigurationResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Configuration > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__GetVideoAnalyticsConfigurationResponse(struct soap *soap, const struct _trt__GetVideoAnalyticsConfigurationResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__trt__GetVideoAnalyticsConfigurationResponse);
	if (soap_out__trt__GetVideoAnalyticsConfigurationResponse(soap, tag?tag:"trt:GetVideoAnalyticsConfigurationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetVideoAnalyticsConfigurationResponse * SOAP_FMAC4 soap_get__trt__GetVideoAnalyticsConfigurationResponse(struct soap *soap, struct _trt__GetVideoAnalyticsConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__GetVideoAnalyticsConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__GetVideoAnalyticsConfiguration(struct soap *soap, struct _trt__GetVideoAnalyticsConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ConfigurationToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__GetVideoAnalyticsConfiguration(struct soap *soap, const struct _trt__GetVideoAnalyticsConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_tt__ReferenceToken(soap, &a->ConfigurationToken);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__GetVideoAnalyticsConfiguration(struct soap *soap, const char *tag, int id, const struct _trt__GetVideoAnalyticsConfiguration *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__GetVideoAnalyticsConfiguration), type))
		return soap->error;
	if (a->ConfigurationToken)
	{	if (soap_out_tt__ReferenceToken(soap, "trt:ConfigurationToken", -1, &a->ConfigurationToken, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "trt:ConfigurationToken"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__GetVideoAnalyticsConfiguration * SOAP_FMAC4 soap_in__trt__GetVideoAnalyticsConfiguration(struct soap *soap, const char *tag, struct _trt__GetVideoAnalyticsConfiguration *a, const char *type)
{
	size_t soap_flag_ConfigurationToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trt__GetVideoAnalyticsConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetVideoAnalyticsConfiguration, sizeof(struct _trt__GetVideoAnalyticsConfiguration), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__GetVideoAnalyticsConfiguration(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ConfigurationToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "trt:ConfigurationToken", &a->ConfigurationToken, "tt:ReferenceToken"))
				{	soap_flag_ConfigurationToken--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trt__GetVideoAnalyticsConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetVideoAnalyticsConfiguration, 0, sizeof(struct _trt__GetVideoAnalyticsConfiguration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ConfigurationToken > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__GetVideoAnalyticsConfiguration(struct soap *soap, const struct _trt__GetVideoAnalyticsConfiguration *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__trt__GetVideoAnalyticsConfiguration);
	if (soap_out__trt__GetVideoAnalyticsConfiguration(soap, tag?tag:"trt:GetVideoAnalyticsConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetVideoAnalyticsConfiguration * SOAP_FMAC4 soap_get__trt__GetVideoAnalyticsConfiguration(struct soap *soap, struct _trt__GetVideoAnalyticsConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__GetVideoAnalyticsConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__GetAudioEncoderConfigurationResponse(struct soap *soap, struct _trt__GetAudioEncoderConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Configuration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__GetAudioEncoderConfigurationResponse(struct soap *soap, const struct _trt__GetAudioEncoderConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTott__AudioEncoderConfiguration(soap, &a->Configuration);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__GetAudioEncoderConfigurationResponse(struct soap *soap, const char *tag, int id, const struct _trt__GetAudioEncoderConfigurationResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__GetAudioEncoderConfigurationResponse), type))
		return soap->error;
	if (a->Configuration)
		soap_element_result(soap, "trt:Configuration");
	if (a->Configuration)
	{	if (soap_out_PointerTott__AudioEncoderConfiguration(soap, "trt:Configuration", -1, &a->Configuration, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "trt:Configuration"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__GetAudioEncoderConfigurationResponse * SOAP_FMAC4 soap_in__trt__GetAudioEncoderConfigurationResponse(struct soap *soap, const char *tag, struct _trt__GetAudioEncoderConfigurationResponse *a, const char *type)
{
	size_t soap_flag_Configuration = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trt__GetAudioEncoderConfigurationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetAudioEncoderConfigurationResponse, sizeof(struct _trt__GetAudioEncoderConfigurationResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__GetAudioEncoderConfigurationResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Configuration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__AudioEncoderConfiguration(soap, "trt:Configuration", &a->Configuration, "tt:AudioEncoderConfiguration"))
				{	soap_flag_Configuration--;
					continue;
				}
			soap_check_result(soap, "trt:Configuration");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trt__GetAudioEncoderConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetAudioEncoderConfigurationResponse, 0, sizeof(struct _trt__GetAudioEncoderConfigurationResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Configuration > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__GetAudioEncoderConfigurationResponse(struct soap *soap, const struct _trt__GetAudioEncoderConfigurationResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__trt__GetAudioEncoderConfigurationResponse);
	if (soap_out__trt__GetAudioEncoderConfigurationResponse(soap, tag?tag:"trt:GetAudioEncoderConfigurationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetAudioEncoderConfigurationResponse * SOAP_FMAC4 soap_get__trt__GetAudioEncoderConfigurationResponse(struct soap *soap, struct _trt__GetAudioEncoderConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__GetAudioEncoderConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__GetAudioEncoderConfiguration(struct soap *soap, struct _trt__GetAudioEncoderConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ConfigurationToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__GetAudioEncoderConfiguration(struct soap *soap, const struct _trt__GetAudioEncoderConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_tt__ReferenceToken(soap, &a->ConfigurationToken);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__GetAudioEncoderConfiguration(struct soap *soap, const char *tag, int id, const struct _trt__GetAudioEncoderConfiguration *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__GetAudioEncoderConfiguration), type))
		return soap->error;
	if (a->ConfigurationToken)
	{	if (soap_out_tt__ReferenceToken(soap, "trt:ConfigurationToken", -1, &a->ConfigurationToken, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "trt:ConfigurationToken"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__GetAudioEncoderConfiguration * SOAP_FMAC4 soap_in__trt__GetAudioEncoderConfiguration(struct soap *soap, const char *tag, struct _trt__GetAudioEncoderConfiguration *a, const char *type)
{
	size_t soap_flag_ConfigurationToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trt__GetAudioEncoderConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetAudioEncoderConfiguration, sizeof(struct _trt__GetAudioEncoderConfiguration), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__GetAudioEncoderConfiguration(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ConfigurationToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "trt:ConfigurationToken", &a->ConfigurationToken, "tt:ReferenceToken"))
				{	soap_flag_ConfigurationToken--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trt__GetAudioEncoderConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetAudioEncoderConfiguration, 0, sizeof(struct _trt__GetAudioEncoderConfiguration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ConfigurationToken > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__GetAudioEncoderConfiguration(struct soap *soap, const struct _trt__GetAudioEncoderConfiguration *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__trt__GetAudioEncoderConfiguration);
	if (soap_out__trt__GetAudioEncoderConfiguration(soap, tag?tag:"trt:GetAudioEncoderConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetAudioEncoderConfiguration * SOAP_FMAC4 soap_get__trt__GetAudioEncoderConfiguration(struct soap *soap, struct _trt__GetAudioEncoderConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__GetAudioEncoderConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__GetAudioSourceConfigurationResponse(struct soap *soap, struct _trt__GetAudioSourceConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Configuration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__GetAudioSourceConfigurationResponse(struct soap *soap, const struct _trt__GetAudioSourceConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTott__AudioSourceConfiguration(soap, &a->Configuration);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__GetAudioSourceConfigurationResponse(struct soap *soap, const char *tag, int id, const struct _trt__GetAudioSourceConfigurationResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__GetAudioSourceConfigurationResponse), type))
		return soap->error;
	if (a->Configuration)
		soap_element_result(soap, "trt:Configuration");
	if (a->Configuration)
	{	if (soap_out_PointerTott__AudioSourceConfiguration(soap, "trt:Configuration", -1, &a->Configuration, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "trt:Configuration"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__GetAudioSourceConfigurationResponse * SOAP_FMAC4 soap_in__trt__GetAudioSourceConfigurationResponse(struct soap *soap, const char *tag, struct _trt__GetAudioSourceConfigurationResponse *a, const char *type)
{
	size_t soap_flag_Configuration = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trt__GetAudioSourceConfigurationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetAudioSourceConfigurationResponse, sizeof(struct _trt__GetAudioSourceConfigurationResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__GetAudioSourceConfigurationResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Configuration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__AudioSourceConfiguration(soap, "trt:Configuration", &a->Configuration, "tt:AudioSourceConfiguration"))
				{	soap_flag_Configuration--;
					continue;
				}
			soap_check_result(soap, "trt:Configuration");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trt__GetAudioSourceConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetAudioSourceConfigurationResponse, 0, sizeof(struct _trt__GetAudioSourceConfigurationResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Configuration > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__GetAudioSourceConfigurationResponse(struct soap *soap, const struct _trt__GetAudioSourceConfigurationResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__trt__GetAudioSourceConfigurationResponse);
	if (soap_out__trt__GetAudioSourceConfigurationResponse(soap, tag?tag:"trt:GetAudioSourceConfigurationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetAudioSourceConfigurationResponse * SOAP_FMAC4 soap_get__trt__GetAudioSourceConfigurationResponse(struct soap *soap, struct _trt__GetAudioSourceConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__GetAudioSourceConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__GetAudioSourceConfiguration(struct soap *soap, struct _trt__GetAudioSourceConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ConfigurationToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__GetAudioSourceConfiguration(struct soap *soap, const struct _trt__GetAudioSourceConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_tt__ReferenceToken(soap, &a->ConfigurationToken);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__GetAudioSourceConfiguration(struct soap *soap, const char *tag, int id, const struct _trt__GetAudioSourceConfiguration *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__GetAudioSourceConfiguration), type))
		return soap->error;
	if (a->ConfigurationToken)
	{	if (soap_out_tt__ReferenceToken(soap, "trt:ConfigurationToken", -1, &a->ConfigurationToken, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "trt:ConfigurationToken"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__GetAudioSourceConfiguration * SOAP_FMAC4 soap_in__trt__GetAudioSourceConfiguration(struct soap *soap, const char *tag, struct _trt__GetAudioSourceConfiguration *a, const char *type)
{
	size_t soap_flag_ConfigurationToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trt__GetAudioSourceConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetAudioSourceConfiguration, sizeof(struct _trt__GetAudioSourceConfiguration), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__GetAudioSourceConfiguration(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ConfigurationToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "trt:ConfigurationToken", &a->ConfigurationToken, "tt:ReferenceToken"))
				{	soap_flag_ConfigurationToken--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trt__GetAudioSourceConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetAudioSourceConfiguration, 0, sizeof(struct _trt__GetAudioSourceConfiguration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ConfigurationToken > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__GetAudioSourceConfiguration(struct soap *soap, const struct _trt__GetAudioSourceConfiguration *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__trt__GetAudioSourceConfiguration);
	if (soap_out__trt__GetAudioSourceConfiguration(soap, tag?tag:"trt:GetAudioSourceConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetAudioSourceConfiguration * SOAP_FMAC4 soap_get__trt__GetAudioSourceConfiguration(struct soap *soap, struct _trt__GetAudioSourceConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__GetAudioSourceConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__GetVideoEncoderConfigurationResponse(struct soap *soap, struct _trt__GetVideoEncoderConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Configuration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__GetVideoEncoderConfigurationResponse(struct soap *soap, const struct _trt__GetVideoEncoderConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTott__VideoEncoderConfiguration(soap, &a->Configuration);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__GetVideoEncoderConfigurationResponse(struct soap *soap, const char *tag, int id, const struct _trt__GetVideoEncoderConfigurationResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__GetVideoEncoderConfigurationResponse), type))
		return soap->error;
	if (a->Configuration)
		soap_element_result(soap, "trt:Configuration");
	if (a->Configuration)
	{	if (soap_out_PointerTott__VideoEncoderConfiguration(soap, "trt:Configuration", -1, &a->Configuration, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "trt:Configuration"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__GetVideoEncoderConfigurationResponse * SOAP_FMAC4 soap_in__trt__GetVideoEncoderConfigurationResponse(struct soap *soap, const char *tag, struct _trt__GetVideoEncoderConfigurationResponse *a, const char *type)
{
	size_t soap_flag_Configuration = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trt__GetVideoEncoderConfigurationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetVideoEncoderConfigurationResponse, sizeof(struct _trt__GetVideoEncoderConfigurationResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__GetVideoEncoderConfigurationResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Configuration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__VideoEncoderConfiguration(soap, "trt:Configuration", &a->Configuration, "tt:VideoEncoderConfiguration"))
				{	soap_flag_Configuration--;
					continue;
				}
			soap_check_result(soap, "trt:Configuration");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trt__GetVideoEncoderConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetVideoEncoderConfigurationResponse, 0, sizeof(struct _trt__GetVideoEncoderConfigurationResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Configuration > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__GetVideoEncoderConfigurationResponse(struct soap *soap, const struct _trt__GetVideoEncoderConfigurationResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__trt__GetVideoEncoderConfigurationResponse);
	if (soap_out__trt__GetVideoEncoderConfigurationResponse(soap, tag?tag:"trt:GetVideoEncoderConfigurationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetVideoEncoderConfigurationResponse * SOAP_FMAC4 soap_get__trt__GetVideoEncoderConfigurationResponse(struct soap *soap, struct _trt__GetVideoEncoderConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__GetVideoEncoderConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__GetVideoEncoderConfiguration(struct soap *soap, struct _trt__GetVideoEncoderConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ConfigurationToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__GetVideoEncoderConfiguration(struct soap *soap, const struct _trt__GetVideoEncoderConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_tt__ReferenceToken(soap, &a->ConfigurationToken);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__GetVideoEncoderConfiguration(struct soap *soap, const char *tag, int id, const struct _trt__GetVideoEncoderConfiguration *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__GetVideoEncoderConfiguration), type))
		return soap->error;
	if (a->ConfigurationToken)
	{	if (soap_out_tt__ReferenceToken(soap, "trt:ConfigurationToken", -1, &a->ConfigurationToken, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "trt:ConfigurationToken"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__GetVideoEncoderConfiguration * SOAP_FMAC4 soap_in__trt__GetVideoEncoderConfiguration(struct soap *soap, const char *tag, struct _trt__GetVideoEncoderConfiguration *a, const char *type)
{
	size_t soap_flag_ConfigurationToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trt__GetVideoEncoderConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetVideoEncoderConfiguration, sizeof(struct _trt__GetVideoEncoderConfiguration), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__GetVideoEncoderConfiguration(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ConfigurationToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "trt:ConfigurationToken", &a->ConfigurationToken, "tt:ReferenceToken"))
				{	soap_flag_ConfigurationToken--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trt__GetVideoEncoderConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetVideoEncoderConfiguration, 0, sizeof(struct _trt__GetVideoEncoderConfiguration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ConfigurationToken > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__GetVideoEncoderConfiguration(struct soap *soap, const struct _trt__GetVideoEncoderConfiguration *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__trt__GetVideoEncoderConfiguration);
	if (soap_out__trt__GetVideoEncoderConfiguration(soap, tag?tag:"trt:GetVideoEncoderConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetVideoEncoderConfiguration * SOAP_FMAC4 soap_get__trt__GetVideoEncoderConfiguration(struct soap *soap, struct _trt__GetVideoEncoderConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__GetVideoEncoderConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__GetVideoSourceConfigurationResponse(struct soap *soap, struct _trt__GetVideoSourceConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Configuration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__GetVideoSourceConfigurationResponse(struct soap *soap, const struct _trt__GetVideoSourceConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTott__VideoSourceConfiguration(soap, &a->Configuration);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__GetVideoSourceConfigurationResponse(struct soap *soap, const char *tag, int id, const struct _trt__GetVideoSourceConfigurationResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__GetVideoSourceConfigurationResponse), type))
		return soap->error;
	if (a->Configuration)
		soap_element_result(soap, "trt:Configuration");
	if (a->Configuration)
	{	if (soap_out_PointerTott__VideoSourceConfiguration(soap, "trt:Configuration", -1, &a->Configuration, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "trt:Configuration"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__GetVideoSourceConfigurationResponse * SOAP_FMAC4 soap_in__trt__GetVideoSourceConfigurationResponse(struct soap *soap, const char *tag, struct _trt__GetVideoSourceConfigurationResponse *a, const char *type)
{
	size_t soap_flag_Configuration = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trt__GetVideoSourceConfigurationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetVideoSourceConfigurationResponse, sizeof(struct _trt__GetVideoSourceConfigurationResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__GetVideoSourceConfigurationResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Configuration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__VideoSourceConfiguration(soap, "trt:Configuration", &a->Configuration, "tt:VideoSourceConfiguration"))
				{	soap_flag_Configuration--;
					continue;
				}
			soap_check_result(soap, "trt:Configuration");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trt__GetVideoSourceConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetVideoSourceConfigurationResponse, 0, sizeof(struct _trt__GetVideoSourceConfigurationResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Configuration > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__GetVideoSourceConfigurationResponse(struct soap *soap, const struct _trt__GetVideoSourceConfigurationResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__trt__GetVideoSourceConfigurationResponse);
	if (soap_out__trt__GetVideoSourceConfigurationResponse(soap, tag?tag:"trt:GetVideoSourceConfigurationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetVideoSourceConfigurationResponse * SOAP_FMAC4 soap_get__trt__GetVideoSourceConfigurationResponse(struct soap *soap, struct _trt__GetVideoSourceConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__GetVideoSourceConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__GetVideoSourceConfiguration(struct soap *soap, struct _trt__GetVideoSourceConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ConfigurationToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__GetVideoSourceConfiguration(struct soap *soap, const struct _trt__GetVideoSourceConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_tt__ReferenceToken(soap, &a->ConfigurationToken);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__GetVideoSourceConfiguration(struct soap *soap, const char *tag, int id, const struct _trt__GetVideoSourceConfiguration *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__GetVideoSourceConfiguration), type))
		return soap->error;
	if (a->ConfigurationToken)
	{	if (soap_out_tt__ReferenceToken(soap, "trt:ConfigurationToken", -1, &a->ConfigurationToken, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "trt:ConfigurationToken"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__GetVideoSourceConfiguration * SOAP_FMAC4 soap_in__trt__GetVideoSourceConfiguration(struct soap *soap, const char *tag, struct _trt__GetVideoSourceConfiguration *a, const char *type)
{
	size_t soap_flag_ConfigurationToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trt__GetVideoSourceConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetVideoSourceConfiguration, sizeof(struct _trt__GetVideoSourceConfiguration), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__GetVideoSourceConfiguration(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ConfigurationToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "trt:ConfigurationToken", &a->ConfigurationToken, "tt:ReferenceToken"))
				{	soap_flag_ConfigurationToken--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trt__GetVideoSourceConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetVideoSourceConfiguration, 0, sizeof(struct _trt__GetVideoSourceConfiguration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ConfigurationToken > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__GetVideoSourceConfiguration(struct soap *soap, const struct _trt__GetVideoSourceConfiguration *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__trt__GetVideoSourceConfiguration);
	if (soap_out__trt__GetVideoSourceConfiguration(soap, tag?tag:"trt:GetVideoSourceConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetVideoSourceConfiguration * SOAP_FMAC4 soap_get__trt__GetVideoSourceConfiguration(struct soap *soap, struct _trt__GetVideoSourceConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__GetVideoSourceConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__GetAudioDecoderConfigurationsResponse(struct soap *soap, struct _trt__GetAudioDecoderConfigurationsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeConfigurations = 0;
	a->Configurations = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__GetAudioDecoderConfigurationsResponse(struct soap *soap, const struct _trt__GetAudioDecoderConfigurationsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->Configurations)
	{	int i;
		for (i = 0; i < a->__sizeConfigurations; i++)
		{
			soap_embedded(soap, a->Configurations + i, SOAP_TYPE_tt__AudioDecoderConfiguration);
			soap_serialize_tt__AudioDecoderConfiguration(soap, a->Configurations + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__GetAudioDecoderConfigurationsResponse(struct soap *soap, const char *tag, int id, const struct _trt__GetAudioDecoderConfigurationsResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__GetAudioDecoderConfigurationsResponse), type))
		return soap->error;
	soap_element_result(soap, "-sizeConfigurations");
	if (a->Configurations)
	{	int i;
		for (i = 0; i < a->__sizeConfigurations; i++)
			if (soap_out_tt__AudioDecoderConfiguration(soap, "trt:Configurations", -1, a->Configurations + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__GetAudioDecoderConfigurationsResponse * SOAP_FMAC4 soap_in__trt__GetAudioDecoderConfigurationsResponse(struct soap *soap, const char *tag, struct _trt__GetAudioDecoderConfigurationsResponse *a, const char *type)
{
	struct soap_blist *soap_blist_Configurations = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trt__GetAudioDecoderConfigurationsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetAudioDecoderConfigurationsResponse, sizeof(struct _trt__GetAudioDecoderConfigurationsResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__GetAudioDecoderConfigurationsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "trt:Configurations", 1, NULL))
			{	if (a->Configurations == NULL)
				{	if (soap_blist_Configurations == NULL)
						soap_blist_Configurations = soap_new_block(soap);
					a->Configurations = (struct tt__AudioDecoderConfiguration *)soap_push_block(soap, soap_blist_Configurations, sizeof(struct tt__AudioDecoderConfiguration));
					if (a->Configurations == NULL)
						return NULL;
					soap_default_tt__AudioDecoderConfiguration(soap, a->Configurations);
				}
				soap_revert(soap);
				if (soap_in_tt__AudioDecoderConfiguration(soap, "trt:Configurations", a->Configurations, "tt:AudioDecoderConfiguration"))
				{	a->__sizeConfigurations++;
					a->Configurations = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizeConfigurations");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Configurations)
			soap_pop_block(soap, soap_blist_Configurations);
		if (a->__sizeConfigurations)
			a->Configurations = (struct tt__AudioDecoderConfiguration *)soap_save_block(soap, soap_blist_Configurations, NULL, 1);
		else
		{	a->Configurations = NULL;
			if (soap_blist_Configurations)
				soap_end_block(soap, soap_blist_Configurations);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trt__GetAudioDecoderConfigurationsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetAudioDecoderConfigurationsResponse, 0, sizeof(struct _trt__GetAudioDecoderConfigurationsResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__GetAudioDecoderConfigurationsResponse(struct soap *soap, const struct _trt__GetAudioDecoderConfigurationsResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__trt__GetAudioDecoderConfigurationsResponse);
	if (soap_out__trt__GetAudioDecoderConfigurationsResponse(soap, tag?tag:"trt:GetAudioDecoderConfigurationsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetAudioDecoderConfigurationsResponse * SOAP_FMAC4 soap_get__trt__GetAudioDecoderConfigurationsResponse(struct soap *soap, struct _trt__GetAudioDecoderConfigurationsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__GetAudioDecoderConfigurationsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__GetAudioDecoderConfigurations(struct soap *soap, struct _trt__GetAudioDecoderConfigurations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__GetAudioDecoderConfigurations(struct soap *soap, const struct _trt__GetAudioDecoderConfigurations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__GetAudioDecoderConfigurations(struct soap *soap, const char *tag, int id, const struct _trt__GetAudioDecoderConfigurations *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__GetAudioDecoderConfigurations), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__GetAudioDecoderConfigurations * SOAP_FMAC4 soap_in__trt__GetAudioDecoderConfigurations(struct soap *soap, const char *tag, struct _trt__GetAudioDecoderConfigurations *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trt__GetAudioDecoderConfigurations *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetAudioDecoderConfigurations, sizeof(struct _trt__GetAudioDecoderConfigurations), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__GetAudioDecoderConfigurations(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trt__GetAudioDecoderConfigurations *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetAudioDecoderConfigurations, 0, sizeof(struct _trt__GetAudioDecoderConfigurations), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__GetAudioDecoderConfigurations(struct soap *soap, const struct _trt__GetAudioDecoderConfigurations *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__trt__GetAudioDecoderConfigurations);
	if (soap_out__trt__GetAudioDecoderConfigurations(soap, tag?tag:"trt:GetAudioDecoderConfigurations", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetAudioDecoderConfigurations * SOAP_FMAC4 soap_get__trt__GetAudioDecoderConfigurations(struct soap *soap, struct _trt__GetAudioDecoderConfigurations *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__GetAudioDecoderConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__GetAudioOutputConfigurationsResponse(struct soap *soap, struct _trt__GetAudioOutputConfigurationsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeConfigurations = 0;
	a->Configurations = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__GetAudioOutputConfigurationsResponse(struct soap *soap, const struct _trt__GetAudioOutputConfigurationsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->Configurations)
	{	int i;
		for (i = 0; i < a->__sizeConfigurations; i++)
		{
			soap_embedded(soap, a->Configurations + i, SOAP_TYPE_tt__AudioOutputConfiguration);
			soap_serialize_tt__AudioOutputConfiguration(soap, a->Configurations + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__GetAudioOutputConfigurationsResponse(struct soap *soap, const char *tag, int id, const struct _trt__GetAudioOutputConfigurationsResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__GetAudioOutputConfigurationsResponse), type))
		return soap->error;
	soap_element_result(soap, "-sizeConfigurations");
	if (a->Configurations)
	{	int i;
		for (i = 0; i < a->__sizeConfigurations; i++)
			if (soap_out_tt__AudioOutputConfiguration(soap, "trt:Configurations", -1, a->Configurations + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__GetAudioOutputConfigurationsResponse * SOAP_FMAC4 soap_in__trt__GetAudioOutputConfigurationsResponse(struct soap *soap, const char *tag, struct _trt__GetAudioOutputConfigurationsResponse *a, const char *type)
{
	struct soap_blist *soap_blist_Configurations = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trt__GetAudioOutputConfigurationsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetAudioOutputConfigurationsResponse, sizeof(struct _trt__GetAudioOutputConfigurationsResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__GetAudioOutputConfigurationsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "trt:Configurations", 1, NULL))
			{	if (a->Configurations == NULL)
				{	if (soap_blist_Configurations == NULL)
						soap_blist_Configurations = soap_new_block(soap);
					a->Configurations = (struct tt__AudioOutputConfiguration *)soap_push_block(soap, soap_blist_Configurations, sizeof(struct tt__AudioOutputConfiguration));
					if (a->Configurations == NULL)
						return NULL;
					soap_default_tt__AudioOutputConfiguration(soap, a->Configurations);
				}
				soap_revert(soap);
				if (soap_in_tt__AudioOutputConfiguration(soap, "trt:Configurations", a->Configurations, "tt:AudioOutputConfiguration"))
				{	a->__sizeConfigurations++;
					a->Configurations = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizeConfigurations");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Configurations)
			soap_pop_block(soap, soap_blist_Configurations);
		if (a->__sizeConfigurations)
			a->Configurations = (struct tt__AudioOutputConfiguration *)soap_save_block(soap, soap_blist_Configurations, NULL, 1);
		else
		{	a->Configurations = NULL;
			if (soap_blist_Configurations)
				soap_end_block(soap, soap_blist_Configurations);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trt__GetAudioOutputConfigurationsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetAudioOutputConfigurationsResponse, 0, sizeof(struct _trt__GetAudioOutputConfigurationsResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__GetAudioOutputConfigurationsResponse(struct soap *soap, const struct _trt__GetAudioOutputConfigurationsResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__trt__GetAudioOutputConfigurationsResponse);
	if (soap_out__trt__GetAudioOutputConfigurationsResponse(soap, tag?tag:"trt:GetAudioOutputConfigurationsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetAudioOutputConfigurationsResponse * SOAP_FMAC4 soap_get__trt__GetAudioOutputConfigurationsResponse(struct soap *soap, struct _trt__GetAudioOutputConfigurationsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__GetAudioOutputConfigurationsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__GetAudioOutputConfigurations(struct soap *soap, struct _trt__GetAudioOutputConfigurations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__GetAudioOutputConfigurations(struct soap *soap, const struct _trt__GetAudioOutputConfigurations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__GetAudioOutputConfigurations(struct soap *soap, const char *tag, int id, const struct _trt__GetAudioOutputConfigurations *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__GetAudioOutputConfigurations), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__GetAudioOutputConfigurations * SOAP_FMAC4 soap_in__trt__GetAudioOutputConfigurations(struct soap *soap, const char *tag, struct _trt__GetAudioOutputConfigurations *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trt__GetAudioOutputConfigurations *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetAudioOutputConfigurations, sizeof(struct _trt__GetAudioOutputConfigurations), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__GetAudioOutputConfigurations(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trt__GetAudioOutputConfigurations *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetAudioOutputConfigurations, 0, sizeof(struct _trt__GetAudioOutputConfigurations), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__GetAudioOutputConfigurations(struct soap *soap, const struct _trt__GetAudioOutputConfigurations *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__trt__GetAudioOutputConfigurations);
	if (soap_out__trt__GetAudioOutputConfigurations(soap, tag?tag:"trt:GetAudioOutputConfigurations", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetAudioOutputConfigurations * SOAP_FMAC4 soap_get__trt__GetAudioOutputConfigurations(struct soap *soap, struct _trt__GetAudioOutputConfigurations *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__GetAudioOutputConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__GetMetadataConfigurationsResponse(struct soap *soap, struct _trt__GetMetadataConfigurationsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeConfigurations = 0;
	a->Configurations = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__GetMetadataConfigurationsResponse(struct soap *soap, const struct _trt__GetMetadataConfigurationsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->Configurations)
	{	int i;
		for (i = 0; i < a->__sizeConfigurations; i++)
		{
			soap_embedded(soap, a->Configurations + i, SOAP_TYPE_tt__MetadataConfiguration);
			soap_serialize_tt__MetadataConfiguration(soap, a->Configurations + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__GetMetadataConfigurationsResponse(struct soap *soap, const char *tag, int id, const struct _trt__GetMetadataConfigurationsResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__GetMetadataConfigurationsResponse), type))
		return soap->error;
	soap_element_result(soap, "-sizeConfigurations");
	if (a->Configurations)
	{	int i;
		for (i = 0; i < a->__sizeConfigurations; i++)
			if (soap_out_tt__MetadataConfiguration(soap, "trt:Configurations", -1, a->Configurations + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__GetMetadataConfigurationsResponse * SOAP_FMAC4 soap_in__trt__GetMetadataConfigurationsResponse(struct soap *soap, const char *tag, struct _trt__GetMetadataConfigurationsResponse *a, const char *type)
{
	struct soap_blist *soap_blist_Configurations = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trt__GetMetadataConfigurationsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetMetadataConfigurationsResponse, sizeof(struct _trt__GetMetadataConfigurationsResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__GetMetadataConfigurationsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "trt:Configurations", 1, NULL))
			{	if (a->Configurations == NULL)
				{	if (soap_blist_Configurations == NULL)
						soap_blist_Configurations = soap_new_block(soap);
					a->Configurations = (struct tt__MetadataConfiguration *)soap_push_block(soap, soap_blist_Configurations, sizeof(struct tt__MetadataConfiguration));
					if (a->Configurations == NULL)
						return NULL;
					soap_default_tt__MetadataConfiguration(soap, a->Configurations);
				}
				soap_revert(soap);
				if (soap_in_tt__MetadataConfiguration(soap, "trt:Configurations", a->Configurations, "tt:MetadataConfiguration"))
				{	a->__sizeConfigurations++;
					a->Configurations = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizeConfigurations");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Configurations)
			soap_pop_block(soap, soap_blist_Configurations);
		if (a->__sizeConfigurations)
			a->Configurations = (struct tt__MetadataConfiguration *)soap_save_block(soap, soap_blist_Configurations, NULL, 1);
		else
		{	a->Configurations = NULL;
			if (soap_blist_Configurations)
				soap_end_block(soap, soap_blist_Configurations);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trt__GetMetadataConfigurationsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetMetadataConfigurationsResponse, 0, sizeof(struct _trt__GetMetadataConfigurationsResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__GetMetadataConfigurationsResponse(struct soap *soap, const struct _trt__GetMetadataConfigurationsResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__trt__GetMetadataConfigurationsResponse);
	if (soap_out__trt__GetMetadataConfigurationsResponse(soap, tag?tag:"trt:GetMetadataConfigurationsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetMetadataConfigurationsResponse * SOAP_FMAC4 soap_get__trt__GetMetadataConfigurationsResponse(struct soap *soap, struct _trt__GetMetadataConfigurationsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__GetMetadataConfigurationsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__GetMetadataConfigurations(struct soap *soap, struct _trt__GetMetadataConfigurations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__GetMetadataConfigurations(struct soap *soap, const struct _trt__GetMetadataConfigurations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__GetMetadataConfigurations(struct soap *soap, const char *tag, int id, const struct _trt__GetMetadataConfigurations *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__GetMetadataConfigurations), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__GetMetadataConfigurations * SOAP_FMAC4 soap_in__trt__GetMetadataConfigurations(struct soap *soap, const char *tag, struct _trt__GetMetadataConfigurations *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trt__GetMetadataConfigurations *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetMetadataConfigurations, sizeof(struct _trt__GetMetadataConfigurations), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__GetMetadataConfigurations(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trt__GetMetadataConfigurations *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetMetadataConfigurations, 0, sizeof(struct _trt__GetMetadataConfigurations), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__GetMetadataConfigurations(struct soap *soap, const struct _trt__GetMetadataConfigurations *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__trt__GetMetadataConfigurations);
	if (soap_out__trt__GetMetadataConfigurations(soap, tag?tag:"trt:GetMetadataConfigurations", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetMetadataConfigurations * SOAP_FMAC4 soap_get__trt__GetMetadataConfigurations(struct soap *soap, struct _trt__GetMetadataConfigurations *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__GetMetadataConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__GetVideoAnalyticsConfigurationsResponse(struct soap *soap, struct _trt__GetVideoAnalyticsConfigurationsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeConfigurations = 0;
	a->Configurations = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__GetVideoAnalyticsConfigurationsResponse(struct soap *soap, const struct _trt__GetVideoAnalyticsConfigurationsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->Configurations)
	{	int i;
		for (i = 0; i < a->__sizeConfigurations; i++)
		{
			soap_embedded(soap, a->Configurations + i, SOAP_TYPE_tt__VideoAnalyticsConfiguration);
			soap_serialize_tt__VideoAnalyticsConfiguration(soap, a->Configurations + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__GetVideoAnalyticsConfigurationsResponse(struct soap *soap, const char *tag, int id, const struct _trt__GetVideoAnalyticsConfigurationsResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__GetVideoAnalyticsConfigurationsResponse), type))
		return soap->error;
	soap_element_result(soap, "-sizeConfigurations");
	if (a->Configurations)
	{	int i;
		for (i = 0; i < a->__sizeConfigurations; i++)
			if (soap_out_tt__VideoAnalyticsConfiguration(soap, "trt:Configurations", -1, a->Configurations + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__GetVideoAnalyticsConfigurationsResponse * SOAP_FMAC4 soap_in__trt__GetVideoAnalyticsConfigurationsResponse(struct soap *soap, const char *tag, struct _trt__GetVideoAnalyticsConfigurationsResponse *a, const char *type)
{
	struct soap_blist *soap_blist_Configurations = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trt__GetVideoAnalyticsConfigurationsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetVideoAnalyticsConfigurationsResponse, sizeof(struct _trt__GetVideoAnalyticsConfigurationsResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__GetVideoAnalyticsConfigurationsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "trt:Configurations", 1, NULL))
			{	if (a->Configurations == NULL)
				{	if (soap_blist_Configurations == NULL)
						soap_blist_Configurations = soap_new_block(soap);
					a->Configurations = (struct tt__VideoAnalyticsConfiguration *)soap_push_block(soap, soap_blist_Configurations, sizeof(struct tt__VideoAnalyticsConfiguration));
					if (a->Configurations == NULL)
						return NULL;
					soap_default_tt__VideoAnalyticsConfiguration(soap, a->Configurations);
				}
				soap_revert(soap);
				if (soap_in_tt__VideoAnalyticsConfiguration(soap, "trt:Configurations", a->Configurations, "tt:VideoAnalyticsConfiguration"))
				{	a->__sizeConfigurations++;
					a->Configurations = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizeConfigurations");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Configurations)
			soap_pop_block(soap, soap_blist_Configurations);
		if (a->__sizeConfigurations)
			a->Configurations = (struct tt__VideoAnalyticsConfiguration *)soap_save_block(soap, soap_blist_Configurations, NULL, 1);
		else
		{	a->Configurations = NULL;
			if (soap_blist_Configurations)
				soap_end_block(soap, soap_blist_Configurations);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trt__GetVideoAnalyticsConfigurationsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetVideoAnalyticsConfigurationsResponse, 0, sizeof(struct _trt__GetVideoAnalyticsConfigurationsResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__GetVideoAnalyticsConfigurationsResponse(struct soap *soap, const struct _trt__GetVideoAnalyticsConfigurationsResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__trt__GetVideoAnalyticsConfigurationsResponse);
	if (soap_out__trt__GetVideoAnalyticsConfigurationsResponse(soap, tag?tag:"trt:GetVideoAnalyticsConfigurationsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetVideoAnalyticsConfigurationsResponse * SOAP_FMAC4 soap_get__trt__GetVideoAnalyticsConfigurationsResponse(struct soap *soap, struct _trt__GetVideoAnalyticsConfigurationsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__GetVideoAnalyticsConfigurationsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__GetVideoAnalyticsConfigurations(struct soap *soap, struct _trt__GetVideoAnalyticsConfigurations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__GetVideoAnalyticsConfigurations(struct soap *soap, const struct _trt__GetVideoAnalyticsConfigurations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__GetVideoAnalyticsConfigurations(struct soap *soap, const char *tag, int id, const struct _trt__GetVideoAnalyticsConfigurations *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__GetVideoAnalyticsConfigurations), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__GetVideoAnalyticsConfigurations * SOAP_FMAC4 soap_in__trt__GetVideoAnalyticsConfigurations(struct soap *soap, const char *tag, struct _trt__GetVideoAnalyticsConfigurations *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trt__GetVideoAnalyticsConfigurations *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetVideoAnalyticsConfigurations, sizeof(struct _trt__GetVideoAnalyticsConfigurations), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__GetVideoAnalyticsConfigurations(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trt__GetVideoAnalyticsConfigurations *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetVideoAnalyticsConfigurations, 0, sizeof(struct _trt__GetVideoAnalyticsConfigurations), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__GetVideoAnalyticsConfigurations(struct soap *soap, const struct _trt__GetVideoAnalyticsConfigurations *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__trt__GetVideoAnalyticsConfigurations);
	if (soap_out__trt__GetVideoAnalyticsConfigurations(soap, tag?tag:"trt:GetVideoAnalyticsConfigurations", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetVideoAnalyticsConfigurations * SOAP_FMAC4 soap_get__trt__GetVideoAnalyticsConfigurations(struct soap *soap, struct _trt__GetVideoAnalyticsConfigurations *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__GetVideoAnalyticsConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__GetAudioSourceConfigurationsResponse(struct soap *soap, struct _trt__GetAudioSourceConfigurationsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeConfigurations = 0;
	a->Configurations = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__GetAudioSourceConfigurationsResponse(struct soap *soap, const struct _trt__GetAudioSourceConfigurationsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->Configurations)
	{	int i;
		for (i = 0; i < a->__sizeConfigurations; i++)
		{
			soap_embedded(soap, a->Configurations + i, SOAP_TYPE_tt__AudioSourceConfiguration);
			soap_serialize_tt__AudioSourceConfiguration(soap, a->Configurations + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__GetAudioSourceConfigurationsResponse(struct soap *soap, const char *tag, int id, const struct _trt__GetAudioSourceConfigurationsResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__GetAudioSourceConfigurationsResponse), type))
		return soap->error;
	soap_element_result(soap, "-sizeConfigurations");
	if (a->Configurations)
	{	int i;
		for (i = 0; i < a->__sizeConfigurations; i++)
			if (soap_out_tt__AudioSourceConfiguration(soap, "trt:Configurations", -1, a->Configurations + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__GetAudioSourceConfigurationsResponse * SOAP_FMAC4 soap_in__trt__GetAudioSourceConfigurationsResponse(struct soap *soap, const char *tag, struct _trt__GetAudioSourceConfigurationsResponse *a, const char *type)
{
	struct soap_blist *soap_blist_Configurations = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trt__GetAudioSourceConfigurationsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetAudioSourceConfigurationsResponse, sizeof(struct _trt__GetAudioSourceConfigurationsResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__GetAudioSourceConfigurationsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "trt:Configurations", 1, NULL))
			{	if (a->Configurations == NULL)
				{	if (soap_blist_Configurations == NULL)
						soap_blist_Configurations = soap_new_block(soap);
					a->Configurations = (struct tt__AudioSourceConfiguration *)soap_push_block(soap, soap_blist_Configurations, sizeof(struct tt__AudioSourceConfiguration));
					if (a->Configurations == NULL)
						return NULL;
					soap_default_tt__AudioSourceConfiguration(soap, a->Configurations);
				}
				soap_revert(soap);
				if (soap_in_tt__AudioSourceConfiguration(soap, "trt:Configurations", a->Configurations, "tt:AudioSourceConfiguration"))
				{	a->__sizeConfigurations++;
					a->Configurations = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizeConfigurations");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Configurations)
			soap_pop_block(soap, soap_blist_Configurations);
		if (a->__sizeConfigurations)
			a->Configurations = (struct tt__AudioSourceConfiguration *)soap_save_block(soap, soap_blist_Configurations, NULL, 1);
		else
		{	a->Configurations = NULL;
			if (soap_blist_Configurations)
				soap_end_block(soap, soap_blist_Configurations);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trt__GetAudioSourceConfigurationsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetAudioSourceConfigurationsResponse, 0, sizeof(struct _trt__GetAudioSourceConfigurationsResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__GetAudioSourceConfigurationsResponse(struct soap *soap, const struct _trt__GetAudioSourceConfigurationsResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__trt__GetAudioSourceConfigurationsResponse);
	if (soap_out__trt__GetAudioSourceConfigurationsResponse(soap, tag?tag:"trt:GetAudioSourceConfigurationsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetAudioSourceConfigurationsResponse * SOAP_FMAC4 soap_get__trt__GetAudioSourceConfigurationsResponse(struct soap *soap, struct _trt__GetAudioSourceConfigurationsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__GetAudioSourceConfigurationsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__GetAudioSourceConfigurations(struct soap *soap, struct _trt__GetAudioSourceConfigurations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__GetAudioSourceConfigurations(struct soap *soap, const struct _trt__GetAudioSourceConfigurations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__GetAudioSourceConfigurations(struct soap *soap, const char *tag, int id, const struct _trt__GetAudioSourceConfigurations *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__GetAudioSourceConfigurations), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__GetAudioSourceConfigurations * SOAP_FMAC4 soap_in__trt__GetAudioSourceConfigurations(struct soap *soap, const char *tag, struct _trt__GetAudioSourceConfigurations *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trt__GetAudioSourceConfigurations *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetAudioSourceConfigurations, sizeof(struct _trt__GetAudioSourceConfigurations), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__GetAudioSourceConfigurations(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trt__GetAudioSourceConfigurations *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetAudioSourceConfigurations, 0, sizeof(struct _trt__GetAudioSourceConfigurations), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__GetAudioSourceConfigurations(struct soap *soap, const struct _trt__GetAudioSourceConfigurations *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__trt__GetAudioSourceConfigurations);
	if (soap_out__trt__GetAudioSourceConfigurations(soap, tag?tag:"trt:GetAudioSourceConfigurations", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetAudioSourceConfigurations * SOAP_FMAC4 soap_get__trt__GetAudioSourceConfigurations(struct soap *soap, struct _trt__GetAudioSourceConfigurations *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__GetAudioSourceConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__GetAudioEncoderConfigurationsResponse(struct soap *soap, struct _trt__GetAudioEncoderConfigurationsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeConfigurations = 0;
	a->Configurations = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__GetAudioEncoderConfigurationsResponse(struct soap *soap, const struct _trt__GetAudioEncoderConfigurationsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->Configurations)
	{	int i;
		for (i = 0; i < a->__sizeConfigurations; i++)
		{
			soap_embedded(soap, a->Configurations + i, SOAP_TYPE_tt__AudioEncoderConfiguration);
			soap_serialize_tt__AudioEncoderConfiguration(soap, a->Configurations + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__GetAudioEncoderConfigurationsResponse(struct soap *soap, const char *tag, int id, const struct _trt__GetAudioEncoderConfigurationsResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__GetAudioEncoderConfigurationsResponse), type))
		return soap->error;
	soap_element_result(soap, "-sizeConfigurations");
	if (a->Configurations)
	{	int i;
		for (i = 0; i < a->__sizeConfigurations; i++)
			if (soap_out_tt__AudioEncoderConfiguration(soap, "trt:Configurations", -1, a->Configurations + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__GetAudioEncoderConfigurationsResponse * SOAP_FMAC4 soap_in__trt__GetAudioEncoderConfigurationsResponse(struct soap *soap, const char *tag, struct _trt__GetAudioEncoderConfigurationsResponse *a, const char *type)
{
	struct soap_blist *soap_blist_Configurations = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trt__GetAudioEncoderConfigurationsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetAudioEncoderConfigurationsResponse, sizeof(struct _trt__GetAudioEncoderConfigurationsResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__GetAudioEncoderConfigurationsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "trt:Configurations", 1, NULL))
			{	if (a->Configurations == NULL)
				{	if (soap_blist_Configurations == NULL)
						soap_blist_Configurations = soap_new_block(soap);
					a->Configurations = (struct tt__AudioEncoderConfiguration *)soap_push_block(soap, soap_blist_Configurations, sizeof(struct tt__AudioEncoderConfiguration));
					if (a->Configurations == NULL)
						return NULL;
					soap_default_tt__AudioEncoderConfiguration(soap, a->Configurations);
				}
				soap_revert(soap);
				if (soap_in_tt__AudioEncoderConfiguration(soap, "trt:Configurations", a->Configurations, "tt:AudioEncoderConfiguration"))
				{	a->__sizeConfigurations++;
					a->Configurations = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizeConfigurations");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Configurations)
			soap_pop_block(soap, soap_blist_Configurations);
		if (a->__sizeConfigurations)
			a->Configurations = (struct tt__AudioEncoderConfiguration *)soap_save_block(soap, soap_blist_Configurations, NULL, 1);
		else
		{	a->Configurations = NULL;
			if (soap_blist_Configurations)
				soap_end_block(soap, soap_blist_Configurations);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trt__GetAudioEncoderConfigurationsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetAudioEncoderConfigurationsResponse, 0, sizeof(struct _trt__GetAudioEncoderConfigurationsResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__GetAudioEncoderConfigurationsResponse(struct soap *soap, const struct _trt__GetAudioEncoderConfigurationsResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__trt__GetAudioEncoderConfigurationsResponse);
	if (soap_out__trt__GetAudioEncoderConfigurationsResponse(soap, tag?tag:"trt:GetAudioEncoderConfigurationsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetAudioEncoderConfigurationsResponse * SOAP_FMAC4 soap_get__trt__GetAudioEncoderConfigurationsResponse(struct soap *soap, struct _trt__GetAudioEncoderConfigurationsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__GetAudioEncoderConfigurationsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__GetAudioEncoderConfigurations(struct soap *soap, struct _trt__GetAudioEncoderConfigurations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__GetAudioEncoderConfigurations(struct soap *soap, const struct _trt__GetAudioEncoderConfigurations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__GetAudioEncoderConfigurations(struct soap *soap, const char *tag, int id, const struct _trt__GetAudioEncoderConfigurations *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__GetAudioEncoderConfigurations), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__GetAudioEncoderConfigurations * SOAP_FMAC4 soap_in__trt__GetAudioEncoderConfigurations(struct soap *soap, const char *tag, struct _trt__GetAudioEncoderConfigurations *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trt__GetAudioEncoderConfigurations *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetAudioEncoderConfigurations, sizeof(struct _trt__GetAudioEncoderConfigurations), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__GetAudioEncoderConfigurations(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trt__GetAudioEncoderConfigurations *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetAudioEncoderConfigurations, 0, sizeof(struct _trt__GetAudioEncoderConfigurations), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__GetAudioEncoderConfigurations(struct soap *soap, const struct _trt__GetAudioEncoderConfigurations *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__trt__GetAudioEncoderConfigurations);
	if (soap_out__trt__GetAudioEncoderConfigurations(soap, tag?tag:"trt:GetAudioEncoderConfigurations", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetAudioEncoderConfigurations * SOAP_FMAC4 soap_get__trt__GetAudioEncoderConfigurations(struct soap *soap, struct _trt__GetAudioEncoderConfigurations *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__GetAudioEncoderConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__GetVideoSourceConfigurationsResponse(struct soap *soap, struct _trt__GetVideoSourceConfigurationsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeConfigurations = 0;
	a->Configurations = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__GetVideoSourceConfigurationsResponse(struct soap *soap, const struct _trt__GetVideoSourceConfigurationsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->Configurations)
	{	int i;
		for (i = 0; i < a->__sizeConfigurations; i++)
		{
			soap_embedded(soap, a->Configurations + i, SOAP_TYPE_tt__VideoSourceConfiguration);
			soap_serialize_tt__VideoSourceConfiguration(soap, a->Configurations + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__GetVideoSourceConfigurationsResponse(struct soap *soap, const char *tag, int id, const struct _trt__GetVideoSourceConfigurationsResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__GetVideoSourceConfigurationsResponse), type))
		return soap->error;
	soap_element_result(soap, "-sizeConfigurations");
	if (a->Configurations)
	{	int i;
		for (i = 0; i < a->__sizeConfigurations; i++)
			if (soap_out_tt__VideoSourceConfiguration(soap, "trt:Configurations", -1, a->Configurations + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__GetVideoSourceConfigurationsResponse * SOAP_FMAC4 soap_in__trt__GetVideoSourceConfigurationsResponse(struct soap *soap, const char *tag, struct _trt__GetVideoSourceConfigurationsResponse *a, const char *type)
{
	struct soap_blist *soap_blist_Configurations = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trt__GetVideoSourceConfigurationsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetVideoSourceConfigurationsResponse, sizeof(struct _trt__GetVideoSourceConfigurationsResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__GetVideoSourceConfigurationsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "trt:Configurations", 1, NULL))
			{	if (a->Configurations == NULL)
				{	if (soap_blist_Configurations == NULL)
						soap_blist_Configurations = soap_new_block(soap);
					a->Configurations = (struct tt__VideoSourceConfiguration *)soap_push_block(soap, soap_blist_Configurations, sizeof(struct tt__VideoSourceConfiguration));
					if (a->Configurations == NULL)
						return NULL;
					soap_default_tt__VideoSourceConfiguration(soap, a->Configurations);
				}
				soap_revert(soap);
				if (soap_in_tt__VideoSourceConfiguration(soap, "trt:Configurations", a->Configurations, "tt:VideoSourceConfiguration"))
				{	a->__sizeConfigurations++;
					a->Configurations = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizeConfigurations");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Configurations)
			soap_pop_block(soap, soap_blist_Configurations);
		if (a->__sizeConfigurations)
			a->Configurations = (struct tt__VideoSourceConfiguration *)soap_save_block(soap, soap_blist_Configurations, NULL, 1);
		else
		{	a->Configurations = NULL;
			if (soap_blist_Configurations)
				soap_end_block(soap, soap_blist_Configurations);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trt__GetVideoSourceConfigurationsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetVideoSourceConfigurationsResponse, 0, sizeof(struct _trt__GetVideoSourceConfigurationsResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__GetVideoSourceConfigurationsResponse(struct soap *soap, const struct _trt__GetVideoSourceConfigurationsResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__trt__GetVideoSourceConfigurationsResponse);
	if (soap_out__trt__GetVideoSourceConfigurationsResponse(soap, tag?tag:"trt:GetVideoSourceConfigurationsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetVideoSourceConfigurationsResponse * SOAP_FMAC4 soap_get__trt__GetVideoSourceConfigurationsResponse(struct soap *soap, struct _trt__GetVideoSourceConfigurationsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__GetVideoSourceConfigurationsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__GetVideoSourceConfigurations(struct soap *soap, struct _trt__GetVideoSourceConfigurations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__GetVideoSourceConfigurations(struct soap *soap, const struct _trt__GetVideoSourceConfigurations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__GetVideoSourceConfigurations(struct soap *soap, const char *tag, int id, const struct _trt__GetVideoSourceConfigurations *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__GetVideoSourceConfigurations), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__GetVideoSourceConfigurations * SOAP_FMAC4 soap_in__trt__GetVideoSourceConfigurations(struct soap *soap, const char *tag, struct _trt__GetVideoSourceConfigurations *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trt__GetVideoSourceConfigurations *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetVideoSourceConfigurations, sizeof(struct _trt__GetVideoSourceConfigurations), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__GetVideoSourceConfigurations(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trt__GetVideoSourceConfigurations *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetVideoSourceConfigurations, 0, sizeof(struct _trt__GetVideoSourceConfigurations), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__GetVideoSourceConfigurations(struct soap *soap, const struct _trt__GetVideoSourceConfigurations *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__trt__GetVideoSourceConfigurations);
	if (soap_out__trt__GetVideoSourceConfigurations(soap, tag?tag:"trt:GetVideoSourceConfigurations", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetVideoSourceConfigurations * SOAP_FMAC4 soap_get__trt__GetVideoSourceConfigurations(struct soap *soap, struct _trt__GetVideoSourceConfigurations *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__GetVideoSourceConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__GetVideoEncoderConfigurationsResponse(struct soap *soap, struct _trt__GetVideoEncoderConfigurationsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeConfigurations = 0;
	a->Configurations = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__GetVideoEncoderConfigurationsResponse(struct soap *soap, const struct _trt__GetVideoEncoderConfigurationsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->Configurations)
	{	int i;
		for (i = 0; i < a->__sizeConfigurations; i++)
		{
			soap_embedded(soap, a->Configurations + i, SOAP_TYPE_tt__VideoEncoderConfiguration);
			soap_serialize_tt__VideoEncoderConfiguration(soap, a->Configurations + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__GetVideoEncoderConfigurationsResponse(struct soap *soap, const char *tag, int id, const struct _trt__GetVideoEncoderConfigurationsResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__GetVideoEncoderConfigurationsResponse), type))
		return soap->error;
	soap_element_result(soap, "-sizeConfigurations");
	if (a->Configurations)
	{	int i;
		for (i = 0; i < a->__sizeConfigurations; i++)
			if (soap_out_tt__VideoEncoderConfiguration(soap, "trt:Configurations", -1, a->Configurations + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__GetVideoEncoderConfigurationsResponse * SOAP_FMAC4 soap_in__trt__GetVideoEncoderConfigurationsResponse(struct soap *soap, const char *tag, struct _trt__GetVideoEncoderConfigurationsResponse *a, const char *type)
{
	struct soap_blist *soap_blist_Configurations = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trt__GetVideoEncoderConfigurationsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetVideoEncoderConfigurationsResponse, sizeof(struct _trt__GetVideoEncoderConfigurationsResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__GetVideoEncoderConfigurationsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "trt:Configurations", 1, NULL))
			{	if (a->Configurations == NULL)
				{	if (soap_blist_Configurations == NULL)
						soap_blist_Configurations = soap_new_block(soap);
					a->Configurations = (struct tt__VideoEncoderConfiguration *)soap_push_block(soap, soap_blist_Configurations, sizeof(struct tt__VideoEncoderConfiguration));
					if (a->Configurations == NULL)
						return NULL;
					soap_default_tt__VideoEncoderConfiguration(soap, a->Configurations);
				}
				soap_revert(soap);
				if (soap_in_tt__VideoEncoderConfiguration(soap, "trt:Configurations", a->Configurations, "tt:VideoEncoderConfiguration"))
				{	a->__sizeConfigurations++;
					a->Configurations = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizeConfigurations");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Configurations)
			soap_pop_block(soap, soap_blist_Configurations);
		if (a->__sizeConfigurations)
			a->Configurations = (struct tt__VideoEncoderConfiguration *)soap_save_block(soap, soap_blist_Configurations, NULL, 1);
		else
		{	a->Configurations = NULL;
			if (soap_blist_Configurations)
				soap_end_block(soap, soap_blist_Configurations);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trt__GetVideoEncoderConfigurationsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetVideoEncoderConfigurationsResponse, 0, sizeof(struct _trt__GetVideoEncoderConfigurationsResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__GetVideoEncoderConfigurationsResponse(struct soap *soap, const struct _trt__GetVideoEncoderConfigurationsResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__trt__GetVideoEncoderConfigurationsResponse);
	if (soap_out__trt__GetVideoEncoderConfigurationsResponse(soap, tag?tag:"trt:GetVideoEncoderConfigurationsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetVideoEncoderConfigurationsResponse * SOAP_FMAC4 soap_get__trt__GetVideoEncoderConfigurationsResponse(struct soap *soap, struct _trt__GetVideoEncoderConfigurationsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__GetVideoEncoderConfigurationsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__GetVideoEncoderConfigurations(struct soap *soap, struct _trt__GetVideoEncoderConfigurations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__GetVideoEncoderConfigurations(struct soap *soap, const struct _trt__GetVideoEncoderConfigurations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__GetVideoEncoderConfigurations(struct soap *soap, const char *tag, int id, const struct _trt__GetVideoEncoderConfigurations *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__GetVideoEncoderConfigurations), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__GetVideoEncoderConfigurations * SOAP_FMAC4 soap_in__trt__GetVideoEncoderConfigurations(struct soap *soap, const char *tag, struct _trt__GetVideoEncoderConfigurations *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trt__GetVideoEncoderConfigurations *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetVideoEncoderConfigurations, sizeof(struct _trt__GetVideoEncoderConfigurations), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__GetVideoEncoderConfigurations(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trt__GetVideoEncoderConfigurations *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetVideoEncoderConfigurations, 0, sizeof(struct _trt__GetVideoEncoderConfigurations), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__GetVideoEncoderConfigurations(struct soap *soap, const struct _trt__GetVideoEncoderConfigurations *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__trt__GetVideoEncoderConfigurations);
	if (soap_out__trt__GetVideoEncoderConfigurations(soap, tag?tag:"trt:GetVideoEncoderConfigurations", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetVideoEncoderConfigurations * SOAP_FMAC4 soap_get__trt__GetVideoEncoderConfigurations(struct soap *soap, struct _trt__GetVideoEncoderConfigurations *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__GetVideoEncoderConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__DeleteProfileResponse(struct soap *soap, struct _trt__DeleteProfileResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__DeleteProfileResponse(struct soap *soap, const struct _trt__DeleteProfileResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__DeleteProfileResponse(struct soap *soap, const char *tag, int id, const struct _trt__DeleteProfileResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__DeleteProfileResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__DeleteProfileResponse * SOAP_FMAC4 soap_in__trt__DeleteProfileResponse(struct soap *soap, const char *tag, struct _trt__DeleteProfileResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trt__DeleteProfileResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__DeleteProfileResponse, sizeof(struct _trt__DeleteProfileResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__DeleteProfileResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trt__DeleteProfileResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__DeleteProfileResponse, 0, sizeof(struct _trt__DeleteProfileResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__DeleteProfileResponse(struct soap *soap, const struct _trt__DeleteProfileResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__trt__DeleteProfileResponse);
	if (soap_out__trt__DeleteProfileResponse(soap, tag?tag:"trt:DeleteProfileResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__DeleteProfileResponse * SOAP_FMAC4 soap_get__trt__DeleteProfileResponse(struct soap *soap, struct _trt__DeleteProfileResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__DeleteProfileResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__DeleteProfile(struct soap *soap, struct _trt__DeleteProfile *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ProfileToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__DeleteProfile(struct soap *soap, const struct _trt__DeleteProfile *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_tt__ReferenceToken(soap, &a->ProfileToken);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__DeleteProfile(struct soap *soap, const char *tag, int id, const struct _trt__DeleteProfile *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__DeleteProfile), type))
		return soap->error;
	if (a->ProfileToken)
	{	if (soap_out_tt__ReferenceToken(soap, "trt:ProfileToken", -1, &a->ProfileToken, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "trt:ProfileToken"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__DeleteProfile * SOAP_FMAC4 soap_in__trt__DeleteProfile(struct soap *soap, const char *tag, struct _trt__DeleteProfile *a, const char *type)
{
	size_t soap_flag_ProfileToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trt__DeleteProfile *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__DeleteProfile, sizeof(struct _trt__DeleteProfile), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__DeleteProfile(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "trt:ProfileToken", &a->ProfileToken, "tt:ReferenceToken"))
				{	soap_flag_ProfileToken--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trt__DeleteProfile *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__DeleteProfile, 0, sizeof(struct _trt__DeleteProfile), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ProfileToken > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__DeleteProfile(struct soap *soap, const struct _trt__DeleteProfile *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__trt__DeleteProfile);
	if (soap_out__trt__DeleteProfile(soap, tag?tag:"trt:DeleteProfile", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__DeleteProfile * SOAP_FMAC4 soap_get__trt__DeleteProfile(struct soap *soap, struct _trt__DeleteProfile *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__DeleteProfile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__RemoveAudioDecoderConfigurationResponse(struct soap *soap, struct _trt__RemoveAudioDecoderConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__RemoveAudioDecoderConfigurationResponse(struct soap *soap, const struct _trt__RemoveAudioDecoderConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__RemoveAudioDecoderConfigurationResponse(struct soap *soap, const char *tag, int id, const struct _trt__RemoveAudioDecoderConfigurationResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__RemoveAudioDecoderConfigurationResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__RemoveAudioDecoderConfigurationResponse * SOAP_FMAC4 soap_in__trt__RemoveAudioDecoderConfigurationResponse(struct soap *soap, const char *tag, struct _trt__RemoveAudioDecoderConfigurationResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trt__RemoveAudioDecoderConfigurationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__RemoveAudioDecoderConfigurationResponse, sizeof(struct _trt__RemoveAudioDecoderConfigurationResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__RemoveAudioDecoderConfigurationResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trt__RemoveAudioDecoderConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__RemoveAudioDecoderConfigurationResponse, 0, sizeof(struct _trt__RemoveAudioDecoderConfigurationResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__RemoveAudioDecoderConfigurationResponse(struct soap *soap, const struct _trt__RemoveAudioDecoderConfigurationResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__trt__RemoveAudioDecoderConfigurationResponse);
	if (soap_out__trt__RemoveAudioDecoderConfigurationResponse(soap, tag?tag:"trt:RemoveAudioDecoderConfigurationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__RemoveAudioDecoderConfigurationResponse * SOAP_FMAC4 soap_get__trt__RemoveAudioDecoderConfigurationResponse(struct soap *soap, struct _trt__RemoveAudioDecoderConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__RemoveAudioDecoderConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__RemoveAudioDecoderConfiguration(struct soap *soap, struct _trt__RemoveAudioDecoderConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ProfileToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__RemoveAudioDecoderConfiguration(struct soap *soap, const struct _trt__RemoveAudioDecoderConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_tt__ReferenceToken(soap, &a->ProfileToken);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__RemoveAudioDecoderConfiguration(struct soap *soap, const char *tag, int id, const struct _trt__RemoveAudioDecoderConfiguration *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__RemoveAudioDecoderConfiguration), type))
		return soap->error;
	if (a->ProfileToken)
	{	if (soap_out_tt__ReferenceToken(soap, "trt:ProfileToken", -1, &a->ProfileToken, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "trt:ProfileToken"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__RemoveAudioDecoderConfiguration * SOAP_FMAC4 soap_in__trt__RemoveAudioDecoderConfiguration(struct soap *soap, const char *tag, struct _trt__RemoveAudioDecoderConfiguration *a, const char *type)
{
	size_t soap_flag_ProfileToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trt__RemoveAudioDecoderConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__RemoveAudioDecoderConfiguration, sizeof(struct _trt__RemoveAudioDecoderConfiguration), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__RemoveAudioDecoderConfiguration(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "trt:ProfileToken", &a->ProfileToken, "tt:ReferenceToken"))
				{	soap_flag_ProfileToken--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trt__RemoveAudioDecoderConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__RemoveAudioDecoderConfiguration, 0, sizeof(struct _trt__RemoveAudioDecoderConfiguration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ProfileToken > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__RemoveAudioDecoderConfiguration(struct soap *soap, const struct _trt__RemoveAudioDecoderConfiguration *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__trt__RemoveAudioDecoderConfiguration);
	if (soap_out__trt__RemoveAudioDecoderConfiguration(soap, tag?tag:"trt:RemoveAudioDecoderConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__RemoveAudioDecoderConfiguration * SOAP_FMAC4 soap_get__trt__RemoveAudioDecoderConfiguration(struct soap *soap, struct _trt__RemoveAudioDecoderConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__RemoveAudioDecoderConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__AddAudioDecoderConfigurationResponse(struct soap *soap, struct _trt__AddAudioDecoderConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__AddAudioDecoderConfigurationResponse(struct soap *soap, const struct _trt__AddAudioDecoderConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__AddAudioDecoderConfigurationResponse(struct soap *soap, const char *tag, int id, const struct _trt__AddAudioDecoderConfigurationResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__AddAudioDecoderConfigurationResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__AddAudioDecoderConfigurationResponse * SOAP_FMAC4 soap_in__trt__AddAudioDecoderConfigurationResponse(struct soap *soap, const char *tag, struct _trt__AddAudioDecoderConfigurationResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trt__AddAudioDecoderConfigurationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__AddAudioDecoderConfigurationResponse, sizeof(struct _trt__AddAudioDecoderConfigurationResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__AddAudioDecoderConfigurationResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trt__AddAudioDecoderConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__AddAudioDecoderConfigurationResponse, 0, sizeof(struct _trt__AddAudioDecoderConfigurationResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__AddAudioDecoderConfigurationResponse(struct soap *soap, const struct _trt__AddAudioDecoderConfigurationResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__trt__AddAudioDecoderConfigurationResponse);
	if (soap_out__trt__AddAudioDecoderConfigurationResponse(soap, tag?tag:"trt:AddAudioDecoderConfigurationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__AddAudioDecoderConfigurationResponse * SOAP_FMAC4 soap_get__trt__AddAudioDecoderConfigurationResponse(struct soap *soap, struct _trt__AddAudioDecoderConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__AddAudioDecoderConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__AddAudioDecoderConfiguration(struct soap *soap, struct _trt__AddAudioDecoderConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ProfileToken);
	soap_default_tt__ReferenceToken(soap, &a->ConfigurationToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__AddAudioDecoderConfiguration(struct soap *soap, const struct _trt__AddAudioDecoderConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_tt__ReferenceToken(soap, &a->ProfileToken);
	soap_serialize_tt__ReferenceToken(soap, &a->ConfigurationToken);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__AddAudioDecoderConfiguration(struct soap *soap, const char *tag, int id, const struct _trt__AddAudioDecoderConfiguration *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__AddAudioDecoderConfiguration), type))
		return soap->error;
	if (a->ProfileToken)
	{	if (soap_out_tt__ReferenceToken(soap, "trt:ProfileToken", -1, &a->ProfileToken, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "trt:ProfileToken"))
		return soap->error;
	if (a->ConfigurationToken)
	{	if (soap_out_tt__ReferenceToken(soap, "trt:ConfigurationToken", -1, &a->ConfigurationToken, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "trt:ConfigurationToken"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__AddAudioDecoderConfiguration * SOAP_FMAC4 soap_in__trt__AddAudioDecoderConfiguration(struct soap *soap, const char *tag, struct _trt__AddAudioDecoderConfiguration *a, const char *type)
{
	size_t soap_flag_ProfileToken = 1;
	size_t soap_flag_ConfigurationToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trt__AddAudioDecoderConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__AddAudioDecoderConfiguration, sizeof(struct _trt__AddAudioDecoderConfiguration), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__AddAudioDecoderConfiguration(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "trt:ProfileToken", &a->ProfileToken, "tt:ReferenceToken"))
				{	soap_flag_ProfileToken--;
					continue;
				}
			if (soap_flag_ConfigurationToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "trt:ConfigurationToken", &a->ConfigurationToken, "tt:ReferenceToken"))
				{	soap_flag_ConfigurationToken--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trt__AddAudioDecoderConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__AddAudioDecoderConfiguration, 0, sizeof(struct _trt__AddAudioDecoderConfiguration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ProfileToken > 0 || soap_flag_ConfigurationToken > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__AddAudioDecoderConfiguration(struct soap *soap, const struct _trt__AddAudioDecoderConfiguration *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__trt__AddAudioDecoderConfiguration);
	if (soap_out__trt__AddAudioDecoderConfiguration(soap, tag?tag:"trt:AddAudioDecoderConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__AddAudioDecoderConfiguration * SOAP_FMAC4 soap_get__trt__AddAudioDecoderConfiguration(struct soap *soap, struct _trt__AddAudioDecoderConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__AddAudioDecoderConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__RemoveAudioOutputConfigurationResponse(struct soap *soap, struct _trt__RemoveAudioOutputConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__RemoveAudioOutputConfigurationResponse(struct soap *soap, const struct _trt__RemoveAudioOutputConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__RemoveAudioOutputConfigurationResponse(struct soap *soap, const char *tag, int id, const struct _trt__RemoveAudioOutputConfigurationResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__RemoveAudioOutputConfigurationResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__RemoveAudioOutputConfigurationResponse * SOAP_FMAC4 soap_in__trt__RemoveAudioOutputConfigurationResponse(struct soap *soap, const char *tag, struct _trt__RemoveAudioOutputConfigurationResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trt__RemoveAudioOutputConfigurationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__RemoveAudioOutputConfigurationResponse, sizeof(struct _trt__RemoveAudioOutputConfigurationResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__RemoveAudioOutputConfigurationResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trt__RemoveAudioOutputConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__RemoveAudioOutputConfigurationResponse, 0, sizeof(struct _trt__RemoveAudioOutputConfigurationResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__RemoveAudioOutputConfigurationResponse(struct soap *soap, const struct _trt__RemoveAudioOutputConfigurationResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__trt__RemoveAudioOutputConfigurationResponse);
	if (soap_out__trt__RemoveAudioOutputConfigurationResponse(soap, tag?tag:"trt:RemoveAudioOutputConfigurationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__RemoveAudioOutputConfigurationResponse * SOAP_FMAC4 soap_get__trt__RemoveAudioOutputConfigurationResponse(struct soap *soap, struct _trt__RemoveAudioOutputConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__RemoveAudioOutputConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__RemoveAudioOutputConfiguration(struct soap *soap, struct _trt__RemoveAudioOutputConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ProfileToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__RemoveAudioOutputConfiguration(struct soap *soap, const struct _trt__RemoveAudioOutputConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_tt__ReferenceToken(soap, &a->ProfileToken);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__RemoveAudioOutputConfiguration(struct soap *soap, const char *tag, int id, const struct _trt__RemoveAudioOutputConfiguration *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__RemoveAudioOutputConfiguration), type))
		return soap->error;
	if (a->ProfileToken)
	{	if (soap_out_tt__ReferenceToken(soap, "trt:ProfileToken", -1, &a->ProfileToken, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "trt:ProfileToken"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__RemoveAudioOutputConfiguration * SOAP_FMAC4 soap_in__trt__RemoveAudioOutputConfiguration(struct soap *soap, const char *tag, struct _trt__RemoveAudioOutputConfiguration *a, const char *type)
{
	size_t soap_flag_ProfileToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trt__RemoveAudioOutputConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__RemoveAudioOutputConfiguration, sizeof(struct _trt__RemoveAudioOutputConfiguration), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__RemoveAudioOutputConfiguration(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "trt:ProfileToken", &a->ProfileToken, "tt:ReferenceToken"))
				{	soap_flag_ProfileToken--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trt__RemoveAudioOutputConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__RemoveAudioOutputConfiguration, 0, sizeof(struct _trt__RemoveAudioOutputConfiguration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ProfileToken > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__RemoveAudioOutputConfiguration(struct soap *soap, const struct _trt__RemoveAudioOutputConfiguration *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__trt__RemoveAudioOutputConfiguration);
	if (soap_out__trt__RemoveAudioOutputConfiguration(soap, tag?tag:"trt:RemoveAudioOutputConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__RemoveAudioOutputConfiguration * SOAP_FMAC4 soap_get__trt__RemoveAudioOutputConfiguration(struct soap *soap, struct _trt__RemoveAudioOutputConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__RemoveAudioOutputConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__AddAudioOutputConfigurationResponse(struct soap *soap, struct _trt__AddAudioOutputConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__AddAudioOutputConfigurationResponse(struct soap *soap, const struct _trt__AddAudioOutputConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__AddAudioOutputConfigurationResponse(struct soap *soap, const char *tag, int id, const struct _trt__AddAudioOutputConfigurationResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__AddAudioOutputConfigurationResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__AddAudioOutputConfigurationResponse * SOAP_FMAC4 soap_in__trt__AddAudioOutputConfigurationResponse(struct soap *soap, const char *tag, struct _trt__AddAudioOutputConfigurationResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trt__AddAudioOutputConfigurationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__AddAudioOutputConfigurationResponse, sizeof(struct _trt__AddAudioOutputConfigurationResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__AddAudioOutputConfigurationResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trt__AddAudioOutputConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__AddAudioOutputConfigurationResponse, 0, sizeof(struct _trt__AddAudioOutputConfigurationResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__AddAudioOutputConfigurationResponse(struct soap *soap, const struct _trt__AddAudioOutputConfigurationResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__trt__AddAudioOutputConfigurationResponse);
	if (soap_out__trt__AddAudioOutputConfigurationResponse(soap, tag?tag:"trt:AddAudioOutputConfigurationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__AddAudioOutputConfigurationResponse * SOAP_FMAC4 soap_get__trt__AddAudioOutputConfigurationResponse(struct soap *soap, struct _trt__AddAudioOutputConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__AddAudioOutputConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__AddAudioOutputConfiguration(struct soap *soap, struct _trt__AddAudioOutputConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ProfileToken);
	soap_default_tt__ReferenceToken(soap, &a->ConfigurationToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__AddAudioOutputConfiguration(struct soap *soap, const struct _trt__AddAudioOutputConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_tt__ReferenceToken(soap, &a->ProfileToken);
	soap_serialize_tt__ReferenceToken(soap, &a->ConfigurationToken);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__AddAudioOutputConfiguration(struct soap *soap, const char *tag, int id, const struct _trt__AddAudioOutputConfiguration *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__AddAudioOutputConfiguration), type))
		return soap->error;
	if (a->ProfileToken)
	{	if (soap_out_tt__ReferenceToken(soap, "trt:ProfileToken", -1, &a->ProfileToken, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "trt:ProfileToken"))
		return soap->error;
	if (a->ConfigurationToken)
	{	if (soap_out_tt__ReferenceToken(soap, "trt:ConfigurationToken", -1, &a->ConfigurationToken, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "trt:ConfigurationToken"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__AddAudioOutputConfiguration * SOAP_FMAC4 soap_in__trt__AddAudioOutputConfiguration(struct soap *soap, const char *tag, struct _trt__AddAudioOutputConfiguration *a, const char *type)
{
	size_t soap_flag_ProfileToken = 1;
	size_t soap_flag_ConfigurationToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trt__AddAudioOutputConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__AddAudioOutputConfiguration, sizeof(struct _trt__AddAudioOutputConfiguration), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__AddAudioOutputConfiguration(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "trt:ProfileToken", &a->ProfileToken, "tt:ReferenceToken"))
				{	soap_flag_ProfileToken--;
					continue;
				}
			if (soap_flag_ConfigurationToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "trt:ConfigurationToken", &a->ConfigurationToken, "tt:ReferenceToken"))
				{	soap_flag_ConfigurationToken--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trt__AddAudioOutputConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__AddAudioOutputConfiguration, 0, sizeof(struct _trt__AddAudioOutputConfiguration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ProfileToken > 0 || soap_flag_ConfigurationToken > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__AddAudioOutputConfiguration(struct soap *soap, const struct _trt__AddAudioOutputConfiguration *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__trt__AddAudioOutputConfiguration);
	if (soap_out__trt__AddAudioOutputConfiguration(soap, tag?tag:"trt:AddAudioOutputConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__AddAudioOutputConfiguration * SOAP_FMAC4 soap_get__trt__AddAudioOutputConfiguration(struct soap *soap, struct _trt__AddAudioOutputConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__AddAudioOutputConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__RemoveMetadataConfigurationResponse(struct soap *soap, struct _trt__RemoveMetadataConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__RemoveMetadataConfigurationResponse(struct soap *soap, const struct _trt__RemoveMetadataConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__RemoveMetadataConfigurationResponse(struct soap *soap, const char *tag, int id, const struct _trt__RemoveMetadataConfigurationResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__RemoveMetadataConfigurationResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__RemoveMetadataConfigurationResponse * SOAP_FMAC4 soap_in__trt__RemoveMetadataConfigurationResponse(struct soap *soap, const char *tag, struct _trt__RemoveMetadataConfigurationResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trt__RemoveMetadataConfigurationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__RemoveMetadataConfigurationResponse, sizeof(struct _trt__RemoveMetadataConfigurationResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__RemoveMetadataConfigurationResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trt__RemoveMetadataConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__RemoveMetadataConfigurationResponse, 0, sizeof(struct _trt__RemoveMetadataConfigurationResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__RemoveMetadataConfigurationResponse(struct soap *soap, const struct _trt__RemoveMetadataConfigurationResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__trt__RemoveMetadataConfigurationResponse);
	if (soap_out__trt__RemoveMetadataConfigurationResponse(soap, tag?tag:"trt:RemoveMetadataConfigurationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__RemoveMetadataConfigurationResponse * SOAP_FMAC4 soap_get__trt__RemoveMetadataConfigurationResponse(struct soap *soap, struct _trt__RemoveMetadataConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__RemoveMetadataConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__RemoveMetadataConfiguration(struct soap *soap, struct _trt__RemoveMetadataConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ProfileToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__RemoveMetadataConfiguration(struct soap *soap, const struct _trt__RemoveMetadataConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_tt__ReferenceToken(soap, &a->ProfileToken);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__RemoveMetadataConfiguration(struct soap *soap, const char *tag, int id, const struct _trt__RemoveMetadataConfiguration *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__RemoveMetadataConfiguration), type))
		return soap->error;
	if (a->ProfileToken)
	{	if (soap_out_tt__ReferenceToken(soap, "trt:ProfileToken", -1, &a->ProfileToken, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "trt:ProfileToken"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__RemoveMetadataConfiguration * SOAP_FMAC4 soap_in__trt__RemoveMetadataConfiguration(struct soap *soap, const char *tag, struct _trt__RemoveMetadataConfiguration *a, const char *type)
{
	size_t soap_flag_ProfileToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trt__RemoveMetadataConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__RemoveMetadataConfiguration, sizeof(struct _trt__RemoveMetadataConfiguration), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__RemoveMetadataConfiguration(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "trt:ProfileToken", &a->ProfileToken, "tt:ReferenceToken"))
				{	soap_flag_ProfileToken--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trt__RemoveMetadataConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__RemoveMetadataConfiguration, 0, sizeof(struct _trt__RemoveMetadataConfiguration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ProfileToken > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__RemoveMetadataConfiguration(struct soap *soap, const struct _trt__RemoveMetadataConfiguration *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__trt__RemoveMetadataConfiguration);
	if (soap_out__trt__RemoveMetadataConfiguration(soap, tag?tag:"trt:RemoveMetadataConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__RemoveMetadataConfiguration * SOAP_FMAC4 soap_get__trt__RemoveMetadataConfiguration(struct soap *soap, struct _trt__RemoveMetadataConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__RemoveMetadataConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__AddMetadataConfigurationResponse(struct soap *soap, struct _trt__AddMetadataConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__AddMetadataConfigurationResponse(struct soap *soap, const struct _trt__AddMetadataConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__AddMetadataConfigurationResponse(struct soap *soap, const char *tag, int id, const struct _trt__AddMetadataConfigurationResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__AddMetadataConfigurationResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__AddMetadataConfigurationResponse * SOAP_FMAC4 soap_in__trt__AddMetadataConfigurationResponse(struct soap *soap, const char *tag, struct _trt__AddMetadataConfigurationResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trt__AddMetadataConfigurationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__AddMetadataConfigurationResponse, sizeof(struct _trt__AddMetadataConfigurationResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__AddMetadataConfigurationResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trt__AddMetadataConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__AddMetadataConfigurationResponse, 0, sizeof(struct _trt__AddMetadataConfigurationResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__AddMetadataConfigurationResponse(struct soap *soap, const struct _trt__AddMetadataConfigurationResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__trt__AddMetadataConfigurationResponse);
	if (soap_out__trt__AddMetadataConfigurationResponse(soap, tag?tag:"trt:AddMetadataConfigurationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__AddMetadataConfigurationResponse * SOAP_FMAC4 soap_get__trt__AddMetadataConfigurationResponse(struct soap *soap, struct _trt__AddMetadataConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__AddMetadataConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__AddMetadataConfiguration(struct soap *soap, struct _trt__AddMetadataConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ProfileToken);
	soap_default_tt__ReferenceToken(soap, &a->ConfigurationToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__AddMetadataConfiguration(struct soap *soap, const struct _trt__AddMetadataConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_tt__ReferenceToken(soap, &a->ProfileToken);
	soap_serialize_tt__ReferenceToken(soap, &a->ConfigurationToken);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__AddMetadataConfiguration(struct soap *soap, const char *tag, int id, const struct _trt__AddMetadataConfiguration *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__AddMetadataConfiguration), type))
		return soap->error;
	if (a->ProfileToken)
	{	if (soap_out_tt__ReferenceToken(soap, "trt:ProfileToken", -1, &a->ProfileToken, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "trt:ProfileToken"))
		return soap->error;
	if (a->ConfigurationToken)
	{	if (soap_out_tt__ReferenceToken(soap, "trt:ConfigurationToken", -1, &a->ConfigurationToken, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "trt:ConfigurationToken"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__AddMetadataConfiguration * SOAP_FMAC4 soap_in__trt__AddMetadataConfiguration(struct soap *soap, const char *tag, struct _trt__AddMetadataConfiguration *a, const char *type)
{
	size_t soap_flag_ProfileToken = 1;
	size_t soap_flag_ConfigurationToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trt__AddMetadataConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__AddMetadataConfiguration, sizeof(struct _trt__AddMetadataConfiguration), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__AddMetadataConfiguration(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "trt:ProfileToken", &a->ProfileToken, "tt:ReferenceToken"))
				{	soap_flag_ProfileToken--;
					continue;
				}
			if (soap_flag_ConfigurationToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "trt:ConfigurationToken", &a->ConfigurationToken, "tt:ReferenceToken"))
				{	soap_flag_ConfigurationToken--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trt__AddMetadataConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__AddMetadataConfiguration, 0, sizeof(struct _trt__AddMetadataConfiguration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ProfileToken > 0 || soap_flag_ConfigurationToken > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__AddMetadataConfiguration(struct soap *soap, const struct _trt__AddMetadataConfiguration *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__trt__AddMetadataConfiguration);
	if (soap_out__trt__AddMetadataConfiguration(soap, tag?tag:"trt:AddMetadataConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__AddMetadataConfiguration * SOAP_FMAC4 soap_get__trt__AddMetadataConfiguration(struct soap *soap, struct _trt__AddMetadataConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__AddMetadataConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__RemoveVideoAnalyticsConfigurationResponse(struct soap *soap, struct _trt__RemoveVideoAnalyticsConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__RemoveVideoAnalyticsConfigurationResponse(struct soap *soap, const struct _trt__RemoveVideoAnalyticsConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__RemoveVideoAnalyticsConfigurationResponse(struct soap *soap, const char *tag, int id, const struct _trt__RemoveVideoAnalyticsConfigurationResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__RemoveVideoAnalyticsConfigurationResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__RemoveVideoAnalyticsConfigurationResponse * SOAP_FMAC4 soap_in__trt__RemoveVideoAnalyticsConfigurationResponse(struct soap *soap, const char *tag, struct _trt__RemoveVideoAnalyticsConfigurationResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trt__RemoveVideoAnalyticsConfigurationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__RemoveVideoAnalyticsConfigurationResponse, sizeof(struct _trt__RemoveVideoAnalyticsConfigurationResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__RemoveVideoAnalyticsConfigurationResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trt__RemoveVideoAnalyticsConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__RemoveVideoAnalyticsConfigurationResponse, 0, sizeof(struct _trt__RemoveVideoAnalyticsConfigurationResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__RemoveVideoAnalyticsConfigurationResponse(struct soap *soap, const struct _trt__RemoveVideoAnalyticsConfigurationResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__trt__RemoveVideoAnalyticsConfigurationResponse);
	if (soap_out__trt__RemoveVideoAnalyticsConfigurationResponse(soap, tag?tag:"trt:RemoveVideoAnalyticsConfigurationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__RemoveVideoAnalyticsConfigurationResponse * SOAP_FMAC4 soap_get__trt__RemoveVideoAnalyticsConfigurationResponse(struct soap *soap, struct _trt__RemoveVideoAnalyticsConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__RemoveVideoAnalyticsConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__RemoveVideoAnalyticsConfiguration(struct soap *soap, struct _trt__RemoveVideoAnalyticsConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ProfileToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__RemoveVideoAnalyticsConfiguration(struct soap *soap, const struct _trt__RemoveVideoAnalyticsConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_tt__ReferenceToken(soap, &a->ProfileToken);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__RemoveVideoAnalyticsConfiguration(struct soap *soap, const char *tag, int id, const struct _trt__RemoveVideoAnalyticsConfiguration *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__RemoveVideoAnalyticsConfiguration), type))
		return soap->error;
	if (a->ProfileToken)
	{	if (soap_out_tt__ReferenceToken(soap, "trt:ProfileToken", -1, &a->ProfileToken, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "trt:ProfileToken"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__RemoveVideoAnalyticsConfiguration * SOAP_FMAC4 soap_in__trt__RemoveVideoAnalyticsConfiguration(struct soap *soap, const char *tag, struct _trt__RemoveVideoAnalyticsConfiguration *a, const char *type)
{
	size_t soap_flag_ProfileToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trt__RemoveVideoAnalyticsConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__RemoveVideoAnalyticsConfiguration, sizeof(struct _trt__RemoveVideoAnalyticsConfiguration), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__RemoveVideoAnalyticsConfiguration(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "trt:ProfileToken", &a->ProfileToken, "tt:ReferenceToken"))
				{	soap_flag_ProfileToken--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trt__RemoveVideoAnalyticsConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__RemoveVideoAnalyticsConfiguration, 0, sizeof(struct _trt__RemoveVideoAnalyticsConfiguration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ProfileToken > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__RemoveVideoAnalyticsConfiguration(struct soap *soap, const struct _trt__RemoveVideoAnalyticsConfiguration *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__trt__RemoveVideoAnalyticsConfiguration);
	if (soap_out__trt__RemoveVideoAnalyticsConfiguration(soap, tag?tag:"trt:RemoveVideoAnalyticsConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__RemoveVideoAnalyticsConfiguration * SOAP_FMAC4 soap_get__trt__RemoveVideoAnalyticsConfiguration(struct soap *soap, struct _trt__RemoveVideoAnalyticsConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__RemoveVideoAnalyticsConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__AddVideoAnalyticsConfigurationResponse(struct soap *soap, struct _trt__AddVideoAnalyticsConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__AddVideoAnalyticsConfigurationResponse(struct soap *soap, const struct _trt__AddVideoAnalyticsConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__AddVideoAnalyticsConfigurationResponse(struct soap *soap, const char *tag, int id, const struct _trt__AddVideoAnalyticsConfigurationResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__AddVideoAnalyticsConfigurationResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__AddVideoAnalyticsConfigurationResponse * SOAP_FMAC4 soap_in__trt__AddVideoAnalyticsConfigurationResponse(struct soap *soap, const char *tag, struct _trt__AddVideoAnalyticsConfigurationResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trt__AddVideoAnalyticsConfigurationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__AddVideoAnalyticsConfigurationResponse, sizeof(struct _trt__AddVideoAnalyticsConfigurationResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__AddVideoAnalyticsConfigurationResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trt__AddVideoAnalyticsConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__AddVideoAnalyticsConfigurationResponse, 0, sizeof(struct _trt__AddVideoAnalyticsConfigurationResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__AddVideoAnalyticsConfigurationResponse(struct soap *soap, const struct _trt__AddVideoAnalyticsConfigurationResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__trt__AddVideoAnalyticsConfigurationResponse);
	if (soap_out__trt__AddVideoAnalyticsConfigurationResponse(soap, tag?tag:"trt:AddVideoAnalyticsConfigurationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__AddVideoAnalyticsConfigurationResponse * SOAP_FMAC4 soap_get__trt__AddVideoAnalyticsConfigurationResponse(struct soap *soap, struct _trt__AddVideoAnalyticsConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__AddVideoAnalyticsConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__AddVideoAnalyticsConfiguration(struct soap *soap, struct _trt__AddVideoAnalyticsConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ProfileToken);
	soap_default_tt__ReferenceToken(soap, &a->ConfigurationToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__AddVideoAnalyticsConfiguration(struct soap *soap, const struct _trt__AddVideoAnalyticsConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_tt__ReferenceToken(soap, &a->ProfileToken);
	soap_serialize_tt__ReferenceToken(soap, &a->ConfigurationToken);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__AddVideoAnalyticsConfiguration(struct soap *soap, const char *tag, int id, const struct _trt__AddVideoAnalyticsConfiguration *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__AddVideoAnalyticsConfiguration), type))
		return soap->error;
	if (a->ProfileToken)
	{	if (soap_out_tt__ReferenceToken(soap, "trt:ProfileToken", -1, &a->ProfileToken, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "trt:ProfileToken"))
		return soap->error;
	if (a->ConfigurationToken)
	{	if (soap_out_tt__ReferenceToken(soap, "trt:ConfigurationToken", -1, &a->ConfigurationToken, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "trt:ConfigurationToken"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__AddVideoAnalyticsConfiguration * SOAP_FMAC4 soap_in__trt__AddVideoAnalyticsConfiguration(struct soap *soap, const char *tag, struct _trt__AddVideoAnalyticsConfiguration *a, const char *type)
{
	size_t soap_flag_ProfileToken = 1;
	size_t soap_flag_ConfigurationToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trt__AddVideoAnalyticsConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__AddVideoAnalyticsConfiguration, sizeof(struct _trt__AddVideoAnalyticsConfiguration), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__AddVideoAnalyticsConfiguration(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "trt:ProfileToken", &a->ProfileToken, "tt:ReferenceToken"))
				{	soap_flag_ProfileToken--;
					continue;
				}
			if (soap_flag_ConfigurationToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "trt:ConfigurationToken", &a->ConfigurationToken, "tt:ReferenceToken"))
				{	soap_flag_ConfigurationToken--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trt__AddVideoAnalyticsConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__AddVideoAnalyticsConfiguration, 0, sizeof(struct _trt__AddVideoAnalyticsConfiguration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ProfileToken > 0 || soap_flag_ConfigurationToken > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__AddVideoAnalyticsConfiguration(struct soap *soap, const struct _trt__AddVideoAnalyticsConfiguration *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__trt__AddVideoAnalyticsConfiguration);
	if (soap_out__trt__AddVideoAnalyticsConfiguration(soap, tag?tag:"trt:AddVideoAnalyticsConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__AddVideoAnalyticsConfiguration * SOAP_FMAC4 soap_get__trt__AddVideoAnalyticsConfiguration(struct soap *soap, struct _trt__AddVideoAnalyticsConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__AddVideoAnalyticsConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__RemovePTZConfigurationResponse(struct soap *soap, struct _trt__RemovePTZConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__RemovePTZConfigurationResponse(struct soap *soap, const struct _trt__RemovePTZConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__RemovePTZConfigurationResponse(struct soap *soap, const char *tag, int id, const struct _trt__RemovePTZConfigurationResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__RemovePTZConfigurationResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__RemovePTZConfigurationResponse * SOAP_FMAC4 soap_in__trt__RemovePTZConfigurationResponse(struct soap *soap, const char *tag, struct _trt__RemovePTZConfigurationResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trt__RemovePTZConfigurationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__RemovePTZConfigurationResponse, sizeof(struct _trt__RemovePTZConfigurationResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__RemovePTZConfigurationResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trt__RemovePTZConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__RemovePTZConfigurationResponse, 0, sizeof(struct _trt__RemovePTZConfigurationResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__RemovePTZConfigurationResponse(struct soap *soap, const struct _trt__RemovePTZConfigurationResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__trt__RemovePTZConfigurationResponse);
	if (soap_out__trt__RemovePTZConfigurationResponse(soap, tag?tag:"trt:RemovePTZConfigurationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__RemovePTZConfigurationResponse * SOAP_FMAC4 soap_get__trt__RemovePTZConfigurationResponse(struct soap *soap, struct _trt__RemovePTZConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__RemovePTZConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__RemovePTZConfiguration(struct soap *soap, struct _trt__RemovePTZConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ProfileToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__RemovePTZConfiguration(struct soap *soap, const struct _trt__RemovePTZConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_tt__ReferenceToken(soap, &a->ProfileToken);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__RemovePTZConfiguration(struct soap *soap, const char *tag, int id, const struct _trt__RemovePTZConfiguration *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__RemovePTZConfiguration), type))
		return soap->error;
	if (a->ProfileToken)
	{	if (soap_out_tt__ReferenceToken(soap, "trt:ProfileToken", -1, &a->ProfileToken, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "trt:ProfileToken"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__RemovePTZConfiguration * SOAP_FMAC4 soap_in__trt__RemovePTZConfiguration(struct soap *soap, const char *tag, struct _trt__RemovePTZConfiguration *a, const char *type)
{
	size_t soap_flag_ProfileToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trt__RemovePTZConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__RemovePTZConfiguration, sizeof(struct _trt__RemovePTZConfiguration), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__RemovePTZConfiguration(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "trt:ProfileToken", &a->ProfileToken, "tt:ReferenceToken"))
				{	soap_flag_ProfileToken--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trt__RemovePTZConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__RemovePTZConfiguration, 0, sizeof(struct _trt__RemovePTZConfiguration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ProfileToken > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__RemovePTZConfiguration(struct soap *soap, const struct _trt__RemovePTZConfiguration *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__trt__RemovePTZConfiguration);
	if (soap_out__trt__RemovePTZConfiguration(soap, tag?tag:"trt:RemovePTZConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__RemovePTZConfiguration * SOAP_FMAC4 soap_get__trt__RemovePTZConfiguration(struct soap *soap, struct _trt__RemovePTZConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__RemovePTZConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__AddPTZConfigurationResponse(struct soap *soap, struct _trt__AddPTZConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__AddPTZConfigurationResponse(struct soap *soap, const struct _trt__AddPTZConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__AddPTZConfigurationResponse(struct soap *soap, const char *tag, int id, const struct _trt__AddPTZConfigurationResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__AddPTZConfigurationResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__AddPTZConfigurationResponse * SOAP_FMAC4 soap_in__trt__AddPTZConfigurationResponse(struct soap *soap, const char *tag, struct _trt__AddPTZConfigurationResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trt__AddPTZConfigurationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__AddPTZConfigurationResponse, sizeof(struct _trt__AddPTZConfigurationResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__AddPTZConfigurationResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trt__AddPTZConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__AddPTZConfigurationResponse, 0, sizeof(struct _trt__AddPTZConfigurationResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__AddPTZConfigurationResponse(struct soap *soap, const struct _trt__AddPTZConfigurationResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__trt__AddPTZConfigurationResponse);
	if (soap_out__trt__AddPTZConfigurationResponse(soap, tag?tag:"trt:AddPTZConfigurationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__AddPTZConfigurationResponse * SOAP_FMAC4 soap_get__trt__AddPTZConfigurationResponse(struct soap *soap, struct _trt__AddPTZConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__AddPTZConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__AddPTZConfiguration(struct soap *soap, struct _trt__AddPTZConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ProfileToken);
	soap_default_tt__ReferenceToken(soap, &a->ConfigurationToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__AddPTZConfiguration(struct soap *soap, const struct _trt__AddPTZConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_tt__ReferenceToken(soap, &a->ProfileToken);
	soap_serialize_tt__ReferenceToken(soap, &a->ConfigurationToken);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__AddPTZConfiguration(struct soap *soap, const char *tag, int id, const struct _trt__AddPTZConfiguration *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__AddPTZConfiguration), type))
		return soap->error;
	if (a->ProfileToken)
	{	if (soap_out_tt__ReferenceToken(soap, "trt:ProfileToken", -1, &a->ProfileToken, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "trt:ProfileToken"))
		return soap->error;
	if (a->ConfigurationToken)
	{	if (soap_out_tt__ReferenceToken(soap, "trt:ConfigurationToken", -1, &a->ConfigurationToken, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "trt:ConfigurationToken"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__AddPTZConfiguration * SOAP_FMAC4 soap_in__trt__AddPTZConfiguration(struct soap *soap, const char *tag, struct _trt__AddPTZConfiguration *a, const char *type)
{
	size_t soap_flag_ProfileToken = 1;
	size_t soap_flag_ConfigurationToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trt__AddPTZConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__AddPTZConfiguration, sizeof(struct _trt__AddPTZConfiguration), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__AddPTZConfiguration(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "trt:ProfileToken", &a->ProfileToken, "tt:ReferenceToken"))
				{	soap_flag_ProfileToken--;
					continue;
				}
			if (soap_flag_ConfigurationToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "trt:ConfigurationToken", &a->ConfigurationToken, "tt:ReferenceToken"))
				{	soap_flag_ConfigurationToken--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trt__AddPTZConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__AddPTZConfiguration, 0, sizeof(struct _trt__AddPTZConfiguration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ProfileToken > 0 || soap_flag_ConfigurationToken > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__AddPTZConfiguration(struct soap *soap, const struct _trt__AddPTZConfiguration *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__trt__AddPTZConfiguration);
	if (soap_out__trt__AddPTZConfiguration(soap, tag?tag:"trt:AddPTZConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__AddPTZConfiguration * SOAP_FMAC4 soap_get__trt__AddPTZConfiguration(struct soap *soap, struct _trt__AddPTZConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__AddPTZConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__RemoveAudioSourceConfigurationResponse(struct soap *soap, struct _trt__RemoveAudioSourceConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__RemoveAudioSourceConfigurationResponse(struct soap *soap, const struct _trt__RemoveAudioSourceConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__RemoveAudioSourceConfigurationResponse(struct soap *soap, const char *tag, int id, const struct _trt__RemoveAudioSourceConfigurationResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__RemoveAudioSourceConfigurationResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__RemoveAudioSourceConfigurationResponse * SOAP_FMAC4 soap_in__trt__RemoveAudioSourceConfigurationResponse(struct soap *soap, const char *tag, struct _trt__RemoveAudioSourceConfigurationResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trt__RemoveAudioSourceConfigurationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__RemoveAudioSourceConfigurationResponse, sizeof(struct _trt__RemoveAudioSourceConfigurationResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__RemoveAudioSourceConfigurationResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trt__RemoveAudioSourceConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__RemoveAudioSourceConfigurationResponse, 0, sizeof(struct _trt__RemoveAudioSourceConfigurationResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__RemoveAudioSourceConfigurationResponse(struct soap *soap, const struct _trt__RemoveAudioSourceConfigurationResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__trt__RemoveAudioSourceConfigurationResponse);
	if (soap_out__trt__RemoveAudioSourceConfigurationResponse(soap, tag?tag:"trt:RemoveAudioSourceConfigurationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__RemoveAudioSourceConfigurationResponse * SOAP_FMAC4 soap_get__trt__RemoveAudioSourceConfigurationResponse(struct soap *soap, struct _trt__RemoveAudioSourceConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__RemoveAudioSourceConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__RemoveAudioSourceConfiguration(struct soap *soap, struct _trt__RemoveAudioSourceConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ProfileToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__RemoveAudioSourceConfiguration(struct soap *soap, const struct _trt__RemoveAudioSourceConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_tt__ReferenceToken(soap, &a->ProfileToken);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__RemoveAudioSourceConfiguration(struct soap *soap, const char *tag, int id, const struct _trt__RemoveAudioSourceConfiguration *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__RemoveAudioSourceConfiguration), type))
		return soap->error;
	if (a->ProfileToken)
	{	if (soap_out_tt__ReferenceToken(soap, "trt:ProfileToken", -1, &a->ProfileToken, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "trt:ProfileToken"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__RemoveAudioSourceConfiguration * SOAP_FMAC4 soap_in__trt__RemoveAudioSourceConfiguration(struct soap *soap, const char *tag, struct _trt__RemoveAudioSourceConfiguration *a, const char *type)
{
	size_t soap_flag_ProfileToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trt__RemoveAudioSourceConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__RemoveAudioSourceConfiguration, sizeof(struct _trt__RemoveAudioSourceConfiguration), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__RemoveAudioSourceConfiguration(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "trt:ProfileToken", &a->ProfileToken, "tt:ReferenceToken"))
				{	soap_flag_ProfileToken--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trt__RemoveAudioSourceConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__RemoveAudioSourceConfiguration, 0, sizeof(struct _trt__RemoveAudioSourceConfiguration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ProfileToken > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__RemoveAudioSourceConfiguration(struct soap *soap, const struct _trt__RemoveAudioSourceConfiguration *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__trt__RemoveAudioSourceConfiguration);
	if (soap_out__trt__RemoveAudioSourceConfiguration(soap, tag?tag:"trt:RemoveAudioSourceConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__RemoveAudioSourceConfiguration * SOAP_FMAC4 soap_get__trt__RemoveAudioSourceConfiguration(struct soap *soap, struct _trt__RemoveAudioSourceConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__RemoveAudioSourceConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__AddAudioSourceConfigurationResponse(struct soap *soap, struct _trt__AddAudioSourceConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__AddAudioSourceConfigurationResponse(struct soap *soap, const struct _trt__AddAudioSourceConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__AddAudioSourceConfigurationResponse(struct soap *soap, const char *tag, int id, const struct _trt__AddAudioSourceConfigurationResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__AddAudioSourceConfigurationResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__AddAudioSourceConfigurationResponse * SOAP_FMAC4 soap_in__trt__AddAudioSourceConfigurationResponse(struct soap *soap, const char *tag, struct _trt__AddAudioSourceConfigurationResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trt__AddAudioSourceConfigurationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__AddAudioSourceConfigurationResponse, sizeof(struct _trt__AddAudioSourceConfigurationResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__AddAudioSourceConfigurationResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trt__AddAudioSourceConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__AddAudioSourceConfigurationResponse, 0, sizeof(struct _trt__AddAudioSourceConfigurationResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__AddAudioSourceConfigurationResponse(struct soap *soap, const struct _trt__AddAudioSourceConfigurationResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__trt__AddAudioSourceConfigurationResponse);
	if (soap_out__trt__AddAudioSourceConfigurationResponse(soap, tag?tag:"trt:AddAudioSourceConfigurationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__AddAudioSourceConfigurationResponse * SOAP_FMAC4 soap_get__trt__AddAudioSourceConfigurationResponse(struct soap *soap, struct _trt__AddAudioSourceConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__AddAudioSourceConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__AddAudioSourceConfiguration(struct soap *soap, struct _trt__AddAudioSourceConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ProfileToken);
	soap_default_tt__ReferenceToken(soap, &a->ConfigurationToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__AddAudioSourceConfiguration(struct soap *soap, const struct _trt__AddAudioSourceConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_tt__ReferenceToken(soap, &a->ProfileToken);
	soap_serialize_tt__ReferenceToken(soap, &a->ConfigurationToken);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__AddAudioSourceConfiguration(struct soap *soap, const char *tag, int id, const struct _trt__AddAudioSourceConfiguration *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__AddAudioSourceConfiguration), type))
		return soap->error;
	if (a->ProfileToken)
	{	if (soap_out_tt__ReferenceToken(soap, "trt:ProfileToken", -1, &a->ProfileToken, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "trt:ProfileToken"))
		return soap->error;
	if (a->ConfigurationToken)
	{	if (soap_out_tt__ReferenceToken(soap, "trt:ConfigurationToken", -1, &a->ConfigurationToken, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "trt:ConfigurationToken"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__AddAudioSourceConfiguration * SOAP_FMAC4 soap_in__trt__AddAudioSourceConfiguration(struct soap *soap, const char *tag, struct _trt__AddAudioSourceConfiguration *a, const char *type)
{
	size_t soap_flag_ProfileToken = 1;
	size_t soap_flag_ConfigurationToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trt__AddAudioSourceConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__AddAudioSourceConfiguration, sizeof(struct _trt__AddAudioSourceConfiguration), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__AddAudioSourceConfiguration(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "trt:ProfileToken", &a->ProfileToken, "tt:ReferenceToken"))
				{	soap_flag_ProfileToken--;
					continue;
				}
			if (soap_flag_ConfigurationToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "trt:ConfigurationToken", &a->ConfigurationToken, "tt:ReferenceToken"))
				{	soap_flag_ConfigurationToken--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trt__AddAudioSourceConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__AddAudioSourceConfiguration, 0, sizeof(struct _trt__AddAudioSourceConfiguration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ProfileToken > 0 || soap_flag_ConfigurationToken > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__AddAudioSourceConfiguration(struct soap *soap, const struct _trt__AddAudioSourceConfiguration *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__trt__AddAudioSourceConfiguration);
	if (soap_out__trt__AddAudioSourceConfiguration(soap, tag?tag:"trt:AddAudioSourceConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__AddAudioSourceConfiguration * SOAP_FMAC4 soap_get__trt__AddAudioSourceConfiguration(struct soap *soap, struct _trt__AddAudioSourceConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__AddAudioSourceConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__RemoveAudioEncoderConfigurationResponse(struct soap *soap, struct _trt__RemoveAudioEncoderConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__RemoveAudioEncoderConfigurationResponse(struct soap *soap, const struct _trt__RemoveAudioEncoderConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__RemoveAudioEncoderConfigurationResponse(struct soap *soap, const char *tag, int id, const struct _trt__RemoveAudioEncoderConfigurationResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__RemoveAudioEncoderConfigurationResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__RemoveAudioEncoderConfigurationResponse * SOAP_FMAC4 soap_in__trt__RemoveAudioEncoderConfigurationResponse(struct soap *soap, const char *tag, struct _trt__RemoveAudioEncoderConfigurationResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trt__RemoveAudioEncoderConfigurationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__RemoveAudioEncoderConfigurationResponse, sizeof(struct _trt__RemoveAudioEncoderConfigurationResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__RemoveAudioEncoderConfigurationResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trt__RemoveAudioEncoderConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__RemoveAudioEncoderConfigurationResponse, 0, sizeof(struct _trt__RemoveAudioEncoderConfigurationResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__RemoveAudioEncoderConfigurationResponse(struct soap *soap, const struct _trt__RemoveAudioEncoderConfigurationResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__trt__RemoveAudioEncoderConfigurationResponse);
	if (soap_out__trt__RemoveAudioEncoderConfigurationResponse(soap, tag?tag:"trt:RemoveAudioEncoderConfigurationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__RemoveAudioEncoderConfigurationResponse * SOAP_FMAC4 soap_get__trt__RemoveAudioEncoderConfigurationResponse(struct soap *soap, struct _trt__RemoveAudioEncoderConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__RemoveAudioEncoderConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__RemoveAudioEncoderConfiguration(struct soap *soap, struct _trt__RemoveAudioEncoderConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ProfileToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__RemoveAudioEncoderConfiguration(struct soap *soap, const struct _trt__RemoveAudioEncoderConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_tt__ReferenceToken(soap, &a->ProfileToken);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__RemoveAudioEncoderConfiguration(struct soap *soap, const char *tag, int id, const struct _trt__RemoveAudioEncoderConfiguration *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__RemoveAudioEncoderConfiguration), type))
		return soap->error;
	if (a->ProfileToken)
	{	if (soap_out_tt__ReferenceToken(soap, "trt:ProfileToken", -1, &a->ProfileToken, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "trt:ProfileToken"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__RemoveAudioEncoderConfiguration * SOAP_FMAC4 soap_in__trt__RemoveAudioEncoderConfiguration(struct soap *soap, const char *tag, struct _trt__RemoveAudioEncoderConfiguration *a, const char *type)
{
	size_t soap_flag_ProfileToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trt__RemoveAudioEncoderConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__RemoveAudioEncoderConfiguration, sizeof(struct _trt__RemoveAudioEncoderConfiguration), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__RemoveAudioEncoderConfiguration(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "trt:ProfileToken", &a->ProfileToken, "tt:ReferenceToken"))
				{	soap_flag_ProfileToken--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trt__RemoveAudioEncoderConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__RemoveAudioEncoderConfiguration, 0, sizeof(struct _trt__RemoveAudioEncoderConfiguration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ProfileToken > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__RemoveAudioEncoderConfiguration(struct soap *soap, const struct _trt__RemoveAudioEncoderConfiguration *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__trt__RemoveAudioEncoderConfiguration);
	if (soap_out__trt__RemoveAudioEncoderConfiguration(soap, tag?tag:"trt:RemoveAudioEncoderConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__RemoveAudioEncoderConfiguration * SOAP_FMAC4 soap_get__trt__RemoveAudioEncoderConfiguration(struct soap *soap, struct _trt__RemoveAudioEncoderConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__RemoveAudioEncoderConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__AddAudioEncoderConfigurationResponse(struct soap *soap, struct _trt__AddAudioEncoderConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__AddAudioEncoderConfigurationResponse(struct soap *soap, const struct _trt__AddAudioEncoderConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__AddAudioEncoderConfigurationResponse(struct soap *soap, const char *tag, int id, const struct _trt__AddAudioEncoderConfigurationResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__AddAudioEncoderConfigurationResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__AddAudioEncoderConfigurationResponse * SOAP_FMAC4 soap_in__trt__AddAudioEncoderConfigurationResponse(struct soap *soap, const char *tag, struct _trt__AddAudioEncoderConfigurationResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trt__AddAudioEncoderConfigurationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__AddAudioEncoderConfigurationResponse, sizeof(struct _trt__AddAudioEncoderConfigurationResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__AddAudioEncoderConfigurationResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trt__AddAudioEncoderConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__AddAudioEncoderConfigurationResponse, 0, sizeof(struct _trt__AddAudioEncoderConfigurationResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__AddAudioEncoderConfigurationResponse(struct soap *soap, const struct _trt__AddAudioEncoderConfigurationResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__trt__AddAudioEncoderConfigurationResponse);
	if (soap_out__trt__AddAudioEncoderConfigurationResponse(soap, tag?tag:"trt:AddAudioEncoderConfigurationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__AddAudioEncoderConfigurationResponse * SOAP_FMAC4 soap_get__trt__AddAudioEncoderConfigurationResponse(struct soap *soap, struct _trt__AddAudioEncoderConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__AddAudioEncoderConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__AddAudioEncoderConfiguration(struct soap *soap, struct _trt__AddAudioEncoderConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ProfileToken);
	soap_default_tt__ReferenceToken(soap, &a->ConfigurationToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__AddAudioEncoderConfiguration(struct soap *soap, const struct _trt__AddAudioEncoderConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_tt__ReferenceToken(soap, &a->ProfileToken);
	soap_serialize_tt__ReferenceToken(soap, &a->ConfigurationToken);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__AddAudioEncoderConfiguration(struct soap *soap, const char *tag, int id, const struct _trt__AddAudioEncoderConfiguration *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__AddAudioEncoderConfiguration), type))
		return soap->error;
	if (a->ProfileToken)
	{	if (soap_out_tt__ReferenceToken(soap, "trt:ProfileToken", -1, &a->ProfileToken, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "trt:ProfileToken"))
		return soap->error;
	if (a->ConfigurationToken)
	{	if (soap_out_tt__ReferenceToken(soap, "trt:ConfigurationToken", -1, &a->ConfigurationToken, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "trt:ConfigurationToken"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__AddAudioEncoderConfiguration * SOAP_FMAC4 soap_in__trt__AddAudioEncoderConfiguration(struct soap *soap, const char *tag, struct _trt__AddAudioEncoderConfiguration *a, const char *type)
{
	size_t soap_flag_ProfileToken = 1;
	size_t soap_flag_ConfigurationToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trt__AddAudioEncoderConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__AddAudioEncoderConfiguration, sizeof(struct _trt__AddAudioEncoderConfiguration), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__AddAudioEncoderConfiguration(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "trt:ProfileToken", &a->ProfileToken, "tt:ReferenceToken"))
				{	soap_flag_ProfileToken--;
					continue;
				}
			if (soap_flag_ConfigurationToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "trt:ConfigurationToken", &a->ConfigurationToken, "tt:ReferenceToken"))
				{	soap_flag_ConfigurationToken--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trt__AddAudioEncoderConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__AddAudioEncoderConfiguration, 0, sizeof(struct _trt__AddAudioEncoderConfiguration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ProfileToken > 0 || soap_flag_ConfigurationToken > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__AddAudioEncoderConfiguration(struct soap *soap, const struct _trt__AddAudioEncoderConfiguration *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__trt__AddAudioEncoderConfiguration);
	if (soap_out__trt__AddAudioEncoderConfiguration(soap, tag?tag:"trt:AddAudioEncoderConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__AddAudioEncoderConfiguration * SOAP_FMAC4 soap_get__trt__AddAudioEncoderConfiguration(struct soap *soap, struct _trt__AddAudioEncoderConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__AddAudioEncoderConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__RemoveVideoSourceConfigurationResponse(struct soap *soap, struct _trt__RemoveVideoSourceConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__RemoveVideoSourceConfigurationResponse(struct soap *soap, const struct _trt__RemoveVideoSourceConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__RemoveVideoSourceConfigurationResponse(struct soap *soap, const char *tag, int id, const struct _trt__RemoveVideoSourceConfigurationResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__RemoveVideoSourceConfigurationResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__RemoveVideoSourceConfigurationResponse * SOAP_FMAC4 soap_in__trt__RemoveVideoSourceConfigurationResponse(struct soap *soap, const char *tag, struct _trt__RemoveVideoSourceConfigurationResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trt__RemoveVideoSourceConfigurationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__RemoveVideoSourceConfigurationResponse, sizeof(struct _trt__RemoveVideoSourceConfigurationResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__RemoveVideoSourceConfigurationResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trt__RemoveVideoSourceConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__RemoveVideoSourceConfigurationResponse, 0, sizeof(struct _trt__RemoveVideoSourceConfigurationResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__RemoveVideoSourceConfigurationResponse(struct soap *soap, const struct _trt__RemoveVideoSourceConfigurationResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__trt__RemoveVideoSourceConfigurationResponse);
	if (soap_out__trt__RemoveVideoSourceConfigurationResponse(soap, tag?tag:"trt:RemoveVideoSourceConfigurationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__RemoveVideoSourceConfigurationResponse * SOAP_FMAC4 soap_get__trt__RemoveVideoSourceConfigurationResponse(struct soap *soap, struct _trt__RemoveVideoSourceConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__RemoveVideoSourceConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__RemoveVideoSourceConfiguration(struct soap *soap, struct _trt__RemoveVideoSourceConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ProfileToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__RemoveVideoSourceConfiguration(struct soap *soap, const struct _trt__RemoveVideoSourceConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_tt__ReferenceToken(soap, &a->ProfileToken);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__RemoveVideoSourceConfiguration(struct soap *soap, const char *tag, int id, const struct _trt__RemoveVideoSourceConfiguration *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__RemoveVideoSourceConfiguration), type))
		return soap->error;
	if (a->ProfileToken)
	{	if (soap_out_tt__ReferenceToken(soap, "trt:ProfileToken", -1, &a->ProfileToken, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "trt:ProfileToken"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__RemoveVideoSourceConfiguration * SOAP_FMAC4 soap_in__trt__RemoveVideoSourceConfiguration(struct soap *soap, const char *tag, struct _trt__RemoveVideoSourceConfiguration *a, const char *type)
{
	size_t soap_flag_ProfileToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trt__RemoveVideoSourceConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__RemoveVideoSourceConfiguration, sizeof(struct _trt__RemoveVideoSourceConfiguration), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__RemoveVideoSourceConfiguration(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "trt:ProfileToken", &a->ProfileToken, "tt:ReferenceToken"))
				{	soap_flag_ProfileToken--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trt__RemoveVideoSourceConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__RemoveVideoSourceConfiguration, 0, sizeof(struct _trt__RemoveVideoSourceConfiguration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ProfileToken > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__RemoveVideoSourceConfiguration(struct soap *soap, const struct _trt__RemoveVideoSourceConfiguration *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__trt__RemoveVideoSourceConfiguration);
	if (soap_out__trt__RemoveVideoSourceConfiguration(soap, tag?tag:"trt:RemoveVideoSourceConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__RemoveVideoSourceConfiguration * SOAP_FMAC4 soap_get__trt__RemoveVideoSourceConfiguration(struct soap *soap, struct _trt__RemoveVideoSourceConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__RemoveVideoSourceConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__AddVideoSourceConfigurationResponse(struct soap *soap, struct _trt__AddVideoSourceConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__AddVideoSourceConfigurationResponse(struct soap *soap, const struct _trt__AddVideoSourceConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__AddVideoSourceConfigurationResponse(struct soap *soap, const char *tag, int id, const struct _trt__AddVideoSourceConfigurationResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__AddVideoSourceConfigurationResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__AddVideoSourceConfigurationResponse * SOAP_FMAC4 soap_in__trt__AddVideoSourceConfigurationResponse(struct soap *soap, const char *tag, struct _trt__AddVideoSourceConfigurationResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trt__AddVideoSourceConfigurationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__AddVideoSourceConfigurationResponse, sizeof(struct _trt__AddVideoSourceConfigurationResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__AddVideoSourceConfigurationResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trt__AddVideoSourceConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__AddVideoSourceConfigurationResponse, 0, sizeof(struct _trt__AddVideoSourceConfigurationResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__AddVideoSourceConfigurationResponse(struct soap *soap, const struct _trt__AddVideoSourceConfigurationResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__trt__AddVideoSourceConfigurationResponse);
	if (soap_out__trt__AddVideoSourceConfigurationResponse(soap, tag?tag:"trt:AddVideoSourceConfigurationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__AddVideoSourceConfigurationResponse * SOAP_FMAC4 soap_get__trt__AddVideoSourceConfigurationResponse(struct soap *soap, struct _trt__AddVideoSourceConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__AddVideoSourceConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__AddVideoSourceConfiguration(struct soap *soap, struct _trt__AddVideoSourceConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ProfileToken);
	soap_default_tt__ReferenceToken(soap, &a->ConfigurationToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__AddVideoSourceConfiguration(struct soap *soap, const struct _trt__AddVideoSourceConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_tt__ReferenceToken(soap, &a->ProfileToken);
	soap_serialize_tt__ReferenceToken(soap, &a->ConfigurationToken);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__AddVideoSourceConfiguration(struct soap *soap, const char *tag, int id, const struct _trt__AddVideoSourceConfiguration *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__AddVideoSourceConfiguration), type))
		return soap->error;
	if (a->ProfileToken)
	{	if (soap_out_tt__ReferenceToken(soap, "trt:ProfileToken", -1, &a->ProfileToken, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "trt:ProfileToken"))
		return soap->error;
	if (a->ConfigurationToken)
	{	if (soap_out_tt__ReferenceToken(soap, "trt:ConfigurationToken", -1, &a->ConfigurationToken, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "trt:ConfigurationToken"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__AddVideoSourceConfiguration * SOAP_FMAC4 soap_in__trt__AddVideoSourceConfiguration(struct soap *soap, const char *tag, struct _trt__AddVideoSourceConfiguration *a, const char *type)
{
	size_t soap_flag_ProfileToken = 1;
	size_t soap_flag_ConfigurationToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trt__AddVideoSourceConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__AddVideoSourceConfiguration, sizeof(struct _trt__AddVideoSourceConfiguration), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__AddVideoSourceConfiguration(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "trt:ProfileToken", &a->ProfileToken, "tt:ReferenceToken"))
				{	soap_flag_ProfileToken--;
					continue;
				}
			if (soap_flag_ConfigurationToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "trt:ConfigurationToken", &a->ConfigurationToken, "tt:ReferenceToken"))
				{	soap_flag_ConfigurationToken--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trt__AddVideoSourceConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__AddVideoSourceConfiguration, 0, sizeof(struct _trt__AddVideoSourceConfiguration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ProfileToken > 0 || soap_flag_ConfigurationToken > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__AddVideoSourceConfiguration(struct soap *soap, const struct _trt__AddVideoSourceConfiguration *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__trt__AddVideoSourceConfiguration);
	if (soap_out__trt__AddVideoSourceConfiguration(soap, tag?tag:"trt:AddVideoSourceConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__AddVideoSourceConfiguration * SOAP_FMAC4 soap_get__trt__AddVideoSourceConfiguration(struct soap *soap, struct _trt__AddVideoSourceConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__AddVideoSourceConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__RemoveVideoEncoderConfigurationResponse(struct soap *soap, struct _trt__RemoveVideoEncoderConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__RemoveVideoEncoderConfigurationResponse(struct soap *soap, const struct _trt__RemoveVideoEncoderConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__RemoveVideoEncoderConfigurationResponse(struct soap *soap, const char *tag, int id, const struct _trt__RemoveVideoEncoderConfigurationResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__RemoveVideoEncoderConfigurationResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__RemoveVideoEncoderConfigurationResponse * SOAP_FMAC4 soap_in__trt__RemoveVideoEncoderConfigurationResponse(struct soap *soap, const char *tag, struct _trt__RemoveVideoEncoderConfigurationResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trt__RemoveVideoEncoderConfigurationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__RemoveVideoEncoderConfigurationResponse, sizeof(struct _trt__RemoveVideoEncoderConfigurationResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__RemoveVideoEncoderConfigurationResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trt__RemoveVideoEncoderConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__RemoveVideoEncoderConfigurationResponse, 0, sizeof(struct _trt__RemoveVideoEncoderConfigurationResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__RemoveVideoEncoderConfigurationResponse(struct soap *soap, const struct _trt__RemoveVideoEncoderConfigurationResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__trt__RemoveVideoEncoderConfigurationResponse);
	if (soap_out__trt__RemoveVideoEncoderConfigurationResponse(soap, tag?tag:"trt:RemoveVideoEncoderConfigurationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__RemoveVideoEncoderConfigurationResponse * SOAP_FMAC4 soap_get__trt__RemoveVideoEncoderConfigurationResponse(struct soap *soap, struct _trt__RemoveVideoEncoderConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__RemoveVideoEncoderConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__RemoveVideoEncoderConfiguration(struct soap *soap, struct _trt__RemoveVideoEncoderConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ProfileToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__RemoveVideoEncoderConfiguration(struct soap *soap, const struct _trt__RemoveVideoEncoderConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_tt__ReferenceToken(soap, &a->ProfileToken);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__RemoveVideoEncoderConfiguration(struct soap *soap, const char *tag, int id, const struct _trt__RemoveVideoEncoderConfiguration *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__RemoveVideoEncoderConfiguration), type))
		return soap->error;
	if (a->ProfileToken)
	{	if (soap_out_tt__ReferenceToken(soap, "trt:ProfileToken", -1, &a->ProfileToken, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "trt:ProfileToken"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__RemoveVideoEncoderConfiguration * SOAP_FMAC4 soap_in__trt__RemoveVideoEncoderConfiguration(struct soap *soap, const char *tag, struct _trt__RemoveVideoEncoderConfiguration *a, const char *type)
{
	size_t soap_flag_ProfileToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trt__RemoveVideoEncoderConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__RemoveVideoEncoderConfiguration, sizeof(struct _trt__RemoveVideoEncoderConfiguration), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__RemoveVideoEncoderConfiguration(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "trt:ProfileToken", &a->ProfileToken, "tt:ReferenceToken"))
				{	soap_flag_ProfileToken--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trt__RemoveVideoEncoderConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__RemoveVideoEncoderConfiguration, 0, sizeof(struct _trt__RemoveVideoEncoderConfiguration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ProfileToken > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__RemoveVideoEncoderConfiguration(struct soap *soap, const struct _trt__RemoveVideoEncoderConfiguration *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__trt__RemoveVideoEncoderConfiguration);
	if (soap_out__trt__RemoveVideoEncoderConfiguration(soap, tag?tag:"trt:RemoveVideoEncoderConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__RemoveVideoEncoderConfiguration * SOAP_FMAC4 soap_get__trt__RemoveVideoEncoderConfiguration(struct soap *soap, struct _trt__RemoveVideoEncoderConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__RemoveVideoEncoderConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__AddVideoEncoderConfigurationResponse(struct soap *soap, struct _trt__AddVideoEncoderConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__AddVideoEncoderConfigurationResponse(struct soap *soap, const struct _trt__AddVideoEncoderConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__AddVideoEncoderConfigurationResponse(struct soap *soap, const char *tag, int id, const struct _trt__AddVideoEncoderConfigurationResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__AddVideoEncoderConfigurationResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__AddVideoEncoderConfigurationResponse * SOAP_FMAC4 soap_in__trt__AddVideoEncoderConfigurationResponse(struct soap *soap, const char *tag, struct _trt__AddVideoEncoderConfigurationResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trt__AddVideoEncoderConfigurationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__AddVideoEncoderConfigurationResponse, sizeof(struct _trt__AddVideoEncoderConfigurationResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__AddVideoEncoderConfigurationResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trt__AddVideoEncoderConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__AddVideoEncoderConfigurationResponse, 0, sizeof(struct _trt__AddVideoEncoderConfigurationResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__AddVideoEncoderConfigurationResponse(struct soap *soap, const struct _trt__AddVideoEncoderConfigurationResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__trt__AddVideoEncoderConfigurationResponse);
	if (soap_out__trt__AddVideoEncoderConfigurationResponse(soap, tag?tag:"trt:AddVideoEncoderConfigurationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__AddVideoEncoderConfigurationResponse * SOAP_FMAC4 soap_get__trt__AddVideoEncoderConfigurationResponse(struct soap *soap, struct _trt__AddVideoEncoderConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__AddVideoEncoderConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__AddVideoEncoderConfiguration(struct soap *soap, struct _trt__AddVideoEncoderConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ProfileToken);
	soap_default_tt__ReferenceToken(soap, &a->ConfigurationToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__AddVideoEncoderConfiguration(struct soap *soap, const struct _trt__AddVideoEncoderConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_tt__ReferenceToken(soap, &a->ProfileToken);
	soap_serialize_tt__ReferenceToken(soap, &a->ConfigurationToken);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__AddVideoEncoderConfiguration(struct soap *soap, const char *tag, int id, const struct _trt__AddVideoEncoderConfiguration *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__AddVideoEncoderConfiguration), type))
		return soap->error;
	if (a->ProfileToken)
	{	if (soap_out_tt__ReferenceToken(soap, "trt:ProfileToken", -1, &a->ProfileToken, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "trt:ProfileToken"))
		return soap->error;
	if (a->ConfigurationToken)
	{	if (soap_out_tt__ReferenceToken(soap, "trt:ConfigurationToken", -1, &a->ConfigurationToken, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "trt:ConfigurationToken"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__AddVideoEncoderConfiguration * SOAP_FMAC4 soap_in__trt__AddVideoEncoderConfiguration(struct soap *soap, const char *tag, struct _trt__AddVideoEncoderConfiguration *a, const char *type)
{
	size_t soap_flag_ProfileToken = 1;
	size_t soap_flag_ConfigurationToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trt__AddVideoEncoderConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__AddVideoEncoderConfiguration, sizeof(struct _trt__AddVideoEncoderConfiguration), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__AddVideoEncoderConfiguration(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "trt:ProfileToken", &a->ProfileToken, "tt:ReferenceToken"))
				{	soap_flag_ProfileToken--;
					continue;
				}
			if (soap_flag_ConfigurationToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "trt:ConfigurationToken", &a->ConfigurationToken, "tt:ReferenceToken"))
				{	soap_flag_ConfigurationToken--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trt__AddVideoEncoderConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__AddVideoEncoderConfiguration, 0, sizeof(struct _trt__AddVideoEncoderConfiguration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ProfileToken > 0 || soap_flag_ConfigurationToken > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__AddVideoEncoderConfiguration(struct soap *soap, const struct _trt__AddVideoEncoderConfiguration *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__trt__AddVideoEncoderConfiguration);
	if (soap_out__trt__AddVideoEncoderConfiguration(soap, tag?tag:"trt:AddVideoEncoderConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__AddVideoEncoderConfiguration * SOAP_FMAC4 soap_get__trt__AddVideoEncoderConfiguration(struct soap *soap, struct _trt__AddVideoEncoderConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__AddVideoEncoderConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__GetProfilesResponse(struct soap *soap, struct _trt__GetProfilesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeProfiles = 0;
	a->Profiles = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__GetProfilesResponse(struct soap *soap, const struct _trt__GetProfilesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->Profiles)
	{	int i;
		for (i = 0; i < a->__sizeProfiles; i++)
		{
			soap_embedded(soap, a->Profiles + i, SOAP_TYPE_tt__Profile);
			soap_serialize_tt__Profile(soap, a->Profiles + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__GetProfilesResponse(struct soap *soap, const char *tag, int id, const struct _trt__GetProfilesResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__GetProfilesResponse), type))
		return soap->error;
	soap_element_result(soap, "-sizeProfiles");
	if (a->Profiles)
	{	int i;
		for (i = 0; i < a->__sizeProfiles; i++)
			if (soap_out_tt__Profile(soap, "trt:Profiles", -1, a->Profiles + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__GetProfilesResponse * SOAP_FMAC4 soap_in__trt__GetProfilesResponse(struct soap *soap, const char *tag, struct _trt__GetProfilesResponse *a, const char *type)
{
	struct soap_blist *soap_blist_Profiles = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trt__GetProfilesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetProfilesResponse, sizeof(struct _trt__GetProfilesResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__GetProfilesResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "trt:Profiles", 1, NULL))
			{	if (a->Profiles == NULL)
				{	if (soap_blist_Profiles == NULL)
						soap_blist_Profiles = soap_new_block(soap);
					a->Profiles = (struct tt__Profile *)soap_push_block(soap, soap_blist_Profiles, sizeof(struct tt__Profile));
					if (a->Profiles == NULL)
						return NULL;
					soap_default_tt__Profile(soap, a->Profiles);
				}
				soap_revert(soap);
				if (soap_in_tt__Profile(soap, "trt:Profiles", a->Profiles, "tt:Profile"))
				{	a->__sizeProfiles++;
					a->Profiles = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizeProfiles");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Profiles)
			soap_pop_block(soap, soap_blist_Profiles);
		if (a->__sizeProfiles)
			a->Profiles = (struct tt__Profile *)soap_save_block(soap, soap_blist_Profiles, NULL, 1);
		else
		{	a->Profiles = NULL;
			if (soap_blist_Profiles)
				soap_end_block(soap, soap_blist_Profiles);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trt__GetProfilesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetProfilesResponse, 0, sizeof(struct _trt__GetProfilesResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__GetProfilesResponse(struct soap *soap, const struct _trt__GetProfilesResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__trt__GetProfilesResponse);
	if (soap_out__trt__GetProfilesResponse(soap, tag?tag:"trt:GetProfilesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetProfilesResponse * SOAP_FMAC4 soap_get__trt__GetProfilesResponse(struct soap *soap, struct _trt__GetProfilesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__GetProfilesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__GetProfiles(struct soap *soap, struct _trt__GetProfiles *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__GetProfiles(struct soap *soap, const struct _trt__GetProfiles *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__GetProfiles(struct soap *soap, const char *tag, int id, const struct _trt__GetProfiles *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__GetProfiles), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__GetProfiles * SOAP_FMAC4 soap_in__trt__GetProfiles(struct soap *soap, const char *tag, struct _trt__GetProfiles *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trt__GetProfiles *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetProfiles, sizeof(struct _trt__GetProfiles), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__GetProfiles(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trt__GetProfiles *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetProfiles, 0, sizeof(struct _trt__GetProfiles), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__GetProfiles(struct soap *soap, const struct _trt__GetProfiles *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__trt__GetProfiles);
	if (soap_out__trt__GetProfiles(soap, tag?tag:"trt:GetProfiles", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetProfiles * SOAP_FMAC4 soap_get__trt__GetProfiles(struct soap *soap, struct _trt__GetProfiles *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__GetProfiles(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__GetProfileResponse(struct soap *soap, struct _trt__GetProfileResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Profile = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__GetProfileResponse(struct soap *soap, const struct _trt__GetProfileResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTott__Profile(soap, &a->Profile);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__GetProfileResponse(struct soap *soap, const char *tag, int id, const struct _trt__GetProfileResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__GetProfileResponse), type))
		return soap->error;
	if (a->Profile)
		soap_element_result(soap, "trt:Profile");
	if (a->Profile)
	{	if (soap_out_PointerTott__Profile(soap, "trt:Profile", -1, &a->Profile, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "trt:Profile"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__GetProfileResponse * SOAP_FMAC4 soap_in__trt__GetProfileResponse(struct soap *soap, const char *tag, struct _trt__GetProfileResponse *a, const char *type)
{
	size_t soap_flag_Profile = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trt__GetProfileResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetProfileResponse, sizeof(struct _trt__GetProfileResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__GetProfileResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Profile && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__Profile(soap, "trt:Profile", &a->Profile, "tt:Profile"))
				{	soap_flag_Profile--;
					continue;
				}
			soap_check_result(soap, "trt:Profile");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trt__GetProfileResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetProfileResponse, 0, sizeof(struct _trt__GetProfileResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Profile > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__GetProfileResponse(struct soap *soap, const struct _trt__GetProfileResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__trt__GetProfileResponse);
	if (soap_out__trt__GetProfileResponse(soap, tag?tag:"trt:GetProfileResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetProfileResponse * SOAP_FMAC4 soap_get__trt__GetProfileResponse(struct soap *soap, struct _trt__GetProfileResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__GetProfileResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__GetProfile(struct soap *soap, struct _trt__GetProfile *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ProfileToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__GetProfile(struct soap *soap, const struct _trt__GetProfile *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_tt__ReferenceToken(soap, &a->ProfileToken);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__GetProfile(struct soap *soap, const char *tag, int id, const struct _trt__GetProfile *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__GetProfile), type))
		return soap->error;
	if (a->ProfileToken)
	{	if (soap_out_tt__ReferenceToken(soap, "trt:ProfileToken", -1, &a->ProfileToken, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "trt:ProfileToken"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__GetProfile * SOAP_FMAC4 soap_in__trt__GetProfile(struct soap *soap, const char *tag, struct _trt__GetProfile *a, const char *type)
{
	size_t soap_flag_ProfileToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trt__GetProfile *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetProfile, sizeof(struct _trt__GetProfile), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__GetProfile(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "trt:ProfileToken", &a->ProfileToken, "tt:ReferenceToken"))
				{	soap_flag_ProfileToken--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trt__GetProfile *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetProfile, 0, sizeof(struct _trt__GetProfile), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ProfileToken > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__GetProfile(struct soap *soap, const struct _trt__GetProfile *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__trt__GetProfile);
	if (soap_out__trt__GetProfile(soap, tag?tag:"trt:GetProfile", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetProfile * SOAP_FMAC4 soap_get__trt__GetProfile(struct soap *soap, struct _trt__GetProfile *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__GetProfile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__CreateProfileResponse(struct soap *soap, struct _trt__CreateProfileResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Profile = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__CreateProfileResponse(struct soap *soap, const struct _trt__CreateProfileResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTott__Profile(soap, &a->Profile);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__CreateProfileResponse(struct soap *soap, const char *tag, int id, const struct _trt__CreateProfileResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__CreateProfileResponse), type))
		return soap->error;
	if (a->Profile)
		soap_element_result(soap, "trt:Profile");
	if (a->Profile)
	{	if (soap_out_PointerTott__Profile(soap, "trt:Profile", -1, &a->Profile, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "trt:Profile"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__CreateProfileResponse * SOAP_FMAC4 soap_in__trt__CreateProfileResponse(struct soap *soap, const char *tag, struct _trt__CreateProfileResponse *a, const char *type)
{
	size_t soap_flag_Profile = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trt__CreateProfileResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__CreateProfileResponse, sizeof(struct _trt__CreateProfileResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__CreateProfileResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Profile && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__Profile(soap, "trt:Profile", &a->Profile, "tt:Profile"))
				{	soap_flag_Profile--;
					continue;
				}
			soap_check_result(soap, "trt:Profile");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trt__CreateProfileResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__CreateProfileResponse, 0, sizeof(struct _trt__CreateProfileResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Profile > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__CreateProfileResponse(struct soap *soap, const struct _trt__CreateProfileResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__trt__CreateProfileResponse);
	if (soap_out__trt__CreateProfileResponse(soap, tag?tag:"trt:CreateProfileResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__CreateProfileResponse * SOAP_FMAC4 soap_get__trt__CreateProfileResponse(struct soap *soap, struct _trt__CreateProfileResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__CreateProfileResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__CreateProfile(struct soap *soap, struct _trt__CreateProfile *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__Name(soap, &a->Name);
	soap_default_tt__ReferenceToken(soap, &a->Token);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__CreateProfile(struct soap *soap, const struct _trt__CreateProfile *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_tt__Name(soap, &a->Name);
	soap_serialize_tt__ReferenceToken(soap, &a->Token);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__CreateProfile(struct soap *soap, const char *tag, int id, const struct _trt__CreateProfile *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__CreateProfile), type))
		return soap->error;
	if (a->Name)
	{	if (soap_out_tt__Name(soap, "trt:Name", -1, &a->Name, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "trt:Name"))
		return soap->error;
	if (soap_out_tt__ReferenceToken(soap, "trt:Token", -1, &a->Token, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__CreateProfile * SOAP_FMAC4 soap_in__trt__CreateProfile(struct soap *soap, const char *tag, struct _trt__CreateProfile *a, const char *type)
{
	size_t soap_flag_Name = 1;
	size_t soap_flag_Token = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trt__CreateProfile *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__CreateProfile, sizeof(struct _trt__CreateProfile), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__CreateProfile(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__Name(soap, "trt:Name", &a->Name, "tt:Name"))
				{	soap_flag_Name--;
					continue;
				}
			if (soap_flag_Token && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "trt:Token", &a->Token, "tt:ReferenceToken"))
				{	soap_flag_Token--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trt__CreateProfile *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__CreateProfile, 0, sizeof(struct _trt__CreateProfile), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Name > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__CreateProfile(struct soap *soap, const struct _trt__CreateProfile *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__trt__CreateProfile);
	if (soap_out__trt__CreateProfile(soap, tag?tag:"trt:CreateProfile", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__CreateProfile * SOAP_FMAC4 soap_get__trt__CreateProfile(struct soap *soap, struct _trt__CreateProfile *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__CreateProfile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__AudioOutput(struct soap *soap, struct tt__AudioOutput *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->token);
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__AudioOutput(struct soap *soap, const struct tt__AudioOutput *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AudioOutput(struct soap *soap, const char *tag, int id, const struct tt__AudioOutput *a, const char *type)
{
	if (a->token)
		soap_set_attr(soap, "token", a->token, 1);
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AudioOutput), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__AudioOutput * SOAP_FMAC4 soap_in_tt__AudioOutput(struct soap *soap, const char *tag, struct tt__AudioOutput *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__AudioOutput *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AudioOutput, sizeof(struct tt__AudioOutput), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__AudioOutput(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "token", 1), &a->token, -1, 64))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__AudioOutput *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AudioOutput, 0, sizeof(struct tt__AudioOutput), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__AudioOutput(struct soap *soap, const struct tt__AudioOutput *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__AudioOutput);
	if (soap_out_tt__AudioOutput(soap, tag?tag:"tt:AudioOutput", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AudioOutput * SOAP_FMAC4 soap_get_tt__AudioOutput(struct soap *soap, struct tt__AudioOutput *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AudioOutput(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__GetAudioOutputsResponse(struct soap *soap, struct _trt__GetAudioOutputsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeAudioOutputs = 0;
	a->AudioOutputs = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__GetAudioOutputsResponse(struct soap *soap, const struct _trt__GetAudioOutputsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->AudioOutputs)
	{	int i;
		for (i = 0; i < a->__sizeAudioOutputs; i++)
		{
			soap_embedded(soap, a->AudioOutputs + i, SOAP_TYPE_tt__AudioOutput);
			soap_serialize_tt__AudioOutput(soap, a->AudioOutputs + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__GetAudioOutputsResponse(struct soap *soap, const char *tag, int id, const struct _trt__GetAudioOutputsResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__GetAudioOutputsResponse), type))
		return soap->error;
	soap_element_result(soap, "-sizeAudioOutputs");
	if (a->AudioOutputs)
	{	int i;
		for (i = 0; i < a->__sizeAudioOutputs; i++)
			if (soap_out_tt__AudioOutput(soap, "trt:AudioOutputs", -1, a->AudioOutputs + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__GetAudioOutputsResponse * SOAP_FMAC4 soap_in__trt__GetAudioOutputsResponse(struct soap *soap, const char *tag, struct _trt__GetAudioOutputsResponse *a, const char *type)
{
	struct soap_blist *soap_blist_AudioOutputs = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trt__GetAudioOutputsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetAudioOutputsResponse, sizeof(struct _trt__GetAudioOutputsResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__GetAudioOutputsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "trt:AudioOutputs", 1, NULL))
			{	if (a->AudioOutputs == NULL)
				{	if (soap_blist_AudioOutputs == NULL)
						soap_blist_AudioOutputs = soap_new_block(soap);
					a->AudioOutputs = (struct tt__AudioOutput *)soap_push_block(soap, soap_blist_AudioOutputs, sizeof(struct tt__AudioOutput));
					if (a->AudioOutputs == NULL)
						return NULL;
					soap_default_tt__AudioOutput(soap, a->AudioOutputs);
				}
				soap_revert(soap);
				if (soap_in_tt__AudioOutput(soap, "trt:AudioOutputs", a->AudioOutputs, "tt:AudioOutput"))
				{	a->__sizeAudioOutputs++;
					a->AudioOutputs = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizeAudioOutputs");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->AudioOutputs)
			soap_pop_block(soap, soap_blist_AudioOutputs);
		if (a->__sizeAudioOutputs)
			a->AudioOutputs = (struct tt__AudioOutput *)soap_save_block(soap, soap_blist_AudioOutputs, NULL, 1);
		else
		{	a->AudioOutputs = NULL;
			if (soap_blist_AudioOutputs)
				soap_end_block(soap, soap_blist_AudioOutputs);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trt__GetAudioOutputsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetAudioOutputsResponse, 0, sizeof(struct _trt__GetAudioOutputsResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__GetAudioOutputsResponse(struct soap *soap, const struct _trt__GetAudioOutputsResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__trt__GetAudioOutputsResponse);
	if (soap_out__trt__GetAudioOutputsResponse(soap, tag?tag:"trt:GetAudioOutputsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetAudioOutputsResponse * SOAP_FMAC4 soap_get__trt__GetAudioOutputsResponse(struct soap *soap, struct _trt__GetAudioOutputsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__GetAudioOutputsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__GetAudioOutputs(struct soap *soap, struct _trt__GetAudioOutputs *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__GetAudioOutputs(struct soap *soap, const struct _trt__GetAudioOutputs *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__GetAudioOutputs(struct soap *soap, const char *tag, int id, const struct _trt__GetAudioOutputs *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__GetAudioOutputs), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__GetAudioOutputs * SOAP_FMAC4 soap_in__trt__GetAudioOutputs(struct soap *soap, const char *tag, struct _trt__GetAudioOutputs *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trt__GetAudioOutputs *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetAudioOutputs, sizeof(struct _trt__GetAudioOutputs), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__GetAudioOutputs(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trt__GetAudioOutputs *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetAudioOutputs, 0, sizeof(struct _trt__GetAudioOutputs), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__GetAudioOutputs(struct soap *soap, const struct _trt__GetAudioOutputs *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__trt__GetAudioOutputs);
	if (soap_out__trt__GetAudioOutputs(soap, tag?tag:"trt:GetAudioOutputs", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetAudioOutputs * SOAP_FMAC4 soap_get__trt__GetAudioOutputs(struct soap *soap, struct _trt__GetAudioOutputs *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__GetAudioOutputs(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__AudioSource(struct soap *soap, struct tt__AudioSource *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->token);
	soap_default_int(soap, &a->Channels);
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__AudioSource(struct soap *soap, const struct tt__AudioSource *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->Channels, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AudioSource(struct soap *soap, const char *tag, int id, const struct tt__AudioSource *a, const char *type)
{
	if (a->token)
		soap_set_attr(soap, "token", a->token, 1);
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AudioSource), type))
		return soap->error;
	if (soap_out_int(soap, "tt:Channels", -1, &a->Channels, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__AudioSource * SOAP_FMAC4 soap_in_tt__AudioSource(struct soap *soap, const char *tag, struct tt__AudioSource *a, const char *type)
{
	size_t soap_flag_Channels = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__AudioSource *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AudioSource, sizeof(struct tt__AudioSource), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__AudioSource(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "token", 1), &a->token, -1, 64))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Channels && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "tt:Channels", &a->Channels, "xsd:int"))
				{	soap_flag_Channels--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__AudioSource *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AudioSource, 0, sizeof(struct tt__AudioSource), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Channels > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__AudioSource(struct soap *soap, const struct tt__AudioSource *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__AudioSource);
	if (soap_out_tt__AudioSource(soap, tag?tag:"tt:AudioSource", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AudioSource * SOAP_FMAC4 soap_get_tt__AudioSource(struct soap *soap, struct tt__AudioSource *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AudioSource(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__GetAudioSourcesResponse(struct soap *soap, struct _trt__GetAudioSourcesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeAudioSources = 0;
	a->AudioSources = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__GetAudioSourcesResponse(struct soap *soap, const struct _trt__GetAudioSourcesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->AudioSources)
	{	int i;
		for (i = 0; i < a->__sizeAudioSources; i++)
		{
			soap_embedded(soap, a->AudioSources + i, SOAP_TYPE_tt__AudioSource);
			soap_serialize_tt__AudioSource(soap, a->AudioSources + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__GetAudioSourcesResponse(struct soap *soap, const char *tag, int id, const struct _trt__GetAudioSourcesResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__GetAudioSourcesResponse), type))
		return soap->error;
	soap_element_result(soap, "-sizeAudioSources");
	if (a->AudioSources)
	{	int i;
		for (i = 0; i < a->__sizeAudioSources; i++)
			if (soap_out_tt__AudioSource(soap, "trt:AudioSources", -1, a->AudioSources + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__GetAudioSourcesResponse * SOAP_FMAC4 soap_in__trt__GetAudioSourcesResponse(struct soap *soap, const char *tag, struct _trt__GetAudioSourcesResponse *a, const char *type)
{
	struct soap_blist *soap_blist_AudioSources = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trt__GetAudioSourcesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetAudioSourcesResponse, sizeof(struct _trt__GetAudioSourcesResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__GetAudioSourcesResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "trt:AudioSources", 1, NULL))
			{	if (a->AudioSources == NULL)
				{	if (soap_blist_AudioSources == NULL)
						soap_blist_AudioSources = soap_new_block(soap);
					a->AudioSources = (struct tt__AudioSource *)soap_push_block(soap, soap_blist_AudioSources, sizeof(struct tt__AudioSource));
					if (a->AudioSources == NULL)
						return NULL;
					soap_default_tt__AudioSource(soap, a->AudioSources);
				}
				soap_revert(soap);
				if (soap_in_tt__AudioSource(soap, "trt:AudioSources", a->AudioSources, "tt:AudioSource"))
				{	a->__sizeAudioSources++;
					a->AudioSources = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizeAudioSources");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->AudioSources)
			soap_pop_block(soap, soap_blist_AudioSources);
		if (a->__sizeAudioSources)
			a->AudioSources = (struct tt__AudioSource *)soap_save_block(soap, soap_blist_AudioSources, NULL, 1);
		else
		{	a->AudioSources = NULL;
			if (soap_blist_AudioSources)
				soap_end_block(soap, soap_blist_AudioSources);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trt__GetAudioSourcesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetAudioSourcesResponse, 0, sizeof(struct _trt__GetAudioSourcesResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__GetAudioSourcesResponse(struct soap *soap, const struct _trt__GetAudioSourcesResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__trt__GetAudioSourcesResponse);
	if (soap_out__trt__GetAudioSourcesResponse(soap, tag?tag:"trt:GetAudioSourcesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetAudioSourcesResponse * SOAP_FMAC4 soap_get__trt__GetAudioSourcesResponse(struct soap *soap, struct _trt__GetAudioSourcesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__GetAudioSourcesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__GetAudioSources(struct soap *soap, struct _trt__GetAudioSources *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__GetAudioSources(struct soap *soap, const struct _trt__GetAudioSources *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__GetAudioSources(struct soap *soap, const char *tag, int id, const struct _trt__GetAudioSources *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__GetAudioSources), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__GetAudioSources * SOAP_FMAC4 soap_in__trt__GetAudioSources(struct soap *soap, const char *tag, struct _trt__GetAudioSources *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trt__GetAudioSources *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetAudioSources, sizeof(struct _trt__GetAudioSources), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__GetAudioSources(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trt__GetAudioSources *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetAudioSources, 0, sizeof(struct _trt__GetAudioSources), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__GetAudioSources(struct soap *soap, const struct _trt__GetAudioSources *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__trt__GetAudioSources);
	if (soap_out__trt__GetAudioSources(soap, tag?tag:"trt:GetAudioSources", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetAudioSources * SOAP_FMAC4 soap_get__trt__GetAudioSources(struct soap *soap, struct _trt__GetAudioSources *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__GetAudioSources(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__VideoSource(struct soap *soap, struct tt__VideoSource *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->token);
	soap_default_float(soap, &a->Framerate);
	a->Resolution = NULL;
	a->Imaging = NULL;
	a->Extension = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__VideoSource(struct soap *soap, const struct tt__VideoSource *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->Framerate, SOAP_TYPE_float);
	soap_serialize_PointerTott__VideoResolution(soap, &a->Resolution);
	soap_serialize_PointerTott__ImagingSettings(soap, &a->Imaging);
	soap_serialize_PointerTott__VideoSourceExtension(soap, &a->Extension);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__VideoSource(struct soap *soap, const char *tag, int id, const struct tt__VideoSource *a, const char *type)
{
	if (a->token)
		soap_set_attr(soap, "token", a->token, 1);
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__VideoSource), type))
		return soap->error;
	if (soap_out_float(soap, "tt:Framerate", -1, &a->Framerate, ""))
		return soap->error;
	if (a->Resolution)
	{	if (soap_out_PointerTott__VideoResolution(soap, "tt:Resolution", -1, &a->Resolution, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:Resolution"))
		return soap->error;
	if (soap_out_PointerTott__ImagingSettings(soap, "tt:Imaging", -1, &a->Imaging, ""))
		return soap->error;
	if (soap_out_PointerTott__VideoSourceExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__VideoSource * SOAP_FMAC4 soap_in_tt__VideoSource(struct soap *soap, const char *tag, struct tt__VideoSource *a, const char *type)
{
	size_t soap_flag_Framerate = 1;
	size_t soap_flag_Resolution = 1;
	size_t soap_flag_Imaging = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__VideoSource *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__VideoSource, sizeof(struct tt__VideoSource), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__VideoSource(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "token", 1), &a->token, -1, 64))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Framerate && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_float(soap, "tt:Framerate", &a->Framerate, "xsd:float"))
				{	soap_flag_Framerate--;
					continue;
				}
			if (soap_flag_Resolution && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__VideoResolution(soap, "tt:Resolution", &a->Resolution, "tt:VideoResolution"))
				{	soap_flag_Resolution--;
					continue;
				}
			if (soap_flag_Imaging && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__ImagingSettings(soap, "tt:Imaging", &a->Imaging, "tt:ImagingSettings"))
				{	soap_flag_Imaging--;
					continue;
				}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__VideoSourceExtension(soap, "tt:Extension", &a->Extension, "tt:VideoSourceExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__VideoSource *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__VideoSource, 0, sizeof(struct tt__VideoSource), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Framerate > 0 || soap_flag_Resolution > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__VideoSource(struct soap *soap, const struct tt__VideoSource *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__VideoSource);
	if (soap_out_tt__VideoSource(soap, tag?tag:"tt:VideoSource", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__VideoSource * SOAP_FMAC4 soap_get_tt__VideoSource(struct soap *soap, struct tt__VideoSource *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__VideoSource(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__GetVideoSourcesResponse(struct soap *soap, struct _trt__GetVideoSourcesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeVideoSources = 0;
	a->VideoSources = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__GetVideoSourcesResponse(struct soap *soap, const struct _trt__GetVideoSourcesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->VideoSources)
	{	int i;
		for (i = 0; i < a->__sizeVideoSources; i++)
		{
			soap_embedded(soap, a->VideoSources + i, SOAP_TYPE_tt__VideoSource);
			soap_serialize_tt__VideoSource(soap, a->VideoSources + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__GetVideoSourcesResponse(struct soap *soap, const char *tag, int id, const struct _trt__GetVideoSourcesResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__GetVideoSourcesResponse), type))
		return soap->error;
	soap_element_result(soap, "-sizeVideoSources");
	if (a->VideoSources)
	{	int i;
		for (i = 0; i < a->__sizeVideoSources; i++)
			if (soap_out_tt__VideoSource(soap, "trt:VideoSources", -1, a->VideoSources + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__GetVideoSourcesResponse * SOAP_FMAC4 soap_in__trt__GetVideoSourcesResponse(struct soap *soap, const char *tag, struct _trt__GetVideoSourcesResponse *a, const char *type)
{
	struct soap_blist *soap_blist_VideoSources = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trt__GetVideoSourcesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetVideoSourcesResponse, sizeof(struct _trt__GetVideoSourcesResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__GetVideoSourcesResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "trt:VideoSources", 1, NULL))
			{	if (a->VideoSources == NULL)
				{	if (soap_blist_VideoSources == NULL)
						soap_blist_VideoSources = soap_new_block(soap);
					a->VideoSources = (struct tt__VideoSource *)soap_push_block(soap, soap_blist_VideoSources, sizeof(struct tt__VideoSource));
					if (a->VideoSources == NULL)
						return NULL;
					soap_default_tt__VideoSource(soap, a->VideoSources);
				}
				soap_revert(soap);
				if (soap_in_tt__VideoSource(soap, "trt:VideoSources", a->VideoSources, "tt:VideoSource"))
				{	a->__sizeVideoSources++;
					a->VideoSources = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizeVideoSources");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->VideoSources)
			soap_pop_block(soap, soap_blist_VideoSources);
		if (a->__sizeVideoSources)
			a->VideoSources = (struct tt__VideoSource *)soap_save_block(soap, soap_blist_VideoSources, NULL, 1);
		else
		{	a->VideoSources = NULL;
			if (soap_blist_VideoSources)
				soap_end_block(soap, soap_blist_VideoSources);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trt__GetVideoSourcesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetVideoSourcesResponse, 0, sizeof(struct _trt__GetVideoSourcesResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__GetVideoSourcesResponse(struct soap *soap, const struct _trt__GetVideoSourcesResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__trt__GetVideoSourcesResponse);
	if (soap_out__trt__GetVideoSourcesResponse(soap, tag?tag:"trt:GetVideoSourcesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetVideoSourcesResponse * SOAP_FMAC4 soap_get__trt__GetVideoSourcesResponse(struct soap *soap, struct _trt__GetVideoSourcesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__GetVideoSourcesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__GetVideoSources(struct soap *soap, struct _trt__GetVideoSources *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__GetVideoSources(struct soap *soap, const struct _trt__GetVideoSources *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__GetVideoSources(struct soap *soap, const char *tag, int id, const struct _trt__GetVideoSources *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__GetVideoSources), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__GetVideoSources * SOAP_FMAC4 soap_in__trt__GetVideoSources(struct soap *soap, const char *tag, struct _trt__GetVideoSources *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trt__GetVideoSources *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetVideoSources, sizeof(struct _trt__GetVideoSources), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__GetVideoSources(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trt__GetVideoSources *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetVideoSources, 0, sizeof(struct _trt__GetVideoSources), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__GetVideoSources(struct soap *soap, const struct _trt__GetVideoSources *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__trt__GetVideoSources);
	if (soap_out__trt__GetVideoSources(soap, tag?tag:"trt:GetVideoSources", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetVideoSources * SOAP_FMAC4 soap_get__trt__GetVideoSources(struct soap *soap, struct _trt__GetVideoSources *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__GetVideoSources(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__GetServiceCapabilitiesResponse(struct soap *soap, struct _trt__GetServiceCapabilitiesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Capabilities = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__GetServiceCapabilitiesResponse(struct soap *soap, const struct _trt__GetServiceCapabilitiesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTotrt__Capabilities(soap, &a->Capabilities);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__GetServiceCapabilitiesResponse(struct soap *soap, const char *tag, int id, const struct _trt__GetServiceCapabilitiesResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__GetServiceCapabilitiesResponse), type))
		return soap->error;
	if (a->Capabilities)
		soap_element_result(soap, "trt:Capabilities");
	if (a->Capabilities)
	{	if (soap_out_PointerTotrt__Capabilities(soap, "trt:Capabilities", -1, &a->Capabilities, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "trt:Capabilities"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__GetServiceCapabilitiesResponse * SOAP_FMAC4 soap_in__trt__GetServiceCapabilitiesResponse(struct soap *soap, const char *tag, struct _trt__GetServiceCapabilitiesResponse *a, const char *type)
{
	size_t soap_flag_Capabilities = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trt__GetServiceCapabilitiesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetServiceCapabilitiesResponse, sizeof(struct _trt__GetServiceCapabilitiesResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__GetServiceCapabilitiesResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Capabilities && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotrt__Capabilities(soap, "trt:Capabilities", &a->Capabilities, "trt:Capabilities"))
				{	soap_flag_Capabilities--;
					continue;
				}
			soap_check_result(soap, "trt:Capabilities");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trt__GetServiceCapabilitiesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetServiceCapabilitiesResponse, 0, sizeof(struct _trt__GetServiceCapabilitiesResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Capabilities > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__GetServiceCapabilitiesResponse(struct soap *soap, const struct _trt__GetServiceCapabilitiesResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__trt__GetServiceCapabilitiesResponse);
	if (soap_out__trt__GetServiceCapabilitiesResponse(soap, tag?tag:"trt:GetServiceCapabilitiesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetServiceCapabilitiesResponse * SOAP_FMAC4 soap_get__trt__GetServiceCapabilitiesResponse(struct soap *soap, struct _trt__GetServiceCapabilitiesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__GetServiceCapabilitiesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__GetServiceCapabilities(struct soap *soap, struct _trt__GetServiceCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__GetServiceCapabilities(struct soap *soap, const struct _trt__GetServiceCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__GetServiceCapabilities(struct soap *soap, const char *tag, int id, const struct _trt__GetServiceCapabilities *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__GetServiceCapabilities), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__GetServiceCapabilities * SOAP_FMAC4 soap_in__trt__GetServiceCapabilities(struct soap *soap, const char *tag, struct _trt__GetServiceCapabilities *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trt__GetServiceCapabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetServiceCapabilities, sizeof(struct _trt__GetServiceCapabilities), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__GetServiceCapabilities(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trt__GetServiceCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetServiceCapabilities, 0, sizeof(struct _trt__GetServiceCapabilities), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__GetServiceCapabilities(struct soap *soap, const struct _trt__GetServiceCapabilities *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__trt__GetServiceCapabilities);
	if (soap_out__trt__GetServiceCapabilities(soap, tag?tag:"trt:GetServiceCapabilities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetServiceCapabilities * SOAP_FMAC4 soap_get__trt__GetServiceCapabilities(struct soap *soap, struct _trt__GetServiceCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__GetServiceCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_trt__StreamingCapabilities(struct soap *soap, struct trt__StreamingCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
	a->RTPMulticast = NULL;
	a->RTP_USCORETCP = NULL;
	a->RTP_USCORERTSP_USCORETCP = NULL;
	a->NonAggregateControl = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_trt__StreamingCapabilities(struct soap *soap, const struct trt__StreamingCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_trt__StreamingCapabilities(struct soap *soap, const char *tag, int id, const struct trt__StreamingCapabilities *a, const char *type)
{
	if (a->RTPMulticast)
		soap_set_attr(soap, "RTPMulticast", soap_xsd__boolean_2s(soap, *a->RTPMulticast), 1);
	if (a->RTP_USCORETCP)
		soap_set_attr(soap, "RTP_TCP", soap_xsd__boolean_2s(soap, *a->RTP_USCORETCP), 1);
	if (a->RTP_USCORERTSP_USCORETCP)
		soap_set_attr(soap, "RTP_RTSP_TCP", soap_xsd__boolean_2s(soap, *a->RTP_USCORERTSP_USCORETCP), 1);
	if (a->NonAggregateControl)
		soap_set_attr(soap, "NonAggregateControl", soap_xsd__boolean_2s(soap, *a->NonAggregateControl), 1);
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_trt__StreamingCapabilities), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct trt__StreamingCapabilities * SOAP_FMAC4 soap_in_trt__StreamingCapabilities(struct soap *soap, const char *tag, struct trt__StreamingCapabilities *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct trt__StreamingCapabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_trt__StreamingCapabilities, sizeof(struct trt__StreamingCapabilities), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_trt__StreamingCapabilities(soap, a);
	{	const char *t = soap_attr_value(soap, "RTPMulticast", 0);
		if (t)
		{
			if (!(a->RTPMulticast = (enum xsd__boolean_ *)soap_malloc(soap, sizeof(enum xsd__boolean_))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean_(soap, t, a->RTPMulticast))
			return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "RTP_TCP", 0);
		if (t)
		{
			if (!(a->RTP_USCORETCP = (enum xsd__boolean_ *)soap_malloc(soap, sizeof(enum xsd__boolean_))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean_(soap, t, a->RTP_USCORETCP))
			return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "RTP_RTSP_TCP", 0);
		if (t)
		{
			if (!(a->RTP_USCORERTSP_USCORETCP = (enum xsd__boolean_ *)soap_malloc(soap, sizeof(enum xsd__boolean_))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean_(soap, t, a->RTP_USCORERTSP_USCORETCP))
			return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "NonAggregateControl", 0);
		if (t)
		{
			if (!(a->NonAggregateControl = (enum xsd__boolean_ *)soap_malloc(soap, sizeof(enum xsd__boolean_))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean_(soap, t, a->NonAggregateControl))
			return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct trt__StreamingCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_trt__StreamingCapabilities, 0, sizeof(struct trt__StreamingCapabilities), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_trt__StreamingCapabilities(struct soap *soap, const struct trt__StreamingCapabilities *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_trt__StreamingCapabilities);
	if (soap_out_trt__StreamingCapabilities(soap, tag?tag:"trt:StreamingCapabilities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct trt__StreamingCapabilities * SOAP_FMAC4 soap_get_trt__StreamingCapabilities(struct soap *soap, struct trt__StreamingCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_trt__StreamingCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_trt__ProfileCapabilities(struct soap *soap, struct trt__ProfileCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
	a->MaximumNumberOfProfiles = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_trt__ProfileCapabilities(struct soap *soap, const struct trt__ProfileCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_trt__ProfileCapabilities(struct soap *soap, const char *tag, int id, const struct trt__ProfileCapabilities *a, const char *type)
{
	if (a->MaximumNumberOfProfiles)
		soap_set_attr(soap, "MaximumNumberOfProfiles", soap_int2s(soap, *a->MaximumNumberOfProfiles), 1);
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_trt__ProfileCapabilities), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct trt__ProfileCapabilities * SOAP_FMAC4 soap_in_trt__ProfileCapabilities(struct soap *soap, const char *tag, struct trt__ProfileCapabilities *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct trt__ProfileCapabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_trt__ProfileCapabilities, sizeof(struct trt__ProfileCapabilities), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_trt__ProfileCapabilities(soap, a);
	{	const char *t = soap_attr_value(soap, "MaximumNumberOfProfiles", 0);
		if (t)
		{
			if (!(a->MaximumNumberOfProfiles = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2int(soap, t, a->MaximumNumberOfProfiles))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct trt__ProfileCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_trt__ProfileCapabilities, 0, sizeof(struct trt__ProfileCapabilities), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_trt__ProfileCapabilities(struct soap *soap, const struct trt__ProfileCapabilities *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_trt__ProfileCapabilities);
	if (soap_out_trt__ProfileCapabilities(soap, tag?tag:"trt:ProfileCapabilities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct trt__ProfileCapabilities * SOAP_FMAC4 soap_get_trt__ProfileCapabilities(struct soap *soap, struct trt__ProfileCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_trt__ProfileCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_trt__Capabilities(struct soap *soap, struct trt__Capabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ProfileCapabilities = NULL;
	a->StreamingCapabilities = NULL;
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_trt__Capabilities(struct soap *soap, const struct trt__Capabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTotrt__ProfileCapabilities(soap, &a->ProfileCapabilities);
	soap_serialize_PointerTotrt__StreamingCapabilities(soap, &a->StreamingCapabilities);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_trt__Capabilities(struct soap *soap, const char *tag, int id, const struct trt__Capabilities *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_trt__Capabilities), type))
		return soap->error;
	if (a->ProfileCapabilities)
	{	if (soap_out_PointerTotrt__ProfileCapabilities(soap, "trt:ProfileCapabilities", -1, &a->ProfileCapabilities, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "trt:ProfileCapabilities"))
		return soap->error;
	if (a->StreamingCapabilities)
	{	if (soap_out_PointerTotrt__StreamingCapabilities(soap, "trt:StreamingCapabilities", -1, &a->StreamingCapabilities, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "trt:StreamingCapabilities"))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct trt__Capabilities * SOAP_FMAC4 soap_in_trt__Capabilities(struct soap *soap, const char *tag, struct trt__Capabilities *a, const char *type)
{
	size_t soap_flag_ProfileCapabilities = 1;
	size_t soap_flag_StreamingCapabilities = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct trt__Capabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_trt__Capabilities, sizeof(struct trt__Capabilities), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_trt__Capabilities(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ProfileCapabilities && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotrt__ProfileCapabilities(soap, "trt:ProfileCapabilities", &a->ProfileCapabilities, "trt:ProfileCapabilities"))
				{	soap_flag_ProfileCapabilities--;
					continue;
				}
			if (soap_flag_StreamingCapabilities && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotrt__StreamingCapabilities(soap, "trt:StreamingCapabilities", &a->StreamingCapabilities, "trt:StreamingCapabilities"))
				{	soap_flag_StreamingCapabilities--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct trt__Capabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_trt__Capabilities, 0, sizeof(struct trt__Capabilities), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ProfileCapabilities > 0 || soap_flag_StreamingCapabilities > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_trt__Capabilities(struct soap *soap, const struct trt__Capabilities *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_trt__Capabilities);
	if (soap_out_trt__Capabilities(soap, tag?tag:"trt:Capabilities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct trt__Capabilities * SOAP_FMAC4 soap_get_trt__Capabilities(struct soap *soap, struct trt__Capabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_trt__Capabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__timg__GetStatusResponse(struct soap *soap, struct _timg__GetStatusResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Status = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__timg__GetStatusResponse(struct soap *soap, const struct _timg__GetStatusResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTott__ImagingStatus20(soap, &a->Status);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__timg__GetStatusResponse(struct soap *soap, const char *tag, int id, const struct _timg__GetStatusResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__timg__GetStatusResponse), type))
		return soap->error;
	if (a->Status)
		soap_element_result(soap, "timg:Status");
	if (a->Status)
	{	if (soap_out_PointerTott__ImagingStatus20(soap, "timg:Status", -1, &a->Status, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "timg:Status"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _timg__GetStatusResponse * SOAP_FMAC4 soap_in__timg__GetStatusResponse(struct soap *soap, const char *tag, struct _timg__GetStatusResponse *a, const char *type)
{
	size_t soap_flag_Status = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _timg__GetStatusResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__timg__GetStatusResponse, sizeof(struct _timg__GetStatusResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__timg__GetStatusResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Status && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__ImagingStatus20(soap, "timg:Status", &a->Status, "tt:ImagingStatus20"))
				{	soap_flag_Status--;
					continue;
				}
			soap_check_result(soap, "timg:Status");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _timg__GetStatusResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__timg__GetStatusResponse, 0, sizeof(struct _timg__GetStatusResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Status > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__timg__GetStatusResponse(struct soap *soap, const struct _timg__GetStatusResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__timg__GetStatusResponse);
	if (soap_out__timg__GetStatusResponse(soap, tag?tag:"timg:GetStatusResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _timg__GetStatusResponse * SOAP_FMAC4 soap_get__timg__GetStatusResponse(struct soap *soap, struct _timg__GetStatusResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__timg__GetStatusResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__timg__GetStatus(struct soap *soap, struct _timg__GetStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->VideoSourceToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__timg__GetStatus(struct soap *soap, const struct _timg__GetStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_tt__ReferenceToken(soap, &a->VideoSourceToken);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__timg__GetStatus(struct soap *soap, const char *tag, int id, const struct _timg__GetStatus *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__timg__GetStatus), type))
		return soap->error;
	if (a->VideoSourceToken)
	{	if (soap_out_tt__ReferenceToken(soap, "timg:VideoSourceToken", -1, &a->VideoSourceToken, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "timg:VideoSourceToken"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _timg__GetStatus * SOAP_FMAC4 soap_in__timg__GetStatus(struct soap *soap, const char *tag, struct _timg__GetStatus *a, const char *type)
{
	size_t soap_flag_VideoSourceToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _timg__GetStatus *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__timg__GetStatus, sizeof(struct _timg__GetStatus), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__timg__GetStatus(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_VideoSourceToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "timg:VideoSourceToken", &a->VideoSourceToken, "tt:ReferenceToken"))
				{	soap_flag_VideoSourceToken--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _timg__GetStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__timg__GetStatus, 0, sizeof(struct _timg__GetStatus), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_VideoSourceToken > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__timg__GetStatus(struct soap *soap, const struct _timg__GetStatus *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__timg__GetStatus);
	if (soap_out__timg__GetStatus(soap, tag?tag:"timg:GetStatus", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _timg__GetStatus * SOAP_FMAC4 soap_get__timg__GetStatus(struct soap *soap, struct _timg__GetStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in__timg__GetStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__timg__StopResponse(struct soap *soap, struct _timg__StopResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__timg__StopResponse(struct soap *soap, const struct _timg__StopResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__timg__StopResponse(struct soap *soap, const char *tag, int id, const struct _timg__StopResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__timg__StopResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _timg__StopResponse * SOAP_FMAC4 soap_in__timg__StopResponse(struct soap *soap, const char *tag, struct _timg__StopResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _timg__StopResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__timg__StopResponse, sizeof(struct _timg__StopResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__timg__StopResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _timg__StopResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__timg__StopResponse, 0, sizeof(struct _timg__StopResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__timg__StopResponse(struct soap *soap, const struct _timg__StopResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__timg__StopResponse);
	if (soap_out__timg__StopResponse(soap, tag?tag:"timg:StopResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _timg__StopResponse * SOAP_FMAC4 soap_get__timg__StopResponse(struct soap *soap, struct _timg__StopResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__timg__StopResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__timg__Stop(struct soap *soap, struct _timg__Stop *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->VideoSourceToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__timg__Stop(struct soap *soap, const struct _timg__Stop *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_tt__ReferenceToken(soap, &a->VideoSourceToken);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__timg__Stop(struct soap *soap, const char *tag, int id, const struct _timg__Stop *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__timg__Stop), type))
		return soap->error;
	if (a->VideoSourceToken)
	{	if (soap_out_tt__ReferenceToken(soap, "timg:VideoSourceToken", -1, &a->VideoSourceToken, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "timg:VideoSourceToken"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _timg__Stop * SOAP_FMAC4 soap_in__timg__Stop(struct soap *soap, const char *tag, struct _timg__Stop *a, const char *type)
{
	size_t soap_flag_VideoSourceToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _timg__Stop *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__timg__Stop, sizeof(struct _timg__Stop), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__timg__Stop(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_VideoSourceToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "timg:VideoSourceToken", &a->VideoSourceToken, "tt:ReferenceToken"))
				{	soap_flag_VideoSourceToken--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _timg__Stop *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__timg__Stop, 0, sizeof(struct _timg__Stop), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_VideoSourceToken > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__timg__Stop(struct soap *soap, const struct _timg__Stop *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__timg__Stop);
	if (soap_out__timg__Stop(soap, tag?tag:"timg:Stop", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _timg__Stop * SOAP_FMAC4 soap_get__timg__Stop(struct soap *soap, struct _timg__Stop *p, const char *tag, const char *type)
{
	if ((p = soap_in__timg__Stop(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__timg__GetMoveOptionsResponse(struct soap *soap, struct _timg__GetMoveOptionsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->MoveOptions = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__timg__GetMoveOptionsResponse(struct soap *soap, const struct _timg__GetMoveOptionsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTott__MoveOptions20(soap, &a->MoveOptions);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__timg__GetMoveOptionsResponse(struct soap *soap, const char *tag, int id, const struct _timg__GetMoveOptionsResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__timg__GetMoveOptionsResponse), type))
		return soap->error;
	if (a->MoveOptions)
		soap_element_result(soap, "timg:MoveOptions");
	if (a->MoveOptions)
	{	if (soap_out_PointerTott__MoveOptions20(soap, "timg:MoveOptions", -1, &a->MoveOptions, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "timg:MoveOptions"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _timg__GetMoveOptionsResponse * SOAP_FMAC4 soap_in__timg__GetMoveOptionsResponse(struct soap *soap, const char *tag, struct _timg__GetMoveOptionsResponse *a, const char *type)
{
	size_t soap_flag_MoveOptions = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _timg__GetMoveOptionsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__timg__GetMoveOptionsResponse, sizeof(struct _timg__GetMoveOptionsResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__timg__GetMoveOptionsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_MoveOptions && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__MoveOptions20(soap, "timg:MoveOptions", &a->MoveOptions, "tt:MoveOptions20"))
				{	soap_flag_MoveOptions--;
					continue;
				}
			soap_check_result(soap, "timg:MoveOptions");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _timg__GetMoveOptionsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__timg__GetMoveOptionsResponse, 0, sizeof(struct _timg__GetMoveOptionsResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_MoveOptions > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__timg__GetMoveOptionsResponse(struct soap *soap, const struct _timg__GetMoveOptionsResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__timg__GetMoveOptionsResponse);
	if (soap_out__timg__GetMoveOptionsResponse(soap, tag?tag:"timg:GetMoveOptionsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _timg__GetMoveOptionsResponse * SOAP_FMAC4 soap_get__timg__GetMoveOptionsResponse(struct soap *soap, struct _timg__GetMoveOptionsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__timg__GetMoveOptionsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__timg__GetMoveOptions(struct soap *soap, struct _timg__GetMoveOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->VideoSourceToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__timg__GetMoveOptions(struct soap *soap, const struct _timg__GetMoveOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_tt__ReferenceToken(soap, &a->VideoSourceToken);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__timg__GetMoveOptions(struct soap *soap, const char *tag, int id, const struct _timg__GetMoveOptions *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__timg__GetMoveOptions), type))
		return soap->error;
	if (a->VideoSourceToken)
	{	if (soap_out_tt__ReferenceToken(soap, "timg:VideoSourceToken", -1, &a->VideoSourceToken, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "timg:VideoSourceToken"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _timg__GetMoveOptions * SOAP_FMAC4 soap_in__timg__GetMoveOptions(struct soap *soap, const char *tag, struct _timg__GetMoveOptions *a, const char *type)
{
	size_t soap_flag_VideoSourceToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _timg__GetMoveOptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__timg__GetMoveOptions, sizeof(struct _timg__GetMoveOptions), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__timg__GetMoveOptions(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_VideoSourceToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "timg:VideoSourceToken", &a->VideoSourceToken, "tt:ReferenceToken"))
				{	soap_flag_VideoSourceToken--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _timg__GetMoveOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__timg__GetMoveOptions, 0, sizeof(struct _timg__GetMoveOptions), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_VideoSourceToken > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__timg__GetMoveOptions(struct soap *soap, const struct _timg__GetMoveOptions *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__timg__GetMoveOptions);
	if (soap_out__timg__GetMoveOptions(soap, tag?tag:"timg:GetMoveOptions", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _timg__GetMoveOptions * SOAP_FMAC4 soap_get__timg__GetMoveOptions(struct soap *soap, struct _timg__GetMoveOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in__timg__GetMoveOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__timg__MoveResponse(struct soap *soap, struct _timg__MoveResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__timg__MoveResponse(struct soap *soap, const struct _timg__MoveResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__timg__MoveResponse(struct soap *soap, const char *tag, int id, const struct _timg__MoveResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__timg__MoveResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _timg__MoveResponse * SOAP_FMAC4 soap_in__timg__MoveResponse(struct soap *soap, const char *tag, struct _timg__MoveResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _timg__MoveResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__timg__MoveResponse, sizeof(struct _timg__MoveResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__timg__MoveResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _timg__MoveResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__timg__MoveResponse, 0, sizeof(struct _timg__MoveResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__timg__MoveResponse(struct soap *soap, const struct _timg__MoveResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__timg__MoveResponse);
	if (soap_out__timg__MoveResponse(soap, tag?tag:"timg:MoveResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _timg__MoveResponse * SOAP_FMAC4 soap_get__timg__MoveResponse(struct soap *soap, struct _timg__MoveResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__timg__MoveResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__timg__Move(struct soap *soap, struct _timg__Move *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->VideoSourceToken);
	a->Focus = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__timg__Move(struct soap *soap, const struct _timg__Move *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_tt__ReferenceToken(soap, &a->VideoSourceToken);
	soap_serialize_PointerTott__FocusMove(soap, &a->Focus);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__timg__Move(struct soap *soap, const char *tag, int id, const struct _timg__Move *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__timg__Move), type))
		return soap->error;
	if (a->VideoSourceToken)
	{	if (soap_out_tt__ReferenceToken(soap, "timg:VideoSourceToken", -1, &a->VideoSourceToken, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "timg:VideoSourceToken"))
		return soap->error;
	if (a->Focus)
	{	if (soap_out_PointerTott__FocusMove(soap, "timg:Focus", -1, &a->Focus, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "timg:Focus"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _timg__Move * SOAP_FMAC4 soap_in__timg__Move(struct soap *soap, const char *tag, struct _timg__Move *a, const char *type)
{
	size_t soap_flag_VideoSourceToken = 1;
	size_t soap_flag_Focus = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _timg__Move *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__timg__Move, sizeof(struct _timg__Move), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__timg__Move(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_VideoSourceToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "timg:VideoSourceToken", &a->VideoSourceToken, "tt:ReferenceToken"))
				{	soap_flag_VideoSourceToken--;
					continue;
				}
			if (soap_flag_Focus && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__FocusMove(soap, "timg:Focus", &a->Focus, "tt:FocusMove"))
				{	soap_flag_Focus--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _timg__Move *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__timg__Move, 0, sizeof(struct _timg__Move), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_VideoSourceToken > 0 || soap_flag_Focus > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__timg__Move(struct soap *soap, const struct _timg__Move *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__timg__Move);
	if (soap_out__timg__Move(soap, tag?tag:"timg:Move", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _timg__Move * SOAP_FMAC4 soap_get__timg__Move(struct soap *soap, struct _timg__Move *p, const char *tag, const char *type)
{
	if ((p = soap_in__timg__Move(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__timg__GetOptionsResponse(struct soap *soap, struct _timg__GetOptionsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ImagingOptions = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__timg__GetOptionsResponse(struct soap *soap, const struct _timg__GetOptionsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTott__ImagingOptions20(soap, &a->ImagingOptions);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__timg__GetOptionsResponse(struct soap *soap, const char *tag, int id, const struct _timg__GetOptionsResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__timg__GetOptionsResponse), type))
		return soap->error;
	if (a->ImagingOptions)
		soap_element_result(soap, "timg:ImagingOptions");
	if (a->ImagingOptions)
	{	if (soap_out_PointerTott__ImagingOptions20(soap, "timg:ImagingOptions", -1, &a->ImagingOptions, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "timg:ImagingOptions"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _timg__GetOptionsResponse * SOAP_FMAC4 soap_in__timg__GetOptionsResponse(struct soap *soap, const char *tag, struct _timg__GetOptionsResponse *a, const char *type)
{
	size_t soap_flag_ImagingOptions = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _timg__GetOptionsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__timg__GetOptionsResponse, sizeof(struct _timg__GetOptionsResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__timg__GetOptionsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ImagingOptions && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__ImagingOptions20(soap, "timg:ImagingOptions", &a->ImagingOptions, "tt:ImagingOptions20"))
				{	soap_flag_ImagingOptions--;
					continue;
				}
			soap_check_result(soap, "timg:ImagingOptions");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _timg__GetOptionsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__timg__GetOptionsResponse, 0, sizeof(struct _timg__GetOptionsResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ImagingOptions > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__timg__GetOptionsResponse(struct soap *soap, const struct _timg__GetOptionsResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__timg__GetOptionsResponse);
	if (soap_out__timg__GetOptionsResponse(soap, tag?tag:"timg:GetOptionsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _timg__GetOptionsResponse * SOAP_FMAC4 soap_get__timg__GetOptionsResponse(struct soap *soap, struct _timg__GetOptionsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__timg__GetOptionsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__timg__GetOptions(struct soap *soap, struct _timg__GetOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->VideoSourceToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__timg__GetOptions(struct soap *soap, const struct _timg__GetOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_tt__ReferenceToken(soap, &a->VideoSourceToken);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__timg__GetOptions(struct soap *soap, const char *tag, int id, const struct _timg__GetOptions *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__timg__GetOptions), type))
		return soap->error;
	if (a->VideoSourceToken)
	{	if (soap_out_tt__ReferenceToken(soap, "timg:VideoSourceToken", -1, &a->VideoSourceToken, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "timg:VideoSourceToken"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _timg__GetOptions * SOAP_FMAC4 soap_in__timg__GetOptions(struct soap *soap, const char *tag, struct _timg__GetOptions *a, const char *type)
{
	size_t soap_flag_VideoSourceToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _timg__GetOptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__timg__GetOptions, sizeof(struct _timg__GetOptions), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__timg__GetOptions(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_VideoSourceToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "timg:VideoSourceToken", &a->VideoSourceToken, "tt:ReferenceToken"))
				{	soap_flag_VideoSourceToken--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _timg__GetOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__timg__GetOptions, 0, sizeof(struct _timg__GetOptions), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_VideoSourceToken > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__timg__GetOptions(struct soap *soap, const struct _timg__GetOptions *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__timg__GetOptions);
	if (soap_out__timg__GetOptions(soap, tag?tag:"timg:GetOptions", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _timg__GetOptions * SOAP_FMAC4 soap_get__timg__GetOptions(struct soap *soap, struct _timg__GetOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in__timg__GetOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__timg__SetImagingSettingsResponse(struct soap *soap, struct _timg__SetImagingSettingsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__timg__SetImagingSettingsResponse(struct soap *soap, const struct _timg__SetImagingSettingsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__timg__SetImagingSettingsResponse(struct soap *soap, const char *tag, int id, const struct _timg__SetImagingSettingsResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__timg__SetImagingSettingsResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _timg__SetImagingSettingsResponse * SOAP_FMAC4 soap_in__timg__SetImagingSettingsResponse(struct soap *soap, const char *tag, struct _timg__SetImagingSettingsResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _timg__SetImagingSettingsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__timg__SetImagingSettingsResponse, sizeof(struct _timg__SetImagingSettingsResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__timg__SetImagingSettingsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _timg__SetImagingSettingsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__timg__SetImagingSettingsResponse, 0, sizeof(struct _timg__SetImagingSettingsResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__timg__SetImagingSettingsResponse(struct soap *soap, const struct _timg__SetImagingSettingsResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__timg__SetImagingSettingsResponse);
	if (soap_out__timg__SetImagingSettingsResponse(soap, tag?tag:"timg:SetImagingSettingsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _timg__SetImagingSettingsResponse * SOAP_FMAC4 soap_get__timg__SetImagingSettingsResponse(struct soap *soap, struct _timg__SetImagingSettingsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__timg__SetImagingSettingsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__timg__SetImagingSettings(struct soap *soap, struct _timg__SetImagingSettings *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->VideoSourceToken);
	a->ImagingSettings = NULL;
	a->ForcePersistence_x0020 = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__timg__SetImagingSettings(struct soap *soap, const struct _timg__SetImagingSettings *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_tt__ReferenceToken(soap, &a->VideoSourceToken);
	soap_serialize_PointerTott__ImagingSettings20(soap, &a->ImagingSettings);
	soap_serialize_PointerToxsd__boolean_(soap, &a->ForcePersistence_x0020);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__timg__SetImagingSettings(struct soap *soap, const char *tag, int id, const struct _timg__SetImagingSettings *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__timg__SetImagingSettings), type))
		return soap->error;
	if (a->VideoSourceToken)
	{	if (soap_out_tt__ReferenceToken(soap, "timg:VideoSourceToken", -1, &a->VideoSourceToken, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "timg:VideoSourceToken"))
		return soap->error;
	if (a->ImagingSettings)
	{	if (soap_out_PointerTott__ImagingSettings20(soap, "timg:ImagingSettings", -1, &a->ImagingSettings, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "timg:ImagingSettings"))
		return soap->error;
	if (soap_out_PointerToxsd__boolean_(soap, "timg:ForcePersistence ", -1, &a->ForcePersistence_x0020, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _timg__SetImagingSettings * SOAP_FMAC4 soap_in__timg__SetImagingSettings(struct soap *soap, const char *tag, struct _timg__SetImagingSettings *a, const char *type)
{
	size_t soap_flag_VideoSourceToken = 1;
	size_t soap_flag_ImagingSettings = 1;
	size_t soap_flag_ForcePersistence_x0020 = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _timg__SetImagingSettings *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__timg__SetImagingSettings, sizeof(struct _timg__SetImagingSettings), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__timg__SetImagingSettings(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_VideoSourceToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "timg:VideoSourceToken", &a->VideoSourceToken, "tt:ReferenceToken"))
				{	soap_flag_VideoSourceToken--;
					continue;
				}
			if (soap_flag_ImagingSettings && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__ImagingSettings20(soap, "timg:ImagingSettings", &a->ImagingSettings, "tt:ImagingSettings20"))
				{	soap_flag_ImagingSettings--;
					continue;
				}
			if (soap_flag_ForcePersistence_x0020 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__boolean_(soap, "timg:ForcePersistence ", &a->ForcePersistence_x0020, "xsd:boolean"))
				{	soap_flag_ForcePersistence_x0020--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _timg__SetImagingSettings *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__timg__SetImagingSettings, 0, sizeof(struct _timg__SetImagingSettings), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_VideoSourceToken > 0 || soap_flag_ImagingSettings > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__timg__SetImagingSettings(struct soap *soap, const struct _timg__SetImagingSettings *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__timg__SetImagingSettings);
	if (soap_out__timg__SetImagingSettings(soap, tag?tag:"timg:SetImagingSettings", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _timg__SetImagingSettings * SOAP_FMAC4 soap_get__timg__SetImagingSettings(struct soap *soap, struct _timg__SetImagingSettings *p, const char *tag, const char *type)
{
	if ((p = soap_in__timg__SetImagingSettings(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__timg__GetImagingSettingsResponse(struct soap *soap, struct _timg__GetImagingSettingsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ImagingSettings = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__timg__GetImagingSettingsResponse(struct soap *soap, const struct _timg__GetImagingSettingsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTott__ImagingSettings20(soap, &a->ImagingSettings);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__timg__GetImagingSettingsResponse(struct soap *soap, const char *tag, int id, const struct _timg__GetImagingSettingsResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__timg__GetImagingSettingsResponse), type))
		return soap->error;
	if (a->ImagingSettings)
		soap_element_result(soap, "timg:ImagingSettings");
	if (a->ImagingSettings)
	{	if (soap_out_PointerTott__ImagingSettings20(soap, "timg:ImagingSettings", -1, &a->ImagingSettings, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "timg:ImagingSettings"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _timg__GetImagingSettingsResponse * SOAP_FMAC4 soap_in__timg__GetImagingSettingsResponse(struct soap *soap, const char *tag, struct _timg__GetImagingSettingsResponse *a, const char *type)
{
	size_t soap_flag_ImagingSettings = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _timg__GetImagingSettingsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__timg__GetImagingSettingsResponse, sizeof(struct _timg__GetImagingSettingsResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__timg__GetImagingSettingsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ImagingSettings && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__ImagingSettings20(soap, "timg:ImagingSettings", &a->ImagingSettings, "tt:ImagingSettings20"))
				{	soap_flag_ImagingSettings--;
					continue;
				}
			soap_check_result(soap, "timg:ImagingSettings");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _timg__GetImagingSettingsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__timg__GetImagingSettingsResponse, 0, sizeof(struct _timg__GetImagingSettingsResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ImagingSettings > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__timg__GetImagingSettingsResponse(struct soap *soap, const struct _timg__GetImagingSettingsResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__timg__GetImagingSettingsResponse);
	if (soap_out__timg__GetImagingSettingsResponse(soap, tag?tag:"timg:GetImagingSettingsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _timg__GetImagingSettingsResponse * SOAP_FMAC4 soap_get__timg__GetImagingSettingsResponse(struct soap *soap, struct _timg__GetImagingSettingsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__timg__GetImagingSettingsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__timg__GetImagingSettings(struct soap *soap, struct _timg__GetImagingSettings *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->VideoSourceToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__timg__GetImagingSettings(struct soap *soap, const struct _timg__GetImagingSettings *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_tt__ReferenceToken(soap, &a->VideoSourceToken);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__timg__GetImagingSettings(struct soap *soap, const char *tag, int id, const struct _timg__GetImagingSettings *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__timg__GetImagingSettings), type))
		return soap->error;
	if (a->VideoSourceToken)
	{	if (soap_out_tt__ReferenceToken(soap, "timg:VideoSourceToken", -1, &a->VideoSourceToken, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "timg:VideoSourceToken"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _timg__GetImagingSettings * SOAP_FMAC4 soap_in__timg__GetImagingSettings(struct soap *soap, const char *tag, struct _timg__GetImagingSettings *a, const char *type)
{
	size_t soap_flag_VideoSourceToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _timg__GetImagingSettings *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__timg__GetImagingSettings, sizeof(struct _timg__GetImagingSettings), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__timg__GetImagingSettings(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_VideoSourceToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "timg:VideoSourceToken", &a->VideoSourceToken, "tt:ReferenceToken"))
				{	soap_flag_VideoSourceToken--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _timg__GetImagingSettings *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__timg__GetImagingSettings, 0, sizeof(struct _timg__GetImagingSettings), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_VideoSourceToken > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__timg__GetImagingSettings(struct soap *soap, const struct _timg__GetImagingSettings *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__timg__GetImagingSettings);
	if (soap_out__timg__GetImagingSettings(soap, tag?tag:"timg:GetImagingSettings", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _timg__GetImagingSettings * SOAP_FMAC4 soap_get__timg__GetImagingSettings(struct soap *soap, struct _timg__GetImagingSettings *p, const char *tag, const char *type)
{
	if ((p = soap_in__timg__GetImagingSettings(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__timg__GetServiceCapabilitiesResponse(struct soap *soap, struct _timg__GetServiceCapabilitiesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Capabilities = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__timg__GetServiceCapabilitiesResponse(struct soap *soap, const struct _timg__GetServiceCapabilitiesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTotimg__Capabilities(soap, &a->Capabilities);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__timg__GetServiceCapabilitiesResponse(struct soap *soap, const char *tag, int id, const struct _timg__GetServiceCapabilitiesResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__timg__GetServiceCapabilitiesResponse), type))
		return soap->error;
	if (a->Capabilities)
		soap_element_result(soap, "timg:Capabilities");
	if (a->Capabilities)
	{	if (soap_out_PointerTotimg__Capabilities(soap, "timg:Capabilities", -1, &a->Capabilities, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "timg:Capabilities"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _timg__GetServiceCapabilitiesResponse * SOAP_FMAC4 soap_in__timg__GetServiceCapabilitiesResponse(struct soap *soap, const char *tag, struct _timg__GetServiceCapabilitiesResponse *a, const char *type)
{
	size_t soap_flag_Capabilities = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _timg__GetServiceCapabilitiesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__timg__GetServiceCapabilitiesResponse, sizeof(struct _timg__GetServiceCapabilitiesResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__timg__GetServiceCapabilitiesResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Capabilities && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotimg__Capabilities(soap, "timg:Capabilities", &a->Capabilities, "timg:Capabilities"))
				{	soap_flag_Capabilities--;
					continue;
				}
			soap_check_result(soap, "timg:Capabilities");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _timg__GetServiceCapabilitiesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__timg__GetServiceCapabilitiesResponse, 0, sizeof(struct _timg__GetServiceCapabilitiesResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Capabilities > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__timg__GetServiceCapabilitiesResponse(struct soap *soap, const struct _timg__GetServiceCapabilitiesResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__timg__GetServiceCapabilitiesResponse);
	if (soap_out__timg__GetServiceCapabilitiesResponse(soap, tag?tag:"timg:GetServiceCapabilitiesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _timg__GetServiceCapabilitiesResponse * SOAP_FMAC4 soap_get__timg__GetServiceCapabilitiesResponse(struct soap *soap, struct _timg__GetServiceCapabilitiesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__timg__GetServiceCapabilitiesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__timg__GetServiceCapabilities(struct soap *soap, struct _timg__GetServiceCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__timg__GetServiceCapabilities(struct soap *soap, const struct _timg__GetServiceCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__timg__GetServiceCapabilities(struct soap *soap, const char *tag, int id, const struct _timg__GetServiceCapabilities *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__timg__GetServiceCapabilities), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _timg__GetServiceCapabilities * SOAP_FMAC4 soap_in__timg__GetServiceCapabilities(struct soap *soap, const char *tag, struct _timg__GetServiceCapabilities *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _timg__GetServiceCapabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__timg__GetServiceCapabilities, sizeof(struct _timg__GetServiceCapabilities), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__timg__GetServiceCapabilities(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _timg__GetServiceCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__timg__GetServiceCapabilities, 0, sizeof(struct _timg__GetServiceCapabilities), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__timg__GetServiceCapabilities(struct soap *soap, const struct _timg__GetServiceCapabilities *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__timg__GetServiceCapabilities);
	if (soap_out__timg__GetServiceCapabilities(soap, tag?tag:"timg:GetServiceCapabilities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _timg__GetServiceCapabilities * SOAP_FMAC4 soap_get__timg__GetServiceCapabilities(struct soap *soap, struct _timg__GetServiceCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in__timg__GetServiceCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_timg__Capabilities(struct soap *soap, struct timg__Capabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_timg__Capabilities(struct soap *soap, const struct timg__Capabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_timg__Capabilities(struct soap *soap, const char *tag, int id, const struct timg__Capabilities *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_timg__Capabilities), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct timg__Capabilities * SOAP_FMAC4 soap_in_timg__Capabilities(struct soap *soap, const char *tag, struct timg__Capabilities *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct timg__Capabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_timg__Capabilities, sizeof(struct timg__Capabilities), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_timg__Capabilities(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct timg__Capabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_timg__Capabilities, 0, sizeof(struct timg__Capabilities), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_timg__Capabilities(struct soap *soap, const struct timg__Capabilities *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_timg__Capabilities);
	if (soap_out_timg__Capabilities(soap, tag?tag:"timg:Capabilities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct timg__Capabilities * SOAP_FMAC4 soap_get_timg__Capabilities(struct soap *soap, struct timg__Capabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_timg__Capabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wstop__QueryExpressionType(struct soap *soap, struct wstop__QueryExpressionType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
	soap_default_string(soap, &a->Dialect);
	a->__mixed = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wstop__QueryExpressionType(struct soap *soap, const struct wstop__QueryExpressionType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wstop__QueryExpressionType(struct soap *soap, const char *tag, int id, const struct wstop__QueryExpressionType *a, const char *type)
{
	if (a->Dialect)
		soap_set_attr(soap, "Dialect", a->Dialect, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wstop__QueryExpressionType), type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	soap_outliteral(soap, "-mixed", &a->__mixed, NULL);
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wstop__QueryExpressionType * SOAP_FMAC4 soap_in_wstop__QueryExpressionType(struct soap *soap, const char *tag, struct wstop__QueryExpressionType *a, const char *type)
{
	size_t soap_flag___any = 1;
	size_t soap_flag___mixed = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wstop__QueryExpressionType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wstop__QueryExpressionType, sizeof(struct wstop__QueryExpressionType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wstop__QueryExpressionType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Dialect", 1), &a->Dialect, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap_flag___mixed && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-mixed", &a->__mixed))
				{	soap_flag___mixed--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wstop__QueryExpressionType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wstop__QueryExpressionType, 0, sizeof(struct wstop__QueryExpressionType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wstop__QueryExpressionType(struct soap *soap, const struct wstop__QueryExpressionType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wstop__QueryExpressionType);
	if (soap_out_wstop__QueryExpressionType(soap, tag?tag:"wstop:QueryExpressionType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wstop__QueryExpressionType * SOAP_FMAC4 soap_get_wstop__QueryExpressionType(struct soap *soap, struct wstop__QueryExpressionType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wstop__QueryExpressionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wstop__ExtensibleDocumented(struct soap *soap, struct wstop__ExtensibleDocumented *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->documentation = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wstop__ExtensibleDocumented(struct soap *soap, const struct wstop__ExtensibleDocumented *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTowstop__Documentation(soap, &a->documentation);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wstop__ExtensibleDocumented(struct soap *soap, const char *tag, int id, const struct wstop__ExtensibleDocumented *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wstop__ExtensibleDocumented), type))
		return soap->error;
	if (soap_out_PointerTowstop__Documentation(soap, "wstop:documentation", -1, &a->documentation, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wstop__ExtensibleDocumented * SOAP_FMAC4 soap_in_wstop__ExtensibleDocumented(struct soap *soap, const char *tag, struct wstop__ExtensibleDocumented *a, const char *type)
{
	size_t soap_flag_documentation = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wstop__ExtensibleDocumented *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wstop__ExtensibleDocumented, sizeof(struct wstop__ExtensibleDocumented), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wstop__ExtensibleDocumented(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_documentation && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowstop__Documentation(soap, "wstop:documentation", &a->documentation, "wstop:Documentation"))
				{	soap_flag_documentation--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wstop__ExtensibleDocumented *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wstop__ExtensibleDocumented, 0, sizeof(struct wstop__ExtensibleDocumented), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wstop__ExtensibleDocumented(struct soap *soap, const struct wstop__ExtensibleDocumented *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wstop__ExtensibleDocumented);
	if (soap_out_wstop__ExtensibleDocumented(soap, tag?tag:"wstop:ExtensibleDocumented", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wstop__ExtensibleDocumented * SOAP_FMAC4 soap_get_wstop__ExtensibleDocumented(struct soap *soap, struct wstop__ExtensibleDocumented *p, const char *tag, const char *type)
{
	if ((p = soap_in_wstop__ExtensibleDocumented(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wstop__Documentation(struct soap *soap, struct wstop__Documentation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
	a->__mixed = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wstop__Documentation(struct soap *soap, const struct wstop__Documentation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wstop__Documentation(struct soap *soap, const char *tag, int id, const struct wstop__Documentation *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wstop__Documentation), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	soap_outliteral(soap, "-mixed", &a->__mixed, NULL);
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wstop__Documentation * SOAP_FMAC4 soap_in_wstop__Documentation(struct soap *soap, const char *tag, struct wstop__Documentation *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	size_t soap_flag___mixed = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wstop__Documentation *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wstop__Documentation, sizeof(struct wstop__Documentation), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wstop__Documentation(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap_flag___mixed && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-mixed", &a->__mixed))
				{	soap_flag___mixed--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wstop__Documentation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wstop__Documentation, 0, sizeof(struct wstop__Documentation), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wstop__Documentation(struct soap *soap, const struct wstop__Documentation *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wstop__Documentation);
	if (soap_out_wstop__Documentation(soap, tag?tag:"wstop:Documentation", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wstop__Documentation * SOAP_FMAC4 soap_get_wstop__Documentation(struct soap *soap, struct wstop__Documentation *p, const char *tag, const char *type)
{
	if ((p = soap_in_wstop__Documentation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__BaseFaultType_FaultCause(struct soap *soap, struct _ns1__BaseFaultType_FaultCause *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__BaseFaultType_FaultCause(struct soap *soap, const struct _ns1__BaseFaultType_FaultCause *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__BaseFaultType_FaultCause(struct soap *soap, const char *tag, int id, const struct _ns1__BaseFaultType_FaultCause *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__BaseFaultType_FaultCause), type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__BaseFaultType_FaultCause * SOAP_FMAC4 soap_in__ns1__BaseFaultType_FaultCause(struct soap *soap, const char *tag, struct _ns1__BaseFaultType_FaultCause *a, const char *type)
{
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__BaseFaultType_FaultCause *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__BaseFaultType_FaultCause, sizeof(struct _ns1__BaseFaultType_FaultCause), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__BaseFaultType_FaultCause(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__BaseFaultType_FaultCause *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__BaseFaultType_FaultCause, 0, sizeof(struct _ns1__BaseFaultType_FaultCause), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__BaseFaultType_FaultCause(struct soap *soap, const struct _ns1__BaseFaultType_FaultCause *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__BaseFaultType_FaultCause);
	if (soap_out__ns1__BaseFaultType_FaultCause(soap, tag?tag:"ns1:BaseFaultType-FaultCause", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__BaseFaultType_FaultCause * SOAP_FMAC4 soap_get__ns1__BaseFaultType_FaultCause(struct soap *soap, struct _ns1__BaseFaultType_FaultCause *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__BaseFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__BaseFaultType_Description(struct soap *soap, struct _ns1__BaseFaultType_Description *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default__xml__lang(soap, &a->xml__lang);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__BaseFaultType_Description(struct soap *soap, const struct _ns1__BaseFaultType_Description *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->__item);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__BaseFaultType_Description(struct soap *soap, const char *tag, int id, const struct _ns1__BaseFaultType_Description *a, const char *type)
{
	if (a->xml__lang)
		soap_set_attr(soap, "xml:lang", a->xml__lang, 1);
	return soap_out_string(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct _ns1__BaseFaultType_Description * SOAP_FMAC4 soap_in__ns1__BaseFaultType_Description(struct soap *soap, const char *tag, struct _ns1__BaseFaultType_Description *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct _ns1__BaseFaultType_Description *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__BaseFaultType_Description, sizeof(struct _ns1__BaseFaultType_Description), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__ns1__BaseFaultType_Description(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "xml:lang", 0), &a->xml__lang, -1, -1))
		return NULL;
	if (!soap_in_string(soap, tag, &a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__BaseFaultType_Description(struct soap *soap, const struct _ns1__BaseFaultType_Description *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__BaseFaultType_Description);
	if (soap_out__ns1__BaseFaultType_Description(soap, tag?tag:"ns1:BaseFaultType-Description", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__BaseFaultType_Description * SOAP_FMAC4 soap_get__ns1__BaseFaultType_Description(struct soap *soap, struct _ns1__BaseFaultType_Description *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__BaseFaultType_Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__BaseFaultType_ErrorCode(struct soap *soap, struct _ns1__BaseFaultType_ErrorCode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->dialect);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__BaseFaultType_ErrorCode(struct soap *soap, const struct _ns1__BaseFaultType_ErrorCode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__BaseFaultType_ErrorCode(struct soap *soap, const char *tag, int id, const struct _ns1__BaseFaultType_ErrorCode *a, const char *type)
{
	if (a->dialect)
		soap_set_attr(soap, "dialect", a->dialect, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__BaseFaultType_ErrorCode), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__BaseFaultType_ErrorCode * SOAP_FMAC4 soap_in__ns1__BaseFaultType_ErrorCode(struct soap *soap, const char *tag, struct _ns1__BaseFaultType_ErrorCode *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__BaseFaultType_ErrorCode *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__BaseFaultType_ErrorCode, sizeof(struct _ns1__BaseFaultType_ErrorCode), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__BaseFaultType_ErrorCode(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "dialect", 1), &a->dialect, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__BaseFaultType_ErrorCode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__BaseFaultType_ErrorCode, 0, sizeof(struct _ns1__BaseFaultType_ErrorCode), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__BaseFaultType_ErrorCode(struct soap *soap, const struct _ns1__BaseFaultType_ErrorCode *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__BaseFaultType_ErrorCode);
	if (soap_out__ns1__BaseFaultType_ErrorCode(soap, tag?tag:"ns1:BaseFaultType-ErrorCode", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__BaseFaultType_ErrorCode * SOAP_FMAC4 soap_get__ns1__BaseFaultType_ErrorCode(struct soap *soap, struct _ns1__BaseFaultType_ErrorCode *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__BaseFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__BaseFaultType(struct soap *soap, struct ns1__BaseFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
	soap_default_time(soap, &a->Timestamp);
	a->Originator = NULL;
	a->ErrorCode = NULL;
	a->__sizeDescription = 0;
	a->Description = NULL;
	a->FaultCause = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__BaseFaultType(struct soap *soap, const struct ns1__BaseFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->Timestamp, SOAP_TYPE_time);
	soap_serialize_PointerTowsa5__EndpointReferenceType(soap, &a->Originator);
	soap_serialize_PointerTo_ns1__BaseFaultType_ErrorCode(soap, &a->ErrorCode);
	if (a->Description)
	{	int i;
		for (i = 0; i < a->__sizeDescription; i++)
		{
			soap_embedded(soap, a->Description + i, SOAP_TYPE__ns1__BaseFaultType_Description);
			soap_serialize__ns1__BaseFaultType_Description(soap, a->Description + i);
		}
	}
	soap_serialize_PointerTo_ns1__BaseFaultType_FaultCause(soap, &a->FaultCause);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__BaseFaultType(struct soap *soap, const char *tag, int id, const struct ns1__BaseFaultType *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__BaseFaultType), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	if (soap_out_time(soap, "ns1:Timestamp", -1, &a->Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "ns1:Originator", -1, &a->Originator, ""))
		return soap->error;
	if (soap_out_PointerTo_ns1__BaseFaultType_ErrorCode(soap, "ns1:ErrorCode", -1, &a->ErrorCode, ""))
		return soap->error;
	if (a->Description)
	{	int i;
		for (i = 0; i < a->__sizeDescription; i++)
			if (soap_out__ns1__BaseFaultType_Description(soap, "ns1:Description", -1, a->Description + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTo_ns1__BaseFaultType_FaultCause(soap, "ns1:FaultCause", -1, &a->FaultCause, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__BaseFaultType * SOAP_FMAC4 soap_in_ns1__BaseFaultType(struct soap *soap, const char *tag, struct ns1__BaseFaultType *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	size_t soap_flag_Timestamp = 1;
	size_t soap_flag_Originator = 1;
	size_t soap_flag_ErrorCode = 1;
	struct soap_blist *soap_blist_Description = NULL;
	size_t soap_flag_FaultCause = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__BaseFaultType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__BaseFaultType, sizeof(struct ns1__BaseFaultType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__BaseFaultType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap_flag_Timestamp && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "ns1:Timestamp", &a->Timestamp, "xsd:dateTime"))
				{	soap_flag_Timestamp--;
					continue;
				}
			if (soap_flag_Originator && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "ns1:Originator", &a->Originator, "wsa5:EndpointReferenceType"))
				{	soap_flag_Originator--;
					continue;
				}
			if (soap_flag_ErrorCode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__BaseFaultType_ErrorCode(soap, "ns1:ErrorCode", &a->ErrorCode, ""))
				{	soap_flag_ErrorCode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns1:Description", 1, NULL))
			{	if (a->Description == NULL)
				{	if (soap_blist_Description == NULL)
						soap_blist_Description = soap_new_block(soap);
					a->Description = (struct _ns1__BaseFaultType_Description *)soap_push_block(soap, soap_blist_Description, sizeof(struct _ns1__BaseFaultType_Description));
					if (a->Description == NULL)
						return NULL;
					soap_default__ns1__BaseFaultType_Description(soap, a->Description);
				}
				soap_revert(soap);
				if (soap_in__ns1__BaseFaultType_Description(soap, "ns1:Description", a->Description, ""))
				{	a->__sizeDescription++;
					a->Description = NULL;
					continue;
				}
			}
			if (soap_flag_FaultCause && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__BaseFaultType_FaultCause(soap, "ns1:FaultCause", &a->FaultCause, ""))
				{	soap_flag_FaultCause--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (a->Description)
			soap_pop_block(soap, soap_blist_Description);
		if (a->__sizeDescription)
			a->Description = (struct _ns1__BaseFaultType_Description *)soap_save_block(soap, soap_blist_Description, NULL, 1);
		else
		{	a->Description = NULL;
			if (soap_blist_Description)
				soap_end_block(soap, soap_blist_Description);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__BaseFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__BaseFaultType, 0, sizeof(struct ns1__BaseFaultType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Timestamp > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__BaseFaultType(struct soap *soap, const struct ns1__BaseFaultType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__BaseFaultType);
	if (soap_out_ns1__BaseFaultType(soap, tag?tag:"ns1:BaseFaultType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__BaseFaultType * SOAP_FMAC4 soap_get_ns1__BaseFaultType(struct soap *soap, struct ns1__BaseFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__BaseFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__ResumeSubscriptionResponse(struct soap *soap, struct _wsnt__ResumeSubscriptionResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__ResumeSubscriptionResponse(struct soap *soap, const struct _wsnt__ResumeSubscriptionResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__ResumeSubscriptionResponse(struct soap *soap, const char *tag, int id, const struct _wsnt__ResumeSubscriptionResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__ResumeSubscriptionResponse), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__ResumeSubscriptionResponse * SOAP_FMAC4 soap_in__wsnt__ResumeSubscriptionResponse(struct soap *soap, const char *tag, struct _wsnt__ResumeSubscriptionResponse *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _wsnt__ResumeSubscriptionResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__ResumeSubscriptionResponse, sizeof(struct _wsnt__ResumeSubscriptionResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__ResumeSubscriptionResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__ResumeSubscriptionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__ResumeSubscriptionResponse, 0, sizeof(struct _wsnt__ResumeSubscriptionResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__ResumeSubscriptionResponse(struct soap *soap, const struct _wsnt__ResumeSubscriptionResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__wsnt__ResumeSubscriptionResponse);
	if (soap_out__wsnt__ResumeSubscriptionResponse(soap, tag?tag:"wsnt:ResumeSubscriptionResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__ResumeSubscriptionResponse * SOAP_FMAC4 soap_get__wsnt__ResumeSubscriptionResponse(struct soap *soap, struct _wsnt__ResumeSubscriptionResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__ResumeSubscriptionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__ResumeSubscription(struct soap *soap, struct _wsnt__ResumeSubscription *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__ResumeSubscription(struct soap *soap, const struct _wsnt__ResumeSubscription *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__ResumeSubscription(struct soap *soap, const char *tag, int id, const struct _wsnt__ResumeSubscription *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__ResumeSubscription), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__ResumeSubscription * SOAP_FMAC4 soap_in__wsnt__ResumeSubscription(struct soap *soap, const char *tag, struct _wsnt__ResumeSubscription *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _wsnt__ResumeSubscription *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__ResumeSubscription, sizeof(struct _wsnt__ResumeSubscription), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__ResumeSubscription(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__ResumeSubscription *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__ResumeSubscription, 0, sizeof(struct _wsnt__ResumeSubscription), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__ResumeSubscription(struct soap *soap, const struct _wsnt__ResumeSubscription *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__wsnt__ResumeSubscription);
	if (soap_out__wsnt__ResumeSubscription(soap, tag?tag:"wsnt:ResumeSubscription", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__ResumeSubscription * SOAP_FMAC4 soap_get__wsnt__ResumeSubscription(struct soap *soap, struct _wsnt__ResumeSubscription *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__ResumeSubscription(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__PauseSubscriptionResponse(struct soap *soap, struct _wsnt__PauseSubscriptionResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__PauseSubscriptionResponse(struct soap *soap, const struct _wsnt__PauseSubscriptionResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__PauseSubscriptionResponse(struct soap *soap, const char *tag, int id, const struct _wsnt__PauseSubscriptionResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__PauseSubscriptionResponse), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__PauseSubscriptionResponse * SOAP_FMAC4 soap_in__wsnt__PauseSubscriptionResponse(struct soap *soap, const char *tag, struct _wsnt__PauseSubscriptionResponse *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _wsnt__PauseSubscriptionResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__PauseSubscriptionResponse, sizeof(struct _wsnt__PauseSubscriptionResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__PauseSubscriptionResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__PauseSubscriptionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__PauseSubscriptionResponse, 0, sizeof(struct _wsnt__PauseSubscriptionResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__PauseSubscriptionResponse(struct soap *soap, const struct _wsnt__PauseSubscriptionResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__wsnt__PauseSubscriptionResponse);
	if (soap_out__wsnt__PauseSubscriptionResponse(soap, tag?tag:"wsnt:PauseSubscriptionResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__PauseSubscriptionResponse * SOAP_FMAC4 soap_get__wsnt__PauseSubscriptionResponse(struct soap *soap, struct _wsnt__PauseSubscriptionResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__PauseSubscriptionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__PauseSubscription(struct soap *soap, struct _wsnt__PauseSubscription *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__PauseSubscription(struct soap *soap, const struct _wsnt__PauseSubscription *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__PauseSubscription(struct soap *soap, const char *tag, int id, const struct _wsnt__PauseSubscription *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__PauseSubscription), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__PauseSubscription * SOAP_FMAC4 soap_in__wsnt__PauseSubscription(struct soap *soap, const char *tag, struct _wsnt__PauseSubscription *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _wsnt__PauseSubscription *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__PauseSubscription, sizeof(struct _wsnt__PauseSubscription), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__PauseSubscription(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__PauseSubscription *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__PauseSubscription, 0, sizeof(struct _wsnt__PauseSubscription), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__PauseSubscription(struct soap *soap, const struct _wsnt__PauseSubscription *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__wsnt__PauseSubscription);
	if (soap_out__wsnt__PauseSubscription(soap, tag?tag:"wsnt:PauseSubscription", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__PauseSubscription * SOAP_FMAC4 soap_get__wsnt__PauseSubscription(struct soap *soap, struct _wsnt__PauseSubscription *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__PauseSubscription(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__UnsubscribeResponse(struct soap *soap, struct _wsnt__UnsubscribeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__UnsubscribeResponse(struct soap *soap, const struct _wsnt__UnsubscribeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__UnsubscribeResponse(struct soap *soap, const char *tag, int id, const struct _wsnt__UnsubscribeResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__UnsubscribeResponse), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__UnsubscribeResponse * SOAP_FMAC4 soap_in__wsnt__UnsubscribeResponse(struct soap *soap, const char *tag, struct _wsnt__UnsubscribeResponse *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _wsnt__UnsubscribeResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__UnsubscribeResponse, sizeof(struct _wsnt__UnsubscribeResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__UnsubscribeResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__UnsubscribeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__UnsubscribeResponse, 0, sizeof(struct _wsnt__UnsubscribeResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__UnsubscribeResponse(struct soap *soap, const struct _wsnt__UnsubscribeResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__wsnt__UnsubscribeResponse);
	if (soap_out__wsnt__UnsubscribeResponse(soap, tag?tag:"wsnt:UnsubscribeResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnsubscribeResponse * SOAP_FMAC4 soap_get__wsnt__UnsubscribeResponse(struct soap *soap, struct _wsnt__UnsubscribeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__UnsubscribeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__Unsubscribe(struct soap *soap, struct _wsnt__Unsubscribe *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__Unsubscribe(struct soap *soap, const struct _wsnt__Unsubscribe *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__Unsubscribe(struct soap *soap, const char *tag, int id, const struct _wsnt__Unsubscribe *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__Unsubscribe), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__Unsubscribe * SOAP_FMAC4 soap_in__wsnt__Unsubscribe(struct soap *soap, const char *tag, struct _wsnt__Unsubscribe *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _wsnt__Unsubscribe *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__Unsubscribe, sizeof(struct _wsnt__Unsubscribe), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__Unsubscribe(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__Unsubscribe *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__Unsubscribe, 0, sizeof(struct _wsnt__Unsubscribe), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__Unsubscribe(struct soap *soap, const struct _wsnt__Unsubscribe *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__wsnt__Unsubscribe);
	if (soap_out__wsnt__Unsubscribe(soap, tag?tag:"wsnt:Unsubscribe", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__Unsubscribe * SOAP_FMAC4 soap_get__wsnt__Unsubscribe(struct soap *soap, struct _wsnt__Unsubscribe *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__Unsubscribe(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__RenewResponse(struct soap *soap, struct _wsnt__RenewResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_time(soap, &a->TerminationTime);
	a->CurrentTime = NULL;
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__RenewResponse(struct soap *soap, const struct _wsnt__RenewResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->TerminationTime, SOAP_TYPE_time);
	soap_serialize_PointerTotime(soap, &a->CurrentTime);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__RenewResponse(struct soap *soap, const char *tag, int id, const struct _wsnt__RenewResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__RenewResponse), type))
		return soap->error;
	if (soap_out_time(soap, "wsnt:TerminationTime", -1, &a->TerminationTime, ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "wsnt:CurrentTime", -1, &a->CurrentTime, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__RenewResponse * SOAP_FMAC4 soap_in__wsnt__RenewResponse(struct soap *soap, const char *tag, struct _wsnt__RenewResponse *a, const char *type)
{
	size_t soap_flag_TerminationTime = 1;
	size_t soap_flag_CurrentTime = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _wsnt__RenewResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__RenewResponse, sizeof(struct _wsnt__RenewResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__RenewResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_TerminationTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "wsnt:TerminationTime", &a->TerminationTime, "xsd:dateTime"))
				{	soap_flag_TerminationTime--;
					continue;
				}
			if (soap_flag_CurrentTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "wsnt:CurrentTime", &a->CurrentTime, "xsd:dateTime"))
				{	soap_flag_CurrentTime--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__RenewResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__RenewResponse, 0, sizeof(struct _wsnt__RenewResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_TerminationTime > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__RenewResponse(struct soap *soap, const struct _wsnt__RenewResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__wsnt__RenewResponse);
	if (soap_out__wsnt__RenewResponse(soap, tag?tag:"wsnt:RenewResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__RenewResponse * SOAP_FMAC4 soap_get__wsnt__RenewResponse(struct soap *soap, struct _wsnt__RenewResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__RenewResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__Renew(struct soap *soap, struct _wsnt__Renew *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_wsnt__AbsoluteOrRelativeTimeType(soap, &a->TerminationTime);
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__Renew(struct soap *soap, const struct _wsnt__Renew *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_wsnt__AbsoluteOrRelativeTimeType(soap, &a->TerminationTime);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__Renew(struct soap *soap, const char *tag, int id, const struct _wsnt__Renew *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__Renew), type))
		return soap->error;
	if (a->TerminationTime)
	{	if (soap_out_wsnt__AbsoluteOrRelativeTimeType(soap, "wsnt:TerminationTime", -1, &a->TerminationTime, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "wsnt:TerminationTime"))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__Renew * SOAP_FMAC4 soap_in__wsnt__Renew(struct soap *soap, const char *tag, struct _wsnt__Renew *a, const char *type)
{
	size_t soap_flag_TerminationTime = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _wsnt__Renew *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__Renew, sizeof(struct _wsnt__Renew), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__Renew(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_TerminationTime && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wsnt__AbsoluteOrRelativeTimeType(soap, "wsnt:TerminationTime", &a->TerminationTime, "wsnt:AbsoluteOrRelativeTimeType"))
				{	soap_flag_TerminationTime--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__Renew *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__Renew, 0, sizeof(struct _wsnt__Renew), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_TerminationTime > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__Renew(struct soap *soap, const struct _wsnt__Renew *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__wsnt__Renew);
	if (soap_out__wsnt__Renew(soap, tag?tag:"wsnt:Renew", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__Renew * SOAP_FMAC4 soap_get__wsnt__Renew(struct soap *soap, struct _wsnt__Renew *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__Renew(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__CreatePullPointResponse(struct soap *soap, struct _wsnt__CreatePullPointResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_wsa5__EndpointReferenceType(soap, &a->PullPoint);
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__CreatePullPointResponse(struct soap *soap, const struct _wsnt__CreatePullPointResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->PullPoint, SOAP_TYPE_wsa5__EndpointReferenceType);
	soap_serialize_wsa5__EndpointReferenceType(soap, &a->PullPoint);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__CreatePullPointResponse(struct soap *soap, const char *tag, int id, const struct _wsnt__CreatePullPointResponse *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__CreatePullPointResponse), type))
		return soap->error;
	if (soap_out_wsa5__EndpointReferenceType(soap, "wsnt:PullPoint", -1, &a->PullPoint, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__CreatePullPointResponse * SOAP_FMAC4 soap_in__wsnt__CreatePullPointResponse(struct soap *soap, const char *tag, struct _wsnt__CreatePullPointResponse *a, const char *type)
{
	size_t soap_flag_PullPoint = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _wsnt__CreatePullPointResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__CreatePullPointResponse, sizeof(struct _wsnt__CreatePullPointResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__CreatePullPointResponse(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_PullPoint && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_wsa5__EndpointReferenceType(soap, "wsnt:PullPoint", &a->PullPoint, "wsa5:EndpointReferenceType"))
				{	soap_flag_PullPoint--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__CreatePullPointResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__CreatePullPointResponse, 0, sizeof(struct _wsnt__CreatePullPointResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_PullPoint > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__CreatePullPointResponse(struct soap *soap, const struct _wsnt__CreatePullPointResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__wsnt__CreatePullPointResponse);
	if (soap_out__wsnt__CreatePullPointResponse(soap, tag?tag:"wsnt:CreatePullPointResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__CreatePullPointResponse * SOAP_FMAC4 soap_get__wsnt__CreatePullPointResponse(struct soap *soap, struct _wsnt__CreatePullPointResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__CreatePullPointResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__CreatePullPoint(struct soap *soap, struct _wsnt__CreatePullPoint *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__CreatePullPoint(struct soap *soap, const struct _wsnt__CreatePullPoint *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__CreatePullPoint(struct soap *soap, const char *tag, int id, const struct _wsnt__CreatePullPoint *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__CreatePullPoint), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__CreatePullPoint * SOAP_FMAC4 soap_in__wsnt__CreatePullPoint(struct soap *soap, const char *tag, struct _wsnt__CreatePullPoint *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _wsnt__CreatePullPoint *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__CreatePullPoint, sizeof(struct _wsnt__CreatePullPoint), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__CreatePullPoint(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__CreatePullPoint *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__CreatePullPoint, 0, sizeof(struct _wsnt__CreatePullPoint), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__CreatePullPoint(struct soap *soap, const struct _wsnt__CreatePullPoint *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__wsnt__CreatePullPoint);
	if (soap_out__wsnt__CreatePullPoint(soap, tag?tag:"wsnt:CreatePullPoint", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__CreatePullPoint * SOAP_FMAC4 soap_get__wsnt__CreatePullPoint(struct soap *soap, struct _wsnt__CreatePullPoint *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__CreatePullPoint(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__DestroyPullPointResponse(struct soap *soap, struct _wsnt__DestroyPullPointResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__DestroyPullPointResponse(struct soap *soap, const struct _wsnt__DestroyPullPointResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__DestroyPullPointResponse(struct soap *soap, const char *tag, int id, const struct _wsnt__DestroyPullPointResponse *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__DestroyPullPointResponse), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__DestroyPullPointResponse * SOAP_FMAC4 soap_in__wsnt__DestroyPullPointResponse(struct soap *soap, const char *tag, struct _wsnt__DestroyPullPointResponse *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _wsnt__DestroyPullPointResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__DestroyPullPointResponse, sizeof(struct _wsnt__DestroyPullPointResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__DestroyPullPointResponse(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__DestroyPullPointResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__DestroyPullPointResponse, 0, sizeof(struct _wsnt__DestroyPullPointResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__DestroyPullPointResponse(struct soap *soap, const struct _wsnt__DestroyPullPointResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__wsnt__DestroyPullPointResponse);
	if (soap_out__wsnt__DestroyPullPointResponse(soap, tag?tag:"wsnt:DestroyPullPointResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__DestroyPullPointResponse * SOAP_FMAC4 soap_get__wsnt__DestroyPullPointResponse(struct soap *soap, struct _wsnt__DestroyPullPointResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__DestroyPullPointResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__DestroyPullPoint(struct soap *soap, struct _wsnt__DestroyPullPoint *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__DestroyPullPoint(struct soap *soap, const struct _wsnt__DestroyPullPoint *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__DestroyPullPoint(struct soap *soap, const char *tag, int id, const struct _wsnt__DestroyPullPoint *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__DestroyPullPoint), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__DestroyPullPoint * SOAP_FMAC4 soap_in__wsnt__DestroyPullPoint(struct soap *soap, const char *tag, struct _wsnt__DestroyPullPoint *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _wsnt__DestroyPullPoint *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__DestroyPullPoint, sizeof(struct _wsnt__DestroyPullPoint), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__DestroyPullPoint(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__DestroyPullPoint *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__DestroyPullPoint, 0, sizeof(struct _wsnt__DestroyPullPoint), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__DestroyPullPoint(struct soap *soap, const struct _wsnt__DestroyPullPoint *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__wsnt__DestroyPullPoint);
	if (soap_out__wsnt__DestroyPullPoint(soap, tag?tag:"wsnt:DestroyPullPoint", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__DestroyPullPoint * SOAP_FMAC4 soap_get__wsnt__DestroyPullPoint(struct soap *soap, struct _wsnt__DestroyPullPoint *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__DestroyPullPoint(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__GetMessagesResponse(struct soap *soap, struct _wsnt__GetMessagesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeNotificationMessage = 0;
	a->NotificationMessage = NULL;
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__GetMessagesResponse(struct soap *soap, const struct _wsnt__GetMessagesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->NotificationMessage)
	{	int i;
		for (i = 0; i < a->__sizeNotificationMessage; i++)
		{
			soap_embedded(soap, a->NotificationMessage + i, SOAP_TYPE_wsnt__NotificationMessageHolderType);
			soap_serialize_wsnt__NotificationMessageHolderType(soap, a->NotificationMessage + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__GetMessagesResponse(struct soap *soap, const char *tag, int id, const struct _wsnt__GetMessagesResponse *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__GetMessagesResponse), type))
		return soap->error;
	if (a->NotificationMessage)
	{	int i;
		for (i = 0; i < a->__sizeNotificationMessage; i++)
			if (soap_out_wsnt__NotificationMessageHolderType(soap, "wsnt:NotificationMessage", -1, a->NotificationMessage + i, ""))
				return soap->error;
	}
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__GetMessagesResponse * SOAP_FMAC4 soap_in__wsnt__GetMessagesResponse(struct soap *soap, const char *tag, struct _wsnt__GetMessagesResponse *a, const char *type)
{
	struct soap_blist *soap_blist_NotificationMessage = NULL;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _wsnt__GetMessagesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__GetMessagesResponse, sizeof(struct _wsnt__GetMessagesResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__GetMessagesResponse(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wsnt:NotificationMessage", 1, NULL))
			{	if (a->NotificationMessage == NULL)
				{	if (soap_blist_NotificationMessage == NULL)
						soap_blist_NotificationMessage = soap_new_block(soap);
					a->NotificationMessage = (struct wsnt__NotificationMessageHolderType *)soap_push_block(soap, soap_blist_NotificationMessage, sizeof(struct wsnt__NotificationMessageHolderType));
					if (a->NotificationMessage == NULL)
						return NULL;
					soap_default_wsnt__NotificationMessageHolderType(soap, a->NotificationMessage);
				}
				soap_revert(soap);
				if (soap_in_wsnt__NotificationMessageHolderType(soap, "wsnt:NotificationMessage", a->NotificationMessage, "wsnt:NotificationMessageHolderType"))
				{	a->__sizeNotificationMessage++;
					a->NotificationMessage = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->NotificationMessage)
			soap_pop_block(soap, soap_blist_NotificationMessage);
		if (a->__sizeNotificationMessage)
			a->NotificationMessage = (struct wsnt__NotificationMessageHolderType *)soap_save_block(soap, soap_blist_NotificationMessage, NULL, 1);
		else
		{	a->NotificationMessage = NULL;
			if (soap_blist_NotificationMessage)
				soap_end_block(soap, soap_blist_NotificationMessage);
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__GetMessagesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__GetMessagesResponse, 0, sizeof(struct _wsnt__GetMessagesResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__GetMessagesResponse(struct soap *soap, const struct _wsnt__GetMessagesResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__wsnt__GetMessagesResponse);
	if (soap_out__wsnt__GetMessagesResponse(soap, tag?tag:"wsnt:GetMessagesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__GetMessagesResponse * SOAP_FMAC4 soap_get__wsnt__GetMessagesResponse(struct soap *soap, struct _wsnt__GetMessagesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__GetMessagesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__GetMessages(struct soap *soap, struct _wsnt__GetMessages *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->MaximumNumber = NULL;
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__GetMessages(struct soap *soap, const struct _wsnt__GetMessages *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTounsignedInt(soap, &a->MaximumNumber);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__GetMessages(struct soap *soap, const char *tag, int id, const struct _wsnt__GetMessages *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__GetMessages), type))
		return soap->error;
	if (soap_out_PointerTounsignedInt(soap, "wsnt:MaximumNumber", -1, &a->MaximumNumber, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__GetMessages * SOAP_FMAC4 soap_in__wsnt__GetMessages(struct soap *soap, const char *tag, struct _wsnt__GetMessages *a, const char *type)
{
	size_t soap_flag_MaximumNumber = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _wsnt__GetMessages *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__GetMessages, sizeof(struct _wsnt__GetMessages), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__GetMessages(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_MaximumNumber && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTounsignedInt(soap, "wsnt:MaximumNumber", &a->MaximumNumber, "xsd:unsignedInt"))
				{	soap_flag_MaximumNumber--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__GetMessages *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__GetMessages, 0, sizeof(struct _wsnt__GetMessages), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__GetMessages(struct soap *soap, const struct _wsnt__GetMessages *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__wsnt__GetMessages);
	if (soap_out__wsnt__GetMessages(soap, tag?tag:"wsnt:GetMessages", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__GetMessages * SOAP_FMAC4 soap_get__wsnt__GetMessages(struct soap *soap, struct _wsnt__GetMessages *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__GetMessages(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__GetCurrentMessageResponse(struct soap *soap, struct _wsnt__GetCurrentMessageResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__GetCurrentMessageResponse(struct soap *soap, const struct _wsnt__GetCurrentMessageResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__GetCurrentMessageResponse(struct soap *soap, const char *tag, int id, const struct _wsnt__GetCurrentMessageResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__GetCurrentMessageResponse), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__GetCurrentMessageResponse * SOAP_FMAC4 soap_in__wsnt__GetCurrentMessageResponse(struct soap *soap, const char *tag, struct _wsnt__GetCurrentMessageResponse *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _wsnt__GetCurrentMessageResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__GetCurrentMessageResponse, sizeof(struct _wsnt__GetCurrentMessageResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__GetCurrentMessageResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__GetCurrentMessageResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__GetCurrentMessageResponse, 0, sizeof(struct _wsnt__GetCurrentMessageResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__GetCurrentMessageResponse(struct soap *soap, const struct _wsnt__GetCurrentMessageResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__wsnt__GetCurrentMessageResponse);
	if (soap_out__wsnt__GetCurrentMessageResponse(soap, tag?tag:"wsnt:GetCurrentMessageResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__GetCurrentMessageResponse * SOAP_FMAC4 soap_get__wsnt__GetCurrentMessageResponse(struct soap *soap, struct _wsnt__GetCurrentMessageResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__GetCurrentMessageResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__GetCurrentMessage(struct soap *soap, struct _wsnt__GetCurrentMessage *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Topic = NULL;
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__GetCurrentMessage(struct soap *soap, const struct _wsnt__GetCurrentMessage *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTowsnt__TopicExpressionType(soap, &a->Topic);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__GetCurrentMessage(struct soap *soap, const char *tag, int id, const struct _wsnt__GetCurrentMessage *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__GetCurrentMessage), type))
		return soap->error;
	if (a->Topic)
	{	if (soap_out_PointerTowsnt__TopicExpressionType(soap, "wsnt:Topic", -1, &a->Topic, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "wsnt:Topic"))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__GetCurrentMessage * SOAP_FMAC4 soap_in__wsnt__GetCurrentMessage(struct soap *soap, const char *tag, struct _wsnt__GetCurrentMessage *a, const char *type)
{
	size_t soap_flag_Topic = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _wsnt__GetCurrentMessage *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__GetCurrentMessage, sizeof(struct _wsnt__GetCurrentMessage), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__GetCurrentMessage(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Topic && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsnt__TopicExpressionType(soap, "wsnt:Topic", &a->Topic, "wsnt:TopicExpressionType"))
				{	soap_flag_Topic--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__GetCurrentMessage *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__GetCurrentMessage, 0, sizeof(struct _wsnt__GetCurrentMessage), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Topic > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__GetCurrentMessage(struct soap *soap, const struct _wsnt__GetCurrentMessage *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__wsnt__GetCurrentMessage);
	if (soap_out__wsnt__GetCurrentMessage(soap, tag?tag:"wsnt:GetCurrentMessage", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__GetCurrentMessage * SOAP_FMAC4 soap_get__wsnt__GetCurrentMessage(struct soap *soap, struct _wsnt__GetCurrentMessage *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__GetCurrentMessage(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__SubscribeResponse(struct soap *soap, struct _wsnt__SubscribeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_wsa5__EndpointReferenceType(soap, &a->SubscriptionReference);
	a->CurrentTime = NULL;
	a->TerminationTime = NULL;
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__SubscribeResponse(struct soap *soap, const struct _wsnt__SubscribeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->SubscriptionReference, SOAP_TYPE_wsa5__EndpointReferenceType);
	soap_serialize_wsa5__EndpointReferenceType(soap, &a->SubscriptionReference);
	soap_serialize_PointerTotime(soap, &a->CurrentTime);
	soap_serialize_PointerTotime(soap, &a->TerminationTime);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__SubscribeResponse(struct soap *soap, const char *tag, int id, const struct _wsnt__SubscribeResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__SubscribeResponse), type))
		return soap->error;
	if (soap_out_wsa5__EndpointReferenceType(soap, "wsnt:SubscriptionReference", -1, &a->SubscriptionReference, ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "wsnt:CurrentTime", -1, &a->CurrentTime, ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "wsnt:TerminationTime", -1, &a->TerminationTime, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__SubscribeResponse * SOAP_FMAC4 soap_in__wsnt__SubscribeResponse(struct soap *soap, const char *tag, struct _wsnt__SubscribeResponse *a, const char *type)
{
	size_t soap_flag_SubscriptionReference = 1;
	size_t soap_flag_CurrentTime = 1;
	size_t soap_flag_TerminationTime = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _wsnt__SubscribeResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__SubscribeResponse, sizeof(struct _wsnt__SubscribeResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__SubscribeResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SubscriptionReference && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_wsa5__EndpointReferenceType(soap, "wsnt:SubscriptionReference", &a->SubscriptionReference, "wsa5:EndpointReferenceType"))
				{	soap_flag_SubscriptionReference--;
					continue;
				}
			if (soap_flag_CurrentTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "wsnt:CurrentTime", &a->CurrentTime, "xsd:dateTime"))
				{	soap_flag_CurrentTime--;
					continue;
				}
			if (soap_flag_TerminationTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "wsnt:TerminationTime", &a->TerminationTime, "xsd:dateTime"))
				{	soap_flag_TerminationTime--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__SubscribeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__SubscribeResponse, 0, sizeof(struct _wsnt__SubscribeResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_SubscriptionReference > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__SubscribeResponse(struct soap *soap, const struct _wsnt__SubscribeResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__wsnt__SubscribeResponse);
	if (soap_out__wsnt__SubscribeResponse(soap, tag?tag:"wsnt:SubscribeResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__SubscribeResponse * SOAP_FMAC4 soap_get__wsnt__SubscribeResponse(struct soap *soap, struct _wsnt__SubscribeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__SubscribeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__Subscribe_SubscriptionPolicy(struct soap *soap, struct _wsnt__Subscribe_SubscriptionPolicy *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__Subscribe_SubscriptionPolicy(struct soap *soap, const struct _wsnt__Subscribe_SubscriptionPolicy *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__Subscribe_SubscriptionPolicy(struct soap *soap, const char *tag, int id, const struct _wsnt__Subscribe_SubscriptionPolicy *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__Subscribe_SubscriptionPolicy), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__Subscribe_SubscriptionPolicy * SOAP_FMAC4 soap_in__wsnt__Subscribe_SubscriptionPolicy(struct soap *soap, const char *tag, struct _wsnt__Subscribe_SubscriptionPolicy *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _wsnt__Subscribe_SubscriptionPolicy *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__Subscribe_SubscriptionPolicy, sizeof(struct _wsnt__Subscribe_SubscriptionPolicy), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__Subscribe_SubscriptionPolicy(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__Subscribe_SubscriptionPolicy *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__Subscribe_SubscriptionPolicy, 0, sizeof(struct _wsnt__Subscribe_SubscriptionPolicy), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__Subscribe_SubscriptionPolicy(struct soap *soap, const struct _wsnt__Subscribe_SubscriptionPolicy *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__wsnt__Subscribe_SubscriptionPolicy);
	if (soap_out__wsnt__Subscribe_SubscriptionPolicy(soap, tag?tag:"wsnt:Subscribe-SubscriptionPolicy", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__Subscribe_SubscriptionPolicy * SOAP_FMAC4 soap_get__wsnt__Subscribe_SubscriptionPolicy(struct soap *soap, struct _wsnt__Subscribe_SubscriptionPolicy *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__Subscribe_SubscriptionPolicy(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__Subscribe(struct soap *soap, struct _wsnt__Subscribe *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_wsa5__EndpointReferenceType(soap, &a->ConsumerReference);
	a->Filter = NULL;
	soap_default_wsnt__AbsoluteOrRelativeTimeType(soap, &a->InitialTerminationTime);
	a->SubscriptionPolicy = NULL;
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__Subscribe(struct soap *soap, const struct _wsnt__Subscribe *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->ConsumerReference, SOAP_TYPE_wsa5__EndpointReferenceType);
	soap_serialize_wsa5__EndpointReferenceType(soap, &a->ConsumerReference);
	soap_serialize_PointerTowsnt__FilterType(soap, &a->Filter);
	soap_serialize_wsnt__AbsoluteOrRelativeTimeType(soap, &a->InitialTerminationTime);
	soap_serialize_PointerTo_wsnt__Subscribe_SubscriptionPolicy(soap, &a->SubscriptionPolicy);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__Subscribe(struct soap *soap, const char *tag, int id, const struct _wsnt__Subscribe *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__Subscribe), type))
		return soap->error;
	if (soap_out_wsa5__EndpointReferenceType(soap, "wsnt:ConsumerReference", -1, &a->ConsumerReference, ""))
		return soap->error;
	if (soap_out_PointerTowsnt__FilterType(soap, "wsnt:Filter", -1, &a->Filter, ""))
		return soap->error;
	if (soap_out_wsnt__AbsoluteOrRelativeTimeType(soap, "wsnt:InitialTerminationTime", -1, &a->InitialTerminationTime, ""))
		return soap->error;
	if (soap_out_PointerTo_wsnt__Subscribe_SubscriptionPolicy(soap, "wsnt:SubscriptionPolicy", -1, &a->SubscriptionPolicy, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__Subscribe * SOAP_FMAC4 soap_in__wsnt__Subscribe(struct soap *soap, const char *tag, struct _wsnt__Subscribe *a, const char *type)
{
	size_t soap_flag_ConsumerReference = 1;
	size_t soap_flag_Filter = 1;
	size_t soap_flag_InitialTerminationTime = 1;
	size_t soap_flag_SubscriptionPolicy = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _wsnt__Subscribe *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__Subscribe, sizeof(struct _wsnt__Subscribe), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__Subscribe(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ConsumerReference && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_wsa5__EndpointReferenceType(soap, "wsnt:ConsumerReference", &a->ConsumerReference, "wsa5:EndpointReferenceType"))
				{	soap_flag_ConsumerReference--;
					continue;
				}
			if (soap_flag_Filter && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsnt__FilterType(soap, "wsnt:Filter", &a->Filter, "wsnt:FilterType"))
				{	soap_flag_Filter--;
					continue;
				}
			if (soap_flag_InitialTerminationTime && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wsnt__AbsoluteOrRelativeTimeType(soap, "wsnt:InitialTerminationTime", &a->InitialTerminationTime, "wsnt:AbsoluteOrRelativeTimeType"))
				{	soap_flag_InitialTerminationTime--;
					continue;
				}
			if (soap_flag_SubscriptionPolicy && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsnt__Subscribe_SubscriptionPolicy(soap, "wsnt:SubscriptionPolicy", &a->SubscriptionPolicy, ""))
				{	soap_flag_SubscriptionPolicy--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__Subscribe *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__Subscribe, 0, sizeof(struct _wsnt__Subscribe), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ConsumerReference > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__Subscribe(struct soap *soap, const struct _wsnt__Subscribe *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__wsnt__Subscribe);
	if (soap_out__wsnt__Subscribe(soap, tag?tag:"wsnt:Subscribe", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__Subscribe * SOAP_FMAC4 soap_get__wsnt__Subscribe(struct soap *soap, struct _wsnt__Subscribe *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__Subscribe(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__UseRaw(struct soap *soap, struct _wsnt__UseRaw *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__UseRaw(struct soap *soap, const struct _wsnt__UseRaw *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__UseRaw(struct soap *soap, const char *tag, int id, const struct _wsnt__UseRaw *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__UseRaw), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__UseRaw * SOAP_FMAC4 soap_in__wsnt__UseRaw(struct soap *soap, const char *tag, struct _wsnt__UseRaw *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _wsnt__UseRaw *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__UseRaw, sizeof(struct _wsnt__UseRaw), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__UseRaw(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__UseRaw *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__UseRaw, 0, sizeof(struct _wsnt__UseRaw), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__UseRaw(struct soap *soap, const struct _wsnt__UseRaw *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__wsnt__UseRaw);
	if (soap_out__wsnt__UseRaw(soap, tag?tag:"wsnt:UseRaw", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UseRaw * SOAP_FMAC4 soap_get__wsnt__UseRaw(struct soap *soap, struct _wsnt__UseRaw *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__UseRaw(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__Notify(struct soap *soap, struct _wsnt__Notify *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeNotificationMessage = 0;
	a->NotificationMessage = NULL;
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__Notify(struct soap *soap, const struct _wsnt__Notify *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->NotificationMessage)
	{	int i;
		for (i = 0; i < a->__sizeNotificationMessage; i++)
		{
			soap_embedded(soap, a->NotificationMessage + i, SOAP_TYPE_wsnt__NotificationMessageHolderType);
			soap_serialize_wsnt__NotificationMessageHolderType(soap, a->NotificationMessage + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__Notify(struct soap *soap, const char *tag, int id, const struct _wsnt__Notify *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__Notify), type))
		return soap->error;
	if (a->NotificationMessage)
	{	int i;
		for (i = 0; i < a->__sizeNotificationMessage; i++)
			if (soap_out_wsnt__NotificationMessageHolderType(soap, "wsnt:NotificationMessage", -1, a->NotificationMessage + i, ""))
				return soap->error;
	}
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__Notify * SOAP_FMAC4 soap_in__wsnt__Notify(struct soap *soap, const char *tag, struct _wsnt__Notify *a, const char *type)
{
	struct soap_blist *soap_blist_NotificationMessage = NULL;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _wsnt__Notify *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__Notify, sizeof(struct _wsnt__Notify), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__Notify(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wsnt:NotificationMessage", 1, NULL))
			{	if (a->NotificationMessage == NULL)
				{	if (soap_blist_NotificationMessage == NULL)
						soap_blist_NotificationMessage = soap_new_block(soap);
					a->NotificationMessage = (struct wsnt__NotificationMessageHolderType *)soap_push_block(soap, soap_blist_NotificationMessage, sizeof(struct wsnt__NotificationMessageHolderType));
					if (a->NotificationMessage == NULL)
						return NULL;
					soap_default_wsnt__NotificationMessageHolderType(soap, a->NotificationMessage);
				}
				soap_revert(soap);
				if (soap_in_wsnt__NotificationMessageHolderType(soap, "wsnt:NotificationMessage", a->NotificationMessage, "wsnt:NotificationMessageHolderType"))
				{	a->__sizeNotificationMessage++;
					a->NotificationMessage = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->NotificationMessage)
			soap_pop_block(soap, soap_blist_NotificationMessage);
		if (a->__sizeNotificationMessage)
			a->NotificationMessage = (struct wsnt__NotificationMessageHolderType *)soap_save_block(soap, soap_blist_NotificationMessage, NULL, 1);
		else
		{	a->NotificationMessage = NULL;
			if (soap_blist_NotificationMessage)
				soap_end_block(soap, soap_blist_NotificationMessage);
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__Notify *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__Notify, 0, sizeof(struct _wsnt__Notify), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeNotificationMessage < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__Notify(struct soap *soap, const struct _wsnt__Notify *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__wsnt__Notify);
	if (soap_out__wsnt__Notify(soap, tag?tag:"wsnt:Notify", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__Notify * SOAP_FMAC4 soap_get__wsnt__Notify(struct soap *soap, struct _wsnt__Notify *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__Notify(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__SubscriptionManagerRP(struct soap *soap, struct _wsnt__SubscriptionManagerRP *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_wsa5__EndpointReferenceType(soap, &a->ConsumerReference);
	a->Filter = NULL;
	a->SubscriptionPolicy = NULL;
	a->CreationTime = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__SubscriptionManagerRP(struct soap *soap, const struct _wsnt__SubscriptionManagerRP *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->ConsumerReference, SOAP_TYPE_wsa5__EndpointReferenceType);
	soap_serialize_wsa5__EndpointReferenceType(soap, &a->ConsumerReference);
	soap_serialize_PointerTowsnt__FilterType(soap, &a->Filter);
	soap_serialize_PointerTowsnt__SubscriptionPolicyType(soap, &a->SubscriptionPolicy);
	soap_serialize_PointerTotime(soap, &a->CreationTime);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__SubscriptionManagerRP(struct soap *soap, const char *tag, int id, const struct _wsnt__SubscriptionManagerRP *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__SubscriptionManagerRP), type))
		return soap->error;
	if (soap_out_wsa5__EndpointReferenceType(soap, "wsnt:ConsumerReference", -1, &a->ConsumerReference, ""))
		return soap->error;
	if (soap_out_PointerTowsnt__FilterType(soap, "wsnt:Filter", -1, &a->Filter, ""))
		return soap->error;
	if (soap_out_PointerTowsnt__SubscriptionPolicyType(soap, "wsnt:SubscriptionPolicy", -1, &a->SubscriptionPolicy, ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "wsnt:CreationTime", -1, &a->CreationTime, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__SubscriptionManagerRP * SOAP_FMAC4 soap_in__wsnt__SubscriptionManagerRP(struct soap *soap, const char *tag, struct _wsnt__SubscriptionManagerRP *a, const char *type)
{
	size_t soap_flag_ConsumerReference = 1;
	size_t soap_flag_Filter = 1;
	size_t soap_flag_SubscriptionPolicy = 1;
	size_t soap_flag_CreationTime = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _wsnt__SubscriptionManagerRP *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__SubscriptionManagerRP, sizeof(struct _wsnt__SubscriptionManagerRP), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__SubscriptionManagerRP(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ConsumerReference && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_wsa5__EndpointReferenceType(soap, "wsnt:ConsumerReference", &a->ConsumerReference, "wsa5:EndpointReferenceType"))
				{	soap_flag_ConsumerReference--;
					continue;
				}
			if (soap_flag_Filter && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsnt__FilterType(soap, "wsnt:Filter", &a->Filter, "wsnt:FilterType"))
				{	soap_flag_Filter--;
					continue;
				}
			if (soap_flag_SubscriptionPolicy && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsnt__SubscriptionPolicyType(soap, "wsnt:SubscriptionPolicy", &a->SubscriptionPolicy, "wsnt:SubscriptionPolicyType"))
				{	soap_flag_SubscriptionPolicy--;
					continue;
				}
			if (soap_flag_CreationTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "wsnt:CreationTime", &a->CreationTime, "xsd:dateTime"))
				{	soap_flag_CreationTime--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__SubscriptionManagerRP *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__SubscriptionManagerRP, 0, sizeof(struct _wsnt__SubscriptionManagerRP), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ConsumerReference > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__SubscriptionManagerRP(struct soap *soap, const struct _wsnt__SubscriptionManagerRP *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__wsnt__SubscriptionManagerRP);
	if (soap_out__wsnt__SubscriptionManagerRP(soap, tag?tag:"wsnt:SubscriptionManagerRP", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__SubscriptionManagerRP * SOAP_FMAC4 soap_get__wsnt__SubscriptionManagerRP(struct soap *soap, struct _wsnt__SubscriptionManagerRP *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__SubscriptionManagerRP(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wstop__TopicSetType(struct soap *soap, struct wstop__TopicSetType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->documentation = NULL;
	a->__anyAttribute = NULL;
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wstop__TopicSetType(struct soap *soap, const struct wstop__TopicSetType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTowstop__Documentation(soap, &a->documentation);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wstop__TopicSetType(struct soap *soap, const char *tag, int id, const struct wstop__TopicSetType *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wstop__TopicSetType), type))
		return soap->error;
	if (soap_out_PointerTowstop__Documentation(soap, "wstop:documentation", -1, &a->documentation, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wstop__TopicSetType * SOAP_FMAC4 soap_in_wstop__TopicSetType(struct soap *soap, const char *tag, struct wstop__TopicSetType *a, const char *type)
{
	size_t soap_flag_documentation = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wstop__TopicSetType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wstop__TopicSetType, sizeof(struct wstop__TopicSetType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wstop__TopicSetType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_documentation && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowstop__Documentation(soap, "wstop:documentation", &a->documentation, "wstop:Documentation"))
				{	soap_flag_documentation--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wstop__TopicSetType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wstop__TopicSetType, 0, sizeof(struct wstop__TopicSetType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wstop__TopicSetType(struct soap *soap, const struct wstop__TopicSetType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wstop__TopicSetType);
	if (soap_out_wstop__TopicSetType(soap, tag?tag:"wstop:TopicSetType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wstop__TopicSetType * SOAP_FMAC4 soap_get_wstop__TopicSetType(struct soap *soap, struct wstop__TopicSetType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wstop__TopicSetType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__NotificationProducerRP(struct soap *soap, struct _wsnt__NotificationProducerRP *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeTopicExpression = 0;
	a->TopicExpression = NULL;
	a->FixedTopicSet = NULL;
	a->__sizeTopicExpressionDialect = 0;
	a->TopicExpressionDialect = NULL;
	a->wstop__TopicSet = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__NotificationProducerRP(struct soap *soap, const struct _wsnt__NotificationProducerRP *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->TopicExpression)
	{	int i;
		for (i = 0; i < a->__sizeTopicExpression; i++)
		{
			soap_embedded(soap, a->TopicExpression + i, SOAP_TYPE_wsnt__TopicExpressionType);
			soap_serialize_wsnt__TopicExpressionType(soap, a->TopicExpression + i);
		}
	}
	soap_serialize_PointerToxsd__boolean_(soap, &a->FixedTopicSet);
	if (a->TopicExpressionDialect)
	{	int i;
		for (i = 0; i < a->__sizeTopicExpressionDialect; i++)
		{
			soap_serialize_string(soap, a->TopicExpressionDialect + i);
		}
	}
	soap_serialize_PointerTowstop__TopicSetType(soap, &a->wstop__TopicSet);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__NotificationProducerRP(struct soap *soap, const char *tag, int id, const struct _wsnt__NotificationProducerRP *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__NotificationProducerRP), type))
		return soap->error;
	if (a->TopicExpression)
	{	int i;
		for (i = 0; i < a->__sizeTopicExpression; i++)
			if (soap_out_wsnt__TopicExpressionType(soap, "wsnt:TopicExpression", -1, a->TopicExpression + i, ""))
				return soap->error;
	}
	if (soap_out_PointerToxsd__boolean_(soap, "wsnt:FixedTopicSet", -1, &a->FixedTopicSet, ""))
		return soap->error;
	if (a->TopicExpressionDialect)
	{	int i;
		for (i = 0; i < a->__sizeTopicExpressionDialect; i++)
			if (soap_out_string(soap, "wsnt:TopicExpressionDialect", -1, a->TopicExpressionDialect + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTowstop__TopicSetType(soap, "wstop:TopicSet", -1, &a->wstop__TopicSet, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__NotificationProducerRP * SOAP_FMAC4 soap_in__wsnt__NotificationProducerRP(struct soap *soap, const char *tag, struct _wsnt__NotificationProducerRP *a, const char *type)
{
	struct soap_blist *soap_blist_TopicExpression = NULL;
	size_t soap_flag_FixedTopicSet = 1;
	struct soap_blist *soap_blist_TopicExpressionDialect = NULL;
	size_t soap_flag_wstop__TopicSet = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _wsnt__NotificationProducerRP *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__NotificationProducerRP, sizeof(struct _wsnt__NotificationProducerRP), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__NotificationProducerRP(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wsnt:TopicExpression", 1, NULL))
			{	if (a->TopicExpression == NULL)
				{	if (soap_blist_TopicExpression == NULL)
						soap_blist_TopicExpression = soap_new_block(soap);
					a->TopicExpression = (struct wsnt__TopicExpressionType *)soap_push_block(soap, soap_blist_TopicExpression, sizeof(struct wsnt__TopicExpressionType));
					if (a->TopicExpression == NULL)
						return NULL;
					soap_default_wsnt__TopicExpressionType(soap, a->TopicExpression);
				}
				soap_revert(soap);
				if (soap_in_wsnt__TopicExpressionType(soap, "wsnt:TopicExpression", a->TopicExpression, "wsnt:TopicExpressionType"))
				{	a->__sizeTopicExpression++;
					a->TopicExpression = NULL;
					continue;
				}
			}
			if (soap_flag_FixedTopicSet && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__boolean_(soap, "wsnt:FixedTopicSet", &a->FixedTopicSet, "xsd:boolean"))
				{	soap_flag_FixedTopicSet--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wsnt:TopicExpressionDialect", 1, NULL))
			{	if (a->TopicExpressionDialect == NULL)
				{	if (soap_blist_TopicExpressionDialect == NULL)
						soap_blist_TopicExpressionDialect = soap_new_block(soap);
					a->TopicExpressionDialect = (char **)soap_push_block(soap, soap_blist_TopicExpressionDialect, sizeof(char *));
					if (a->TopicExpressionDialect == NULL)
						return NULL;
					*a->TopicExpressionDialect = NULL;
				}
				soap_revert(soap);
				if (soap_in_string(soap, "wsnt:TopicExpressionDialect", a->TopicExpressionDialect, "xsd:string"))
				{	a->__sizeTopicExpressionDialect++;
					a->TopicExpressionDialect = NULL;
					continue;
				}
			}
			if (soap_flag_wstop__TopicSet && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowstop__TopicSetType(soap, "wstop:TopicSet", &a->wstop__TopicSet, "wstop:TopicSetType"))
				{	soap_flag_wstop__TopicSet--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->TopicExpression)
			soap_pop_block(soap, soap_blist_TopicExpression);
		if (a->__sizeTopicExpression)
			a->TopicExpression = (struct wsnt__TopicExpressionType *)soap_save_block(soap, soap_blist_TopicExpression, NULL, 1);
		else
		{	a->TopicExpression = NULL;
			if (soap_blist_TopicExpression)
				soap_end_block(soap, soap_blist_TopicExpression);
		}
		if (a->TopicExpressionDialect)
			soap_pop_block(soap, soap_blist_TopicExpressionDialect);
		if (a->__sizeTopicExpressionDialect)
			a->TopicExpressionDialect = (char **)soap_save_block(soap, soap_blist_TopicExpressionDialect, NULL, 1);
		else
		{	a->TopicExpressionDialect = NULL;
			if (soap_blist_TopicExpressionDialect)
				soap_end_block(soap, soap_blist_TopicExpressionDialect);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__NotificationProducerRP *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__NotificationProducerRP, 0, sizeof(struct _wsnt__NotificationProducerRP), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__NotificationProducerRP(struct soap *soap, const struct _wsnt__NotificationProducerRP *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__wsnt__NotificationProducerRP);
	if (soap_out__wsnt__NotificationProducerRP(soap, tag?tag:"wsnt:NotificationProducerRP", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__NotificationProducerRP * SOAP_FMAC4 soap_get__wsnt__NotificationProducerRP(struct soap *soap, struct _wsnt__NotificationProducerRP *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__NotificationProducerRP(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__NotificationMessageHolderType_Message(struct soap *soap, struct _wsnt__NotificationMessageHolderType_Message *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__NotificationMessageHolderType_Message(struct soap *soap, const struct _wsnt__NotificationMessageHolderType_Message *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__NotificationMessageHolderType_Message(struct soap *soap, const char *tag, int id, const struct _wsnt__NotificationMessageHolderType_Message *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__NotificationMessageHolderType_Message), type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__NotificationMessageHolderType_Message * SOAP_FMAC4 soap_in__wsnt__NotificationMessageHolderType_Message(struct soap *soap, const char *tag, struct _wsnt__NotificationMessageHolderType_Message *a, const char *type)
{
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _wsnt__NotificationMessageHolderType_Message *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__NotificationMessageHolderType_Message, sizeof(struct _wsnt__NotificationMessageHolderType_Message), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__NotificationMessageHolderType_Message(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__NotificationMessageHolderType_Message *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__NotificationMessageHolderType_Message, 0, sizeof(struct _wsnt__NotificationMessageHolderType_Message), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__NotificationMessageHolderType_Message(struct soap *soap, const struct _wsnt__NotificationMessageHolderType_Message *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__wsnt__NotificationMessageHolderType_Message);
	if (soap_out__wsnt__NotificationMessageHolderType_Message(soap, tag?tag:"wsnt:NotificationMessageHolderType-Message", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__NotificationMessageHolderType_Message * SOAP_FMAC4 soap_get__wsnt__NotificationMessageHolderType_Message(struct soap *soap, struct _wsnt__NotificationMessageHolderType_Message *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__NotificationMessageHolderType_Message(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsnt__SubscriptionPolicyType(struct soap *soap, struct wsnt__SubscriptionPolicyType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsnt__SubscriptionPolicyType(struct soap *soap, const struct wsnt__SubscriptionPolicyType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__SubscriptionPolicyType(struct soap *soap, const char *tag, int id, const struct wsnt__SubscriptionPolicyType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsnt__SubscriptionPolicyType), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsnt__SubscriptionPolicyType * SOAP_FMAC4 soap_in_wsnt__SubscriptionPolicyType(struct soap *soap, const char *tag, struct wsnt__SubscriptionPolicyType *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wsnt__SubscriptionPolicyType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsnt__SubscriptionPolicyType, sizeof(struct wsnt__SubscriptionPolicyType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsnt__SubscriptionPolicyType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wsnt__SubscriptionPolicyType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnt__SubscriptionPolicyType, 0, sizeof(struct wsnt__SubscriptionPolicyType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsnt__SubscriptionPolicyType(struct soap *soap, const struct wsnt__SubscriptionPolicyType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wsnt__SubscriptionPolicyType);
	if (soap_out_wsnt__SubscriptionPolicyType(soap, tag?tag:"wsnt:SubscriptionPolicyType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsnt__SubscriptionPolicyType * SOAP_FMAC4 soap_get_wsnt__SubscriptionPolicyType(struct soap *soap, struct wsnt__SubscriptionPolicyType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnt__SubscriptionPolicyType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsnt__TopicExpressionType(struct soap *soap, struct wsnt__TopicExpressionType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
	soap_default_string(soap, &a->Dialect);
	a->__anyAttribute = NULL;
	a->__mixed = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsnt__TopicExpressionType(struct soap *soap, const struct wsnt__TopicExpressionType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__TopicExpressionType(struct soap *soap, const char *tag, int id, const struct wsnt__TopicExpressionType *a, const char *type)
{
	if (a->Dialect)
		soap_set_attr(soap, "Dialect", a->Dialect, 1);
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsnt__TopicExpressionType), type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	soap_outliteral(soap, "-mixed", &a->__mixed, NULL);
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsnt__TopicExpressionType * SOAP_FMAC4 soap_in_wsnt__TopicExpressionType(struct soap *soap, const char *tag, struct wsnt__TopicExpressionType *a, const char *type)
{
	size_t soap_flag___any = 1;
	size_t soap_flag___mixed = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wsnt__TopicExpressionType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsnt__TopicExpressionType, sizeof(struct wsnt__TopicExpressionType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsnt__TopicExpressionType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Dialect", 1), &a->Dialect, -1, -1))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap_flag___mixed && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-mixed", &a->__mixed))
				{	soap_flag___mixed--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wsnt__TopicExpressionType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnt__TopicExpressionType, 0, sizeof(struct wsnt__TopicExpressionType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsnt__TopicExpressionType(struct soap *soap, const struct wsnt__TopicExpressionType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wsnt__TopicExpressionType);
	if (soap_out_wsnt__TopicExpressionType(soap, tag?tag:"wsnt:TopicExpressionType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsnt__TopicExpressionType * SOAP_FMAC4 soap_get_wsnt__TopicExpressionType(struct soap *soap, struct wsnt__TopicExpressionType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnt__TopicExpressionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsnt__QueryExpressionType(struct soap *soap, struct wsnt__QueryExpressionType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
	soap_default_string(soap, &a->Dialect);
	a->__mixed = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsnt__QueryExpressionType(struct soap *soap, const struct wsnt__QueryExpressionType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__QueryExpressionType(struct soap *soap, const char *tag, int id, const struct wsnt__QueryExpressionType *a, const char *type)
{
	if (a->Dialect)
		soap_set_attr(soap, "Dialect", a->Dialect, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsnt__QueryExpressionType), type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	soap_outliteral(soap, "-mixed", &a->__mixed, NULL);
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsnt__QueryExpressionType * SOAP_FMAC4 soap_in_wsnt__QueryExpressionType(struct soap *soap, const char *tag, struct wsnt__QueryExpressionType *a, const char *type)
{
	size_t soap_flag___any = 1;
	size_t soap_flag___mixed = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wsnt__QueryExpressionType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsnt__QueryExpressionType, sizeof(struct wsnt__QueryExpressionType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsnt__QueryExpressionType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Dialect", 1), &a->Dialect, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap_flag___mixed && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-mixed", &a->__mixed))
				{	soap_flag___mixed--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wsnt__QueryExpressionType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnt__QueryExpressionType, 0, sizeof(struct wsnt__QueryExpressionType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsnt__QueryExpressionType(struct soap *soap, const struct wsnt__QueryExpressionType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wsnt__QueryExpressionType);
	if (soap_out_wsnt__QueryExpressionType(soap, tag?tag:"wsnt:QueryExpressionType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsnt__QueryExpressionType * SOAP_FMAC4 soap_get_wsnt__QueryExpressionType(struct soap *soap, struct wsnt__QueryExpressionType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnt__QueryExpressionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tt__Message(struct soap *soap, struct _tt__Message *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Source = NULL;
	a->Key = NULL;
	a->Data = NULL;
	a->Extension = NULL;
	soap_default_time(soap, &a->UtcTime);
	a->PropertyOperation = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tt__Message(struct soap *soap, const struct _tt__Message *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTott__ItemList(soap, &a->Source);
	soap_serialize_PointerTott__ItemList(soap, &a->Key);
	soap_serialize_PointerTott__ItemList(soap, &a->Data);
	soap_serialize_PointerTott__MessageExtension(soap, &a->Extension);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tt__Message(struct soap *soap, const char *tag, int id, const struct _tt__Message *a, const char *type)
{
	soap_set_attr(soap, "UtcTime", soap_dateTime2s(soap, a->UtcTime), 1);
	if (a->PropertyOperation)
		soap_set_attr(soap, "PropertyOperation", soap_tt__PropertyOperation2s(soap, *a->PropertyOperation), 1);
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tt__Message), type))
		return soap->error;
	if (soap_out_PointerTott__ItemList(soap, "tt:Source", -1, &a->Source, ""))
		return soap->error;
	if (soap_out_PointerTott__ItemList(soap, "tt:Key", -1, &a->Key, ""))
		return soap->error;
	if (soap_out_PointerTott__ItemList(soap, "tt:Data", -1, &a->Data, ""))
		return soap->error;
	if (soap_out_PointerTott__MessageExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tt__Message * SOAP_FMAC4 soap_in__tt__Message(struct soap *soap, const char *tag, struct _tt__Message *a, const char *type)
{
	size_t soap_flag_Source = 1;
	size_t soap_flag_Key = 1;
	size_t soap_flag_Data = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tt__Message *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tt__Message, sizeof(struct _tt__Message), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tt__Message(soap, a);
	if (soap_s2dateTime(soap, soap_attr_value(soap, "UtcTime", 1), &a->UtcTime))
		return NULL;
	{	const char *t = soap_attr_value(soap, "PropertyOperation", 0);
		if (t)
		{
			if (!(a->PropertyOperation = (enum tt__PropertyOperation *)soap_malloc(soap, sizeof(enum tt__PropertyOperation))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2tt__PropertyOperation(soap, t, a->PropertyOperation))
			return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Source && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__ItemList(soap, "tt:Source", &a->Source, "tt:ItemList"))
				{	soap_flag_Source--;
					continue;
				}
			if (soap_flag_Key && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__ItemList(soap, "tt:Key", &a->Key, "tt:ItemList"))
				{	soap_flag_Key--;
					continue;
				}
			if (soap_flag_Data && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__ItemList(soap, "tt:Data", &a->Data, "tt:ItemList"))
				{	soap_flag_Data--;
					continue;
				}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__MessageExtension(soap, "tt:Extension", &a->Extension, "tt:MessageExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tt__Message *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tt__Message, 0, sizeof(struct _tt__Message), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tt__Message(struct soap *soap, const struct _tt__Message *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tt__Message);
	if (soap_out__tt__Message(soap, tag?tag:"tt:Message", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tt__Message * SOAP_FMAC4 soap_get__tt__Message(struct soap *soap, struct _tt__Message *p, const char *tag, const char *type)
{
	if ((p = soap_in__tt__Message(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__AnalyticsState(struct soap *soap, struct tt__AnalyticsState *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Error);
	soap_default_string(soap, &a->State);
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__AnalyticsState(struct soap *soap, const struct tt__AnalyticsState *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Error);
	soap_serialize_string(soap, &a->State);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AnalyticsState(struct soap *soap, const char *tag, int id, const struct tt__AnalyticsState *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AnalyticsState), type))
		return soap->error;
	if (soap_out_string(soap, "tt:Error", -1, &a->Error, ""))
		return soap->error;
	if (a->State)
	{	if (soap_out_string(soap, "tt:State", -1, &a->State, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:State"))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__AnalyticsState * SOAP_FMAC4 soap_in_tt__AnalyticsState(struct soap *soap, const char *tag, struct tt__AnalyticsState *a, const char *type)
{
	size_t soap_flag_Error = 1;
	size_t soap_flag_State = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__AnalyticsState *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AnalyticsState, sizeof(struct tt__AnalyticsState), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__AnalyticsState(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Error && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "tt:Error", &a->Error, "xsd:string"))
				{	soap_flag_Error--;
					continue;
				}
			if (soap_flag_State && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "tt:State", &a->State, "xsd:string"))
				{	soap_flag_State--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__AnalyticsState *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AnalyticsState, 0, sizeof(struct tt__AnalyticsState), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_State > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__AnalyticsState(struct soap *soap, const struct tt__AnalyticsState *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__AnalyticsState);
	if (soap_out_tt__AnalyticsState(soap, tag?tag:"tt:AnalyticsState", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AnalyticsState * SOAP_FMAC4 soap_get_tt__AnalyticsState(struct soap *soap, struct tt__AnalyticsState *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AnalyticsState(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__AnalyticsStateInformation(struct soap *soap, struct tt__AnalyticsStateInformation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->AnalyticsEngineControlToken);
	a->State = NULL;
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__AnalyticsStateInformation(struct soap *soap, const struct tt__AnalyticsStateInformation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_tt__ReferenceToken(soap, &a->AnalyticsEngineControlToken);
	soap_serialize_PointerTott__AnalyticsState(soap, &a->State);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AnalyticsStateInformation(struct soap *soap, const char *tag, int id, const struct tt__AnalyticsStateInformation *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AnalyticsStateInformation), type))
		return soap->error;
	if (a->AnalyticsEngineControlToken)
	{	if (soap_out_tt__ReferenceToken(soap, "tt:AnalyticsEngineControlToken", -1, &a->AnalyticsEngineControlToken, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:AnalyticsEngineControlToken"))
		return soap->error;
	if (a->State)
	{	if (soap_out_PointerTott__AnalyticsState(soap, "tt:State", -1, &a->State, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:State"))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__AnalyticsStateInformation * SOAP_FMAC4 soap_in_tt__AnalyticsStateInformation(struct soap *soap, const char *tag, struct tt__AnalyticsStateInformation *a, const char *type)
{
	size_t soap_flag_AnalyticsEngineControlToken = 1;
	size_t soap_flag_State = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__AnalyticsStateInformation *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AnalyticsStateInformation, sizeof(struct tt__AnalyticsStateInformation), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__AnalyticsStateInformation(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_AnalyticsEngineControlToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "tt:AnalyticsEngineControlToken", &a->AnalyticsEngineControlToken, "tt:ReferenceToken"))
				{	soap_flag_AnalyticsEngineControlToken--;
					continue;
				}
			if (soap_flag_State && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__AnalyticsState(soap, "tt:State", &a->State, "tt:AnalyticsState"))
				{	soap_flag_State--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__AnalyticsStateInformation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AnalyticsStateInformation, 0, sizeof(struct tt__AnalyticsStateInformation), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_AnalyticsEngineControlToken > 0 || soap_flag_State > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__AnalyticsStateInformation(struct soap *soap, const struct tt__AnalyticsStateInformation *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__AnalyticsStateInformation);
	if (soap_out_tt__AnalyticsStateInformation(soap, tag?tag:"tt:AnalyticsStateInformation", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AnalyticsStateInformation * SOAP_FMAC4 soap_get_tt__AnalyticsStateInformation(struct soap *soap, struct tt__AnalyticsStateInformation *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AnalyticsStateInformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__MetadataInputExtension(struct soap *soap, struct tt__MetadataInputExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__MetadataInputExtension(struct soap *soap, const struct tt__MetadataInputExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__MetadataInputExtension(struct soap *soap, const char *tag, int id, const struct tt__MetadataInputExtension *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__MetadataInputExtension), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__MetadataInputExtension * SOAP_FMAC4 soap_in_tt__MetadataInputExtension(struct soap *soap, const char *tag, struct tt__MetadataInputExtension *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__MetadataInputExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__MetadataInputExtension, sizeof(struct tt__MetadataInputExtension), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__MetadataInputExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__MetadataInputExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__MetadataInputExtension, 0, sizeof(struct tt__MetadataInputExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__MetadataInputExtension(struct soap *soap, const struct tt__MetadataInputExtension *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__MetadataInputExtension);
	if (soap_out_tt__MetadataInputExtension(soap, tag?tag:"tt:MetadataInputExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__MetadataInputExtension * SOAP_FMAC4 soap_get_tt__MetadataInputExtension(struct soap *soap, struct tt__MetadataInputExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__MetadataInputExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__MetadataInput(struct soap *soap, struct tt__MetadataInput *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeMetadataConfig = 0;
	a->MetadataConfig = NULL;
	a->Extension = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__MetadataInput(struct soap *soap, const struct tt__MetadataInput *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->MetadataConfig)
	{	int i;
		for (i = 0; i < a->__sizeMetadataConfig; i++)
		{
			soap_embedded(soap, a->MetadataConfig + i, SOAP_TYPE_tt__Config);
			soap_serialize_tt__Config(soap, a->MetadataConfig + i);
		}
	}
	soap_serialize_PointerTott__MetadataInputExtension(soap, &a->Extension);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__MetadataInput(struct soap *soap, const char *tag, int id, const struct tt__MetadataInput *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__MetadataInput), type))
		return soap->error;
	if (a->MetadataConfig)
	{	int i;
		for (i = 0; i < a->__sizeMetadataConfig; i++)
			if (soap_out_tt__Config(soap, "tt:MetadataConfig", -1, a->MetadataConfig + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTott__MetadataInputExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__MetadataInput * SOAP_FMAC4 soap_in_tt__MetadataInput(struct soap *soap, const char *tag, struct tt__MetadataInput *a, const char *type)
{
	struct soap_blist *soap_blist_MetadataConfig = NULL;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__MetadataInput *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__MetadataInput, sizeof(struct tt__MetadataInput), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__MetadataInput(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:MetadataConfig", 1, NULL))
			{	if (a->MetadataConfig == NULL)
				{	if (soap_blist_MetadataConfig == NULL)
						soap_blist_MetadataConfig = soap_new_block(soap);
					a->MetadataConfig = (struct tt__Config *)soap_push_block(soap, soap_blist_MetadataConfig, sizeof(struct tt__Config));
					if (a->MetadataConfig == NULL)
						return NULL;
					soap_default_tt__Config(soap, a->MetadataConfig);
				}
				soap_revert(soap);
				if (soap_in_tt__Config(soap, "tt:MetadataConfig", a->MetadataConfig, "tt:Config"))
				{	a->__sizeMetadataConfig++;
					a->MetadataConfig = NULL;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__MetadataInputExtension(soap, "tt:Extension", &a->Extension, "tt:MetadataInputExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->MetadataConfig)
			soap_pop_block(soap, soap_blist_MetadataConfig);
		if (a->__sizeMetadataConfig)
			a->MetadataConfig = (struct tt__Config *)soap_save_block(soap, soap_blist_MetadataConfig, NULL, 1);
		else
		{	a->MetadataConfig = NULL;
			if (soap_blist_MetadataConfig)
				soap_end_block(soap, soap_blist_MetadataConfig);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__MetadataInput *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__MetadataInput, 0, sizeof(struct tt__MetadataInput), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__MetadataInput(struct soap *soap, const struct tt__MetadataInput *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__MetadataInput);
	if (soap_out_tt__MetadataInput(soap, tag?tag:"tt:MetadataInput", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__MetadataInput * SOAP_FMAC4 soap_get_tt__MetadataInput(struct soap *soap, struct tt__MetadataInput *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__MetadataInput(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__SourceIdentificationExtension(struct soap *soap, struct tt__SourceIdentificationExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__SourceIdentificationExtension(struct soap *soap, const struct tt__SourceIdentificationExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__SourceIdentificationExtension(struct soap *soap, const char *tag, int id, const struct tt__SourceIdentificationExtension *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__SourceIdentificationExtension), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__SourceIdentificationExtension * SOAP_FMAC4 soap_in_tt__SourceIdentificationExtension(struct soap *soap, const char *tag, struct tt__SourceIdentificationExtension *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__SourceIdentificationExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__SourceIdentificationExtension, sizeof(struct tt__SourceIdentificationExtension), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__SourceIdentificationExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__SourceIdentificationExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__SourceIdentificationExtension, 0, sizeof(struct tt__SourceIdentificationExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__SourceIdentificationExtension(struct soap *soap, const struct tt__SourceIdentificationExtension *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__SourceIdentificationExtension);
	if (soap_out_tt__SourceIdentificationExtension(soap, tag?tag:"tt:SourceIdentificationExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__SourceIdentificationExtension * SOAP_FMAC4 soap_get_tt__SourceIdentificationExtension(struct soap *soap, struct tt__SourceIdentificationExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__SourceIdentificationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__SourceIdentification(struct soap *soap, struct tt__SourceIdentification *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Name);
	a->__sizeToken = 0;
	a->Token = NULL;
	a->Extension = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__SourceIdentification(struct soap *soap, const struct tt__SourceIdentification *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Name);
	if (a->Token)
	{	int i;
		for (i = 0; i < a->__sizeToken; i++)
		{
			soap_serialize_tt__ReferenceToken(soap, a->Token + i);
		}
	}
	soap_serialize_PointerTott__SourceIdentificationExtension(soap, &a->Extension);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__SourceIdentification(struct soap *soap, const char *tag, int id, const struct tt__SourceIdentification *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__SourceIdentification), type))
		return soap->error;
	if (a->Name)
	{	if (soap_out_string(soap, "tt:Name", -1, &a->Name, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:Name"))
		return soap->error;
	if (a->Token)
	{	int i;
		for (i = 0; i < a->__sizeToken; i++)
			if (soap_out_tt__ReferenceToken(soap, "tt:Token", -1, a->Token + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTott__SourceIdentificationExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__SourceIdentification * SOAP_FMAC4 soap_in_tt__SourceIdentification(struct soap *soap, const char *tag, struct tt__SourceIdentification *a, const char *type)
{
	size_t soap_flag_Name = 1;
	struct soap_blist *soap_blist_Token = NULL;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__SourceIdentification *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__SourceIdentification, sizeof(struct tt__SourceIdentification), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__SourceIdentification(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "tt:Name", &a->Name, "xsd:string"))
				{	soap_flag_Name--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Token", 1, NULL))
			{	if (a->Token == NULL)
				{	if (soap_blist_Token == NULL)
						soap_blist_Token = soap_new_block(soap);
					a->Token = (char **)soap_push_block(soap, soap_blist_Token, sizeof(char *));
					if (a->Token == NULL)
						return NULL;
					*a->Token = NULL;
				}
				soap_revert(soap);
				if (soap_in_tt__ReferenceToken(soap, "tt:Token", a->Token, "tt:ReferenceToken"))
				{	a->__sizeToken++;
					a->Token = NULL;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__SourceIdentificationExtension(soap, "tt:Extension", &a->Extension, "tt:SourceIdentificationExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Token)
			soap_pop_block(soap, soap_blist_Token);
		if (a->__sizeToken)
			a->Token = (char **)soap_save_block(soap, soap_blist_Token, NULL, 1);
		else
		{	a->Token = NULL;
			if (soap_blist_Token)
				soap_end_block(soap, soap_blist_Token);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__SourceIdentification *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__SourceIdentification, 0, sizeof(struct tt__SourceIdentification), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Name > 0 || a->__sizeToken < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__SourceIdentification(struct soap *soap, const struct tt__SourceIdentification *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__SourceIdentification);
	if (soap_out_tt__SourceIdentification(soap, tag?tag:"tt:SourceIdentification", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__SourceIdentification * SOAP_FMAC4 soap_get_tt__SourceIdentification(struct soap *soap, struct tt__SourceIdentification *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__SourceIdentification(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__AnalyticsEngineInputInfoExtension(struct soap *soap, struct tt__AnalyticsEngineInputInfoExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__AnalyticsEngineInputInfoExtension(struct soap *soap, const struct tt__AnalyticsEngineInputInfoExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AnalyticsEngineInputInfoExtension(struct soap *soap, const char *tag, int id, const struct tt__AnalyticsEngineInputInfoExtension *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AnalyticsEngineInputInfoExtension), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__AnalyticsEngineInputInfoExtension * SOAP_FMAC4 soap_in_tt__AnalyticsEngineInputInfoExtension(struct soap *soap, const char *tag, struct tt__AnalyticsEngineInputInfoExtension *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__AnalyticsEngineInputInfoExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AnalyticsEngineInputInfoExtension, sizeof(struct tt__AnalyticsEngineInputInfoExtension), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__AnalyticsEngineInputInfoExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__AnalyticsEngineInputInfoExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AnalyticsEngineInputInfoExtension, 0, sizeof(struct tt__AnalyticsEngineInputInfoExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__AnalyticsEngineInputInfoExtension(struct soap *soap, const struct tt__AnalyticsEngineInputInfoExtension *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__AnalyticsEngineInputInfoExtension);
	if (soap_out_tt__AnalyticsEngineInputInfoExtension(soap, tag?tag:"tt:AnalyticsEngineInputInfoExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AnalyticsEngineInputInfoExtension * SOAP_FMAC4 soap_get_tt__AnalyticsEngineInputInfoExtension(struct soap *soap, struct tt__AnalyticsEngineInputInfoExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AnalyticsEngineInputInfoExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__AnalyticsEngineInputInfo(struct soap *soap, struct tt__AnalyticsEngineInputInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->InputInfo = NULL;
	a->Extension = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__AnalyticsEngineInputInfo(struct soap *soap, const struct tt__AnalyticsEngineInputInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTott__Config(soap, &a->InputInfo);
	soap_serialize_PointerTott__AnalyticsEngineInputInfoExtension(soap, &a->Extension);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AnalyticsEngineInputInfo(struct soap *soap, const char *tag, int id, const struct tt__AnalyticsEngineInputInfo *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AnalyticsEngineInputInfo), type))
		return soap->error;
	if (soap_out_PointerTott__Config(soap, "tt:InputInfo", -1, &a->InputInfo, ""))
		return soap->error;
	if (soap_out_PointerTott__AnalyticsEngineInputInfoExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__AnalyticsEngineInputInfo * SOAP_FMAC4 soap_in_tt__AnalyticsEngineInputInfo(struct soap *soap, const char *tag, struct tt__AnalyticsEngineInputInfo *a, const char *type)
{
	size_t soap_flag_InputInfo = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__AnalyticsEngineInputInfo *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AnalyticsEngineInputInfo, sizeof(struct tt__AnalyticsEngineInputInfo), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__AnalyticsEngineInputInfo(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_InputInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__Config(soap, "tt:InputInfo", &a->InputInfo, "tt:Config"))
				{	soap_flag_InputInfo--;
					continue;
				}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__AnalyticsEngineInputInfoExtension(soap, "tt:Extension", &a->Extension, "tt:AnalyticsEngineInputInfoExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__AnalyticsEngineInputInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AnalyticsEngineInputInfo, 0, sizeof(struct tt__AnalyticsEngineInputInfo), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__AnalyticsEngineInputInfo(struct soap *soap, const struct tt__AnalyticsEngineInputInfo *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__AnalyticsEngineInputInfo);
	if (soap_out_tt__AnalyticsEngineInputInfo(soap, tag?tag:"tt:AnalyticsEngineInputInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AnalyticsEngineInputInfo * SOAP_FMAC4 soap_get_tt__AnalyticsEngineInputInfo(struct soap *soap, struct tt__AnalyticsEngineInputInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AnalyticsEngineInputInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__AnalyticsDeviceEngineConfigurationExtension(struct soap *soap, struct tt__AnalyticsDeviceEngineConfigurationExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__AnalyticsDeviceEngineConfigurationExtension(struct soap *soap, const struct tt__AnalyticsDeviceEngineConfigurationExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AnalyticsDeviceEngineConfigurationExtension(struct soap *soap, const char *tag, int id, const struct tt__AnalyticsDeviceEngineConfigurationExtension *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AnalyticsDeviceEngineConfigurationExtension), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__AnalyticsDeviceEngineConfigurationExtension * SOAP_FMAC4 soap_in_tt__AnalyticsDeviceEngineConfigurationExtension(struct soap *soap, const char *tag, struct tt__AnalyticsDeviceEngineConfigurationExtension *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__AnalyticsDeviceEngineConfigurationExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AnalyticsDeviceEngineConfigurationExtension, sizeof(struct tt__AnalyticsDeviceEngineConfigurationExtension), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__AnalyticsDeviceEngineConfigurationExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__AnalyticsDeviceEngineConfigurationExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AnalyticsDeviceEngineConfigurationExtension, 0, sizeof(struct tt__AnalyticsDeviceEngineConfigurationExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__AnalyticsDeviceEngineConfigurationExtension(struct soap *soap, const struct tt__AnalyticsDeviceEngineConfigurationExtension *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__AnalyticsDeviceEngineConfigurationExtension);
	if (soap_out_tt__AnalyticsDeviceEngineConfigurationExtension(soap, tag?tag:"tt:AnalyticsDeviceEngineConfigurationExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AnalyticsDeviceEngineConfigurationExtension * SOAP_FMAC4 soap_get_tt__AnalyticsDeviceEngineConfigurationExtension(struct soap *soap, struct tt__AnalyticsDeviceEngineConfigurationExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AnalyticsDeviceEngineConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__EngineConfiguration(struct soap *soap, struct tt__EngineConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->VideoAnalyticsConfiguration = NULL;
	a->AnalyticsEngineInputInfo = NULL;
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__EngineConfiguration(struct soap *soap, const struct tt__EngineConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTott__VideoAnalyticsConfiguration(soap, &a->VideoAnalyticsConfiguration);
	soap_serialize_PointerTott__AnalyticsEngineInputInfo(soap, &a->AnalyticsEngineInputInfo);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__EngineConfiguration(struct soap *soap, const char *tag, int id, const struct tt__EngineConfiguration *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__EngineConfiguration), type))
		return soap->error;
	if (a->VideoAnalyticsConfiguration)
	{	if (soap_out_PointerTott__VideoAnalyticsConfiguration(soap, "tt:VideoAnalyticsConfiguration", -1, &a->VideoAnalyticsConfiguration, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:VideoAnalyticsConfiguration"))
		return soap->error;
	if (a->AnalyticsEngineInputInfo)
	{	if (soap_out_PointerTott__AnalyticsEngineInputInfo(soap, "tt:AnalyticsEngineInputInfo", -1, &a->AnalyticsEngineInputInfo, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:AnalyticsEngineInputInfo"))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__EngineConfiguration * SOAP_FMAC4 soap_in_tt__EngineConfiguration(struct soap *soap, const char *tag, struct tt__EngineConfiguration *a, const char *type)
{
	size_t soap_flag_VideoAnalyticsConfiguration = 1;
	size_t soap_flag_AnalyticsEngineInputInfo = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__EngineConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__EngineConfiguration, sizeof(struct tt__EngineConfiguration), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__EngineConfiguration(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_VideoAnalyticsConfiguration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__VideoAnalyticsConfiguration(soap, "tt:VideoAnalyticsConfiguration", &a->VideoAnalyticsConfiguration, "tt:VideoAnalyticsConfiguration"))
				{	soap_flag_VideoAnalyticsConfiguration--;
					continue;
				}
			if (soap_flag_AnalyticsEngineInputInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__AnalyticsEngineInputInfo(soap, "tt:AnalyticsEngineInputInfo", &a->AnalyticsEngineInputInfo, "tt:AnalyticsEngineInputInfo"))
				{	soap_flag_AnalyticsEngineInputInfo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__EngineConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__EngineConfiguration, 0, sizeof(struct tt__EngineConfiguration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_VideoAnalyticsConfiguration > 0 || soap_flag_AnalyticsEngineInputInfo > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__EngineConfiguration(struct soap *soap, const struct tt__EngineConfiguration *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__EngineConfiguration);
	if (soap_out_tt__EngineConfiguration(soap, tag?tag:"tt:EngineConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__EngineConfiguration * SOAP_FMAC4 soap_get_tt__EngineConfiguration(struct soap *soap, struct tt__EngineConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__EngineConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__AnalyticsDeviceEngineConfiguration(struct soap *soap, struct tt__AnalyticsDeviceEngineConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeEngineConfiguration = 0;
	a->EngineConfiguration = NULL;
	a->Extension = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__AnalyticsDeviceEngineConfiguration(struct soap *soap, const struct tt__AnalyticsDeviceEngineConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->EngineConfiguration)
	{	int i;
		for (i = 0; i < a->__sizeEngineConfiguration; i++)
		{
			soap_embedded(soap, a->EngineConfiguration + i, SOAP_TYPE_tt__EngineConfiguration);
			soap_serialize_tt__EngineConfiguration(soap, a->EngineConfiguration + i);
		}
	}
	soap_serialize_PointerTott__AnalyticsDeviceEngineConfigurationExtension(soap, &a->Extension);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AnalyticsDeviceEngineConfiguration(struct soap *soap, const char *tag, int id, const struct tt__AnalyticsDeviceEngineConfiguration *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AnalyticsDeviceEngineConfiguration), type))
		return soap->error;
	if (a->EngineConfiguration)
	{	int i;
		for (i = 0; i < a->__sizeEngineConfiguration; i++)
			if (soap_out_tt__EngineConfiguration(soap, "tt:EngineConfiguration", -1, a->EngineConfiguration + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTott__AnalyticsDeviceEngineConfigurationExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__AnalyticsDeviceEngineConfiguration * SOAP_FMAC4 soap_in_tt__AnalyticsDeviceEngineConfiguration(struct soap *soap, const char *tag, struct tt__AnalyticsDeviceEngineConfiguration *a, const char *type)
{
	struct soap_blist *soap_blist_EngineConfiguration = NULL;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__AnalyticsDeviceEngineConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AnalyticsDeviceEngineConfiguration, sizeof(struct tt__AnalyticsDeviceEngineConfiguration), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__AnalyticsDeviceEngineConfiguration(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:EngineConfiguration", 1, NULL))
			{	if (a->EngineConfiguration == NULL)
				{	if (soap_blist_EngineConfiguration == NULL)
						soap_blist_EngineConfiguration = soap_new_block(soap);
					a->EngineConfiguration = (struct tt__EngineConfiguration *)soap_push_block(soap, soap_blist_EngineConfiguration, sizeof(struct tt__EngineConfiguration));
					if (a->EngineConfiguration == NULL)
						return NULL;
					soap_default_tt__EngineConfiguration(soap, a->EngineConfiguration);
				}
				soap_revert(soap);
				if (soap_in_tt__EngineConfiguration(soap, "tt:EngineConfiguration", a->EngineConfiguration, "tt:EngineConfiguration"))
				{	a->__sizeEngineConfiguration++;
					a->EngineConfiguration = NULL;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__AnalyticsDeviceEngineConfigurationExtension(soap, "tt:Extension", &a->Extension, "tt:AnalyticsDeviceEngineConfigurationExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->EngineConfiguration)
			soap_pop_block(soap, soap_blist_EngineConfiguration);
		if (a->__sizeEngineConfiguration)
			a->EngineConfiguration = (struct tt__EngineConfiguration *)soap_save_block(soap, soap_blist_EngineConfiguration, NULL, 1);
		else
		{	a->EngineConfiguration = NULL;
			if (soap_blist_EngineConfiguration)
				soap_end_block(soap, soap_blist_EngineConfiguration);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__AnalyticsDeviceEngineConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AnalyticsDeviceEngineConfiguration, 0, sizeof(struct tt__AnalyticsDeviceEngineConfiguration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeEngineConfiguration < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__AnalyticsDeviceEngineConfiguration(struct soap *soap, const struct tt__AnalyticsDeviceEngineConfiguration *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__AnalyticsDeviceEngineConfiguration);
	if (soap_out_tt__AnalyticsDeviceEngineConfiguration(soap, tag?tag:"tt:AnalyticsDeviceEngineConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AnalyticsDeviceEngineConfiguration * SOAP_FMAC4 soap_get_tt__AnalyticsDeviceEngineConfiguration(struct soap *soap, struct tt__AnalyticsDeviceEngineConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AnalyticsDeviceEngineConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__ReplayConfiguration(struct soap *soap, struct tt__ReplayConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->SessionTimeout);
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__ReplayConfiguration(struct soap *soap, const struct tt__ReplayConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->SessionTimeout);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ReplayConfiguration(struct soap *soap, const char *tag, int id, const struct tt__ReplayConfiguration *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ReplayConfiguration), type))
		return soap->error;
	if (a->SessionTimeout)
	{	if (soap_out_string(soap, "tt:SessionTimeout", -1, &a->SessionTimeout, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:SessionTimeout"))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__ReplayConfiguration * SOAP_FMAC4 soap_in_tt__ReplayConfiguration(struct soap *soap, const char *tag, struct tt__ReplayConfiguration *a, const char *type)
{
	size_t soap_flag_SessionTimeout = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__ReplayConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ReplayConfiguration, sizeof(struct tt__ReplayConfiguration), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__ReplayConfiguration(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SessionTimeout && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "tt:SessionTimeout", &a->SessionTimeout, "xsd:string"))
				{	soap_flag_SessionTimeout--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__ReplayConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ReplayConfiguration, 0, sizeof(struct tt__ReplayConfiguration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_SessionTimeout > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ReplayConfiguration(struct soap *soap, const struct tt__ReplayConfiguration *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__ReplayConfiguration);
	if (soap_out_tt__ReplayConfiguration(soap, tag?tag:"tt:ReplayConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ReplayConfiguration * SOAP_FMAC4 soap_get_tt__ReplayConfiguration(struct soap *soap, struct tt__ReplayConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ReplayConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__GetRecordingJobsResponseItem(struct soap *soap, struct tt__GetRecordingJobsResponseItem *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__RecordingJobReference(soap, &a->JobToken);
	a->JobConfiguration = NULL;
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__GetRecordingJobsResponseItem(struct soap *soap, const struct tt__GetRecordingJobsResponseItem *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_tt__RecordingJobReference(soap, &a->JobToken);
	soap_serialize_PointerTott__RecordingJobConfiguration(soap, &a->JobConfiguration);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__GetRecordingJobsResponseItem(struct soap *soap, const char *tag, int id, const struct tt__GetRecordingJobsResponseItem *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__GetRecordingJobsResponseItem), type))
		return soap->error;
	if (a->JobToken)
	{	if (soap_out_tt__RecordingJobReference(soap, "tt:JobToken", -1, &a->JobToken, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:JobToken"))
		return soap->error;
	if (a->JobConfiguration)
	{	if (soap_out_PointerTott__RecordingJobConfiguration(soap, "tt:JobConfiguration", -1, &a->JobConfiguration, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:JobConfiguration"))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__GetRecordingJobsResponseItem * SOAP_FMAC4 soap_in_tt__GetRecordingJobsResponseItem(struct soap *soap, const char *tag, struct tt__GetRecordingJobsResponseItem *a, const char *type)
{
	size_t soap_flag_JobToken = 1;
	size_t soap_flag_JobConfiguration = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__GetRecordingJobsResponseItem *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__GetRecordingJobsResponseItem, sizeof(struct tt__GetRecordingJobsResponseItem), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__GetRecordingJobsResponseItem(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_JobToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__RecordingJobReference(soap, "tt:JobToken", &a->JobToken, "tt:RecordingJobReference"))
				{	soap_flag_JobToken--;
					continue;
				}
			if (soap_flag_JobConfiguration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__RecordingJobConfiguration(soap, "tt:JobConfiguration", &a->JobConfiguration, "tt:RecordingJobConfiguration"))
				{	soap_flag_JobConfiguration--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__GetRecordingJobsResponseItem *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__GetRecordingJobsResponseItem, 0, sizeof(struct tt__GetRecordingJobsResponseItem), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_JobToken > 0 || soap_flag_JobConfiguration > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__GetRecordingJobsResponseItem(struct soap *soap, const struct tt__GetRecordingJobsResponseItem *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__GetRecordingJobsResponseItem);
	if (soap_out_tt__GetRecordingJobsResponseItem(soap, tag?tag:"tt:GetRecordingJobsResponseItem", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__GetRecordingJobsResponseItem * SOAP_FMAC4 soap_get_tt__GetRecordingJobsResponseItem(struct soap *soap, struct tt__GetRecordingJobsResponseItem *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__GetRecordingJobsResponseItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__RecordingJobStateTrack(struct soap *soap, struct tt__RecordingJobStateTrack *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->SourceTag);
	soap_default_tt__TrackReference(soap, &a->Destination);
	soap_default_string(soap, &a->Error);
	soap_default_tt__RecordingJobState(soap, &a->State);
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__RecordingJobStateTrack(struct soap *soap, const struct tt__RecordingJobStateTrack *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->SourceTag);
	soap_serialize_tt__TrackReference(soap, &a->Destination);
	soap_serialize_string(soap, &a->Error);
	soap_serialize_tt__RecordingJobState(soap, &a->State);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__RecordingJobStateTrack(struct soap *soap, const char *tag, int id, const struct tt__RecordingJobStateTrack *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__RecordingJobStateTrack), type))
		return soap->error;
	if (a->SourceTag)
	{	if (soap_out_string(soap, "tt:SourceTag", -1, &a->SourceTag, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:SourceTag"))
		return soap->error;
	if (a->Destination)
	{	if (soap_out_tt__TrackReference(soap, "tt:Destination", -1, &a->Destination, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:Destination"))
		return soap->error;
	if (soap_out_string(soap, "tt:Error", -1, &a->Error, ""))
		return soap->error;
	if (a->State)
	{	if (soap_out_tt__RecordingJobState(soap, "tt:State", -1, &a->State, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:State"))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__RecordingJobStateTrack * SOAP_FMAC4 soap_in_tt__RecordingJobStateTrack(struct soap *soap, const char *tag, struct tt__RecordingJobStateTrack *a, const char *type)
{
	size_t soap_flag_SourceTag = 1;
	size_t soap_flag_Destination = 1;
	size_t soap_flag_Error = 1;
	size_t soap_flag_State = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__RecordingJobStateTrack *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RecordingJobStateTrack, sizeof(struct tt__RecordingJobStateTrack), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__RecordingJobStateTrack(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SourceTag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "tt:SourceTag", &a->SourceTag, "xsd:string"))
				{	soap_flag_SourceTag--;
					continue;
				}
			if (soap_flag_Destination && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__TrackReference(soap, "tt:Destination", &a->Destination, "tt:TrackReference"))
				{	soap_flag_Destination--;
					continue;
				}
			if (soap_flag_Error && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "tt:Error", &a->Error, "xsd:string"))
				{	soap_flag_Error--;
					continue;
				}
			if (soap_flag_State && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__RecordingJobState(soap, "tt:State", &a->State, "tt:RecordingJobState"))
				{	soap_flag_State--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__RecordingJobStateTrack *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__RecordingJobStateTrack, 0, sizeof(struct tt__RecordingJobStateTrack), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_SourceTag > 0 || soap_flag_Destination > 0 || soap_flag_State > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__RecordingJobStateTrack(struct soap *soap, const struct tt__RecordingJobStateTrack *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__RecordingJobStateTrack);
	if (soap_out_tt__RecordingJobStateTrack(soap, tag?tag:"tt:RecordingJobStateTrack", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__RecordingJobStateTrack * SOAP_FMAC4 soap_get_tt__RecordingJobStateTrack(struct soap *soap, struct tt__RecordingJobStateTrack *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__RecordingJobStateTrack(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__RecordingJobStateTracks(struct soap *soap, struct tt__RecordingJobStateTracks *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeTrack = 0;
	a->Track = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__RecordingJobStateTracks(struct soap *soap, const struct tt__RecordingJobStateTracks *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->Track)
	{	int i;
		for (i = 0; i < a->__sizeTrack; i++)
		{
			soap_embedded(soap, a->Track + i, SOAP_TYPE_tt__RecordingJobStateTrack);
			soap_serialize_tt__RecordingJobStateTrack(soap, a->Track + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__RecordingJobStateTracks(struct soap *soap, const char *tag, int id, const struct tt__RecordingJobStateTracks *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__RecordingJobStateTracks), type))
		return soap->error;
	if (a->Track)
	{	int i;
		for (i = 0; i < a->__sizeTrack; i++)
			if (soap_out_tt__RecordingJobStateTrack(soap, "tt:Track", -1, a->Track + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__RecordingJobStateTracks * SOAP_FMAC4 soap_in_tt__RecordingJobStateTracks(struct soap *soap, const char *tag, struct tt__RecordingJobStateTracks *a, const char *type)
{
	struct soap_blist *soap_blist_Track = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__RecordingJobStateTracks *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RecordingJobStateTracks, sizeof(struct tt__RecordingJobStateTracks), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__RecordingJobStateTracks(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Track", 1, NULL))
			{	if (a->Track == NULL)
				{	if (soap_blist_Track == NULL)
						soap_blist_Track = soap_new_block(soap);
					a->Track = (struct tt__RecordingJobStateTrack *)soap_push_block(soap, soap_blist_Track, sizeof(struct tt__RecordingJobStateTrack));
					if (a->Track == NULL)
						return NULL;
					soap_default_tt__RecordingJobStateTrack(soap, a->Track);
				}
				soap_revert(soap);
				if (soap_in_tt__RecordingJobStateTrack(soap, "tt:Track", a->Track, "tt:RecordingJobStateTrack"))
				{	a->__sizeTrack++;
					a->Track = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Track)
			soap_pop_block(soap, soap_blist_Track);
		if (a->__sizeTrack)
			a->Track = (struct tt__RecordingJobStateTrack *)soap_save_block(soap, soap_blist_Track, NULL, 1);
		else
		{	a->Track = NULL;
			if (soap_blist_Track)
				soap_end_block(soap, soap_blist_Track);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__RecordingJobStateTracks *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__RecordingJobStateTracks, 0, sizeof(struct tt__RecordingJobStateTracks), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__RecordingJobStateTracks(struct soap *soap, const struct tt__RecordingJobStateTracks *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__RecordingJobStateTracks);
	if (soap_out_tt__RecordingJobStateTracks(soap, tag?tag:"tt:RecordingJobStateTracks", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__RecordingJobStateTracks * SOAP_FMAC4 soap_get_tt__RecordingJobStateTracks(struct soap *soap, struct tt__RecordingJobStateTracks *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__RecordingJobStateTracks(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__RecordingJobStateInformationExtension(struct soap *soap, struct tt__RecordingJobStateInformationExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__RecordingJobStateInformationExtension(struct soap *soap, const struct tt__RecordingJobStateInformationExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__RecordingJobStateInformationExtension(struct soap *soap, const char *tag, int id, const struct tt__RecordingJobStateInformationExtension *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__RecordingJobStateInformationExtension), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__RecordingJobStateInformationExtension * SOAP_FMAC4 soap_in_tt__RecordingJobStateInformationExtension(struct soap *soap, const char *tag, struct tt__RecordingJobStateInformationExtension *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__RecordingJobStateInformationExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RecordingJobStateInformationExtension, sizeof(struct tt__RecordingJobStateInformationExtension), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__RecordingJobStateInformationExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__RecordingJobStateInformationExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__RecordingJobStateInformationExtension, 0, sizeof(struct tt__RecordingJobStateInformationExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__RecordingJobStateInformationExtension(struct soap *soap, const struct tt__RecordingJobStateInformationExtension *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__RecordingJobStateInformationExtension);
	if (soap_out_tt__RecordingJobStateInformationExtension(soap, tag?tag:"tt:RecordingJobStateInformationExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__RecordingJobStateInformationExtension * SOAP_FMAC4 soap_get_tt__RecordingJobStateInformationExtension(struct soap *soap, struct tt__RecordingJobStateInformationExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__RecordingJobStateInformationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__RecordingJobStateSource(struct soap *soap, struct tt__RecordingJobStateSource *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->SourceToken = NULL;
	soap_default_tt__RecordingJobState(soap, &a->State);
	a->Tracks = NULL;
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__RecordingJobStateSource(struct soap *soap, const struct tt__RecordingJobStateSource *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTott__SourceReference(soap, &a->SourceToken);
	soap_serialize_tt__RecordingJobState(soap, &a->State);
	soap_serialize_PointerTott__RecordingJobStateTracks(soap, &a->Tracks);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__RecordingJobStateSource(struct soap *soap, const char *tag, int id, const struct tt__RecordingJobStateSource *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__RecordingJobStateSource), type))
		return soap->error;
	if (a->SourceToken)
	{	if (soap_out_PointerTott__SourceReference(soap, "tt:SourceToken", -1, &a->SourceToken, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:SourceToken"))
		return soap->error;
	if (a->State)
	{	if (soap_out_tt__RecordingJobState(soap, "tt:State", -1, &a->State, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:State"))
		return soap->error;
	if (a->Tracks)
	{	if (soap_out_PointerTott__RecordingJobStateTracks(soap, "tt:Tracks", -1, &a->Tracks, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:Tracks"))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__RecordingJobStateSource * SOAP_FMAC4 soap_in_tt__RecordingJobStateSource(struct soap *soap, const char *tag, struct tt__RecordingJobStateSource *a, const char *type)
{
	size_t soap_flag_SourceToken = 1;
	size_t soap_flag_State = 1;
	size_t soap_flag_Tracks = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__RecordingJobStateSource *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RecordingJobStateSource, sizeof(struct tt__RecordingJobStateSource), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__RecordingJobStateSource(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SourceToken && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__SourceReference(soap, "tt:SourceToken", &a->SourceToken, "tt:SourceReference"))
				{	soap_flag_SourceToken--;
					continue;
				}
			if (soap_flag_State && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__RecordingJobState(soap, "tt:State", &a->State, "tt:RecordingJobState"))
				{	soap_flag_State--;
					continue;
				}
			if (soap_flag_Tracks && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__RecordingJobStateTracks(soap, "tt:Tracks", &a->Tracks, "tt:RecordingJobStateTracks"))
				{	soap_flag_Tracks--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__RecordingJobStateSource *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__RecordingJobStateSource, 0, sizeof(struct tt__RecordingJobStateSource), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_SourceToken > 0 || soap_flag_State > 0 || soap_flag_Tracks > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__RecordingJobStateSource(struct soap *soap, const struct tt__RecordingJobStateSource *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__RecordingJobStateSource);
	if (soap_out_tt__RecordingJobStateSource(soap, tag?tag:"tt:RecordingJobStateSource", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__RecordingJobStateSource * SOAP_FMAC4 soap_get_tt__RecordingJobStateSource(struct soap *soap, struct tt__RecordingJobStateSource *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__RecordingJobStateSource(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__RecordingJobStateInformation(struct soap *soap, struct tt__RecordingJobStateInformation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__RecordingReference(soap, &a->RecordingToken);
	soap_default_tt__RecordingJobState(soap, &a->State);
	a->__sizeSources = 0;
	a->Sources = NULL;
	a->Extension = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__RecordingJobStateInformation(struct soap *soap, const struct tt__RecordingJobStateInformation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_tt__RecordingReference(soap, &a->RecordingToken);
	soap_serialize_tt__RecordingJobState(soap, &a->State);
	if (a->Sources)
	{	int i;
		for (i = 0; i < a->__sizeSources; i++)
		{
			soap_embedded(soap, a->Sources + i, SOAP_TYPE_tt__RecordingJobStateSource);
			soap_serialize_tt__RecordingJobStateSource(soap, a->Sources + i);
		}
	}
	soap_serialize_PointerTott__RecordingJobStateInformationExtension(soap, &a->Extension);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__RecordingJobStateInformation(struct soap *soap, const char *tag, int id, const struct tt__RecordingJobStateInformation *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__RecordingJobStateInformation), type))
		return soap->error;
	if (a->RecordingToken)
	{	if (soap_out_tt__RecordingReference(soap, "tt:RecordingToken", -1, &a->RecordingToken, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:RecordingToken"))
		return soap->error;
	if (a->State)
	{	if (soap_out_tt__RecordingJobState(soap, "tt:State", -1, &a->State, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:State"))
		return soap->error;
	if (a->Sources)
	{	int i;
		for (i = 0; i < a->__sizeSources; i++)
			if (soap_out_tt__RecordingJobStateSource(soap, "tt:Sources", -1, a->Sources + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTott__RecordingJobStateInformationExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__RecordingJobStateInformation * SOAP_FMAC4 soap_in_tt__RecordingJobStateInformation(struct soap *soap, const char *tag, struct tt__RecordingJobStateInformation *a, const char *type)
{
	size_t soap_flag_RecordingToken = 1;
	size_t soap_flag_State = 1;
	struct soap_blist *soap_blist_Sources = NULL;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__RecordingJobStateInformation *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RecordingJobStateInformation, sizeof(struct tt__RecordingJobStateInformation), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__RecordingJobStateInformation(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RecordingToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__RecordingReference(soap, "tt:RecordingToken", &a->RecordingToken, "tt:RecordingReference"))
				{	soap_flag_RecordingToken--;
					continue;
				}
			if (soap_flag_State && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__RecordingJobState(soap, "tt:State", &a->State, "tt:RecordingJobState"))
				{	soap_flag_State--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Sources", 1, NULL))
			{	if (a->Sources == NULL)
				{	if (soap_blist_Sources == NULL)
						soap_blist_Sources = soap_new_block(soap);
					a->Sources = (struct tt__RecordingJobStateSource *)soap_push_block(soap, soap_blist_Sources, sizeof(struct tt__RecordingJobStateSource));
					if (a->Sources == NULL)
						return NULL;
					soap_default_tt__RecordingJobStateSource(soap, a->Sources);
				}
				soap_revert(soap);
				if (soap_in_tt__RecordingJobStateSource(soap, "tt:Sources", a->Sources, "tt:RecordingJobStateSource"))
				{	a->__sizeSources++;
					a->Sources = NULL;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__RecordingJobStateInformationExtension(soap, "tt:Extension", &a->Extension, "tt:RecordingJobStateInformationExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Sources)
			soap_pop_block(soap, soap_blist_Sources);
		if (a->__sizeSources)
			a->Sources = (struct tt__RecordingJobStateSource *)soap_save_block(soap, soap_blist_Sources, NULL, 1);
		else
		{	a->Sources = NULL;
			if (soap_blist_Sources)
				soap_end_block(soap, soap_blist_Sources);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__RecordingJobStateInformation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__RecordingJobStateInformation, 0, sizeof(struct tt__RecordingJobStateInformation), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_RecordingToken > 0 || soap_flag_State > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__RecordingJobStateInformation(struct soap *soap, const struct tt__RecordingJobStateInformation *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__RecordingJobStateInformation);
	if (soap_out_tt__RecordingJobStateInformation(soap, tag?tag:"tt:RecordingJobStateInformation", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__RecordingJobStateInformation * SOAP_FMAC4 soap_get_tt__RecordingJobStateInformation(struct soap *soap, struct tt__RecordingJobStateInformation *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__RecordingJobStateInformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__RecordingJobSourceExtension(struct soap *soap, struct tt__RecordingJobSourceExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__RecordingJobSourceExtension(struct soap *soap, const struct tt__RecordingJobSourceExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__RecordingJobSourceExtension(struct soap *soap, const char *tag, int id, const struct tt__RecordingJobSourceExtension *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__RecordingJobSourceExtension), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__RecordingJobSourceExtension * SOAP_FMAC4 soap_in_tt__RecordingJobSourceExtension(struct soap *soap, const char *tag, struct tt__RecordingJobSourceExtension *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__RecordingJobSourceExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RecordingJobSourceExtension, sizeof(struct tt__RecordingJobSourceExtension), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__RecordingJobSourceExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__RecordingJobSourceExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__RecordingJobSourceExtension, 0, sizeof(struct tt__RecordingJobSourceExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__RecordingJobSourceExtension(struct soap *soap, const struct tt__RecordingJobSourceExtension *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__RecordingJobSourceExtension);
	if (soap_out_tt__RecordingJobSourceExtension(soap, tag?tag:"tt:RecordingJobSourceExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__RecordingJobSourceExtension * SOAP_FMAC4 soap_get_tt__RecordingJobSourceExtension(struct soap *soap, struct tt__RecordingJobSourceExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__RecordingJobSourceExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__RecordingJobTrack(struct soap *soap, struct tt__RecordingJobTrack *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->SourceTag);
	soap_default_tt__TrackReference(soap, &a->Destination);
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__RecordingJobTrack(struct soap *soap, const struct tt__RecordingJobTrack *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->SourceTag);
	soap_serialize_tt__TrackReference(soap, &a->Destination);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__RecordingJobTrack(struct soap *soap, const char *tag, int id, const struct tt__RecordingJobTrack *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__RecordingJobTrack), type))
		return soap->error;
	if (a->SourceTag)
	{	if (soap_out_string(soap, "tt:SourceTag", -1, &a->SourceTag, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:SourceTag"))
		return soap->error;
	if (a->Destination)
	{	if (soap_out_tt__TrackReference(soap, "tt:Destination", -1, &a->Destination, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:Destination"))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__RecordingJobTrack * SOAP_FMAC4 soap_in_tt__RecordingJobTrack(struct soap *soap, const char *tag, struct tt__RecordingJobTrack *a, const char *type)
{
	size_t soap_flag_SourceTag = 1;
	size_t soap_flag_Destination = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__RecordingJobTrack *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RecordingJobTrack, sizeof(struct tt__RecordingJobTrack), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__RecordingJobTrack(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SourceTag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "tt:SourceTag", &a->SourceTag, "xsd:string"))
				{	soap_flag_SourceTag--;
					continue;
				}
			if (soap_flag_Destination && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__TrackReference(soap, "tt:Destination", &a->Destination, "tt:TrackReference"))
				{	soap_flag_Destination--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__RecordingJobTrack *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__RecordingJobTrack, 0, sizeof(struct tt__RecordingJobTrack), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_SourceTag > 0 || soap_flag_Destination > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__RecordingJobTrack(struct soap *soap, const struct tt__RecordingJobTrack *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__RecordingJobTrack);
	if (soap_out_tt__RecordingJobTrack(soap, tag?tag:"tt:RecordingJobTrack", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__RecordingJobTrack * SOAP_FMAC4 soap_get_tt__RecordingJobTrack(struct soap *soap, struct tt__RecordingJobTrack *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__RecordingJobTrack(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__RecordingJobConfigurationExtension(struct soap *soap, struct tt__RecordingJobConfigurationExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__RecordingJobConfigurationExtension(struct soap *soap, const struct tt__RecordingJobConfigurationExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__RecordingJobConfigurationExtension(struct soap *soap, const char *tag, int id, const struct tt__RecordingJobConfigurationExtension *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__RecordingJobConfigurationExtension), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__RecordingJobConfigurationExtension * SOAP_FMAC4 soap_in_tt__RecordingJobConfigurationExtension(struct soap *soap, const char *tag, struct tt__RecordingJobConfigurationExtension *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__RecordingJobConfigurationExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RecordingJobConfigurationExtension, sizeof(struct tt__RecordingJobConfigurationExtension), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__RecordingJobConfigurationExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__RecordingJobConfigurationExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__RecordingJobConfigurationExtension, 0, sizeof(struct tt__RecordingJobConfigurationExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__RecordingJobConfigurationExtension(struct soap *soap, const struct tt__RecordingJobConfigurationExtension *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__RecordingJobConfigurationExtension);
	if (soap_out_tt__RecordingJobConfigurationExtension(soap, tag?tag:"tt:RecordingJobConfigurationExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__RecordingJobConfigurationExtension * SOAP_FMAC4 soap_get_tt__RecordingJobConfigurationExtension(struct soap *soap, struct tt__RecordingJobConfigurationExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__RecordingJobConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__RecordingJobSource(struct soap *soap, struct tt__RecordingJobSource *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->SourceToken = NULL;
	a->AutoCreateReceiver = NULL;
	a->__sizeTracks = 0;
	a->Tracks = NULL;
	a->Extension = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__RecordingJobSource(struct soap *soap, const struct tt__RecordingJobSource *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTott__SourceReference(soap, &a->SourceToken);
	soap_serialize_PointerToxsd__boolean_(soap, &a->AutoCreateReceiver);
	if (a->Tracks)
	{	int i;
		for (i = 0; i < a->__sizeTracks; i++)
		{
			soap_embedded(soap, a->Tracks + i, SOAP_TYPE_tt__RecordingJobTrack);
			soap_serialize_tt__RecordingJobTrack(soap, a->Tracks + i);
		}
	}
	soap_serialize_PointerTott__RecordingJobSourceExtension(soap, &a->Extension);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__RecordingJobSource(struct soap *soap, const char *tag, int id, const struct tt__RecordingJobSource *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__RecordingJobSource), type))
		return soap->error;
	if (soap_out_PointerTott__SourceReference(soap, "tt:SourceToken", -1, &a->SourceToken, ""))
		return soap->error;
	if (soap_out_PointerToxsd__boolean_(soap, "tt:AutoCreateReceiver", -1, &a->AutoCreateReceiver, ""))
		return soap->error;
	if (a->Tracks)
	{	int i;
		for (i = 0; i < a->__sizeTracks; i++)
			if (soap_out_tt__RecordingJobTrack(soap, "tt:Tracks", -1, a->Tracks + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTott__RecordingJobSourceExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__RecordingJobSource * SOAP_FMAC4 soap_in_tt__RecordingJobSource(struct soap *soap, const char *tag, struct tt__RecordingJobSource *a, const char *type)
{
	size_t soap_flag_SourceToken = 1;
	size_t soap_flag_AutoCreateReceiver = 1;
	struct soap_blist *soap_blist_Tracks = NULL;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__RecordingJobSource *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RecordingJobSource, sizeof(struct tt__RecordingJobSource), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__RecordingJobSource(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SourceToken && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__SourceReference(soap, "tt:SourceToken", &a->SourceToken, "tt:SourceReference"))
				{	soap_flag_SourceToken--;
					continue;
				}
			if (soap_flag_AutoCreateReceiver && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__boolean_(soap, "tt:AutoCreateReceiver", &a->AutoCreateReceiver, "xsd:boolean"))
				{	soap_flag_AutoCreateReceiver--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Tracks", 1, NULL))
			{	if (a->Tracks == NULL)
				{	if (soap_blist_Tracks == NULL)
						soap_blist_Tracks = soap_new_block(soap);
					a->Tracks = (struct tt__RecordingJobTrack *)soap_push_block(soap, soap_blist_Tracks, sizeof(struct tt__RecordingJobTrack));
					if (a->Tracks == NULL)
						return NULL;
					soap_default_tt__RecordingJobTrack(soap, a->Tracks);
				}
				soap_revert(soap);
				if (soap_in_tt__RecordingJobTrack(soap, "tt:Tracks", a->Tracks, "tt:RecordingJobTrack"))
				{	a->__sizeTracks++;
					a->Tracks = NULL;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__RecordingJobSourceExtension(soap, "tt:Extension", &a->Extension, "tt:RecordingJobSourceExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Tracks)
			soap_pop_block(soap, soap_blist_Tracks);
		if (a->__sizeTracks)
			a->Tracks = (struct tt__RecordingJobTrack *)soap_save_block(soap, soap_blist_Tracks, NULL, 1);
		else
		{	a->Tracks = NULL;
			if (soap_blist_Tracks)
				soap_end_block(soap, soap_blist_Tracks);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__RecordingJobSource *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__RecordingJobSource, 0, sizeof(struct tt__RecordingJobSource), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__RecordingJobSource(struct soap *soap, const struct tt__RecordingJobSource *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__RecordingJobSource);
	if (soap_out_tt__RecordingJobSource(soap, tag?tag:"tt:RecordingJobSource", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__RecordingJobSource * SOAP_FMAC4 soap_get_tt__RecordingJobSource(struct soap *soap, struct tt__RecordingJobSource *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__RecordingJobSource(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__RecordingJobConfiguration(struct soap *soap, struct tt__RecordingJobConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__RecordingReference(soap, &a->RecordingToken);
	soap_default_tt__RecordingJobMode(soap, &a->Mode);
	soap_default_int(soap, &a->Priority);
	a->__sizeSource = 0;
	a->Source = NULL;
	a->Extension = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__RecordingJobConfiguration(struct soap *soap, const struct tt__RecordingJobConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_tt__RecordingReference(soap, &a->RecordingToken);
	soap_serialize_tt__RecordingJobMode(soap, &a->Mode);
	soap_embedded(soap, &a->Priority, SOAP_TYPE_int);
	if (a->Source)
	{	int i;
		for (i = 0; i < a->__sizeSource; i++)
		{
			soap_embedded(soap, a->Source + i, SOAP_TYPE_tt__RecordingJobSource);
			soap_serialize_tt__RecordingJobSource(soap, a->Source + i);
		}
	}
	soap_serialize_PointerTott__RecordingJobConfigurationExtension(soap, &a->Extension);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__RecordingJobConfiguration(struct soap *soap, const char *tag, int id, const struct tt__RecordingJobConfiguration *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__RecordingJobConfiguration), type))
		return soap->error;
	if (a->RecordingToken)
	{	if (soap_out_tt__RecordingReference(soap, "tt:RecordingToken", -1, &a->RecordingToken, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:RecordingToken"))
		return soap->error;
	if (a->Mode)
	{	if (soap_out_tt__RecordingJobMode(soap, "tt:Mode", -1, &a->Mode, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:Mode"))
		return soap->error;
	if (soap_out_int(soap, "tt:Priority", -1, &a->Priority, ""))
		return soap->error;
	if (a->Source)
	{	int i;
		for (i = 0; i < a->__sizeSource; i++)
			if (soap_out_tt__RecordingJobSource(soap, "tt:Source", -1, a->Source + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTott__RecordingJobConfigurationExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__RecordingJobConfiguration * SOAP_FMAC4 soap_in_tt__RecordingJobConfiguration(struct soap *soap, const char *tag, struct tt__RecordingJobConfiguration *a, const char *type)
{
	size_t soap_flag_RecordingToken = 1;
	size_t soap_flag_Mode = 1;
	size_t soap_flag_Priority = 1;
	struct soap_blist *soap_blist_Source = NULL;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__RecordingJobConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RecordingJobConfiguration, sizeof(struct tt__RecordingJobConfiguration), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__RecordingJobConfiguration(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RecordingToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__RecordingReference(soap, "tt:RecordingToken", &a->RecordingToken, "tt:RecordingReference"))
				{	soap_flag_RecordingToken--;
					continue;
				}
			if (soap_flag_Mode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__RecordingJobMode(soap, "tt:Mode", &a->Mode, "tt:RecordingJobMode"))
				{	soap_flag_Mode--;
					continue;
				}
			if (soap_flag_Priority && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "tt:Priority", &a->Priority, "xsd:int"))
				{	soap_flag_Priority--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Source", 1, NULL))
			{	if (a->Source == NULL)
				{	if (soap_blist_Source == NULL)
						soap_blist_Source = soap_new_block(soap);
					a->Source = (struct tt__RecordingJobSource *)soap_push_block(soap, soap_blist_Source, sizeof(struct tt__RecordingJobSource));
					if (a->Source == NULL)
						return NULL;
					soap_default_tt__RecordingJobSource(soap, a->Source);
				}
				soap_revert(soap);
				if (soap_in_tt__RecordingJobSource(soap, "tt:Source", a->Source, "tt:RecordingJobSource"))
				{	a->__sizeSource++;
					a->Source = NULL;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__RecordingJobConfigurationExtension(soap, "tt:Extension", &a->Extension, "tt:RecordingJobConfigurationExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Source)
			soap_pop_block(soap, soap_blist_Source);
		if (a->__sizeSource)
			a->Source = (struct tt__RecordingJobSource *)soap_save_block(soap, soap_blist_Source, NULL, 1);
		else
		{	a->Source = NULL;
			if (soap_blist_Source)
				soap_end_block(soap, soap_blist_Source);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__RecordingJobConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__RecordingJobConfiguration, 0, sizeof(struct tt__RecordingJobConfiguration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_RecordingToken > 0 || soap_flag_Mode > 0 || soap_flag_Priority > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__RecordingJobConfiguration(struct soap *soap, const struct tt__RecordingJobConfiguration *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__RecordingJobConfiguration);
	if (soap_out_tt__RecordingJobConfiguration(soap, tag?tag:"tt:RecordingJobConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__RecordingJobConfiguration * SOAP_FMAC4 soap_get_tt__RecordingJobConfiguration(struct soap *soap, struct tt__RecordingJobConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__RecordingJobConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__GetTracksResponseItem(struct soap *soap, struct tt__GetTracksResponseItem *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__TrackReference(soap, &a->TrackToken);
	a->Configuration = NULL;
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__GetTracksResponseItem(struct soap *soap, const struct tt__GetTracksResponseItem *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_tt__TrackReference(soap, &a->TrackToken);
	soap_serialize_PointerTott__TrackConfiguration(soap, &a->Configuration);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__GetTracksResponseItem(struct soap *soap, const char *tag, int id, const struct tt__GetTracksResponseItem *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__GetTracksResponseItem), type))
		return soap->error;
	if (a->TrackToken)
	{	if (soap_out_tt__TrackReference(soap, "tt:TrackToken", -1, &a->TrackToken, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:TrackToken"))
		return soap->error;
	if (a->Configuration)
	{	if (soap_out_PointerTott__TrackConfiguration(soap, "tt:Configuration", -1, &a->Configuration, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:Configuration"))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__GetTracksResponseItem * SOAP_FMAC4 soap_in_tt__GetTracksResponseItem(struct soap *soap, const char *tag, struct tt__GetTracksResponseItem *a, const char *type)
{
	size_t soap_flag_TrackToken = 1;
	size_t soap_flag_Configuration = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__GetTracksResponseItem *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__GetTracksResponseItem, sizeof(struct tt__GetTracksResponseItem), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__GetTracksResponseItem(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_TrackToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__TrackReference(soap, "tt:TrackToken", &a->TrackToken, "tt:TrackReference"))
				{	soap_flag_TrackToken--;
					continue;
				}
			if (soap_flag_Configuration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__TrackConfiguration(soap, "tt:Configuration", &a->Configuration, "tt:TrackConfiguration"))
				{	soap_flag_Configuration--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__GetTracksResponseItem *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__GetTracksResponseItem, 0, sizeof(struct tt__GetTracksResponseItem), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_TrackToken > 0 || soap_flag_Configuration > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__GetTracksResponseItem(struct soap *soap, const struct tt__GetTracksResponseItem *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__GetTracksResponseItem);
	if (soap_out_tt__GetTracksResponseItem(soap, tag?tag:"tt:GetTracksResponseItem", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__GetTracksResponseItem * SOAP_FMAC4 soap_get_tt__GetTracksResponseItem(struct soap *soap, struct tt__GetTracksResponseItem *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__GetTracksResponseItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__GetTracksResponseList(struct soap *soap, struct tt__GetTracksResponseList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeTrack = 0;
	a->Track = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__GetTracksResponseList(struct soap *soap, const struct tt__GetTracksResponseList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->Track)
	{	int i;
		for (i = 0; i < a->__sizeTrack; i++)
		{
			soap_embedded(soap, a->Track + i, SOAP_TYPE_tt__GetTracksResponseItem);
			soap_serialize_tt__GetTracksResponseItem(soap, a->Track + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__GetTracksResponseList(struct soap *soap, const char *tag, int id, const struct tt__GetTracksResponseList *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__GetTracksResponseList), type))
		return soap->error;
	if (a->Track)
	{	int i;
		for (i = 0; i < a->__sizeTrack; i++)
			if (soap_out_tt__GetTracksResponseItem(soap, "tt:Track", -1, a->Track + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__GetTracksResponseList * SOAP_FMAC4 soap_in_tt__GetTracksResponseList(struct soap *soap, const char *tag, struct tt__GetTracksResponseList *a, const char *type)
{
	struct soap_blist *soap_blist_Track = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__GetTracksResponseList *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__GetTracksResponseList, sizeof(struct tt__GetTracksResponseList), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__GetTracksResponseList(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Track", 1, NULL))
			{	if (a->Track == NULL)
				{	if (soap_blist_Track == NULL)
						soap_blist_Track = soap_new_block(soap);
					a->Track = (struct tt__GetTracksResponseItem *)soap_push_block(soap, soap_blist_Track, sizeof(struct tt__GetTracksResponseItem));
					if (a->Track == NULL)
						return NULL;
					soap_default_tt__GetTracksResponseItem(soap, a->Track);
				}
				soap_revert(soap);
				if (soap_in_tt__GetTracksResponseItem(soap, "tt:Track", a->Track, "tt:GetTracksResponseItem"))
				{	a->__sizeTrack++;
					a->Track = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Track)
			soap_pop_block(soap, soap_blist_Track);
		if (a->__sizeTrack)
			a->Track = (struct tt__GetTracksResponseItem *)soap_save_block(soap, soap_blist_Track, NULL, 1);
		else
		{	a->Track = NULL;
			if (soap_blist_Track)
				soap_end_block(soap, soap_blist_Track);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__GetTracksResponseList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__GetTracksResponseList, 0, sizeof(struct tt__GetTracksResponseList), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__GetTracksResponseList(struct soap *soap, const struct tt__GetTracksResponseList *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__GetTracksResponseList);
	if (soap_out_tt__GetTracksResponseList(soap, tag?tag:"tt:GetTracksResponseList", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__GetTracksResponseList * SOAP_FMAC4 soap_get_tt__GetTracksResponseList(struct soap *soap, struct tt__GetTracksResponseList *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__GetTracksResponseList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__GetRecordingsResponseItem(struct soap *soap, struct tt__GetRecordingsResponseItem *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__RecordingReference(soap, &a->RecordingToken);
	a->Configuration = NULL;
	a->Tracks = NULL;
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__GetRecordingsResponseItem(struct soap *soap, const struct tt__GetRecordingsResponseItem *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_tt__RecordingReference(soap, &a->RecordingToken);
	soap_serialize_PointerTott__RecordingConfiguration(soap, &a->Configuration);
	soap_serialize_PointerTott__GetTracksResponseList(soap, &a->Tracks);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__GetRecordingsResponseItem(struct soap *soap, const char *tag, int id, const struct tt__GetRecordingsResponseItem *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__GetRecordingsResponseItem), type))
		return soap->error;
	if (a->RecordingToken)
	{	if (soap_out_tt__RecordingReference(soap, "tt:RecordingToken", -1, &a->RecordingToken, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:RecordingToken"))
		return soap->error;
	if (a->Configuration)
	{	if (soap_out_PointerTott__RecordingConfiguration(soap, "tt:Configuration", -1, &a->Configuration, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:Configuration"))
		return soap->error;
	if (a->Tracks)
	{	if (soap_out_PointerTott__GetTracksResponseList(soap, "tt:Tracks", -1, &a->Tracks, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:Tracks"))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__GetRecordingsResponseItem * SOAP_FMAC4 soap_in_tt__GetRecordingsResponseItem(struct soap *soap, const char *tag, struct tt__GetRecordingsResponseItem *a, const char *type)
{
	size_t soap_flag_RecordingToken = 1;
	size_t soap_flag_Configuration = 1;
	size_t soap_flag_Tracks = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__GetRecordingsResponseItem *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__GetRecordingsResponseItem, sizeof(struct tt__GetRecordingsResponseItem), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__GetRecordingsResponseItem(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RecordingToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__RecordingReference(soap, "tt:RecordingToken", &a->RecordingToken, "tt:RecordingReference"))
				{	soap_flag_RecordingToken--;
					continue;
				}
			if (soap_flag_Configuration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__RecordingConfiguration(soap, "tt:Configuration", &a->Configuration, "tt:RecordingConfiguration"))
				{	soap_flag_Configuration--;
					continue;
				}
			if (soap_flag_Tracks && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__GetTracksResponseList(soap, "tt:Tracks", &a->Tracks, "tt:GetTracksResponseList"))
				{	soap_flag_Tracks--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__GetRecordingsResponseItem *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__GetRecordingsResponseItem, 0, sizeof(struct tt__GetRecordingsResponseItem), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_RecordingToken > 0 || soap_flag_Configuration > 0 || soap_flag_Tracks > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__GetRecordingsResponseItem(struct soap *soap, const struct tt__GetRecordingsResponseItem *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__GetRecordingsResponseItem);
	if (soap_out_tt__GetRecordingsResponseItem(soap, tag?tag:"tt:GetRecordingsResponseItem", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__GetRecordingsResponseItem * SOAP_FMAC4 soap_get_tt__GetRecordingsResponseItem(struct soap *soap, struct tt__GetRecordingsResponseItem *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__GetRecordingsResponseItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__TrackConfiguration(struct soap *soap, struct tt__TrackConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__TrackType(soap, &a->TrackType);
	soap_default_tt__Description(soap, &a->Description);
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__TrackConfiguration(struct soap *soap, const struct tt__TrackConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_tt__Description(soap, &a->Description);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__TrackConfiguration(struct soap *soap, const char *tag, int id, const struct tt__TrackConfiguration *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__TrackConfiguration), type))
		return soap->error;
	if (soap_out_tt__TrackType(soap, "tt:TrackType", -1, &a->TrackType, ""))
		return soap->error;
	if (a->Description)
	{	if (soap_out_tt__Description(soap, "tt:Description", -1, &a->Description, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:Description"))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__TrackConfiguration * SOAP_FMAC4 soap_in_tt__TrackConfiguration(struct soap *soap, const char *tag, struct tt__TrackConfiguration *a, const char *type)
{
	size_t soap_flag_TrackType = 1;
	size_t soap_flag_Description = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__TrackConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__TrackConfiguration, sizeof(struct tt__TrackConfiguration), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__TrackConfiguration(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_TrackType && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_tt__TrackType(soap, "tt:TrackType", &a->TrackType, "tt:TrackType"))
				{	soap_flag_TrackType--;
					continue;
				}
			if (soap_flag_Description && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__Description(soap, "tt:Description", &a->Description, "tt:Description"))
				{	soap_flag_Description--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__TrackConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__TrackConfiguration, 0, sizeof(struct tt__TrackConfiguration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_TrackType > 0 || soap_flag_Description > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__TrackConfiguration(struct soap *soap, const struct tt__TrackConfiguration *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__TrackConfiguration);
	if (soap_out_tt__TrackConfiguration(soap, tag?tag:"tt:TrackConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__TrackConfiguration * SOAP_FMAC4 soap_get_tt__TrackConfiguration(struct soap *soap, struct tt__TrackConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__TrackConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__RecordingConfiguration(struct soap *soap, struct tt__RecordingConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Source = NULL;
	soap_default_tt__Description(soap, &a->Content);
	soap_default_string(soap, &a->MaximumRetentionTime);
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__RecordingConfiguration(struct soap *soap, const struct tt__RecordingConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTott__RecordingSourceInformation(soap, &a->Source);
	soap_serialize_tt__Description(soap, &a->Content);
	soap_serialize_string(soap, &a->MaximumRetentionTime);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__RecordingConfiguration(struct soap *soap, const char *tag, int id, const struct tt__RecordingConfiguration *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__RecordingConfiguration), type))
		return soap->error;
	if (a->Source)
	{	if (soap_out_PointerTott__RecordingSourceInformation(soap, "tt:Source", -1, &a->Source, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:Source"))
		return soap->error;
	if (a->Content)
	{	if (soap_out_tt__Description(soap, "tt:Content", -1, &a->Content, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:Content"))
		return soap->error;
	if (a->MaximumRetentionTime)
	{	if (soap_out_string(soap, "tt:MaximumRetentionTime", -1, &a->MaximumRetentionTime, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:MaximumRetentionTime"))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__RecordingConfiguration * SOAP_FMAC4 soap_in_tt__RecordingConfiguration(struct soap *soap, const char *tag, struct tt__RecordingConfiguration *a, const char *type)
{
	size_t soap_flag_Source = 1;
	size_t soap_flag_Content = 1;
	size_t soap_flag_MaximumRetentionTime = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__RecordingConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RecordingConfiguration, sizeof(struct tt__RecordingConfiguration), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__RecordingConfiguration(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Source && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__RecordingSourceInformation(soap, "tt:Source", &a->Source, "tt:RecordingSourceInformation"))
				{	soap_flag_Source--;
					continue;
				}
			if (soap_flag_Content && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__Description(soap, "tt:Content", &a->Content, "tt:Description"))
				{	soap_flag_Content--;
					continue;
				}
			if (soap_flag_MaximumRetentionTime && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "tt:MaximumRetentionTime", &a->MaximumRetentionTime, "xsd:string"))
				{	soap_flag_MaximumRetentionTime--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__RecordingConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__RecordingConfiguration, 0, sizeof(struct tt__RecordingConfiguration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Source > 0 || soap_flag_Content > 0 || soap_flag_MaximumRetentionTime > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__RecordingConfiguration(struct soap *soap, const struct tt__RecordingConfiguration *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__RecordingConfiguration);
	if (soap_out_tt__RecordingConfiguration(soap, tag?tag:"tt:RecordingConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__RecordingConfiguration * SOAP_FMAC4 soap_get_tt__RecordingConfiguration(struct soap *soap, struct tt__RecordingConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__RecordingConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__TrackAttributesExtension(struct soap *soap, struct tt__TrackAttributesExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__TrackAttributesExtension(struct soap *soap, const struct tt__TrackAttributesExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__TrackAttributesExtension(struct soap *soap, const char *tag, int id, const struct tt__TrackAttributesExtension *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__TrackAttributesExtension), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__TrackAttributesExtension * SOAP_FMAC4 soap_in_tt__TrackAttributesExtension(struct soap *soap, const char *tag, struct tt__TrackAttributesExtension *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__TrackAttributesExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__TrackAttributesExtension, sizeof(struct tt__TrackAttributesExtension), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__TrackAttributesExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__TrackAttributesExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__TrackAttributesExtension, 0, sizeof(struct tt__TrackAttributesExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__TrackAttributesExtension(struct soap *soap, const struct tt__TrackAttributesExtension *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__TrackAttributesExtension);
	if (soap_out_tt__TrackAttributesExtension(soap, tag?tag:"tt:TrackAttributesExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__TrackAttributesExtension * SOAP_FMAC4 soap_get_tt__TrackAttributesExtension(struct soap *soap, struct tt__TrackAttributesExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__TrackAttributesExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__MetadataAttributes(struct soap *soap, struct tt__MetadataAttributes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__boolean_(soap, &a->CanContainPTZ);
	soap_default_xsd__boolean_(soap, &a->CanContainAnalytics);
	soap_default_xsd__boolean_(soap, &a->CanContainNotifications);
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__MetadataAttributes(struct soap *soap, const struct tt__MetadataAttributes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->CanContainPTZ, SOAP_TYPE_xsd__boolean_);
	soap_embedded(soap, &a->CanContainAnalytics, SOAP_TYPE_xsd__boolean_);
	soap_embedded(soap, &a->CanContainNotifications, SOAP_TYPE_xsd__boolean_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__MetadataAttributes(struct soap *soap, const char *tag, int id, const struct tt__MetadataAttributes *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__MetadataAttributes), type))
		return soap->error;
	if (soap_out_xsd__boolean_(soap, "tt:CanContainPTZ", -1, &a->CanContainPTZ, ""))
		return soap->error;
	if (soap_out_xsd__boolean_(soap, "tt:CanContainAnalytics", -1, &a->CanContainAnalytics, ""))
		return soap->error;
	if (soap_out_xsd__boolean_(soap, "tt:CanContainNotifications", -1, &a->CanContainNotifications, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__MetadataAttributes * SOAP_FMAC4 soap_in_tt__MetadataAttributes(struct soap *soap, const char *tag, struct tt__MetadataAttributes *a, const char *type)
{
	size_t soap_flag_CanContainPTZ = 1;
	size_t soap_flag_CanContainAnalytics = 1;
	size_t soap_flag_CanContainNotifications = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__MetadataAttributes *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__MetadataAttributes, sizeof(struct tt__MetadataAttributes), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__MetadataAttributes(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CanContainPTZ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean_(soap, "tt:CanContainPTZ", &a->CanContainPTZ, "xsd:boolean"))
				{	soap_flag_CanContainPTZ--;
					continue;
				}
			if (soap_flag_CanContainAnalytics && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean_(soap, "tt:CanContainAnalytics", &a->CanContainAnalytics, "xsd:boolean"))
				{	soap_flag_CanContainAnalytics--;
					continue;
				}
			if (soap_flag_CanContainNotifications && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean_(soap, "tt:CanContainNotifications", &a->CanContainNotifications, "xsd:boolean"))
				{	soap_flag_CanContainNotifications--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__MetadataAttributes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__MetadataAttributes, 0, sizeof(struct tt__MetadataAttributes), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_CanContainPTZ > 0 || soap_flag_CanContainAnalytics > 0 || soap_flag_CanContainNotifications > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__MetadataAttributes(struct soap *soap, const struct tt__MetadataAttributes *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__MetadataAttributes);
	if (soap_out_tt__MetadataAttributes(soap, tag?tag:"tt:MetadataAttributes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__MetadataAttributes * SOAP_FMAC4 soap_get_tt__MetadataAttributes(struct soap *soap, struct tt__MetadataAttributes *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__MetadataAttributes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__AudioAttributes(struct soap *soap, struct tt__AudioAttributes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Bitrate = NULL;
	soap_default_tt__AudioEncoding(soap, &a->Encoding);
	soap_default_int(soap, &a->Samplerate);
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__AudioAttributes(struct soap *soap, const struct tt__AudioAttributes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToint(soap, &a->Bitrate);
	soap_embedded(soap, &a->Samplerate, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AudioAttributes(struct soap *soap, const char *tag, int id, const struct tt__AudioAttributes *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AudioAttributes), type))
		return soap->error;
	if (soap_out_PointerToint(soap, "tt:Bitrate", -1, &a->Bitrate, ""))
		return soap->error;
	if (soap_out_tt__AudioEncoding(soap, "tt:Encoding", -1, &a->Encoding, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:Samplerate", -1, &a->Samplerate, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__AudioAttributes * SOAP_FMAC4 soap_in_tt__AudioAttributes(struct soap *soap, const char *tag, struct tt__AudioAttributes *a, const char *type)
{
	size_t soap_flag_Bitrate = 1;
	size_t soap_flag_Encoding = 1;
	size_t soap_flag_Samplerate = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__AudioAttributes *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AudioAttributes, sizeof(struct tt__AudioAttributes), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__AudioAttributes(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Bitrate && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "tt:Bitrate", &a->Bitrate, "xsd:int"))
				{	soap_flag_Bitrate--;
					continue;
				}
			if (soap_flag_Encoding && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_tt__AudioEncoding(soap, "tt:Encoding", &a->Encoding, "tt:AudioEncoding"))
				{	soap_flag_Encoding--;
					continue;
				}
			if (soap_flag_Samplerate && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "tt:Samplerate", &a->Samplerate, "xsd:int"))
				{	soap_flag_Samplerate--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__AudioAttributes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AudioAttributes, 0, sizeof(struct tt__AudioAttributes), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Encoding > 0 || soap_flag_Samplerate > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__AudioAttributes(struct soap *soap, const struct tt__AudioAttributes *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__AudioAttributes);
	if (soap_out_tt__AudioAttributes(soap, tag?tag:"tt:AudioAttributes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AudioAttributes * SOAP_FMAC4 soap_get_tt__AudioAttributes(struct soap *soap, struct tt__AudioAttributes *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AudioAttributes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__VideoAttributes(struct soap *soap, struct tt__VideoAttributes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Bitrate = NULL;
	soap_default_int(soap, &a->Width);
	soap_default_int(soap, &a->Height);
	soap_default_tt__VideoEncoding(soap, &a->Encoding);
	soap_default_float(soap, &a->Framerate);
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__VideoAttributes(struct soap *soap, const struct tt__VideoAttributes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToint(soap, &a->Bitrate);
	soap_embedded(soap, &a->Width, SOAP_TYPE_int);
	soap_embedded(soap, &a->Height, SOAP_TYPE_int);
	soap_embedded(soap, &a->Framerate, SOAP_TYPE_float);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__VideoAttributes(struct soap *soap, const char *tag, int id, const struct tt__VideoAttributes *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__VideoAttributes), type))
		return soap->error;
	if (soap_out_PointerToint(soap, "tt:Bitrate", -1, &a->Bitrate, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:Width", -1, &a->Width, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:Height", -1, &a->Height, ""))
		return soap->error;
	if (soap_out_tt__VideoEncoding(soap, "tt:Encoding", -1, &a->Encoding, ""))
		return soap->error;
	if (soap_out_float(soap, "tt:Framerate", -1, &a->Framerate, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__VideoAttributes * SOAP_FMAC4 soap_in_tt__VideoAttributes(struct soap *soap, const char *tag, struct tt__VideoAttributes *a, const char *type)
{
	size_t soap_flag_Bitrate = 1;
	size_t soap_flag_Width = 1;
	size_t soap_flag_Height = 1;
	size_t soap_flag_Encoding = 1;
	size_t soap_flag_Framerate = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__VideoAttributes *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__VideoAttributes, sizeof(struct tt__VideoAttributes), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__VideoAttributes(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Bitrate && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "tt:Bitrate", &a->Bitrate, "xsd:int"))
				{	soap_flag_Bitrate--;
					continue;
				}
			if (soap_flag_Width && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "tt:Width", &a->Width, "xsd:int"))
				{	soap_flag_Width--;
					continue;
				}
			if (soap_flag_Height && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "tt:Height", &a->Height, "xsd:int"))
				{	soap_flag_Height--;
					continue;
				}
			if (soap_flag_Encoding && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_tt__VideoEncoding(soap, "tt:Encoding", &a->Encoding, "tt:VideoEncoding"))
				{	soap_flag_Encoding--;
					continue;
				}
			if (soap_flag_Framerate && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_float(soap, "tt:Framerate", &a->Framerate, "xsd:float"))
				{	soap_flag_Framerate--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__VideoAttributes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__VideoAttributes, 0, sizeof(struct tt__VideoAttributes), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Width > 0 || soap_flag_Height > 0 || soap_flag_Encoding > 0 || soap_flag_Framerate > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__VideoAttributes(struct soap *soap, const struct tt__VideoAttributes *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__VideoAttributes);
	if (soap_out_tt__VideoAttributes(soap, tag?tag:"tt:VideoAttributes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__VideoAttributes * SOAP_FMAC4 soap_get_tt__VideoAttributes(struct soap *soap, struct tt__VideoAttributes *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__VideoAttributes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__TrackAttributes(struct soap *soap, struct tt__TrackAttributes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->TrackInformation = NULL;
	a->VideoAttributes = NULL;
	a->AudioAttributes = NULL;
	a->MetadataAttributes = NULL;
	a->Extension = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__TrackAttributes(struct soap *soap, const struct tt__TrackAttributes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTott__TrackInformation(soap, &a->TrackInformation);
	soap_serialize_PointerTott__VideoAttributes(soap, &a->VideoAttributes);
	soap_serialize_PointerTott__AudioAttributes(soap, &a->AudioAttributes);
	soap_serialize_PointerTott__MetadataAttributes(soap, &a->MetadataAttributes);
	soap_serialize_PointerTott__TrackAttributesExtension(soap, &a->Extension);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__TrackAttributes(struct soap *soap, const char *tag, int id, const struct tt__TrackAttributes *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__TrackAttributes), type))
		return soap->error;
	if (a->TrackInformation)
	{	if (soap_out_PointerTott__TrackInformation(soap, "tt:TrackInformation", -1, &a->TrackInformation, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:TrackInformation"))
		return soap->error;
	if (soap_out_PointerTott__VideoAttributes(soap, "tt:VideoAttributes", -1, &a->VideoAttributes, ""))
		return soap->error;
	if (soap_out_PointerTott__AudioAttributes(soap, "tt:AudioAttributes", -1, &a->AudioAttributes, ""))
		return soap->error;
	if (soap_out_PointerTott__MetadataAttributes(soap, "tt:MetadataAttributes", -1, &a->MetadataAttributes, ""))
		return soap->error;
	if (soap_out_PointerTott__TrackAttributesExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__TrackAttributes * SOAP_FMAC4 soap_in_tt__TrackAttributes(struct soap *soap, const char *tag, struct tt__TrackAttributes *a, const char *type)
{
	size_t soap_flag_TrackInformation = 1;
	size_t soap_flag_VideoAttributes = 1;
	size_t soap_flag_AudioAttributes = 1;
	size_t soap_flag_MetadataAttributes = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__TrackAttributes *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__TrackAttributes, sizeof(struct tt__TrackAttributes), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__TrackAttributes(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_TrackInformation && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__TrackInformation(soap, "tt:TrackInformation", &a->TrackInformation, "tt:TrackInformation"))
				{	soap_flag_TrackInformation--;
					continue;
				}
			if (soap_flag_VideoAttributes && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__VideoAttributes(soap, "tt:VideoAttributes", &a->VideoAttributes, "tt:VideoAttributes"))
				{	soap_flag_VideoAttributes--;
					continue;
				}
			if (soap_flag_AudioAttributes && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__AudioAttributes(soap, "tt:AudioAttributes", &a->AudioAttributes, "tt:AudioAttributes"))
				{	soap_flag_AudioAttributes--;
					continue;
				}
			if (soap_flag_MetadataAttributes && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__MetadataAttributes(soap, "tt:MetadataAttributes", &a->MetadataAttributes, "tt:MetadataAttributes"))
				{	soap_flag_MetadataAttributes--;
					continue;
				}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__TrackAttributesExtension(soap, "tt:Extension", &a->Extension, "tt:TrackAttributesExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__TrackAttributes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__TrackAttributes, 0, sizeof(struct tt__TrackAttributes), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_TrackInformation > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__TrackAttributes(struct soap *soap, const struct tt__TrackAttributes *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__TrackAttributes);
	if (soap_out_tt__TrackAttributes(soap, tag?tag:"tt:TrackAttributes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__TrackAttributes * SOAP_FMAC4 soap_get_tt__TrackAttributes(struct soap *soap, struct tt__TrackAttributes *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__TrackAttributes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__MediaAttributes(struct soap *soap, struct tt__MediaAttributes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__RecordingReference(soap, &a->RecordingToken);
	a->__sizeTrackAttributes = 0;
	a->TrackAttributes = NULL;
	soap_default_time(soap, &a->From);
	soap_default_time(soap, &a->Until);
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__MediaAttributes(struct soap *soap, const struct tt__MediaAttributes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_tt__RecordingReference(soap, &a->RecordingToken);
	if (a->TrackAttributes)
	{	int i;
		for (i = 0; i < a->__sizeTrackAttributes; i++)
		{
			soap_embedded(soap, a->TrackAttributes + i, SOAP_TYPE_tt__TrackAttributes);
			soap_serialize_tt__TrackAttributes(soap, a->TrackAttributes + i);
		}
	}
	soap_embedded(soap, &a->From, SOAP_TYPE_time);
	soap_embedded(soap, &a->Until, SOAP_TYPE_time);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__MediaAttributes(struct soap *soap, const char *tag, int id, const struct tt__MediaAttributes *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__MediaAttributes), type))
		return soap->error;
	if (a->RecordingToken)
	{	if (soap_out_tt__RecordingReference(soap, "tt:RecordingToken", -1, &a->RecordingToken, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:RecordingToken"))
		return soap->error;
	if (a->TrackAttributes)
	{	int i;
		for (i = 0; i < a->__sizeTrackAttributes; i++)
			if (soap_out_tt__TrackAttributes(soap, "tt:TrackAttributes", -1, a->TrackAttributes + i, ""))
				return soap->error;
	}
	if (soap_out_time(soap, "tt:From", -1, &a->From, ""))
		return soap->error;
	if (soap_out_time(soap, "tt:Until", -1, &a->Until, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__MediaAttributes * SOAP_FMAC4 soap_in_tt__MediaAttributes(struct soap *soap, const char *tag, struct tt__MediaAttributes *a, const char *type)
{
	size_t soap_flag_RecordingToken = 1;
	struct soap_blist *soap_blist_TrackAttributes = NULL;
	size_t soap_flag_From = 1;
	size_t soap_flag_Until = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__MediaAttributes *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__MediaAttributes, sizeof(struct tt__MediaAttributes), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__MediaAttributes(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RecordingToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__RecordingReference(soap, "tt:RecordingToken", &a->RecordingToken, "tt:RecordingReference"))
				{	soap_flag_RecordingToken--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:TrackAttributes", 1, NULL))
			{	if (a->TrackAttributes == NULL)
				{	if (soap_blist_TrackAttributes == NULL)
						soap_blist_TrackAttributes = soap_new_block(soap);
					a->TrackAttributes = (struct tt__TrackAttributes *)soap_push_block(soap, soap_blist_TrackAttributes, sizeof(struct tt__TrackAttributes));
					if (a->TrackAttributes == NULL)
						return NULL;
					soap_default_tt__TrackAttributes(soap, a->TrackAttributes);
				}
				soap_revert(soap);
				if (soap_in_tt__TrackAttributes(soap, "tt:TrackAttributes", a->TrackAttributes, "tt:TrackAttributes"))
				{	a->__sizeTrackAttributes++;
					a->TrackAttributes = NULL;
					continue;
				}
			}
			if (soap_flag_From && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "tt:From", &a->From, "xsd:dateTime"))
				{	soap_flag_From--;
					continue;
				}
			if (soap_flag_Until && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "tt:Until", &a->Until, "xsd:dateTime"))
				{	soap_flag_Until--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->TrackAttributes)
			soap_pop_block(soap, soap_blist_TrackAttributes);
		if (a->__sizeTrackAttributes)
			a->TrackAttributes = (struct tt__TrackAttributes *)soap_save_block(soap, soap_blist_TrackAttributes, NULL, 1);
		else
		{	a->TrackAttributes = NULL;
			if (soap_blist_TrackAttributes)
				soap_end_block(soap, soap_blist_TrackAttributes);
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__MediaAttributes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__MediaAttributes, 0, sizeof(struct tt__MediaAttributes), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_RecordingToken > 0 || soap_flag_From > 0 || soap_flag_Until > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__MediaAttributes(struct soap *soap, const struct tt__MediaAttributes *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__MediaAttributes);
	if (soap_out_tt__MediaAttributes(soap, tag?tag:"tt:MediaAttributes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__MediaAttributes * SOAP_FMAC4 soap_get_tt__MediaAttributes(struct soap *soap, struct tt__MediaAttributes *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__MediaAttributes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__TrackInformation(struct soap *soap, struct tt__TrackInformation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__TrackReference(soap, &a->TrackToken);
	soap_default_tt__TrackType(soap, &a->TrackType);
	soap_default_tt__Description(soap, &a->Description);
	soap_default_time(soap, &a->DataFrom);
	soap_default_time(soap, &a->DataTo);
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__TrackInformation(struct soap *soap, const struct tt__TrackInformation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_tt__TrackReference(soap, &a->TrackToken);
	soap_serialize_tt__Description(soap, &a->Description);
	soap_embedded(soap, &a->DataFrom, SOAP_TYPE_time);
	soap_embedded(soap, &a->DataTo, SOAP_TYPE_time);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__TrackInformation(struct soap *soap, const char *tag, int id, const struct tt__TrackInformation *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__TrackInformation), type))
		return soap->error;
	if (a->TrackToken)
	{	if (soap_out_tt__TrackReference(soap, "tt:TrackToken", -1, &a->TrackToken, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:TrackToken"))
		return soap->error;
	if (soap_out_tt__TrackType(soap, "tt:TrackType", -1, &a->TrackType, ""))
		return soap->error;
	if (a->Description)
	{	if (soap_out_tt__Description(soap, "tt:Description", -1, &a->Description, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:Description"))
		return soap->error;
	if (soap_out_time(soap, "tt:DataFrom", -1, &a->DataFrom, ""))
		return soap->error;
	if (soap_out_time(soap, "tt:DataTo", -1, &a->DataTo, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__TrackInformation * SOAP_FMAC4 soap_in_tt__TrackInformation(struct soap *soap, const char *tag, struct tt__TrackInformation *a, const char *type)
{
	size_t soap_flag_TrackToken = 1;
	size_t soap_flag_TrackType = 1;
	size_t soap_flag_Description = 1;
	size_t soap_flag_DataFrom = 1;
	size_t soap_flag_DataTo = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__TrackInformation *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__TrackInformation, sizeof(struct tt__TrackInformation), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__TrackInformation(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_TrackToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__TrackReference(soap, "tt:TrackToken", &a->TrackToken, "tt:TrackReference"))
				{	soap_flag_TrackToken--;
					continue;
				}
			if (soap_flag_TrackType && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_tt__TrackType(soap, "tt:TrackType", &a->TrackType, "tt:TrackType"))
				{	soap_flag_TrackType--;
					continue;
				}
			if (soap_flag_Description && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__Description(soap, "tt:Description", &a->Description, "tt:Description"))
				{	soap_flag_Description--;
					continue;
				}
			if (soap_flag_DataFrom && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "tt:DataFrom", &a->DataFrom, "xsd:dateTime"))
				{	soap_flag_DataFrom--;
					continue;
				}
			if (soap_flag_DataTo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "tt:DataTo", &a->DataTo, "xsd:dateTime"))
				{	soap_flag_DataTo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__TrackInformation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__TrackInformation, 0, sizeof(struct tt__TrackInformation), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_TrackToken > 0 || soap_flag_TrackType > 0 || soap_flag_Description > 0 || soap_flag_DataFrom > 0 || soap_flag_DataTo > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__TrackInformation(struct soap *soap, const struct tt__TrackInformation *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__TrackInformation);
	if (soap_out_tt__TrackInformation(soap, tag?tag:"tt:TrackInformation", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__TrackInformation * SOAP_FMAC4 soap_get_tt__TrackInformation(struct soap *soap, struct tt__TrackInformation *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__TrackInformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__RecordingSourceInformation(struct soap *soap, struct tt__RecordingSourceInformation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->SourceId);
	soap_default_tt__Name(soap, &a->Name);
	soap_default_tt__Description(soap, &a->Location);
	soap_default_tt__Description(soap, &a->Description);
	soap_default_string(soap, &a->Address);
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__RecordingSourceInformation(struct soap *soap, const struct tt__RecordingSourceInformation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->SourceId);
	soap_serialize_tt__Name(soap, &a->Name);
	soap_serialize_tt__Description(soap, &a->Location);
	soap_serialize_tt__Description(soap, &a->Description);
	soap_serialize_string(soap, &a->Address);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__RecordingSourceInformation(struct soap *soap, const char *tag, int id, const struct tt__RecordingSourceInformation *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__RecordingSourceInformation), type))
		return soap->error;
	if (a->SourceId)
	{	if (soap_out_string(soap, "tt:SourceId", -1, &a->SourceId, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:SourceId"))
		return soap->error;
	if (a->Name)
	{	if (soap_out_tt__Name(soap, "tt:Name", -1, &a->Name, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:Name"))
		return soap->error;
	if (a->Location)
	{	if (soap_out_tt__Description(soap, "tt:Location", -1, &a->Location, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:Location"))
		return soap->error;
	if (a->Description)
	{	if (soap_out_tt__Description(soap, "tt:Description", -1, &a->Description, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:Description"))
		return soap->error;
	if (a->Address)
	{	if (soap_out_string(soap, "tt:Address", -1, &a->Address, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:Address"))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__RecordingSourceInformation * SOAP_FMAC4 soap_in_tt__RecordingSourceInformation(struct soap *soap, const char *tag, struct tt__RecordingSourceInformation *a, const char *type)
{
	size_t soap_flag_SourceId = 1;
	size_t soap_flag_Name = 1;
	size_t soap_flag_Location = 1;
	size_t soap_flag_Description = 1;
	size_t soap_flag_Address = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__RecordingSourceInformation *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RecordingSourceInformation, sizeof(struct tt__RecordingSourceInformation), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__RecordingSourceInformation(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SourceId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "tt:SourceId", &a->SourceId, "xsd:string"))
				{	soap_flag_SourceId--;
					continue;
				}
			if (soap_flag_Name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__Name(soap, "tt:Name", &a->Name, "tt:Name"))
				{	soap_flag_Name--;
					continue;
				}
			if (soap_flag_Location && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__Description(soap, "tt:Location", &a->Location, "tt:Description"))
				{	soap_flag_Location--;
					continue;
				}
			if (soap_flag_Description && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__Description(soap, "tt:Description", &a->Description, "tt:Description"))
				{	soap_flag_Description--;
					continue;
				}
			if (soap_flag_Address && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "tt:Address", &a->Address, "xsd:string"))
				{	soap_flag_Address--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__RecordingSourceInformation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__RecordingSourceInformation, 0, sizeof(struct tt__RecordingSourceInformation), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_SourceId > 0 || soap_flag_Name > 0 || soap_flag_Location > 0 || soap_flag_Description > 0 || soap_flag_Address > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__RecordingSourceInformation(struct soap *soap, const struct tt__RecordingSourceInformation *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__RecordingSourceInformation);
	if (soap_out_tt__RecordingSourceInformation(soap, tag?tag:"tt:RecordingSourceInformation", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__RecordingSourceInformation * SOAP_FMAC4 soap_get_tt__RecordingSourceInformation(struct soap *soap, struct tt__RecordingSourceInformation *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__RecordingSourceInformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__FindMetadataResult(struct soap *soap, struct tt__FindMetadataResult *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__RecordingReference(soap, &a->RecordingToken);
	soap_default_tt__TrackReference(soap, &a->TrackToken);
	soap_default_time(soap, &a->Time);
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__FindMetadataResult(struct soap *soap, const struct tt__FindMetadataResult *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_tt__RecordingReference(soap, &a->RecordingToken);
	soap_serialize_tt__TrackReference(soap, &a->TrackToken);
	soap_embedded(soap, &a->Time, SOAP_TYPE_time);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__FindMetadataResult(struct soap *soap, const char *tag, int id, const struct tt__FindMetadataResult *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__FindMetadataResult), type))
		return soap->error;
	if (a->RecordingToken)
	{	if (soap_out_tt__RecordingReference(soap, "tt:RecordingToken", -1, &a->RecordingToken, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:RecordingToken"))
		return soap->error;
	if (a->TrackToken)
	{	if (soap_out_tt__TrackReference(soap, "tt:TrackToken", -1, &a->TrackToken, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:TrackToken"))
		return soap->error;
	if (soap_out_time(soap, "tt:Time", -1, &a->Time, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__FindMetadataResult * SOAP_FMAC4 soap_in_tt__FindMetadataResult(struct soap *soap, const char *tag, struct tt__FindMetadataResult *a, const char *type)
{
	size_t soap_flag_RecordingToken = 1;
	size_t soap_flag_TrackToken = 1;
	size_t soap_flag_Time = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__FindMetadataResult *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__FindMetadataResult, sizeof(struct tt__FindMetadataResult), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__FindMetadataResult(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RecordingToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__RecordingReference(soap, "tt:RecordingToken", &a->RecordingToken, "tt:RecordingReference"))
				{	soap_flag_RecordingToken--;
					continue;
				}
			if (soap_flag_TrackToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__TrackReference(soap, "tt:TrackToken", &a->TrackToken, "tt:TrackReference"))
				{	soap_flag_TrackToken--;
					continue;
				}
			if (soap_flag_Time && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "tt:Time", &a->Time, "xsd:dateTime"))
				{	soap_flag_Time--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__FindMetadataResult *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__FindMetadataResult, 0, sizeof(struct tt__FindMetadataResult), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_RecordingToken > 0 || soap_flag_TrackToken > 0 || soap_flag_Time > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__FindMetadataResult(struct soap *soap, const struct tt__FindMetadataResult *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__FindMetadataResult);
	if (soap_out_tt__FindMetadataResult(soap, tag?tag:"tt:FindMetadataResult", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__FindMetadataResult * SOAP_FMAC4 soap_get_tt__FindMetadataResult(struct soap *soap, struct tt__FindMetadataResult *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__FindMetadataResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__FindMetadataResultList(struct soap *soap, struct tt__FindMetadataResultList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__SearchState(soap, &a->SearchState);
	a->__sizeResult = 0;
	a->Result = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__FindMetadataResultList(struct soap *soap, const struct tt__FindMetadataResultList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->Result)
	{	int i;
		for (i = 0; i < a->__sizeResult; i++)
		{
			soap_embedded(soap, a->Result + i, SOAP_TYPE_tt__FindMetadataResult);
			soap_serialize_tt__FindMetadataResult(soap, a->Result + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__FindMetadataResultList(struct soap *soap, const char *tag, int id, const struct tt__FindMetadataResultList *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__FindMetadataResultList), type))
		return soap->error;
	if (soap_out_tt__SearchState(soap, "tt:SearchState", -1, &a->SearchState, ""))
		return soap->error;
	if (a->Result)
	{	int i;
		for (i = 0; i < a->__sizeResult; i++)
			if (soap_out_tt__FindMetadataResult(soap, "tt:Result", -1, a->Result + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__FindMetadataResultList * SOAP_FMAC4 soap_in_tt__FindMetadataResultList(struct soap *soap, const char *tag, struct tt__FindMetadataResultList *a, const char *type)
{
	size_t soap_flag_SearchState = 1;
	struct soap_blist *soap_blist_Result = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__FindMetadataResultList *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__FindMetadataResultList, sizeof(struct tt__FindMetadataResultList), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__FindMetadataResultList(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SearchState && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_tt__SearchState(soap, "tt:SearchState", &a->SearchState, "tt:SearchState"))
				{	soap_flag_SearchState--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Result", 1, NULL))
			{	if (a->Result == NULL)
				{	if (soap_blist_Result == NULL)
						soap_blist_Result = soap_new_block(soap);
					a->Result = (struct tt__FindMetadataResult *)soap_push_block(soap, soap_blist_Result, sizeof(struct tt__FindMetadataResult));
					if (a->Result == NULL)
						return NULL;
					soap_default_tt__FindMetadataResult(soap, a->Result);
				}
				soap_revert(soap);
				if (soap_in_tt__FindMetadataResult(soap, "tt:Result", a->Result, "tt:FindMetadataResult"))
				{	a->__sizeResult++;
					a->Result = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Result)
			soap_pop_block(soap, soap_blist_Result);
		if (a->__sizeResult)
			a->Result = (struct tt__FindMetadataResult *)soap_save_block(soap, soap_blist_Result, NULL, 1);
		else
		{	a->Result = NULL;
			if (soap_blist_Result)
				soap_end_block(soap, soap_blist_Result);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__FindMetadataResultList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__FindMetadataResultList, 0, sizeof(struct tt__FindMetadataResultList), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_SearchState > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__FindMetadataResultList(struct soap *soap, const struct tt__FindMetadataResultList *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__FindMetadataResultList);
	if (soap_out_tt__FindMetadataResultList(soap, tag?tag:"tt:FindMetadataResultList", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__FindMetadataResultList * SOAP_FMAC4 soap_get_tt__FindMetadataResultList(struct soap *soap, struct tt__FindMetadataResultList *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__FindMetadataResultList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__FindPTZPositionResult(struct soap *soap, struct tt__FindPTZPositionResult *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__RecordingReference(soap, &a->RecordingToken);
	soap_default_tt__TrackReference(soap, &a->TrackToken);
	soap_default_time(soap, &a->Time);
	a->Position = NULL;
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__FindPTZPositionResult(struct soap *soap, const struct tt__FindPTZPositionResult *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_tt__RecordingReference(soap, &a->RecordingToken);
	soap_serialize_tt__TrackReference(soap, &a->TrackToken);
	soap_embedded(soap, &a->Time, SOAP_TYPE_time);
	soap_serialize_PointerTott__PTZVector(soap, &a->Position);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__FindPTZPositionResult(struct soap *soap, const char *tag, int id, const struct tt__FindPTZPositionResult *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__FindPTZPositionResult), type))
		return soap->error;
	if (a->RecordingToken)
	{	if (soap_out_tt__RecordingReference(soap, "tt:RecordingToken", -1, &a->RecordingToken, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:RecordingToken"))
		return soap->error;
	if (a->TrackToken)
	{	if (soap_out_tt__TrackReference(soap, "tt:TrackToken", -1, &a->TrackToken, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:TrackToken"))
		return soap->error;
	if (soap_out_time(soap, "tt:Time", -1, &a->Time, ""))
		return soap->error;
	if (a->Position)
	{	if (soap_out_PointerTott__PTZVector(soap, "tt:Position", -1, &a->Position, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:Position"))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__FindPTZPositionResult * SOAP_FMAC4 soap_in_tt__FindPTZPositionResult(struct soap *soap, const char *tag, struct tt__FindPTZPositionResult *a, const char *type)
{
	size_t soap_flag_RecordingToken = 1;
	size_t soap_flag_TrackToken = 1;
	size_t soap_flag_Time = 1;
	size_t soap_flag_Position = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__FindPTZPositionResult *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__FindPTZPositionResult, sizeof(struct tt__FindPTZPositionResult), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__FindPTZPositionResult(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RecordingToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__RecordingReference(soap, "tt:RecordingToken", &a->RecordingToken, "tt:RecordingReference"))
				{	soap_flag_RecordingToken--;
					continue;
				}
			if (soap_flag_TrackToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__TrackReference(soap, "tt:TrackToken", &a->TrackToken, "tt:TrackReference"))
				{	soap_flag_TrackToken--;
					continue;
				}
			if (soap_flag_Time && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "tt:Time", &a->Time, "xsd:dateTime"))
				{	soap_flag_Time--;
					continue;
				}
			if (soap_flag_Position && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__PTZVector(soap, "tt:Position", &a->Position, "tt:PTZVector"))
				{	soap_flag_Position--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__FindPTZPositionResult *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__FindPTZPositionResult, 0, sizeof(struct tt__FindPTZPositionResult), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_RecordingToken > 0 || soap_flag_TrackToken > 0 || soap_flag_Time > 0 || soap_flag_Position > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__FindPTZPositionResult(struct soap *soap, const struct tt__FindPTZPositionResult *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__FindPTZPositionResult);
	if (soap_out_tt__FindPTZPositionResult(soap, tag?tag:"tt:FindPTZPositionResult", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__FindPTZPositionResult * SOAP_FMAC4 soap_get_tt__FindPTZPositionResult(struct soap *soap, struct tt__FindPTZPositionResult *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__FindPTZPositionResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__FindPTZPositionResultList(struct soap *soap, struct tt__FindPTZPositionResultList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__SearchState(soap, &a->SearchState);
	a->__sizeResult = 0;
	a->Result = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__FindPTZPositionResultList(struct soap *soap, const struct tt__FindPTZPositionResultList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->Result)
	{	int i;
		for (i = 0; i < a->__sizeResult; i++)
		{
			soap_embedded(soap, a->Result + i, SOAP_TYPE_tt__FindPTZPositionResult);
			soap_serialize_tt__FindPTZPositionResult(soap, a->Result + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__FindPTZPositionResultList(struct soap *soap, const char *tag, int id, const struct tt__FindPTZPositionResultList *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__FindPTZPositionResultList), type))
		return soap->error;
	if (soap_out_tt__SearchState(soap, "tt:SearchState", -1, &a->SearchState, ""))
		return soap->error;
	if (a->Result)
	{	int i;
		for (i = 0; i < a->__sizeResult; i++)
			if (soap_out_tt__FindPTZPositionResult(soap, "tt:Result", -1, a->Result + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__FindPTZPositionResultList * SOAP_FMAC4 soap_in_tt__FindPTZPositionResultList(struct soap *soap, const char *tag, struct tt__FindPTZPositionResultList *a, const char *type)
{
	size_t soap_flag_SearchState = 1;
	struct soap_blist *soap_blist_Result = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__FindPTZPositionResultList *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__FindPTZPositionResultList, sizeof(struct tt__FindPTZPositionResultList), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__FindPTZPositionResultList(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SearchState && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_tt__SearchState(soap, "tt:SearchState", &a->SearchState, "tt:SearchState"))
				{	soap_flag_SearchState--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Result", 1, NULL))
			{	if (a->Result == NULL)
				{	if (soap_blist_Result == NULL)
						soap_blist_Result = soap_new_block(soap);
					a->Result = (struct tt__FindPTZPositionResult *)soap_push_block(soap, soap_blist_Result, sizeof(struct tt__FindPTZPositionResult));
					if (a->Result == NULL)
						return NULL;
					soap_default_tt__FindPTZPositionResult(soap, a->Result);
				}
				soap_revert(soap);
				if (soap_in_tt__FindPTZPositionResult(soap, "tt:Result", a->Result, "tt:FindPTZPositionResult"))
				{	a->__sizeResult++;
					a->Result = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Result)
			soap_pop_block(soap, soap_blist_Result);
		if (a->__sizeResult)
			a->Result = (struct tt__FindPTZPositionResult *)soap_save_block(soap, soap_blist_Result, NULL, 1);
		else
		{	a->Result = NULL;
			if (soap_blist_Result)
				soap_end_block(soap, soap_blist_Result);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__FindPTZPositionResultList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__FindPTZPositionResultList, 0, sizeof(struct tt__FindPTZPositionResultList), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_SearchState > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__FindPTZPositionResultList(struct soap *soap, const struct tt__FindPTZPositionResultList *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__FindPTZPositionResultList);
	if (soap_out_tt__FindPTZPositionResultList(soap, tag?tag:"tt:FindPTZPositionResultList", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__FindPTZPositionResultList * SOAP_FMAC4 soap_get_tt__FindPTZPositionResultList(struct soap *soap, struct tt__FindPTZPositionResultList *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__FindPTZPositionResultList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__FindEventResult(struct soap *soap, struct tt__FindEventResult *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__RecordingReference(soap, &a->RecordingToken);
	soap_default_tt__TrackReference(soap, &a->TrackToken);
	soap_default_time(soap, &a->Time);
	a->Event = NULL;
	soap_default_xsd__boolean_(soap, &a->StartStateEvent);
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__FindEventResult(struct soap *soap, const struct tt__FindEventResult *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_tt__RecordingReference(soap, &a->RecordingToken);
	soap_serialize_tt__TrackReference(soap, &a->TrackToken);
	soap_embedded(soap, &a->Time, SOAP_TYPE_time);
	soap_serialize_PointerTowsnt__NotificationMessageHolderType(soap, &a->Event);
	soap_embedded(soap, &a->StartStateEvent, SOAP_TYPE_xsd__boolean_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__FindEventResult(struct soap *soap, const char *tag, int id, const struct tt__FindEventResult *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__FindEventResult), type))
		return soap->error;
	if (a->RecordingToken)
	{	if (soap_out_tt__RecordingReference(soap, "tt:RecordingToken", -1, &a->RecordingToken, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:RecordingToken"))
		return soap->error;
	if (a->TrackToken)
	{	if (soap_out_tt__TrackReference(soap, "tt:TrackToken", -1, &a->TrackToken, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:TrackToken"))
		return soap->error;
	if (soap_out_time(soap, "tt:Time", -1, &a->Time, ""))
		return soap->error;
	if (a->Event)
	{	if (soap_out_PointerTowsnt__NotificationMessageHolderType(soap, "tt:Event", -1, &a->Event, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:Event"))
		return soap->error;
	if (soap_out_xsd__boolean_(soap, "tt:StartStateEvent", -1, &a->StartStateEvent, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__FindEventResult * SOAP_FMAC4 soap_in_tt__FindEventResult(struct soap *soap, const char *tag, struct tt__FindEventResult *a, const char *type)
{
	size_t soap_flag_RecordingToken = 1;
	size_t soap_flag_TrackToken = 1;
	size_t soap_flag_Time = 1;
	size_t soap_flag_Event = 1;
	size_t soap_flag_StartStateEvent = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__FindEventResult *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__FindEventResult, sizeof(struct tt__FindEventResult), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__FindEventResult(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RecordingToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__RecordingReference(soap, "tt:RecordingToken", &a->RecordingToken, "tt:RecordingReference"))
				{	soap_flag_RecordingToken--;
					continue;
				}
			if (soap_flag_TrackToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__TrackReference(soap, "tt:TrackToken", &a->TrackToken, "tt:TrackReference"))
				{	soap_flag_TrackToken--;
					continue;
				}
			if (soap_flag_Time && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "tt:Time", &a->Time, "xsd:dateTime"))
				{	soap_flag_Time--;
					continue;
				}
			if (soap_flag_Event && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsnt__NotificationMessageHolderType(soap, "tt:Event", &a->Event, "wsnt:NotificationMessageHolderType"))
				{	soap_flag_Event--;
					continue;
				}
			if (soap_flag_StartStateEvent && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean_(soap, "tt:StartStateEvent", &a->StartStateEvent, "xsd:boolean"))
				{	soap_flag_StartStateEvent--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__FindEventResult *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__FindEventResult, 0, sizeof(struct tt__FindEventResult), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_RecordingToken > 0 || soap_flag_TrackToken > 0 || soap_flag_Time > 0 || soap_flag_Event > 0 || soap_flag_StartStateEvent > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__FindEventResult(struct soap *soap, const struct tt__FindEventResult *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__FindEventResult);
	if (soap_out_tt__FindEventResult(soap, tag?tag:"tt:FindEventResult", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__FindEventResult * SOAP_FMAC4 soap_get_tt__FindEventResult(struct soap *soap, struct tt__FindEventResult *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__FindEventResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__FindEventResultList(struct soap *soap, struct tt__FindEventResultList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__SearchState(soap, &a->SearchState);
	a->__sizeResult = 0;
	a->Result = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__FindEventResultList(struct soap *soap, const struct tt__FindEventResultList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->Result)
	{	int i;
		for (i = 0; i < a->__sizeResult; i++)
		{
			soap_embedded(soap, a->Result + i, SOAP_TYPE_tt__FindEventResult);
			soap_serialize_tt__FindEventResult(soap, a->Result + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__FindEventResultList(struct soap *soap, const char *tag, int id, const struct tt__FindEventResultList *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__FindEventResultList), type))
		return soap->error;
	if (soap_out_tt__SearchState(soap, "tt:SearchState", -1, &a->SearchState, ""))
		return soap->error;
	if (a->Result)
	{	int i;
		for (i = 0; i < a->__sizeResult; i++)
			if (soap_out_tt__FindEventResult(soap, "tt:Result", -1, a->Result + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__FindEventResultList * SOAP_FMAC4 soap_in_tt__FindEventResultList(struct soap *soap, const char *tag, struct tt__FindEventResultList *a, const char *type)
{
	size_t soap_flag_SearchState = 1;
	struct soap_blist *soap_blist_Result = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__FindEventResultList *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__FindEventResultList, sizeof(struct tt__FindEventResultList), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__FindEventResultList(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SearchState && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_tt__SearchState(soap, "tt:SearchState", &a->SearchState, "tt:SearchState"))
				{	soap_flag_SearchState--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Result", 1, NULL))
			{	if (a->Result == NULL)
				{	if (soap_blist_Result == NULL)
						soap_blist_Result = soap_new_block(soap);
					a->Result = (struct tt__FindEventResult *)soap_push_block(soap, soap_blist_Result, sizeof(struct tt__FindEventResult));
					if (a->Result == NULL)
						return NULL;
					soap_default_tt__FindEventResult(soap, a->Result);
				}
				soap_revert(soap);
				if (soap_in_tt__FindEventResult(soap, "tt:Result", a->Result, "tt:FindEventResult"))
				{	a->__sizeResult++;
					a->Result = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Result)
			soap_pop_block(soap, soap_blist_Result);
		if (a->__sizeResult)
			a->Result = (struct tt__FindEventResult *)soap_save_block(soap, soap_blist_Result, NULL, 1);
		else
		{	a->Result = NULL;
			if (soap_blist_Result)
				soap_end_block(soap, soap_blist_Result);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__FindEventResultList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__FindEventResultList, 0, sizeof(struct tt__FindEventResultList), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_SearchState > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__FindEventResultList(struct soap *soap, const struct tt__FindEventResultList *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__FindEventResultList);
	if (soap_out_tt__FindEventResultList(soap, tag?tag:"tt:FindEventResultList", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__FindEventResultList * SOAP_FMAC4 soap_get_tt__FindEventResultList(struct soap *soap, struct tt__FindEventResultList *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__FindEventResultList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__RecordingInformation(struct soap *soap, struct tt__RecordingInformation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__RecordingReference(soap, &a->RecordingToken);
	a->Source = NULL;
	a->EarliestRecording = NULL;
	a->LatestRecording = NULL;
	soap_default_tt__Description(soap, &a->Content);
	a->__sizeTrack = 0;
	a->Track = NULL;
	soap_default_tt__RecordingStatus(soap, &a->RecordingStatus);
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__RecordingInformation(struct soap *soap, const struct tt__RecordingInformation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_tt__RecordingReference(soap, &a->RecordingToken);
	soap_serialize_PointerTott__RecordingSourceInformation(soap, &a->Source);
	soap_serialize_PointerTotime(soap, &a->EarliestRecording);
	soap_serialize_PointerTotime(soap, &a->LatestRecording);
	soap_serialize_tt__Description(soap, &a->Content);
	if (a->Track)
	{	int i;
		for (i = 0; i < a->__sizeTrack; i++)
		{
			soap_embedded(soap, a->Track + i, SOAP_TYPE_tt__TrackInformation);
			soap_serialize_tt__TrackInformation(soap, a->Track + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__RecordingInformation(struct soap *soap, const char *tag, int id, const struct tt__RecordingInformation *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__RecordingInformation), type))
		return soap->error;
	if (a->RecordingToken)
	{	if (soap_out_tt__RecordingReference(soap, "tt:RecordingToken", -1, &a->RecordingToken, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:RecordingToken"))
		return soap->error;
	if (a->Source)
	{	if (soap_out_PointerTott__RecordingSourceInformation(soap, "tt:Source", -1, &a->Source, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:Source"))
		return soap->error;
	if (soap_out_PointerTotime(soap, "tt:EarliestRecording", -1, &a->EarliestRecording, ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "tt:LatestRecording", -1, &a->LatestRecording, ""))
		return soap->error;
	if (a->Content)
	{	if (soap_out_tt__Description(soap, "tt:Content", -1, &a->Content, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:Content"))
		return soap->error;
	if (a->Track)
	{	int i;
		for (i = 0; i < a->__sizeTrack; i++)
			if (soap_out_tt__TrackInformation(soap, "tt:Track", -1, a->Track + i, ""))
				return soap->error;
	}
	if (soap_out_tt__RecordingStatus(soap, "tt:RecordingStatus", -1, &a->RecordingStatus, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__RecordingInformation * SOAP_FMAC4 soap_in_tt__RecordingInformation(struct soap *soap, const char *tag, struct tt__RecordingInformation *a, const char *type)
{
	size_t soap_flag_RecordingToken = 1;
	size_t soap_flag_Source = 1;
	size_t soap_flag_EarliestRecording = 1;
	size_t soap_flag_LatestRecording = 1;
	size_t soap_flag_Content = 1;
	struct soap_blist *soap_blist_Track = NULL;
	size_t soap_flag_RecordingStatus = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__RecordingInformation *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RecordingInformation, sizeof(struct tt__RecordingInformation), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__RecordingInformation(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RecordingToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__RecordingReference(soap, "tt:RecordingToken", &a->RecordingToken, "tt:RecordingReference"))
				{	soap_flag_RecordingToken--;
					continue;
				}
			if (soap_flag_Source && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__RecordingSourceInformation(soap, "tt:Source", &a->Source, "tt:RecordingSourceInformation"))
				{	soap_flag_Source--;
					continue;
				}
			if (soap_flag_EarliestRecording && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "tt:EarliestRecording", &a->EarliestRecording, "xsd:dateTime"))
				{	soap_flag_EarliestRecording--;
					continue;
				}
			if (soap_flag_LatestRecording && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "tt:LatestRecording", &a->LatestRecording, "xsd:dateTime"))
				{	soap_flag_LatestRecording--;
					continue;
				}
			if (soap_flag_Content && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__Description(soap, "tt:Content", &a->Content, "tt:Description"))
				{	soap_flag_Content--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Track", 1, NULL))
			{	if (a->Track == NULL)
				{	if (soap_blist_Track == NULL)
						soap_blist_Track = soap_new_block(soap);
					a->Track = (struct tt__TrackInformation *)soap_push_block(soap, soap_blist_Track, sizeof(struct tt__TrackInformation));
					if (a->Track == NULL)
						return NULL;
					soap_default_tt__TrackInformation(soap, a->Track);
				}
				soap_revert(soap);
				if (soap_in_tt__TrackInformation(soap, "tt:Track", a->Track, "tt:TrackInformation"))
				{	a->__sizeTrack++;
					a->Track = NULL;
					continue;
				}
			}
			if (soap_flag_RecordingStatus && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_tt__RecordingStatus(soap, "tt:RecordingStatus", &a->RecordingStatus, "tt:RecordingStatus"))
				{	soap_flag_RecordingStatus--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Track)
			soap_pop_block(soap, soap_blist_Track);
		if (a->__sizeTrack)
			a->Track = (struct tt__TrackInformation *)soap_save_block(soap, soap_blist_Track, NULL, 1);
		else
		{	a->Track = NULL;
			if (soap_blist_Track)
				soap_end_block(soap, soap_blist_Track);
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__RecordingInformation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__RecordingInformation, 0, sizeof(struct tt__RecordingInformation), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_RecordingToken > 0 || soap_flag_Source > 0 || soap_flag_Content > 0 || soap_flag_RecordingStatus > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__RecordingInformation(struct soap *soap, const struct tt__RecordingInformation *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__RecordingInformation);
	if (soap_out_tt__RecordingInformation(soap, tag?tag:"tt:RecordingInformation", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__RecordingInformation * SOAP_FMAC4 soap_get_tt__RecordingInformation(struct soap *soap, struct tt__RecordingInformation *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__RecordingInformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__FindRecordingResultList(struct soap *soap, struct tt__FindRecordingResultList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__SearchState(soap, &a->SearchState);
	a->__sizeRecordingInformation = 0;
	a->RecordingInformation = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__FindRecordingResultList(struct soap *soap, const struct tt__FindRecordingResultList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->RecordingInformation)
	{	int i;
		for (i = 0; i < a->__sizeRecordingInformation; i++)
		{
			soap_embedded(soap, a->RecordingInformation + i, SOAP_TYPE_tt__RecordingInformation);
			soap_serialize_tt__RecordingInformation(soap, a->RecordingInformation + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__FindRecordingResultList(struct soap *soap, const char *tag, int id, const struct tt__FindRecordingResultList *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__FindRecordingResultList), type))
		return soap->error;
	if (soap_out_tt__SearchState(soap, "tt:SearchState", -1, &a->SearchState, ""))
		return soap->error;
	if (a->RecordingInformation)
	{	int i;
		for (i = 0; i < a->__sizeRecordingInformation; i++)
			if (soap_out_tt__RecordingInformation(soap, "tt:RecordingInformation", -1, a->RecordingInformation + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__FindRecordingResultList * SOAP_FMAC4 soap_in_tt__FindRecordingResultList(struct soap *soap, const char *tag, struct tt__FindRecordingResultList *a, const char *type)
{
	size_t soap_flag_SearchState = 1;
	struct soap_blist *soap_blist_RecordingInformation = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__FindRecordingResultList *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__FindRecordingResultList, sizeof(struct tt__FindRecordingResultList), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__FindRecordingResultList(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SearchState && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_tt__SearchState(soap, "tt:SearchState", &a->SearchState, "tt:SearchState"))
				{	soap_flag_SearchState--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:RecordingInformation", 1, NULL))
			{	if (a->RecordingInformation == NULL)
				{	if (soap_blist_RecordingInformation == NULL)
						soap_blist_RecordingInformation = soap_new_block(soap);
					a->RecordingInformation = (struct tt__RecordingInformation *)soap_push_block(soap, soap_blist_RecordingInformation, sizeof(struct tt__RecordingInformation));
					if (a->RecordingInformation == NULL)
						return NULL;
					soap_default_tt__RecordingInformation(soap, a->RecordingInformation);
				}
				soap_revert(soap);
				if (soap_in_tt__RecordingInformation(soap, "tt:RecordingInformation", a->RecordingInformation, "tt:RecordingInformation"))
				{	a->__sizeRecordingInformation++;
					a->RecordingInformation = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->RecordingInformation)
			soap_pop_block(soap, soap_blist_RecordingInformation);
		if (a->__sizeRecordingInformation)
			a->RecordingInformation = (struct tt__RecordingInformation *)soap_save_block(soap, soap_blist_RecordingInformation, NULL, 1);
		else
		{	a->RecordingInformation = NULL;
			if (soap_blist_RecordingInformation)
				soap_end_block(soap, soap_blist_RecordingInformation);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__FindRecordingResultList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__FindRecordingResultList, 0, sizeof(struct tt__FindRecordingResultList), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_SearchState > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__FindRecordingResultList(struct soap *soap, const struct tt__FindRecordingResultList *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__FindRecordingResultList);
	if (soap_out_tt__FindRecordingResultList(soap, tag?tag:"tt:FindRecordingResultList", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__FindRecordingResultList * SOAP_FMAC4 soap_get_tt__FindRecordingResultList(struct soap *soap, struct tt__FindRecordingResultList *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__FindRecordingResultList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__MetadataFilter(struct soap *soap, struct tt__MetadataFilter *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__XPathExpression(soap, &a->MetadataStreamFilter);
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__MetadataFilter(struct soap *soap, const struct tt__MetadataFilter *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_tt__XPathExpression(soap, &a->MetadataStreamFilter);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__MetadataFilter(struct soap *soap, const char *tag, int id, const struct tt__MetadataFilter *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__MetadataFilter), type))
		return soap->error;
	if (a->MetadataStreamFilter)
	{	if (soap_out_tt__XPathExpression(soap, "tt:MetadataStreamFilter", -1, &a->MetadataStreamFilter, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:MetadataStreamFilter"))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__MetadataFilter * SOAP_FMAC4 soap_in_tt__MetadataFilter(struct soap *soap, const char *tag, struct tt__MetadataFilter *a, const char *type)
{
	size_t soap_flag_MetadataStreamFilter = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__MetadataFilter *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__MetadataFilter, sizeof(struct tt__MetadataFilter), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__MetadataFilter(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_MetadataStreamFilter && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__XPathExpression(soap, "tt:MetadataStreamFilter", &a->MetadataStreamFilter, "tt:XPathExpression"))
				{	soap_flag_MetadataStreamFilter--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__MetadataFilter *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__MetadataFilter, 0, sizeof(struct tt__MetadataFilter), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_MetadataStreamFilter > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__MetadataFilter(struct soap *soap, const struct tt__MetadataFilter *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__MetadataFilter);
	if (soap_out_tt__MetadataFilter(soap, tag?tag:"tt:MetadataFilter", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__MetadataFilter * SOAP_FMAC4 soap_get_tt__MetadataFilter(struct soap *soap, struct tt__MetadataFilter *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__MetadataFilter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__PTZPositionFilter(struct soap *soap, struct tt__PTZPositionFilter *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->MinPosition = NULL;
	a->MaxPosition = NULL;
	soap_default_xsd__boolean_(soap, &a->EnterOrExit);
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__PTZPositionFilter(struct soap *soap, const struct tt__PTZPositionFilter *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTott__PTZVector(soap, &a->MinPosition);
	soap_serialize_PointerTott__PTZVector(soap, &a->MaxPosition);
	soap_embedded(soap, &a->EnterOrExit, SOAP_TYPE_xsd__boolean_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZPositionFilter(struct soap *soap, const char *tag, int id, const struct tt__PTZPositionFilter *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTZPositionFilter), type))
		return soap->error;
	if (a->MinPosition)
	{	if (soap_out_PointerTott__PTZVector(soap, "tt:MinPosition", -1, &a->MinPosition, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:MinPosition"))
		return soap->error;
	if (a->MaxPosition)
	{	if (soap_out_PointerTott__PTZVector(soap, "tt:MaxPosition", -1, &a->MaxPosition, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:MaxPosition"))
		return soap->error;
	if (soap_out_xsd__boolean_(soap, "tt:EnterOrExit", -1, &a->EnterOrExit, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__PTZPositionFilter * SOAP_FMAC4 soap_in_tt__PTZPositionFilter(struct soap *soap, const char *tag, struct tt__PTZPositionFilter *a, const char *type)
{
	size_t soap_flag_MinPosition = 1;
	size_t soap_flag_MaxPosition = 1;
	size_t soap_flag_EnterOrExit = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__PTZPositionFilter *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZPositionFilter, sizeof(struct tt__PTZPositionFilter), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__PTZPositionFilter(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_MinPosition && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__PTZVector(soap, "tt:MinPosition", &a->MinPosition, "tt:PTZVector"))
				{	soap_flag_MinPosition--;
					continue;
				}
			if (soap_flag_MaxPosition && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__PTZVector(soap, "tt:MaxPosition", &a->MaxPosition, "tt:PTZVector"))
				{	soap_flag_MaxPosition--;
					continue;
				}
			if (soap_flag_EnterOrExit && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean_(soap, "tt:EnterOrExit", &a->EnterOrExit, "xsd:boolean"))
				{	soap_flag_EnterOrExit--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__PTZPositionFilter *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZPositionFilter, 0, sizeof(struct tt__PTZPositionFilter), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_MinPosition > 0 || soap_flag_MaxPosition > 0 || soap_flag_EnterOrExit > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__PTZPositionFilter(struct soap *soap, const struct tt__PTZPositionFilter *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__PTZPositionFilter);
	if (soap_out_tt__PTZPositionFilter(soap, tag?tag:"tt:PTZPositionFilter", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PTZPositionFilter * SOAP_FMAC4 soap_get_tt__PTZPositionFilter(struct soap *soap, struct tt__PTZPositionFilter *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTZPositionFilter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__SearchScopeExtension(struct soap *soap, struct tt__SearchScopeExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__SearchScopeExtension(struct soap *soap, const struct tt__SearchScopeExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__SearchScopeExtension(struct soap *soap, const char *tag, int id, const struct tt__SearchScopeExtension *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__SearchScopeExtension), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__SearchScopeExtension * SOAP_FMAC4 soap_in_tt__SearchScopeExtension(struct soap *soap, const char *tag, struct tt__SearchScopeExtension *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__SearchScopeExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__SearchScopeExtension, sizeof(struct tt__SearchScopeExtension), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__SearchScopeExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__SearchScopeExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__SearchScopeExtension, 0, sizeof(struct tt__SearchScopeExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__SearchScopeExtension(struct soap *soap, const struct tt__SearchScopeExtension *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__SearchScopeExtension);
	if (soap_out_tt__SearchScopeExtension(soap, tag?tag:"tt:SearchScopeExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__SearchScopeExtension * SOAP_FMAC4 soap_get_tt__SearchScopeExtension(struct soap *soap, struct tt__SearchScopeExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__SearchScopeExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__SearchScope(struct soap *soap, struct tt__SearchScope *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeIncludedSources = 0;
	a->IncludedSources = NULL;
	a->__sizeIncludedRecordings = 0;
	a->IncludedRecordings = NULL;
	soap_default_tt__XPathExpression(soap, &a->RecordingInformationFilter);
	a->Extension = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__SearchScope(struct soap *soap, const struct tt__SearchScope *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->IncludedSources)
	{	int i;
		for (i = 0; i < a->__sizeIncludedSources; i++)
		{
			soap_embedded(soap, a->IncludedSources + i, SOAP_TYPE_tt__SourceReference);
			soap_serialize_tt__SourceReference(soap, a->IncludedSources + i);
		}
	}
	if (a->IncludedRecordings)
	{	int i;
		for (i = 0; i < a->__sizeIncludedRecordings; i++)
		{
			soap_serialize_tt__RecordingReference(soap, a->IncludedRecordings + i);
		}
	}
	soap_serialize_tt__XPathExpression(soap, &a->RecordingInformationFilter);
	soap_serialize_PointerTott__SearchScopeExtension(soap, &a->Extension);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__SearchScope(struct soap *soap, const char *tag, int id, const struct tt__SearchScope *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__SearchScope), type))
		return soap->error;
	if (a->IncludedSources)
	{	int i;
		for (i = 0; i < a->__sizeIncludedSources; i++)
			if (soap_out_tt__SourceReference(soap, "tt:IncludedSources", -1, a->IncludedSources + i, ""))
				return soap->error;
	}
	if (a->IncludedRecordings)
	{	int i;
		for (i = 0; i < a->__sizeIncludedRecordings; i++)
			if (soap_out_tt__RecordingReference(soap, "tt:IncludedRecordings", -1, a->IncludedRecordings + i, ""))
				return soap->error;
	}
	if (soap_out_tt__XPathExpression(soap, "tt:RecordingInformationFilter", -1, &a->RecordingInformationFilter, ""))
		return soap->error;
	if (soap_out_PointerTott__SearchScopeExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__SearchScope * SOAP_FMAC4 soap_in_tt__SearchScope(struct soap *soap, const char *tag, struct tt__SearchScope *a, const char *type)
{
	struct soap_blist *soap_blist_IncludedSources = NULL;
	struct soap_blist *soap_blist_IncludedRecordings = NULL;
	size_t soap_flag_RecordingInformationFilter = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__SearchScope *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__SearchScope, sizeof(struct tt__SearchScope), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__SearchScope(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:IncludedSources", 1, NULL))
			{	if (a->IncludedSources == NULL)
				{	if (soap_blist_IncludedSources == NULL)
						soap_blist_IncludedSources = soap_new_block(soap);
					a->IncludedSources = (struct tt__SourceReference *)soap_push_block(soap, soap_blist_IncludedSources, sizeof(struct tt__SourceReference));
					if (a->IncludedSources == NULL)
						return NULL;
					soap_default_tt__SourceReference(soap, a->IncludedSources);
				}
				soap_revert(soap);
				if (soap_in_tt__SourceReference(soap, "tt:IncludedSources", a->IncludedSources, "tt:SourceReference"))
				{	a->__sizeIncludedSources++;
					a->IncludedSources = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:IncludedRecordings", 1, NULL))
			{	if (a->IncludedRecordings == NULL)
				{	if (soap_blist_IncludedRecordings == NULL)
						soap_blist_IncludedRecordings = soap_new_block(soap);
					a->IncludedRecordings = (char **)soap_push_block(soap, soap_blist_IncludedRecordings, sizeof(char *));
					if (a->IncludedRecordings == NULL)
						return NULL;
					*a->IncludedRecordings = NULL;
				}
				soap_revert(soap);
				if (soap_in_tt__RecordingReference(soap, "tt:IncludedRecordings", a->IncludedRecordings, "tt:RecordingReference"))
				{	a->__sizeIncludedRecordings++;
					a->IncludedRecordings = NULL;
					continue;
				}
			}
			if (soap_flag_RecordingInformationFilter && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__XPathExpression(soap, "tt:RecordingInformationFilter", &a->RecordingInformationFilter, "tt:XPathExpression"))
				{	soap_flag_RecordingInformationFilter--;
					continue;
				}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__SearchScopeExtension(soap, "tt:Extension", &a->Extension, "tt:SearchScopeExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->IncludedSources)
			soap_pop_block(soap, soap_blist_IncludedSources);
		if (a->__sizeIncludedSources)
			a->IncludedSources = (struct tt__SourceReference *)soap_save_block(soap, soap_blist_IncludedSources, NULL, 1);
		else
		{	a->IncludedSources = NULL;
			if (soap_blist_IncludedSources)
				soap_end_block(soap, soap_blist_IncludedSources);
		}
		if (a->IncludedRecordings)
			soap_pop_block(soap, soap_blist_IncludedRecordings);
		if (a->__sizeIncludedRecordings)
			a->IncludedRecordings = (char **)soap_save_block(soap, soap_blist_IncludedRecordings, NULL, 1);
		else
		{	a->IncludedRecordings = NULL;
			if (soap_blist_IncludedRecordings)
				soap_end_block(soap, soap_blist_IncludedRecordings);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__SearchScope *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__SearchScope, 0, sizeof(struct tt__SearchScope), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__SearchScope(struct soap *soap, const struct tt__SearchScope *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__SearchScope);
	if (soap_out_tt__SearchScope(soap, tag?tag:"tt:SearchScope", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__SearchScope * SOAP_FMAC4 soap_get_tt__SearchScope(struct soap *soap, struct tt__SearchScope *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__SearchScope(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__RecordingSummary(struct soap *soap, struct tt__RecordingSummary *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_time(soap, &a->DataFrom);
	soap_default_time(soap, &a->DataUntil);
	soap_default_int(soap, &a->NumberRecordings);
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__RecordingSummary(struct soap *soap, const struct tt__RecordingSummary *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->DataFrom, SOAP_TYPE_time);
	soap_embedded(soap, &a->DataUntil, SOAP_TYPE_time);
	soap_embedded(soap, &a->NumberRecordings, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__RecordingSummary(struct soap *soap, const char *tag, int id, const struct tt__RecordingSummary *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__RecordingSummary), type))
		return soap->error;
	if (soap_out_time(soap, "tt:DataFrom", -1, &a->DataFrom, ""))
		return soap->error;
	if (soap_out_time(soap, "tt:DataUntil", -1, &a->DataUntil, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:NumberRecordings", -1, &a->NumberRecordings, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__RecordingSummary * SOAP_FMAC4 soap_in_tt__RecordingSummary(struct soap *soap, const char *tag, struct tt__RecordingSummary *a, const char *type)
{
	size_t soap_flag_DataFrom = 1;
	size_t soap_flag_DataUntil = 1;
	size_t soap_flag_NumberRecordings = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__RecordingSummary *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RecordingSummary, sizeof(struct tt__RecordingSummary), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__RecordingSummary(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_DataFrom && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "tt:DataFrom", &a->DataFrom, "xsd:dateTime"))
				{	soap_flag_DataFrom--;
					continue;
				}
			if (soap_flag_DataUntil && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "tt:DataUntil", &a->DataUntil, "xsd:dateTime"))
				{	soap_flag_DataUntil--;
					continue;
				}
			if (soap_flag_NumberRecordings && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "tt:NumberRecordings", &a->NumberRecordings, "xsd:int"))
				{	soap_flag_NumberRecordings--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__RecordingSummary *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__RecordingSummary, 0, sizeof(struct tt__RecordingSummary), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_DataFrom > 0 || soap_flag_DataUntil > 0 || soap_flag_NumberRecordings > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__RecordingSummary(struct soap *soap, const struct tt__RecordingSummary *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__RecordingSummary);
	if (soap_out_tt__RecordingSummary(soap, tag?tag:"tt:RecordingSummary", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__RecordingSummary * SOAP_FMAC4 soap_get_tt__RecordingSummary(struct soap *soap, struct tt__RecordingSummary *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__RecordingSummary(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__SourceReference(struct soap *soap, struct tt__SourceReference *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->Token);
	a->__size = 0;
	a->__any = NULL;
	a->Type = (char*)"http://www.onvif.org/ver10/schema/Receiver";
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__SourceReference(struct soap *soap, const struct tt__SourceReference *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_tt__ReferenceToken(soap, &a->Token);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__SourceReference(struct soap *soap, const char *tag, int id, const struct tt__SourceReference *a, const char *type)
{
	if (a->Type)
		soap_set_attr(soap, "Type", a->Type, 1);
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__SourceReference), type))
		return soap->error;
	if (a->Token)
	{	if (soap_out_tt__ReferenceToken(soap, "tt:Token", -1, &a->Token, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:Token"))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__SourceReference * SOAP_FMAC4 soap_in_tt__SourceReference(struct soap *soap, const char *tag, struct tt__SourceReference *a, const char *type)
{
	size_t soap_flag_Token = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__SourceReference *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__SourceReference, sizeof(struct tt__SourceReference), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__SourceReference(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Type", 0), &a->Type, -1, -1))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Token && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "tt:Token", &a->Token, "tt:ReferenceToken"))
				{	soap_flag_Token--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__SourceReference *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__SourceReference, 0, sizeof(struct tt__SourceReference), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Token > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__SourceReference(struct soap *soap, const struct tt__SourceReference *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__SourceReference);
	if (soap_out_tt__SourceReference(soap, tag?tag:"tt:SourceReference", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__SourceReference * SOAP_FMAC4 soap_get_tt__SourceReference(struct soap *soap, struct tt__SourceReference *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__SourceReference(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__ReceiverStateInformation(struct soap *soap, struct tt__ReceiverStateInformation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReceiverState(soap, &a->State);
	soap_default_xsd__boolean_(soap, &a->AutoCreated);
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__ReceiverStateInformation(struct soap *soap, const struct tt__ReceiverStateInformation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->AutoCreated, SOAP_TYPE_xsd__boolean_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ReceiverStateInformation(struct soap *soap, const char *tag, int id, const struct tt__ReceiverStateInformation *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ReceiverStateInformation), type))
		return soap->error;
	if (soap_out_tt__ReceiverState(soap, "tt:State", -1, &a->State, ""))
		return soap->error;
	if (soap_out_xsd__boolean_(soap, "tt:AutoCreated", -1, &a->AutoCreated, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__ReceiverStateInformation * SOAP_FMAC4 soap_in_tt__ReceiverStateInformation(struct soap *soap, const char *tag, struct tt__ReceiverStateInformation *a, const char *type)
{
	size_t soap_flag_State = 1;
	size_t soap_flag_AutoCreated = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__ReceiverStateInformation *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ReceiverStateInformation, sizeof(struct tt__ReceiverStateInformation), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__ReceiverStateInformation(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_State && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_tt__ReceiverState(soap, "tt:State", &a->State, "tt:ReceiverState"))
				{	soap_flag_State--;
					continue;
				}
			if (soap_flag_AutoCreated && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean_(soap, "tt:AutoCreated", &a->AutoCreated, "xsd:boolean"))
				{	soap_flag_AutoCreated--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__ReceiverStateInformation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ReceiverStateInformation, 0, sizeof(struct tt__ReceiverStateInformation), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_State > 0 || soap_flag_AutoCreated > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ReceiverStateInformation(struct soap *soap, const struct tt__ReceiverStateInformation *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__ReceiverStateInformation);
	if (soap_out_tt__ReceiverStateInformation(soap, tag?tag:"tt:ReceiverStateInformation", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ReceiverStateInformation * SOAP_FMAC4 soap_get_tt__ReceiverStateInformation(struct soap *soap, struct tt__ReceiverStateInformation *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ReceiverStateInformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__ReceiverConfiguration(struct soap *soap, struct tt__ReceiverConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReceiverMode(soap, &a->Mode);
	soap_default_string(soap, &a->MediaUri);
	a->StreamSetup = NULL;
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__ReceiverConfiguration(struct soap *soap, const struct tt__ReceiverConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->MediaUri);
	soap_serialize_PointerTott__StreamSetup(soap, &a->StreamSetup);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ReceiverConfiguration(struct soap *soap, const char *tag, int id, const struct tt__ReceiverConfiguration *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ReceiverConfiguration), type))
		return soap->error;
	if (soap_out_tt__ReceiverMode(soap, "tt:Mode", -1, &a->Mode, ""))
		return soap->error;
	if (a->MediaUri)
	{	if (soap_out_string(soap, "tt:MediaUri", -1, &a->MediaUri, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:MediaUri"))
		return soap->error;
	if (a->StreamSetup)
	{	if (soap_out_PointerTott__StreamSetup(soap, "tt:StreamSetup", -1, &a->StreamSetup, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:StreamSetup"))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__ReceiverConfiguration * SOAP_FMAC4 soap_in_tt__ReceiverConfiguration(struct soap *soap, const char *tag, struct tt__ReceiverConfiguration *a, const char *type)
{
	size_t soap_flag_Mode = 1;
	size_t soap_flag_MediaUri = 1;
	size_t soap_flag_StreamSetup = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__ReceiverConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ReceiverConfiguration, sizeof(struct tt__ReceiverConfiguration), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__ReceiverConfiguration(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Mode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_tt__ReceiverMode(soap, "tt:Mode", &a->Mode, "tt:ReceiverMode"))
				{	soap_flag_Mode--;
					continue;
				}
			if (soap_flag_MediaUri && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "tt:MediaUri", &a->MediaUri, "xsd:string"))
				{	soap_flag_MediaUri--;
					continue;
				}
			if (soap_flag_StreamSetup && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__StreamSetup(soap, "tt:StreamSetup", &a->StreamSetup, "tt:StreamSetup"))
				{	soap_flag_StreamSetup--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__ReceiverConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ReceiverConfiguration, 0, sizeof(struct tt__ReceiverConfiguration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Mode > 0 || soap_flag_MediaUri > 0 || soap_flag_StreamSetup > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ReceiverConfiguration(struct soap *soap, const struct tt__ReceiverConfiguration *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__ReceiverConfiguration);
	if (soap_out_tt__ReceiverConfiguration(soap, tag?tag:"tt:ReceiverConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ReceiverConfiguration * SOAP_FMAC4 soap_get_tt__ReceiverConfiguration(struct soap *soap, struct tt__ReceiverConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ReceiverConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__Receiver(struct soap *soap, struct tt__Receiver *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->Token);
	a->Configuration = NULL;
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__Receiver(struct soap *soap, const struct tt__Receiver *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_tt__ReferenceToken(soap, &a->Token);
	soap_serialize_PointerTott__ReceiverConfiguration(soap, &a->Configuration);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Receiver(struct soap *soap, const char *tag, int id, const struct tt__Receiver *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Receiver), type))
		return soap->error;
	if (a->Token)
	{	if (soap_out_tt__ReferenceToken(soap, "tt:Token", -1, &a->Token, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:Token"))
		return soap->error;
	if (a->Configuration)
	{	if (soap_out_PointerTott__ReceiverConfiguration(soap, "tt:Configuration", -1, &a->Configuration, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:Configuration"))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__Receiver * SOAP_FMAC4 soap_in_tt__Receiver(struct soap *soap, const char *tag, struct tt__Receiver *a, const char *type)
{
	size_t soap_flag_Token = 1;
	size_t soap_flag_Configuration = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__Receiver *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Receiver, sizeof(struct tt__Receiver), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__Receiver(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Token && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "tt:Token", &a->Token, "tt:ReferenceToken"))
				{	soap_flag_Token--;
					continue;
				}
			if (soap_flag_Configuration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__ReceiverConfiguration(soap, "tt:Configuration", &a->Configuration, "tt:ReceiverConfiguration"))
				{	soap_flag_Configuration--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__Receiver *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Receiver, 0, sizeof(struct tt__Receiver), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Token > 0 || soap_flag_Configuration > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Receiver(struct soap *soap, const struct tt__Receiver *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__Receiver);
	if (soap_out_tt__Receiver(soap, tag?tag:"tt:Receiver", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Receiver * SOAP_FMAC4 soap_get_tt__Receiver(struct soap *soap, struct tt__Receiver *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Receiver(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__PaneOptionExtension(struct soap *soap, struct tt__PaneOptionExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__PaneOptionExtension(struct soap *soap, const struct tt__PaneOptionExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PaneOptionExtension(struct soap *soap, const char *tag, int id, const struct tt__PaneOptionExtension *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PaneOptionExtension), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__PaneOptionExtension * SOAP_FMAC4 soap_in_tt__PaneOptionExtension(struct soap *soap, const char *tag, struct tt__PaneOptionExtension *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__PaneOptionExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PaneOptionExtension, sizeof(struct tt__PaneOptionExtension), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__PaneOptionExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__PaneOptionExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PaneOptionExtension, 0, sizeof(struct tt__PaneOptionExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__PaneOptionExtension(struct soap *soap, const struct tt__PaneOptionExtension *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__PaneOptionExtension);
	if (soap_out_tt__PaneOptionExtension(soap, tag?tag:"tt:PaneOptionExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PaneOptionExtension * SOAP_FMAC4 soap_get_tt__PaneOptionExtension(struct soap *soap, struct tt__PaneOptionExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PaneOptionExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__LayoutOptionsExtension(struct soap *soap, struct tt__LayoutOptionsExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__LayoutOptionsExtension(struct soap *soap, const struct tt__LayoutOptionsExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__LayoutOptionsExtension(struct soap *soap, const char *tag, int id, const struct tt__LayoutOptionsExtension *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__LayoutOptionsExtension), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__LayoutOptionsExtension * SOAP_FMAC4 soap_in_tt__LayoutOptionsExtension(struct soap *soap, const char *tag, struct tt__LayoutOptionsExtension *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__LayoutOptionsExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__LayoutOptionsExtension, sizeof(struct tt__LayoutOptionsExtension), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__LayoutOptionsExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__LayoutOptionsExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__LayoutOptionsExtension, 0, sizeof(struct tt__LayoutOptionsExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__LayoutOptionsExtension(struct soap *soap, const struct tt__LayoutOptionsExtension *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__LayoutOptionsExtension);
	if (soap_out_tt__LayoutOptionsExtension(soap, tag?tag:"tt:LayoutOptionsExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__LayoutOptionsExtension * SOAP_FMAC4 soap_get_tt__LayoutOptionsExtension(struct soap *soap, struct tt__LayoutOptionsExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__LayoutOptionsExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__PaneLayoutOptions(struct soap *soap, struct tt__PaneLayoutOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeArea = 0;
	a->Area = NULL;
	a->Extension = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__PaneLayoutOptions(struct soap *soap, const struct tt__PaneLayoutOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->Area)
	{	int i;
		for (i = 0; i < a->__sizeArea; i++)
		{
			soap_embedded(soap, a->Area + i, SOAP_TYPE_tt__Rectangle);
			soap_serialize_tt__Rectangle(soap, a->Area + i);
		}
	}
	soap_serialize_PointerTott__PaneOptionExtension(soap, &a->Extension);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PaneLayoutOptions(struct soap *soap, const char *tag, int id, const struct tt__PaneLayoutOptions *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PaneLayoutOptions), type))
		return soap->error;
	if (a->Area)
	{	int i;
		for (i = 0; i < a->__sizeArea; i++)
			if (soap_out_tt__Rectangle(soap, "tt:Area", -1, a->Area + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTott__PaneOptionExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__PaneLayoutOptions * SOAP_FMAC4 soap_in_tt__PaneLayoutOptions(struct soap *soap, const char *tag, struct tt__PaneLayoutOptions *a, const char *type)
{
	struct soap_blist *soap_blist_Area = NULL;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__PaneLayoutOptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PaneLayoutOptions, sizeof(struct tt__PaneLayoutOptions), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__PaneLayoutOptions(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Area", 1, NULL))
			{	if (a->Area == NULL)
				{	if (soap_blist_Area == NULL)
						soap_blist_Area = soap_new_block(soap);
					a->Area = (struct tt__Rectangle *)soap_push_block(soap, soap_blist_Area, sizeof(struct tt__Rectangle));
					if (a->Area == NULL)
						return NULL;
					soap_default_tt__Rectangle(soap, a->Area);
				}
				soap_revert(soap);
				if (soap_in_tt__Rectangle(soap, "tt:Area", a->Area, "tt:Rectangle"))
				{	a->__sizeArea++;
					a->Area = NULL;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__PaneOptionExtension(soap, "tt:Extension", &a->Extension, "tt:PaneOptionExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Area)
			soap_pop_block(soap, soap_blist_Area);
		if (a->__sizeArea)
			a->Area = (struct tt__Rectangle *)soap_save_block(soap, soap_blist_Area, NULL, 1);
		else
		{	a->Area = NULL;
			if (soap_blist_Area)
				soap_end_block(soap, soap_blist_Area);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__PaneLayoutOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PaneLayoutOptions, 0, sizeof(struct tt__PaneLayoutOptions), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeArea < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__PaneLayoutOptions(struct soap *soap, const struct tt__PaneLayoutOptions *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__PaneLayoutOptions);
	if (soap_out_tt__PaneLayoutOptions(soap, tag?tag:"tt:PaneLayoutOptions", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PaneLayoutOptions * SOAP_FMAC4 soap_get_tt__PaneLayoutOptions(struct soap *soap, struct tt__PaneLayoutOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PaneLayoutOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__LayoutOptions(struct soap *soap, struct tt__LayoutOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizePaneLayoutOptions = 0;
	a->PaneLayoutOptions = NULL;
	a->Extension = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__LayoutOptions(struct soap *soap, const struct tt__LayoutOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->PaneLayoutOptions)
	{	int i;
		for (i = 0; i < a->__sizePaneLayoutOptions; i++)
		{
			soap_embedded(soap, a->PaneLayoutOptions + i, SOAP_TYPE_tt__PaneLayoutOptions);
			soap_serialize_tt__PaneLayoutOptions(soap, a->PaneLayoutOptions + i);
		}
	}
	soap_serialize_PointerTott__LayoutOptionsExtension(soap, &a->Extension);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__LayoutOptions(struct soap *soap, const char *tag, int id, const struct tt__LayoutOptions *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__LayoutOptions), type))
		return soap->error;
	if (a->PaneLayoutOptions)
	{	int i;
		for (i = 0; i < a->__sizePaneLayoutOptions; i++)
			if (soap_out_tt__PaneLayoutOptions(soap, "tt:PaneLayoutOptions", -1, a->PaneLayoutOptions + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTott__LayoutOptionsExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__LayoutOptions * SOAP_FMAC4 soap_in_tt__LayoutOptions(struct soap *soap, const char *tag, struct tt__LayoutOptions *a, const char *type)
{
	struct soap_blist *soap_blist_PaneLayoutOptions = NULL;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__LayoutOptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__LayoutOptions, sizeof(struct tt__LayoutOptions), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__LayoutOptions(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:PaneLayoutOptions", 1, NULL))
			{	if (a->PaneLayoutOptions == NULL)
				{	if (soap_blist_PaneLayoutOptions == NULL)
						soap_blist_PaneLayoutOptions = soap_new_block(soap);
					a->PaneLayoutOptions = (struct tt__PaneLayoutOptions *)soap_push_block(soap, soap_blist_PaneLayoutOptions, sizeof(struct tt__PaneLayoutOptions));
					if (a->PaneLayoutOptions == NULL)
						return NULL;
					soap_default_tt__PaneLayoutOptions(soap, a->PaneLayoutOptions);
				}
				soap_revert(soap);
				if (soap_in_tt__PaneLayoutOptions(soap, "tt:PaneLayoutOptions", a->PaneLayoutOptions, "tt:PaneLayoutOptions"))
				{	a->__sizePaneLayoutOptions++;
					a->PaneLayoutOptions = NULL;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__LayoutOptionsExtension(soap, "tt:Extension", &a->Extension, "tt:LayoutOptionsExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->PaneLayoutOptions)
			soap_pop_block(soap, soap_blist_PaneLayoutOptions);
		if (a->__sizePaneLayoutOptions)
			a->PaneLayoutOptions = (struct tt__PaneLayoutOptions *)soap_save_block(soap, soap_blist_PaneLayoutOptions, NULL, 1);
		else
		{	a->PaneLayoutOptions = NULL;
			if (soap_blist_PaneLayoutOptions)
				soap_end_block(soap, soap_blist_PaneLayoutOptions);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__LayoutOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__LayoutOptions, 0, sizeof(struct tt__LayoutOptions), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->__sizePaneLayoutOptions < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__LayoutOptions(struct soap *soap, const struct tt__LayoutOptions *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__LayoutOptions);
	if (soap_out_tt__LayoutOptions(soap, tag?tag:"tt:LayoutOptions", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__LayoutOptions * SOAP_FMAC4 soap_get_tt__LayoutOptions(struct soap *soap, struct tt__LayoutOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__LayoutOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__CodingCapabilities(struct soap *soap, struct tt__CodingCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->AudioEncodingCapabilities = NULL;
	a->AudioDecodingCapabilities = NULL;
	a->VideoDecodingCapabilities = NULL;
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__CodingCapabilities(struct soap *soap, const struct tt__CodingCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTott__AudioEncoderConfigurationOptions(soap, &a->AudioEncodingCapabilities);
	soap_serialize_PointerTott__AudioDecoderConfigurationOptions(soap, &a->AudioDecodingCapabilities);
	soap_serialize_PointerTott__VideoDecoderConfigurationOptions(soap, &a->VideoDecodingCapabilities);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__CodingCapabilities(struct soap *soap, const char *tag, int id, const struct tt__CodingCapabilities *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__CodingCapabilities), type))
		return soap->error;
	if (soap_out_PointerTott__AudioEncoderConfigurationOptions(soap, "tt:AudioEncodingCapabilities", -1, &a->AudioEncodingCapabilities, ""))
		return soap->error;
	if (soap_out_PointerTott__AudioDecoderConfigurationOptions(soap, "tt:AudioDecodingCapabilities", -1, &a->AudioDecodingCapabilities, ""))
		return soap->error;
	if (a->VideoDecodingCapabilities)
	{	if (soap_out_PointerTott__VideoDecoderConfigurationOptions(soap, "tt:VideoDecodingCapabilities", -1, &a->VideoDecodingCapabilities, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:VideoDecodingCapabilities"))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__CodingCapabilities * SOAP_FMAC4 soap_in_tt__CodingCapabilities(struct soap *soap, const char *tag, struct tt__CodingCapabilities *a, const char *type)
{
	size_t soap_flag_AudioEncodingCapabilities = 1;
	size_t soap_flag_AudioDecodingCapabilities = 1;
	size_t soap_flag_VideoDecodingCapabilities = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__CodingCapabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__CodingCapabilities, sizeof(struct tt__CodingCapabilities), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__CodingCapabilities(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_AudioEncodingCapabilities && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__AudioEncoderConfigurationOptions(soap, "tt:AudioEncodingCapabilities", &a->AudioEncodingCapabilities, "tt:AudioEncoderConfigurationOptions"))
				{	soap_flag_AudioEncodingCapabilities--;
					continue;
				}
			if (soap_flag_AudioDecodingCapabilities && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__AudioDecoderConfigurationOptions(soap, "tt:AudioDecodingCapabilities", &a->AudioDecodingCapabilities, "tt:AudioDecoderConfigurationOptions"))
				{	soap_flag_AudioDecodingCapabilities--;
					continue;
				}
			if (soap_flag_VideoDecodingCapabilities && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__VideoDecoderConfigurationOptions(soap, "tt:VideoDecodingCapabilities", &a->VideoDecodingCapabilities, "tt:VideoDecoderConfigurationOptions"))
				{	soap_flag_VideoDecodingCapabilities--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__CodingCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__CodingCapabilities, 0, sizeof(struct tt__CodingCapabilities), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_VideoDecodingCapabilities > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__CodingCapabilities(struct soap *soap, const struct tt__CodingCapabilities *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__CodingCapabilities);
	if (soap_out_tt__CodingCapabilities(soap, tag?tag:"tt:CodingCapabilities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__CodingCapabilities * SOAP_FMAC4 soap_get_tt__CodingCapabilities(struct soap *soap, struct tt__CodingCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__CodingCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__LayoutExtension(struct soap *soap, struct tt__LayoutExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__LayoutExtension(struct soap *soap, const struct tt__LayoutExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__LayoutExtension(struct soap *soap, const char *tag, int id, const struct tt__LayoutExtension *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__LayoutExtension), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__LayoutExtension * SOAP_FMAC4 soap_in_tt__LayoutExtension(struct soap *soap, const char *tag, struct tt__LayoutExtension *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__LayoutExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__LayoutExtension, sizeof(struct tt__LayoutExtension), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__LayoutExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__LayoutExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__LayoutExtension, 0, sizeof(struct tt__LayoutExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__LayoutExtension(struct soap *soap, const struct tt__LayoutExtension *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__LayoutExtension);
	if (soap_out_tt__LayoutExtension(soap, tag?tag:"tt:LayoutExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__LayoutExtension * SOAP_FMAC4 soap_get_tt__LayoutExtension(struct soap *soap, struct tt__LayoutExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__LayoutExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__Layout(struct soap *soap, struct tt__Layout *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizePaneLayout = 0;
	a->PaneLayout = NULL;
	a->Extension = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__Layout(struct soap *soap, const struct tt__Layout *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->PaneLayout)
	{	int i;
		for (i = 0; i < a->__sizePaneLayout; i++)
		{
			soap_embedded(soap, a->PaneLayout + i, SOAP_TYPE_tt__PaneLayout);
			soap_serialize_tt__PaneLayout(soap, a->PaneLayout + i);
		}
	}
	soap_serialize_PointerTott__LayoutExtension(soap, &a->Extension);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Layout(struct soap *soap, const char *tag, int id, const struct tt__Layout *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Layout), type))
		return soap->error;
	if (a->PaneLayout)
	{	int i;
		for (i = 0; i < a->__sizePaneLayout; i++)
			if (soap_out_tt__PaneLayout(soap, "tt:PaneLayout", -1, a->PaneLayout + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTott__LayoutExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__Layout * SOAP_FMAC4 soap_in_tt__Layout(struct soap *soap, const char *tag, struct tt__Layout *a, const char *type)
{
	struct soap_blist *soap_blist_PaneLayout = NULL;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__Layout *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Layout, sizeof(struct tt__Layout), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__Layout(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:PaneLayout", 1, NULL))
			{	if (a->PaneLayout == NULL)
				{	if (soap_blist_PaneLayout == NULL)
						soap_blist_PaneLayout = soap_new_block(soap);
					a->PaneLayout = (struct tt__PaneLayout *)soap_push_block(soap, soap_blist_PaneLayout, sizeof(struct tt__PaneLayout));
					if (a->PaneLayout == NULL)
						return NULL;
					soap_default_tt__PaneLayout(soap, a->PaneLayout);
				}
				soap_revert(soap);
				if (soap_in_tt__PaneLayout(soap, "tt:PaneLayout", a->PaneLayout, "tt:PaneLayout"))
				{	a->__sizePaneLayout++;
					a->PaneLayout = NULL;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__LayoutExtension(soap, "tt:Extension", &a->Extension, "tt:LayoutExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->PaneLayout)
			soap_pop_block(soap, soap_blist_PaneLayout);
		if (a->__sizePaneLayout)
			a->PaneLayout = (struct tt__PaneLayout *)soap_save_block(soap, soap_blist_PaneLayout, NULL, 1);
		else
		{	a->PaneLayout = NULL;
			if (soap_blist_PaneLayout)
				soap_end_block(soap, soap_blist_PaneLayout);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__Layout *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Layout, 0, sizeof(struct tt__Layout), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->__sizePaneLayout < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Layout(struct soap *soap, const struct tt__Layout *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__Layout);
	if (soap_out_tt__Layout(soap, tag?tag:"tt:Layout", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Layout * SOAP_FMAC4 soap_get_tt__Layout(struct soap *soap, struct tt__Layout *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Layout(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__PaneLayout(struct soap *soap, struct tt__PaneLayout *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->Pane);
	a->Area = NULL;
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__PaneLayout(struct soap *soap, const struct tt__PaneLayout *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_tt__ReferenceToken(soap, &a->Pane);
	soap_serialize_PointerTott__Rectangle(soap, &a->Area);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PaneLayout(struct soap *soap, const char *tag, int id, const struct tt__PaneLayout *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PaneLayout), type))
		return soap->error;
	if (a->Pane)
	{	if (soap_out_tt__ReferenceToken(soap, "tt:Pane", -1, &a->Pane, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:Pane"))
		return soap->error;
	if (a->Area)
	{	if (soap_out_PointerTott__Rectangle(soap, "tt:Area", -1, &a->Area, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:Area"))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__PaneLayout * SOAP_FMAC4 soap_in_tt__PaneLayout(struct soap *soap, const char *tag, struct tt__PaneLayout *a, const char *type)
{
	size_t soap_flag_Pane = 1;
	size_t soap_flag_Area = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__PaneLayout *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PaneLayout, sizeof(struct tt__PaneLayout), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__PaneLayout(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Pane && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "tt:Pane", &a->Pane, "tt:ReferenceToken"))
				{	soap_flag_Pane--;
					continue;
				}
			if (soap_flag_Area && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__Rectangle(soap, "tt:Area", &a->Area, "tt:Rectangle"))
				{	soap_flag_Area--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__PaneLayout *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PaneLayout, 0, sizeof(struct tt__PaneLayout), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Pane > 0 || soap_flag_Area > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__PaneLayout(struct soap *soap, const struct tt__PaneLayout *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__PaneLayout);
	if (soap_out_tt__PaneLayout(soap, tag?tag:"tt:PaneLayout", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PaneLayout * SOAP_FMAC4 soap_get_tt__PaneLayout(struct soap *soap, struct tt__PaneLayout *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PaneLayout(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__PaneConfiguration(struct soap *soap, struct tt__PaneConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->PaneName);
	soap_default_tt__ReferenceToken(soap, &a->AudioOutputToken);
	soap_default_tt__ReferenceToken(soap, &a->AudioSourceToken);
	a->AudioEncoderConfiguration = NULL;
	soap_default_tt__ReferenceToken(soap, &a->ReceiverToken);
	soap_default_tt__ReferenceToken(soap, &a->Token);
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__PaneConfiguration(struct soap *soap, const struct tt__PaneConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->PaneName);
	soap_serialize_tt__ReferenceToken(soap, &a->AudioOutputToken);
	soap_serialize_tt__ReferenceToken(soap, &a->AudioSourceToken);
	soap_serialize_PointerTott__AudioEncoderConfiguration(soap, &a->AudioEncoderConfiguration);
	soap_serialize_tt__ReferenceToken(soap, &a->ReceiverToken);
	soap_serialize_tt__ReferenceToken(soap, &a->Token);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PaneConfiguration(struct soap *soap, const char *tag, int id, const struct tt__PaneConfiguration *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PaneConfiguration), type))
		return soap->error;
	if (soap_out_string(soap, "tt:PaneName", -1, &a->PaneName, ""))
		return soap->error;
	if (soap_out_tt__ReferenceToken(soap, "tt:AudioOutputToken", -1, &a->AudioOutputToken, ""))
		return soap->error;
	if (soap_out_tt__ReferenceToken(soap, "tt:AudioSourceToken", -1, &a->AudioSourceToken, ""))
		return soap->error;
	if (soap_out_PointerTott__AudioEncoderConfiguration(soap, "tt:AudioEncoderConfiguration", -1, &a->AudioEncoderConfiguration, ""))
		return soap->error;
	if (soap_out_tt__ReferenceToken(soap, "tt:ReceiverToken", -1, &a->ReceiverToken, ""))
		return soap->error;
	if (a->Token)
	{	if (soap_out_tt__ReferenceToken(soap, "tt:Token", -1, &a->Token, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:Token"))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__PaneConfiguration * SOAP_FMAC4 soap_in_tt__PaneConfiguration(struct soap *soap, const char *tag, struct tt__PaneConfiguration *a, const char *type)
{
	size_t soap_flag_PaneName = 1;
	size_t soap_flag_AudioOutputToken = 1;
	size_t soap_flag_AudioSourceToken = 1;
	size_t soap_flag_AudioEncoderConfiguration = 1;
	size_t soap_flag_ReceiverToken = 1;
	size_t soap_flag_Token = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__PaneConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PaneConfiguration, sizeof(struct tt__PaneConfiguration), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__PaneConfiguration(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_PaneName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "tt:PaneName", &a->PaneName, "xsd:string"))
				{	soap_flag_PaneName--;
					continue;
				}
			if (soap_flag_AudioOutputToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "tt:AudioOutputToken", &a->AudioOutputToken, "tt:ReferenceToken"))
				{	soap_flag_AudioOutputToken--;
					continue;
				}
			if (soap_flag_AudioSourceToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "tt:AudioSourceToken", &a->AudioSourceToken, "tt:ReferenceToken"))
				{	soap_flag_AudioSourceToken--;
					continue;
				}
			if (soap_flag_AudioEncoderConfiguration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__AudioEncoderConfiguration(soap, "tt:AudioEncoderConfiguration", &a->AudioEncoderConfiguration, "tt:AudioEncoderConfiguration"))
				{	soap_flag_AudioEncoderConfiguration--;
					continue;
				}
			if (soap_flag_ReceiverToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "tt:ReceiverToken", &a->ReceiverToken, "tt:ReferenceToken"))
				{	soap_flag_ReceiverToken--;
					continue;
				}
			if (soap_flag_Token && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "tt:Token", &a->Token, "tt:ReferenceToken"))
				{	soap_flag_Token--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__PaneConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PaneConfiguration, 0, sizeof(struct tt__PaneConfiguration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Token > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__PaneConfiguration(struct soap *soap, const struct tt__PaneConfiguration *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__PaneConfiguration);
	if (soap_out_tt__PaneConfiguration(soap, tag?tag:"tt:PaneConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PaneConfiguration * SOAP_FMAC4 soap_get_tt__PaneConfiguration(struct soap *soap, struct tt__PaneConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PaneConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__EventStreamExtension(struct soap *soap, struct tt__EventStreamExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__EventStreamExtension(struct soap *soap, const struct tt__EventStreamExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__EventStreamExtension(struct soap *soap, const char *tag, int id, const struct tt__EventStreamExtension *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__EventStreamExtension), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__EventStreamExtension * SOAP_FMAC4 soap_in_tt__EventStreamExtension(struct soap *soap, const char *tag, struct tt__EventStreamExtension *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__EventStreamExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__EventStreamExtension, sizeof(struct tt__EventStreamExtension), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__EventStreamExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__EventStreamExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__EventStreamExtension, 0, sizeof(struct tt__EventStreamExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__EventStreamExtension(struct soap *soap, const struct tt__EventStreamExtension *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__EventStreamExtension);
	if (soap_out_tt__EventStreamExtension(soap, tag?tag:"tt:EventStreamExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__EventStreamExtension * SOAP_FMAC4 soap_get_tt__EventStreamExtension(struct soap *soap, struct tt__EventStreamExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__EventStreamExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsnt__NotificationMessageHolderType(struct soap *soap, struct wsnt__NotificationMessageHolderType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->SubscriptionReference = NULL;
	a->Topic = NULL;
	a->ProducerReference = NULL;
	soap_default__wsnt__NotificationMessageHolderType_Message(soap, &a->Message);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsnt__NotificationMessageHolderType(struct soap *soap, const struct wsnt__NotificationMessageHolderType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTowsa5__EndpointReferenceType(soap, &a->SubscriptionReference);
	soap_serialize_PointerTowsnt__TopicExpressionType(soap, &a->Topic);
	soap_serialize_PointerTowsa5__EndpointReferenceType(soap, &a->ProducerReference);
	soap_serialize__wsnt__NotificationMessageHolderType_Message(soap, &a->Message);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__NotificationMessageHolderType(struct soap *soap, const char *tag, int id, const struct wsnt__NotificationMessageHolderType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsnt__NotificationMessageHolderType), type))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "wsnt:SubscriptionReference", -1, &a->SubscriptionReference, ""))
		return soap->error;
	if (soap_out_PointerTowsnt__TopicExpressionType(soap, "wsnt:Topic", -1, &a->Topic, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "wsnt:ProducerReference", -1, &a->ProducerReference, ""))
		return soap->error;
	if (soap_out__wsnt__NotificationMessageHolderType_Message(soap, "wsnt:Message", -1, &a->Message, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsnt__NotificationMessageHolderType * SOAP_FMAC4 soap_in_wsnt__NotificationMessageHolderType(struct soap *soap, const char *tag, struct wsnt__NotificationMessageHolderType *a, const char *type)
{
	size_t soap_flag_SubscriptionReference = 1;
	size_t soap_flag_Topic = 1;
	size_t soap_flag_ProducerReference = 1;
	size_t soap_flag_Message = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wsnt__NotificationMessageHolderType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsnt__NotificationMessageHolderType, sizeof(struct wsnt__NotificationMessageHolderType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsnt__NotificationMessageHolderType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SubscriptionReference && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "wsnt:SubscriptionReference", &a->SubscriptionReference, "wsa5:EndpointReferenceType"))
				{	soap_flag_SubscriptionReference--;
					continue;
				}
			if (soap_flag_Topic && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsnt__TopicExpressionType(soap, "wsnt:Topic", &a->Topic, "wsnt:TopicExpressionType"))
				{	soap_flag_Topic--;
					continue;
				}
			if (soap_flag_ProducerReference && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "wsnt:ProducerReference", &a->ProducerReference, "wsa5:EndpointReferenceType"))
				{	soap_flag_ProducerReference--;
					continue;
				}
			if (soap_flag_Message && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in__wsnt__NotificationMessageHolderType_Message(soap, "wsnt:Message", &a->Message, ""))
				{	soap_flag_Message--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wsnt__NotificationMessageHolderType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnt__NotificationMessageHolderType, 0, sizeof(struct wsnt__NotificationMessageHolderType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Message > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsnt__NotificationMessageHolderType(struct soap *soap, const struct wsnt__NotificationMessageHolderType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wsnt__NotificationMessageHolderType);
	if (soap_out_wsnt__NotificationMessageHolderType(soap, tag?tag:"wsnt:NotificationMessageHolderType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsnt__NotificationMessageHolderType * SOAP_FMAC4 soap_get_wsnt__NotificationMessageHolderType(struct soap *soap, struct wsnt__NotificationMessageHolderType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnt__NotificationMessageHolderType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tt__union_EventStream(struct soap *soap, struct __tt__union_EventStream *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__union_EventStream = 0;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tt__union_EventStream(struct soap *soap, const struct __tt__union_EventStream *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__tt__union_EventStream(soap, a->__union_EventStream, &a->union_EventStream);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tt__union_EventStream(struct soap *soap, const char *tag, int id, const struct __tt__union_EventStream *a, const char *type)
{
	if (soap_out__tt__union_EventStream(soap, a->__union_EventStream, &a->union_EventStream))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tt__union_EventStream * SOAP_FMAC4 soap_in___tt__union_EventStream(struct soap *soap, const char *tag, struct __tt__union_EventStream *a, const char *type)
{
	a = (struct __tt__union_EventStream *)soap_id_enter(soap, "", a, SOAP_TYPE___tt__union_EventStream, sizeof(struct __tt__union_EventStream), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tt__union_EventStream(soap, a);
		if (!soap_in__tt__union_EventStream(soap, &a->__union_EventStream, &a->union_EventStream))
			return NULL;
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tt__union_EventStream(struct soap *soap, const struct __tt__union_EventStream *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tt__union_EventStream(soap, tag?tag:"-tt:union-EventStream", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tt__union_EventStream * SOAP_FMAC4 soap_get___tt__union_EventStream(struct soap *soap, struct __tt__union_EventStream *p, const char *tag, const char *type)
{
	if ((p = soap_in___tt__union_EventStream(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__PTZStreamExtension(struct soap *soap, struct tt__PTZStreamExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__PTZStreamExtension(struct soap *soap, const struct tt__PTZStreamExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZStreamExtension(struct soap *soap, const char *tag, int id, const struct tt__PTZStreamExtension *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTZStreamExtension), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__PTZStreamExtension * SOAP_FMAC4 soap_in_tt__PTZStreamExtension(struct soap *soap, const char *tag, struct tt__PTZStreamExtension *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__PTZStreamExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZStreamExtension, sizeof(struct tt__PTZStreamExtension), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__PTZStreamExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__PTZStreamExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZStreamExtension, 0, sizeof(struct tt__PTZStreamExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__PTZStreamExtension(struct soap *soap, const struct tt__PTZStreamExtension *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__PTZStreamExtension);
	if (soap_out_tt__PTZStreamExtension(soap, tag?tag:"tt:PTZStreamExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PTZStreamExtension * SOAP_FMAC4 soap_get_tt__PTZStreamExtension(struct soap *soap, struct tt__PTZStreamExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTZStreamExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tt__union_PTZStream(struct soap *soap, struct __tt__union_PTZStream *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__union_PTZStream = 0;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tt__union_PTZStream(struct soap *soap, const struct __tt__union_PTZStream *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__tt__union_PTZStream(soap, a->__union_PTZStream, &a->union_PTZStream);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tt__union_PTZStream(struct soap *soap, const char *tag, int id, const struct __tt__union_PTZStream *a, const char *type)
{
	if (soap_out__tt__union_PTZStream(soap, a->__union_PTZStream, &a->union_PTZStream))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tt__union_PTZStream * SOAP_FMAC4 soap_in___tt__union_PTZStream(struct soap *soap, const char *tag, struct __tt__union_PTZStream *a, const char *type)
{
	a = (struct __tt__union_PTZStream *)soap_id_enter(soap, "", a, SOAP_TYPE___tt__union_PTZStream, sizeof(struct __tt__union_PTZStream), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tt__union_PTZStream(soap, a);
		if (!soap_in__tt__union_PTZStream(soap, &a->__union_PTZStream, &a->union_PTZStream))
			return NULL;
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tt__union_PTZStream(struct soap *soap, const struct __tt__union_PTZStream *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tt__union_PTZStream(soap, tag?tag:"-tt:union-PTZStream", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tt__union_PTZStream * SOAP_FMAC4 soap_get___tt__union_PTZStream(struct soap *soap, struct __tt__union_PTZStream *p, const char *tag, const char *type)
{
	if ((p = soap_in___tt__union_PTZStream(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__VideoAnalyticsStreamExtension(struct soap *soap, struct tt__VideoAnalyticsStreamExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__VideoAnalyticsStreamExtension(struct soap *soap, const struct tt__VideoAnalyticsStreamExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__VideoAnalyticsStreamExtension(struct soap *soap, const char *tag, int id, const struct tt__VideoAnalyticsStreamExtension *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__VideoAnalyticsStreamExtension), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__VideoAnalyticsStreamExtension * SOAP_FMAC4 soap_in_tt__VideoAnalyticsStreamExtension(struct soap *soap, const char *tag, struct tt__VideoAnalyticsStreamExtension *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__VideoAnalyticsStreamExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__VideoAnalyticsStreamExtension, sizeof(struct tt__VideoAnalyticsStreamExtension), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__VideoAnalyticsStreamExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__VideoAnalyticsStreamExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__VideoAnalyticsStreamExtension, 0, sizeof(struct tt__VideoAnalyticsStreamExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__VideoAnalyticsStreamExtension(struct soap *soap, const struct tt__VideoAnalyticsStreamExtension *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__VideoAnalyticsStreamExtension);
	if (soap_out_tt__VideoAnalyticsStreamExtension(soap, tag?tag:"tt:VideoAnalyticsStreamExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__VideoAnalyticsStreamExtension * SOAP_FMAC4 soap_get_tt__VideoAnalyticsStreamExtension(struct soap *soap, struct tt__VideoAnalyticsStreamExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__VideoAnalyticsStreamExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tt__union_VideoAnalyticsStream(struct soap *soap, struct __tt__union_VideoAnalyticsStream *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__union_VideoAnalyticsStream = 0;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tt__union_VideoAnalyticsStream(struct soap *soap, const struct __tt__union_VideoAnalyticsStream *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__tt__union_VideoAnalyticsStream(soap, a->__union_VideoAnalyticsStream, &a->union_VideoAnalyticsStream);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tt__union_VideoAnalyticsStream(struct soap *soap, const char *tag, int id, const struct __tt__union_VideoAnalyticsStream *a, const char *type)
{
	if (soap_out__tt__union_VideoAnalyticsStream(soap, a->__union_VideoAnalyticsStream, &a->union_VideoAnalyticsStream))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tt__union_VideoAnalyticsStream * SOAP_FMAC4 soap_in___tt__union_VideoAnalyticsStream(struct soap *soap, const char *tag, struct __tt__union_VideoAnalyticsStream *a, const char *type)
{
	a = (struct __tt__union_VideoAnalyticsStream *)soap_id_enter(soap, "", a, SOAP_TYPE___tt__union_VideoAnalyticsStream, sizeof(struct __tt__union_VideoAnalyticsStream), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tt__union_VideoAnalyticsStream(soap, a);
		if (!soap_in__tt__union_VideoAnalyticsStream(soap, &a->__union_VideoAnalyticsStream, &a->union_VideoAnalyticsStream))
			return NULL;
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tt__union_VideoAnalyticsStream(struct soap *soap, const struct __tt__union_VideoAnalyticsStream *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tt__union_VideoAnalyticsStream(soap, tag?tag:"-tt:union-VideoAnalyticsStream", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tt__union_VideoAnalyticsStream * SOAP_FMAC4 soap_get___tt__union_VideoAnalyticsStream(struct soap *soap, struct __tt__union_VideoAnalyticsStream *p, const char *tag, const char *type)
{
	if ((p = soap_in___tt__union_VideoAnalyticsStream(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__MetadataStreamExtension(struct soap *soap, struct tt__MetadataStreamExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__MetadataStreamExtension(struct soap *soap, const struct tt__MetadataStreamExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__MetadataStreamExtension(struct soap *soap, const char *tag, int id, const struct tt__MetadataStreamExtension *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__MetadataStreamExtension), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__MetadataStreamExtension * SOAP_FMAC4 soap_in_tt__MetadataStreamExtension(struct soap *soap, const char *tag, struct tt__MetadataStreamExtension *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__MetadataStreamExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__MetadataStreamExtension, sizeof(struct tt__MetadataStreamExtension), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__MetadataStreamExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__MetadataStreamExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__MetadataStreamExtension, 0, sizeof(struct tt__MetadataStreamExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__MetadataStreamExtension(struct soap *soap, const struct tt__MetadataStreamExtension *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__MetadataStreamExtension);
	if (soap_out_tt__MetadataStreamExtension(soap, tag?tag:"tt:MetadataStreamExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__MetadataStreamExtension * SOAP_FMAC4 soap_get_tt__MetadataStreamExtension(struct soap *soap, struct tt__MetadataStreamExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__MetadataStreamExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__EventStream(struct soap *soap, struct tt__EventStream *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size_EventStream = 0;
	a->__union_EventStream = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__EventStream(struct soap *soap, const struct tt__EventStream *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->__union_EventStream)
	{	int i;
		for (i = 0; i < a->__size_EventStream; i++)
		{
			soap_serialize___tt__union_EventStream(soap, a->__union_EventStream + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__EventStream(struct soap *soap, const char *tag, int id, const struct tt__EventStream *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__EventStream), type))
		return soap->error;
	if (a->__union_EventStream)
	{	int i;
		for (i = 0; i < a->__size_EventStream; i++)
			if (soap_out___tt__union_EventStream(soap, "-union-EventStream", -1, a->__union_EventStream + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__EventStream * SOAP_FMAC4 soap_in_tt__EventStream(struct soap *soap, const char *tag, struct tt__EventStream *a, const char *type)
{
	struct soap_blist *soap_blist___union_EventStream = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__EventStream *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__EventStream, sizeof(struct tt__EventStream), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__EventStream(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__union_EventStream == NULL)
				{	if (soap_blist___union_EventStream == NULL)
						soap_blist___union_EventStream = soap_new_block(soap);
					a->__union_EventStream = (struct __tt__union_EventStream *)soap_push_block(soap, soap_blist___union_EventStream, sizeof(struct __tt__union_EventStream));
					if (a->__union_EventStream == NULL)
						return NULL;
					soap_default___tt__union_EventStream(soap, a->__union_EventStream);
				}
				if (soap_in___tt__union_EventStream(soap, "-union-EventStream", a->__union_EventStream, "-tt:union-EventStream"))
				{	a->__size_EventStream++;
					a->__union_EventStream = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__union_EventStream)
			soap_pop_block(soap, soap_blist___union_EventStream);
		if (a->__size_EventStream)
			a->__union_EventStream = (struct __tt__union_EventStream *)soap_save_block(soap, soap_blist___union_EventStream, NULL, 1);
		else
		{	a->__union_EventStream = NULL;
			if (soap_blist___union_EventStream)
				soap_end_block(soap, soap_blist___union_EventStream);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__EventStream *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__EventStream, 0, sizeof(struct tt__EventStream), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__EventStream(struct soap *soap, const struct tt__EventStream *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__EventStream);
	if (soap_out_tt__EventStream(soap, tag?tag:"tt:EventStream", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__EventStream * SOAP_FMAC4 soap_get_tt__EventStream(struct soap *soap, struct tt__EventStream *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__EventStream(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__PTZStream(struct soap *soap, struct tt__PTZStream *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size_PTZStream = 0;
	a->__union_PTZStream = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__PTZStream(struct soap *soap, const struct tt__PTZStream *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->__union_PTZStream)
	{	int i;
		for (i = 0; i < a->__size_PTZStream; i++)
		{
			soap_serialize___tt__union_PTZStream(soap, a->__union_PTZStream + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZStream(struct soap *soap, const char *tag, int id, const struct tt__PTZStream *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTZStream), type))
		return soap->error;
	if (a->__union_PTZStream)
	{	int i;
		for (i = 0; i < a->__size_PTZStream; i++)
			if (soap_out___tt__union_PTZStream(soap, "-union-PTZStream", -1, a->__union_PTZStream + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__PTZStream * SOAP_FMAC4 soap_in_tt__PTZStream(struct soap *soap, const char *tag, struct tt__PTZStream *a, const char *type)
{
	struct soap_blist *soap_blist___union_PTZStream = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__PTZStream *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZStream, sizeof(struct tt__PTZStream), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__PTZStream(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__union_PTZStream == NULL)
				{	if (soap_blist___union_PTZStream == NULL)
						soap_blist___union_PTZStream = soap_new_block(soap);
					a->__union_PTZStream = (struct __tt__union_PTZStream *)soap_push_block(soap, soap_blist___union_PTZStream, sizeof(struct __tt__union_PTZStream));
					if (a->__union_PTZStream == NULL)
						return NULL;
					soap_default___tt__union_PTZStream(soap, a->__union_PTZStream);
				}
				if (soap_in___tt__union_PTZStream(soap, "-union-PTZStream", a->__union_PTZStream, "-tt:union-PTZStream"))
				{	a->__size_PTZStream++;
					a->__union_PTZStream = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__union_PTZStream)
			soap_pop_block(soap, soap_blist___union_PTZStream);
		if (a->__size_PTZStream)
			a->__union_PTZStream = (struct __tt__union_PTZStream *)soap_save_block(soap, soap_blist___union_PTZStream, NULL, 1);
		else
		{	a->__union_PTZStream = NULL;
			if (soap_blist___union_PTZStream)
				soap_end_block(soap, soap_blist___union_PTZStream);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__PTZStream *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZStream, 0, sizeof(struct tt__PTZStream), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__PTZStream(struct soap *soap, const struct tt__PTZStream *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__PTZStream);
	if (soap_out_tt__PTZStream(soap, tag?tag:"tt:PTZStream", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PTZStream * SOAP_FMAC4 soap_get_tt__PTZStream(struct soap *soap, struct tt__PTZStream *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTZStream(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__VideoAnalyticsStream(struct soap *soap, struct tt__VideoAnalyticsStream *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size_VideoAnalyticsStream = 0;
	a->__union_VideoAnalyticsStream = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__VideoAnalyticsStream(struct soap *soap, const struct tt__VideoAnalyticsStream *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->__union_VideoAnalyticsStream)
	{	int i;
		for (i = 0; i < a->__size_VideoAnalyticsStream; i++)
		{
			soap_serialize___tt__union_VideoAnalyticsStream(soap, a->__union_VideoAnalyticsStream + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__VideoAnalyticsStream(struct soap *soap, const char *tag, int id, const struct tt__VideoAnalyticsStream *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__VideoAnalyticsStream), type))
		return soap->error;
	if (a->__union_VideoAnalyticsStream)
	{	int i;
		for (i = 0; i < a->__size_VideoAnalyticsStream; i++)
			if (soap_out___tt__union_VideoAnalyticsStream(soap, "-union-VideoAnalyticsStream", -1, a->__union_VideoAnalyticsStream + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__VideoAnalyticsStream * SOAP_FMAC4 soap_in_tt__VideoAnalyticsStream(struct soap *soap, const char *tag, struct tt__VideoAnalyticsStream *a, const char *type)
{
	struct soap_blist *soap_blist___union_VideoAnalyticsStream = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__VideoAnalyticsStream *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__VideoAnalyticsStream, sizeof(struct tt__VideoAnalyticsStream), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__VideoAnalyticsStream(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__union_VideoAnalyticsStream == NULL)
				{	if (soap_blist___union_VideoAnalyticsStream == NULL)
						soap_blist___union_VideoAnalyticsStream = soap_new_block(soap);
					a->__union_VideoAnalyticsStream = (struct __tt__union_VideoAnalyticsStream *)soap_push_block(soap, soap_blist___union_VideoAnalyticsStream, sizeof(struct __tt__union_VideoAnalyticsStream));
					if (a->__union_VideoAnalyticsStream == NULL)
						return NULL;
					soap_default___tt__union_VideoAnalyticsStream(soap, a->__union_VideoAnalyticsStream);
				}
				if (soap_in___tt__union_VideoAnalyticsStream(soap, "-union-VideoAnalyticsStream", a->__union_VideoAnalyticsStream, "-tt:union-VideoAnalyticsStream"))
				{	a->__size_VideoAnalyticsStream++;
					a->__union_VideoAnalyticsStream = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__union_VideoAnalyticsStream)
			soap_pop_block(soap, soap_blist___union_VideoAnalyticsStream);
		if (a->__size_VideoAnalyticsStream)
			a->__union_VideoAnalyticsStream = (struct __tt__union_VideoAnalyticsStream *)soap_save_block(soap, soap_blist___union_VideoAnalyticsStream, NULL, 1);
		else
		{	a->__union_VideoAnalyticsStream = NULL;
			if (soap_blist___union_VideoAnalyticsStream)
				soap_end_block(soap, soap_blist___union_VideoAnalyticsStream);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__VideoAnalyticsStream *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__VideoAnalyticsStream, 0, sizeof(struct tt__VideoAnalyticsStream), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__VideoAnalyticsStream(struct soap *soap, const struct tt__VideoAnalyticsStream *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__VideoAnalyticsStream);
	if (soap_out_tt__VideoAnalyticsStream(soap, tag?tag:"tt:VideoAnalyticsStream", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__VideoAnalyticsStream * SOAP_FMAC4 soap_get_tt__VideoAnalyticsStream(struct soap *soap, struct tt__VideoAnalyticsStream *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__VideoAnalyticsStream(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tt__union_MetadataStream(struct soap *soap, struct __tt__union_MetadataStream *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__union_MetadataStream = 0;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tt__union_MetadataStream(struct soap *soap, const struct __tt__union_MetadataStream *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__tt__union_MetadataStream(soap, a->__union_MetadataStream, &a->union_MetadataStream);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tt__union_MetadataStream(struct soap *soap, const char *tag, int id, const struct __tt__union_MetadataStream *a, const char *type)
{
	if (soap_out__tt__union_MetadataStream(soap, a->__union_MetadataStream, &a->union_MetadataStream))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tt__union_MetadataStream * SOAP_FMAC4 soap_in___tt__union_MetadataStream(struct soap *soap, const char *tag, struct __tt__union_MetadataStream *a, const char *type)
{
	a = (struct __tt__union_MetadataStream *)soap_id_enter(soap, "", a, SOAP_TYPE___tt__union_MetadataStream, sizeof(struct __tt__union_MetadataStream), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tt__union_MetadataStream(soap, a);
		if (!soap_in__tt__union_MetadataStream(soap, &a->__union_MetadataStream, &a->union_MetadataStream))
			return NULL;
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tt__union_MetadataStream(struct soap *soap, const struct __tt__union_MetadataStream *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tt__union_MetadataStream(soap, tag?tag:"-tt:union-MetadataStream", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tt__union_MetadataStream * SOAP_FMAC4 soap_get___tt__union_MetadataStream(struct soap *soap, struct __tt__union_MetadataStream *p, const char *tag, const char *type)
{
	if ((p = soap_in___tt__union_MetadataStream(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__MetadataStream(struct soap *soap, struct tt__MetadataStream *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size_MetadataStream = 0;
	a->__union_MetadataStream = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__MetadataStream(struct soap *soap, const struct tt__MetadataStream *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->__union_MetadataStream)
	{	int i;
		for (i = 0; i < a->__size_MetadataStream; i++)
		{
			soap_serialize___tt__union_MetadataStream(soap, a->__union_MetadataStream + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__MetadataStream(struct soap *soap, const char *tag, int id, const struct tt__MetadataStream *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__MetadataStream), type))
		return soap->error;
	if (a->__union_MetadataStream)
	{	int i;
		for (i = 0; i < a->__size_MetadataStream; i++)
			if (soap_out___tt__union_MetadataStream(soap, "-union-MetadataStream", -1, a->__union_MetadataStream + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__MetadataStream * SOAP_FMAC4 soap_in_tt__MetadataStream(struct soap *soap, const char *tag, struct tt__MetadataStream *a, const char *type)
{
	struct soap_blist *soap_blist___union_MetadataStream = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__MetadataStream *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__MetadataStream, sizeof(struct tt__MetadataStream), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__MetadataStream(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__union_MetadataStream == NULL)
				{	if (soap_blist___union_MetadataStream == NULL)
						soap_blist___union_MetadataStream = soap_new_block(soap);
					a->__union_MetadataStream = (struct __tt__union_MetadataStream *)soap_push_block(soap, soap_blist___union_MetadataStream, sizeof(struct __tt__union_MetadataStream));
					if (a->__union_MetadataStream == NULL)
						return NULL;
					soap_default___tt__union_MetadataStream(soap, a->__union_MetadataStream);
				}
				if (soap_in___tt__union_MetadataStream(soap, "-union-MetadataStream", a->__union_MetadataStream, "-tt:union-MetadataStream"))
				{	a->__size_MetadataStream++;
					a->__union_MetadataStream = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__union_MetadataStream)
			soap_pop_block(soap, soap_blist___union_MetadataStream);
		if (a->__size_MetadataStream)
			a->__union_MetadataStream = (struct __tt__union_MetadataStream *)soap_save_block(soap, soap_blist___union_MetadataStream, NULL, 1);
		else
		{	a->__union_MetadataStream = NULL;
			if (soap_blist___union_MetadataStream)
				soap_end_block(soap, soap_blist___union_MetadataStream);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__MetadataStream *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__MetadataStream, 0, sizeof(struct tt__MetadataStream), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__MetadataStream(struct soap *soap, const struct tt__MetadataStream *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__MetadataStream);
	if (soap_out_tt__MetadataStream(soap, tag?tag:"tt:MetadataStream", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__MetadataStream * SOAP_FMAC4 soap_get_tt__MetadataStream(struct soap *soap, struct tt__MetadataStream *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__MetadataStream(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__SupportedAnalyticsModulesExtension(struct soap *soap, struct tt__SupportedAnalyticsModulesExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__SupportedAnalyticsModulesExtension(struct soap *soap, const struct tt__SupportedAnalyticsModulesExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__SupportedAnalyticsModulesExtension(struct soap *soap, const char *tag, int id, const struct tt__SupportedAnalyticsModulesExtension *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__SupportedAnalyticsModulesExtension), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__SupportedAnalyticsModulesExtension * SOAP_FMAC4 soap_in_tt__SupportedAnalyticsModulesExtension(struct soap *soap, const char *tag, struct tt__SupportedAnalyticsModulesExtension *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__SupportedAnalyticsModulesExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__SupportedAnalyticsModulesExtension, sizeof(struct tt__SupportedAnalyticsModulesExtension), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__SupportedAnalyticsModulesExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__SupportedAnalyticsModulesExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__SupportedAnalyticsModulesExtension, 0, sizeof(struct tt__SupportedAnalyticsModulesExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__SupportedAnalyticsModulesExtension(struct soap *soap, const struct tt__SupportedAnalyticsModulesExtension *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__SupportedAnalyticsModulesExtension);
	if (soap_out_tt__SupportedAnalyticsModulesExtension(soap, tag?tag:"tt:SupportedAnalyticsModulesExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__SupportedAnalyticsModulesExtension * SOAP_FMAC4 soap_get_tt__SupportedAnalyticsModulesExtension(struct soap *soap, struct tt__SupportedAnalyticsModulesExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__SupportedAnalyticsModulesExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__SupportedAnalyticsModules(struct soap *soap, struct tt__SupportedAnalyticsModules *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeAnalyticsModuleContentSchemaLocation = 0;
	a->AnalyticsModuleContentSchemaLocation = NULL;
	a->__sizeAnalyticsModuleDescription = 0;
	a->AnalyticsModuleDescription = NULL;
	a->Extension = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__SupportedAnalyticsModules(struct soap *soap, const struct tt__SupportedAnalyticsModules *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->AnalyticsModuleContentSchemaLocation)
	{	int i;
		for (i = 0; i < a->__sizeAnalyticsModuleContentSchemaLocation; i++)
		{
			soap_serialize_string(soap, a->AnalyticsModuleContentSchemaLocation + i);
		}
	}
	if (a->AnalyticsModuleDescription)
	{	int i;
		for (i = 0; i < a->__sizeAnalyticsModuleDescription; i++)
		{
			soap_embedded(soap, a->AnalyticsModuleDescription + i, SOAP_TYPE_tt__ConfigDescription);
			soap_serialize_tt__ConfigDescription(soap, a->AnalyticsModuleDescription + i);
		}
	}
	soap_serialize_PointerTott__SupportedAnalyticsModulesExtension(soap, &a->Extension);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__SupportedAnalyticsModules(struct soap *soap, const char *tag, int id, const struct tt__SupportedAnalyticsModules *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__SupportedAnalyticsModules), type))
		return soap->error;
	if (a->AnalyticsModuleContentSchemaLocation)
	{	int i;
		for (i = 0; i < a->__sizeAnalyticsModuleContentSchemaLocation; i++)
			if (soap_out_string(soap, "tt:AnalyticsModuleContentSchemaLocation", -1, a->AnalyticsModuleContentSchemaLocation + i, ""))
				return soap->error;
	}
	if (a->AnalyticsModuleDescription)
	{	int i;
		for (i = 0; i < a->__sizeAnalyticsModuleDescription; i++)
			if (soap_out_tt__ConfigDescription(soap, "tt:AnalyticsModuleDescription", -1, a->AnalyticsModuleDescription + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTott__SupportedAnalyticsModulesExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__SupportedAnalyticsModules * SOAP_FMAC4 soap_in_tt__SupportedAnalyticsModules(struct soap *soap, const char *tag, struct tt__SupportedAnalyticsModules *a, const char *type)
{
	struct soap_blist *soap_blist_AnalyticsModuleContentSchemaLocation = NULL;
	struct soap_blist *soap_blist_AnalyticsModuleDescription = NULL;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__SupportedAnalyticsModules *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__SupportedAnalyticsModules, sizeof(struct tt__SupportedAnalyticsModules), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__SupportedAnalyticsModules(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:AnalyticsModuleContentSchemaLocation", 1, NULL))
			{	if (a->AnalyticsModuleContentSchemaLocation == NULL)
				{	if (soap_blist_AnalyticsModuleContentSchemaLocation == NULL)
						soap_blist_AnalyticsModuleContentSchemaLocation = soap_new_block(soap);
					a->AnalyticsModuleContentSchemaLocation = (char **)soap_push_block(soap, soap_blist_AnalyticsModuleContentSchemaLocation, sizeof(char *));
					if (a->AnalyticsModuleContentSchemaLocation == NULL)
						return NULL;
					*a->AnalyticsModuleContentSchemaLocation = NULL;
				}
				soap_revert(soap);
				if (soap_in_string(soap, "tt:AnalyticsModuleContentSchemaLocation", a->AnalyticsModuleContentSchemaLocation, "xsd:string"))
				{	a->__sizeAnalyticsModuleContentSchemaLocation++;
					a->AnalyticsModuleContentSchemaLocation = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:AnalyticsModuleDescription", 1, NULL))
			{	if (a->AnalyticsModuleDescription == NULL)
				{	if (soap_blist_AnalyticsModuleDescription == NULL)
						soap_blist_AnalyticsModuleDescription = soap_new_block(soap);
					a->AnalyticsModuleDescription = (struct tt__ConfigDescription *)soap_push_block(soap, soap_blist_AnalyticsModuleDescription, sizeof(struct tt__ConfigDescription));
					if (a->AnalyticsModuleDescription == NULL)
						return NULL;
					soap_default_tt__ConfigDescription(soap, a->AnalyticsModuleDescription);
				}
				soap_revert(soap);
				if (soap_in_tt__ConfigDescription(soap, "tt:AnalyticsModuleDescription", a->AnalyticsModuleDescription, "tt:ConfigDescription"))
				{	a->__sizeAnalyticsModuleDescription++;
					a->AnalyticsModuleDescription = NULL;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__SupportedAnalyticsModulesExtension(soap, "tt:Extension", &a->Extension, "tt:SupportedAnalyticsModulesExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->AnalyticsModuleContentSchemaLocation)
			soap_pop_block(soap, soap_blist_AnalyticsModuleContentSchemaLocation);
		if (a->__sizeAnalyticsModuleContentSchemaLocation)
			a->AnalyticsModuleContentSchemaLocation = (char **)soap_save_block(soap, soap_blist_AnalyticsModuleContentSchemaLocation, NULL, 1);
		else
		{	a->AnalyticsModuleContentSchemaLocation = NULL;
			if (soap_blist_AnalyticsModuleContentSchemaLocation)
				soap_end_block(soap, soap_blist_AnalyticsModuleContentSchemaLocation);
		}
		if (a->AnalyticsModuleDescription)
			soap_pop_block(soap, soap_blist_AnalyticsModuleDescription);
		if (a->__sizeAnalyticsModuleDescription)
			a->AnalyticsModuleDescription = (struct tt__ConfigDescription *)soap_save_block(soap, soap_blist_AnalyticsModuleDescription, NULL, 1);
		else
		{	a->AnalyticsModuleDescription = NULL;
			if (soap_blist_AnalyticsModuleDescription)
				soap_end_block(soap, soap_blist_AnalyticsModuleDescription);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__SupportedAnalyticsModules *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__SupportedAnalyticsModules, 0, sizeof(struct tt__SupportedAnalyticsModules), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__SupportedAnalyticsModules(struct soap *soap, const struct tt__SupportedAnalyticsModules *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__SupportedAnalyticsModules);
	if (soap_out_tt__SupportedAnalyticsModules(soap, tag?tag:"tt:SupportedAnalyticsModules", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__SupportedAnalyticsModules * SOAP_FMAC4 soap_get_tt__SupportedAnalyticsModules(struct soap *soap, struct tt__SupportedAnalyticsModules *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__SupportedAnalyticsModules(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__SupportedRulesExtension(struct soap *soap, struct tt__SupportedRulesExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__SupportedRulesExtension(struct soap *soap, const struct tt__SupportedRulesExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__SupportedRulesExtension(struct soap *soap, const char *tag, int id, const struct tt__SupportedRulesExtension *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__SupportedRulesExtension), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__SupportedRulesExtension * SOAP_FMAC4 soap_in_tt__SupportedRulesExtension(struct soap *soap, const char *tag, struct tt__SupportedRulesExtension *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__SupportedRulesExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__SupportedRulesExtension, sizeof(struct tt__SupportedRulesExtension), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__SupportedRulesExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__SupportedRulesExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__SupportedRulesExtension, 0, sizeof(struct tt__SupportedRulesExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__SupportedRulesExtension(struct soap *soap, const struct tt__SupportedRulesExtension *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__SupportedRulesExtension);
	if (soap_out_tt__SupportedRulesExtension(soap, tag?tag:"tt:SupportedRulesExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__SupportedRulesExtension * SOAP_FMAC4 soap_get_tt__SupportedRulesExtension(struct soap *soap, struct tt__SupportedRulesExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__SupportedRulesExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__SupportedRules(struct soap *soap, struct tt__SupportedRules *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeRuleContentSchemaLocation = 0;
	a->RuleContentSchemaLocation = NULL;
	a->__sizeRuleDescription = 0;
	a->RuleDescription = NULL;
	a->Extension = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__SupportedRules(struct soap *soap, const struct tt__SupportedRules *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->RuleContentSchemaLocation)
	{	int i;
		for (i = 0; i < a->__sizeRuleContentSchemaLocation; i++)
		{
			soap_serialize_string(soap, a->RuleContentSchemaLocation + i);
		}
	}
	if (a->RuleDescription)
	{	int i;
		for (i = 0; i < a->__sizeRuleDescription; i++)
		{
			soap_embedded(soap, a->RuleDescription + i, SOAP_TYPE_tt__ConfigDescription);
			soap_serialize_tt__ConfigDescription(soap, a->RuleDescription + i);
		}
	}
	soap_serialize_PointerTott__SupportedRulesExtension(soap, &a->Extension);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__SupportedRules(struct soap *soap, const char *tag, int id, const struct tt__SupportedRules *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__SupportedRules), type))
		return soap->error;
	if (a->RuleContentSchemaLocation)
	{	int i;
		for (i = 0; i < a->__sizeRuleContentSchemaLocation; i++)
			if (soap_out_string(soap, "tt:RuleContentSchemaLocation", -1, a->RuleContentSchemaLocation + i, ""))
				return soap->error;
	}
	if (a->RuleDescription)
	{	int i;
		for (i = 0; i < a->__sizeRuleDescription; i++)
			if (soap_out_tt__ConfigDescription(soap, "tt:RuleDescription", -1, a->RuleDescription + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTott__SupportedRulesExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__SupportedRules * SOAP_FMAC4 soap_in_tt__SupportedRules(struct soap *soap, const char *tag, struct tt__SupportedRules *a, const char *type)
{
	struct soap_blist *soap_blist_RuleContentSchemaLocation = NULL;
	struct soap_blist *soap_blist_RuleDescription = NULL;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__SupportedRules *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__SupportedRules, sizeof(struct tt__SupportedRules), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__SupportedRules(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:RuleContentSchemaLocation", 1, NULL))
			{	if (a->RuleContentSchemaLocation == NULL)
				{	if (soap_blist_RuleContentSchemaLocation == NULL)
						soap_blist_RuleContentSchemaLocation = soap_new_block(soap);
					a->RuleContentSchemaLocation = (char **)soap_push_block(soap, soap_blist_RuleContentSchemaLocation, sizeof(char *));
					if (a->RuleContentSchemaLocation == NULL)
						return NULL;
					*a->RuleContentSchemaLocation = NULL;
				}
				soap_revert(soap);
				if (soap_in_string(soap, "tt:RuleContentSchemaLocation", a->RuleContentSchemaLocation, "xsd:string"))
				{	a->__sizeRuleContentSchemaLocation++;
					a->RuleContentSchemaLocation = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:RuleDescription", 1, NULL))
			{	if (a->RuleDescription == NULL)
				{	if (soap_blist_RuleDescription == NULL)
						soap_blist_RuleDescription = soap_new_block(soap);
					a->RuleDescription = (struct tt__ConfigDescription *)soap_push_block(soap, soap_blist_RuleDescription, sizeof(struct tt__ConfigDescription));
					if (a->RuleDescription == NULL)
						return NULL;
					soap_default_tt__ConfigDescription(soap, a->RuleDescription);
				}
				soap_revert(soap);
				if (soap_in_tt__ConfigDescription(soap, "tt:RuleDescription", a->RuleDescription, "tt:ConfigDescription"))
				{	a->__sizeRuleDescription++;
					a->RuleDescription = NULL;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__SupportedRulesExtension(soap, "tt:Extension", &a->Extension, "tt:SupportedRulesExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->RuleContentSchemaLocation)
			soap_pop_block(soap, soap_blist_RuleContentSchemaLocation);
		if (a->__sizeRuleContentSchemaLocation)
			a->RuleContentSchemaLocation = (char **)soap_save_block(soap, soap_blist_RuleContentSchemaLocation, NULL, 1);
		else
		{	a->RuleContentSchemaLocation = NULL;
			if (soap_blist_RuleContentSchemaLocation)
				soap_end_block(soap, soap_blist_RuleContentSchemaLocation);
		}
		if (a->RuleDescription)
			soap_pop_block(soap, soap_blist_RuleDescription);
		if (a->__sizeRuleDescription)
			a->RuleDescription = (struct tt__ConfigDescription *)soap_save_block(soap, soap_blist_RuleDescription, NULL, 1);
		else
		{	a->RuleDescription = NULL;
			if (soap_blist_RuleDescription)
				soap_end_block(soap, soap_blist_RuleDescription);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__SupportedRules *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__SupportedRules, 0, sizeof(struct tt__SupportedRules), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__SupportedRules(struct soap *soap, const struct tt__SupportedRules *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__SupportedRules);
	if (soap_out_tt__SupportedRules(soap, tag?tag:"tt:SupportedRules", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__SupportedRules * SOAP_FMAC4 soap_get_tt__SupportedRules(struct soap *soap, struct tt__SupportedRules *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__SupportedRules(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__ConfigDescriptionExtension(struct soap *soap, struct tt__ConfigDescriptionExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__ConfigDescriptionExtension(struct soap *soap, const struct tt__ConfigDescriptionExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ConfigDescriptionExtension(struct soap *soap, const char *tag, int id, const struct tt__ConfigDescriptionExtension *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ConfigDescriptionExtension), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__ConfigDescriptionExtension * SOAP_FMAC4 soap_in_tt__ConfigDescriptionExtension(struct soap *soap, const char *tag, struct tt__ConfigDescriptionExtension *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__ConfigDescriptionExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ConfigDescriptionExtension, sizeof(struct tt__ConfigDescriptionExtension), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__ConfigDescriptionExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__ConfigDescriptionExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ConfigDescriptionExtension, 0, sizeof(struct tt__ConfigDescriptionExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ConfigDescriptionExtension(struct soap *soap, const struct tt__ConfigDescriptionExtension *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__ConfigDescriptionExtension);
	if (soap_out_tt__ConfigDescriptionExtension(soap, tag?tag:"tt:ConfigDescriptionExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ConfigDescriptionExtension * SOAP_FMAC4 soap_get_tt__ConfigDescriptionExtension(struct soap *soap, struct tt__ConfigDescriptionExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ConfigDescriptionExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tt__ConfigDescription_Messages(struct soap *soap, struct _tt__ConfigDescription_Messages *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Source = NULL;
	a->Key = NULL;
	a->Data = NULL;
	a->Extension = NULL;
	a->IsProperty = NULL;
	a->__anyAttribute = NULL;
	soap_default_string(soap, &a->ParentTopic);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tt__ConfigDescription_Messages(struct soap *soap, const struct _tt__ConfigDescription_Messages *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTott__ItemListDescription(soap, &a->Source);
	soap_serialize_PointerTott__ItemListDescription(soap, &a->Key);
	soap_serialize_PointerTott__ItemListDescription(soap, &a->Data);
	soap_serialize_PointerTott__MessageDescriptionExtension(soap, &a->Extension);
	soap_serialize_string(soap, &a->ParentTopic);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tt__ConfigDescription_Messages(struct soap *soap, const char *tag, int id, const struct _tt__ConfigDescription_Messages *a, const char *type)
{
	if (a->IsProperty)
		soap_set_attr(soap, "IsProperty", soap_xsd__boolean_2s(soap, *a->IsProperty), 1);
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tt__ConfigDescription_Messages), type))
		return soap->error;
	if (soap_out_PointerTott__ItemListDescription(soap, "tt:Source", -1, &a->Source, ""))
		return soap->error;
	if (soap_out_PointerTott__ItemListDescription(soap, "tt:Key", -1, &a->Key, ""))
		return soap->error;
	if (soap_out_PointerTott__ItemListDescription(soap, "tt:Data", -1, &a->Data, ""))
		return soap->error;
	if (soap_out_PointerTott__MessageDescriptionExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	if (a->ParentTopic)
	{	if (soap_out_string(soap, "tt:ParentTopic", -1, &a->ParentTopic, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:ParentTopic"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tt__ConfigDescription_Messages * SOAP_FMAC4 soap_in__tt__ConfigDescription_Messages(struct soap *soap, const char *tag, struct _tt__ConfigDescription_Messages *a, const char *type)
{
	size_t soap_flag_Source = 1;
	size_t soap_flag_Key = 1;
	size_t soap_flag_Data = 1;
	size_t soap_flag_Extension = 1;
	size_t soap_flag_ParentTopic = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tt__ConfigDescription_Messages *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tt__ConfigDescription_Messages, sizeof(struct _tt__ConfigDescription_Messages), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tt__ConfigDescription_Messages(soap, a);
	{	const char *t = soap_attr_value(soap, "IsProperty", 0);
		if (t)
		{
			if (!(a->IsProperty = (enum xsd__boolean_ *)soap_malloc(soap, sizeof(enum xsd__boolean_))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean_(soap, t, a->IsProperty))
			return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Source && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__ItemListDescription(soap, "tt:Source", &a->Source, "tt:ItemListDescription"))
				{	soap_flag_Source--;
					continue;
				}
			if (soap_flag_Key && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__ItemListDescription(soap, "tt:Key", &a->Key, "tt:ItemListDescription"))
				{	soap_flag_Key--;
					continue;
				}
			if (soap_flag_Data && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__ItemListDescription(soap, "tt:Data", &a->Data, "tt:ItemListDescription"))
				{	soap_flag_Data--;
					continue;
				}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__MessageDescriptionExtension(soap, "tt:Extension", &a->Extension, "tt:MessageDescriptionExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap_flag_ParentTopic && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "tt:ParentTopic", &a->ParentTopic, "xsd:string"))
				{	soap_flag_ParentTopic--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tt__ConfigDescription_Messages *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tt__ConfigDescription_Messages, 0, sizeof(struct _tt__ConfigDescription_Messages), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ParentTopic > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tt__ConfigDescription_Messages(struct soap *soap, const struct _tt__ConfigDescription_Messages *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tt__ConfigDescription_Messages);
	if (soap_out__tt__ConfigDescription_Messages(soap, tag?tag:"tt:ConfigDescription-Messages", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tt__ConfigDescription_Messages * SOAP_FMAC4 soap_get__tt__ConfigDescription_Messages(struct soap *soap, struct _tt__ConfigDescription_Messages *p, const char *tag, const char *type)
{
	if ((p = soap_in__tt__ConfigDescription_Messages(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__ConfigDescription(struct soap *soap, struct tt__ConfigDescription *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Parameters = NULL;
	a->__sizeMessages = 0;
	a->Messages = NULL;
	a->Extension = NULL;
	soap_default__QName(soap, &a->Name);
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__ConfigDescription(struct soap *soap, const struct tt__ConfigDescription *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTott__ItemListDescription(soap, &a->Parameters);
	if (a->Messages)
	{	int i;
		for (i = 0; i < a->__sizeMessages; i++)
		{
			soap_embedded(soap, a->Messages + i, SOAP_TYPE__tt__ConfigDescription_Messages);
			soap_serialize__tt__ConfigDescription_Messages(soap, a->Messages + i);
		}
	}
	soap_serialize_PointerTott__ConfigDescriptionExtension(soap, &a->Extension);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ConfigDescription(struct soap *soap, const char *tag, int id, const struct tt__ConfigDescription *a, const char *type)
{
	if (a->Name)
		soap_set_attr(soap, "Name", soap_QName2s(soap, a->Name), 1);
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ConfigDescription), type))
		return soap->error;
	if (a->Parameters)
	{	if (soap_out_PointerTott__ItemListDescription(soap, "tt:Parameters", -1, &a->Parameters, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:Parameters"))
		return soap->error;
	if (a->Messages)
	{	int i;
		for (i = 0; i < a->__sizeMessages; i++)
			if (soap_out__tt__ConfigDescription_Messages(soap, "tt:Messages", -1, a->Messages + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTott__ConfigDescriptionExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__ConfigDescription * SOAP_FMAC4 soap_in_tt__ConfigDescription(struct soap *soap, const char *tag, struct tt__ConfigDescription *a, const char *type)
{
	size_t soap_flag_Parameters = 1;
	struct soap_blist *soap_blist_Messages = NULL;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__ConfigDescription *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ConfigDescription, sizeof(struct tt__ConfigDescription), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__ConfigDescription(soap, a);
	if (soap_s2QName(soap, soap_attr_value(soap, "Name", 1), &a->Name, -1, -1))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Parameters && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__ItemListDescription(soap, "tt:Parameters", &a->Parameters, "tt:ItemListDescription"))
				{	soap_flag_Parameters--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Messages", 1, NULL))
			{	if (a->Messages == NULL)
				{	if (soap_blist_Messages == NULL)
						soap_blist_Messages = soap_new_block(soap);
					a->Messages = (struct _tt__ConfigDescription_Messages *)soap_push_block(soap, soap_blist_Messages, sizeof(struct _tt__ConfigDescription_Messages));
					if (a->Messages == NULL)
						return NULL;
					soap_default__tt__ConfigDescription_Messages(soap, a->Messages);
				}
				soap_revert(soap);
				if (soap_in__tt__ConfigDescription_Messages(soap, "tt:Messages", a->Messages, ""))
				{	a->__sizeMessages++;
					a->Messages = NULL;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__ConfigDescriptionExtension(soap, "tt:Extension", &a->Extension, "tt:ConfigDescriptionExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Messages)
			soap_pop_block(soap, soap_blist_Messages);
		if (a->__sizeMessages)
			a->Messages = (struct _tt__ConfigDescription_Messages *)soap_save_block(soap, soap_blist_Messages, NULL, 1);
		else
		{	a->Messages = NULL;
			if (soap_blist_Messages)
				soap_end_block(soap, soap_blist_Messages);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__ConfigDescription *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ConfigDescription, 0, sizeof(struct tt__ConfigDescription), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Parameters > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ConfigDescription(struct soap *soap, const struct tt__ConfigDescription *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__ConfigDescription);
	if (soap_out_tt__ConfigDescription(soap, tag?tag:"tt:ConfigDescription", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ConfigDescription * SOAP_FMAC4 soap_get_tt__ConfigDescription(struct soap *soap, struct tt__ConfigDescription *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ConfigDescription(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__RuleEngineConfigurationExtension(struct soap *soap, struct tt__RuleEngineConfigurationExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__RuleEngineConfigurationExtension(struct soap *soap, const struct tt__RuleEngineConfigurationExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__RuleEngineConfigurationExtension(struct soap *soap, const char *tag, int id, const struct tt__RuleEngineConfigurationExtension *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__RuleEngineConfigurationExtension), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__RuleEngineConfigurationExtension * SOAP_FMAC4 soap_in_tt__RuleEngineConfigurationExtension(struct soap *soap, const char *tag, struct tt__RuleEngineConfigurationExtension *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__RuleEngineConfigurationExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RuleEngineConfigurationExtension, sizeof(struct tt__RuleEngineConfigurationExtension), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__RuleEngineConfigurationExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__RuleEngineConfigurationExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__RuleEngineConfigurationExtension, 0, sizeof(struct tt__RuleEngineConfigurationExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__RuleEngineConfigurationExtension(struct soap *soap, const struct tt__RuleEngineConfigurationExtension *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__RuleEngineConfigurationExtension);
	if (soap_out_tt__RuleEngineConfigurationExtension(soap, tag?tag:"tt:RuleEngineConfigurationExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__RuleEngineConfigurationExtension * SOAP_FMAC4 soap_get_tt__RuleEngineConfigurationExtension(struct soap *soap, struct tt__RuleEngineConfigurationExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__RuleEngineConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__RuleEngineConfiguration(struct soap *soap, struct tt__RuleEngineConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeRule = 0;
	a->Rule = NULL;
	a->Extension = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__RuleEngineConfiguration(struct soap *soap, const struct tt__RuleEngineConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->Rule)
	{	int i;
		for (i = 0; i < a->__sizeRule; i++)
		{
			soap_embedded(soap, a->Rule + i, SOAP_TYPE_tt__Config);
			soap_serialize_tt__Config(soap, a->Rule + i);
		}
	}
	soap_serialize_PointerTott__RuleEngineConfigurationExtension(soap, &a->Extension);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__RuleEngineConfiguration(struct soap *soap, const char *tag, int id, const struct tt__RuleEngineConfiguration *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__RuleEngineConfiguration), type))
		return soap->error;
	if (a->Rule)
	{	int i;
		for (i = 0; i < a->__sizeRule; i++)
			if (soap_out_tt__Config(soap, "tt:Rule", -1, a->Rule + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTott__RuleEngineConfigurationExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__RuleEngineConfiguration * SOAP_FMAC4 soap_in_tt__RuleEngineConfiguration(struct soap *soap, const char *tag, struct tt__RuleEngineConfiguration *a, const char *type)
{
	struct soap_blist *soap_blist_Rule = NULL;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__RuleEngineConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RuleEngineConfiguration, sizeof(struct tt__RuleEngineConfiguration), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__RuleEngineConfiguration(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Rule", 1, NULL))
			{	if (a->Rule == NULL)
				{	if (soap_blist_Rule == NULL)
						soap_blist_Rule = soap_new_block(soap);
					a->Rule = (struct tt__Config *)soap_push_block(soap, soap_blist_Rule, sizeof(struct tt__Config));
					if (a->Rule == NULL)
						return NULL;
					soap_default_tt__Config(soap, a->Rule);
				}
				soap_revert(soap);
				if (soap_in_tt__Config(soap, "tt:Rule", a->Rule, "tt:Config"))
				{	a->__sizeRule++;
					a->Rule = NULL;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__RuleEngineConfigurationExtension(soap, "tt:Extension", &a->Extension, "tt:RuleEngineConfigurationExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Rule)
			soap_pop_block(soap, soap_blist_Rule);
		if (a->__sizeRule)
			a->Rule = (struct tt__Config *)soap_save_block(soap, soap_blist_Rule, NULL, 1);
		else
		{	a->Rule = NULL;
			if (soap_blist_Rule)
				soap_end_block(soap, soap_blist_Rule);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__RuleEngineConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__RuleEngineConfiguration, 0, sizeof(struct tt__RuleEngineConfiguration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__RuleEngineConfiguration(struct soap *soap, const struct tt__RuleEngineConfiguration *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__RuleEngineConfiguration);
	if (soap_out_tt__RuleEngineConfiguration(soap, tag?tag:"tt:RuleEngineConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__RuleEngineConfiguration * SOAP_FMAC4 soap_get_tt__RuleEngineConfiguration(struct soap *soap, struct tt__RuleEngineConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__RuleEngineConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__AnalyticsEngineConfigurationExtension(struct soap *soap, struct tt__AnalyticsEngineConfigurationExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__AnalyticsEngineConfigurationExtension(struct soap *soap, const struct tt__AnalyticsEngineConfigurationExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AnalyticsEngineConfigurationExtension(struct soap *soap, const char *tag, int id, const struct tt__AnalyticsEngineConfigurationExtension *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AnalyticsEngineConfigurationExtension), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__AnalyticsEngineConfigurationExtension * SOAP_FMAC4 soap_in_tt__AnalyticsEngineConfigurationExtension(struct soap *soap, const char *tag, struct tt__AnalyticsEngineConfigurationExtension *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__AnalyticsEngineConfigurationExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AnalyticsEngineConfigurationExtension, sizeof(struct tt__AnalyticsEngineConfigurationExtension), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__AnalyticsEngineConfigurationExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__AnalyticsEngineConfigurationExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AnalyticsEngineConfigurationExtension, 0, sizeof(struct tt__AnalyticsEngineConfigurationExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__AnalyticsEngineConfigurationExtension(struct soap *soap, const struct tt__AnalyticsEngineConfigurationExtension *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__AnalyticsEngineConfigurationExtension);
	if (soap_out_tt__AnalyticsEngineConfigurationExtension(soap, tag?tag:"tt:AnalyticsEngineConfigurationExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AnalyticsEngineConfigurationExtension * SOAP_FMAC4 soap_get_tt__AnalyticsEngineConfigurationExtension(struct soap *soap, struct tt__AnalyticsEngineConfigurationExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AnalyticsEngineConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__Config(struct soap *soap, struct tt__Config *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Parameters = NULL;
	soap_default_string(soap, &a->Name);
	soap_default__QName(soap, &a->Type);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__Config(struct soap *soap, const struct tt__Config *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTott__ItemList(soap, &a->Parameters);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Config(struct soap *soap, const char *tag, int id, const struct tt__Config *a, const char *type)
{
	if (a->Name)
		soap_set_attr(soap, "Name", a->Name, 1);
	if (a->Type)
		soap_set_attr(soap, "Type", soap_QName2s(soap, a->Type), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Config), type))
		return soap->error;
	if (a->Parameters)
	{	if (soap_out_PointerTott__ItemList(soap, "tt:Parameters", -1, &a->Parameters, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:Parameters"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__Config * SOAP_FMAC4 soap_in_tt__Config(struct soap *soap, const char *tag, struct tt__Config *a, const char *type)
{
	size_t soap_flag_Parameters = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__Config *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Config, sizeof(struct tt__Config), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__Config(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Name", 1), &a->Name, -1, -1))
		return NULL;
	if (soap_s2QName(soap, soap_attr_value(soap, "Type", 1), &a->Type, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Parameters && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__ItemList(soap, "tt:Parameters", &a->Parameters, "tt:ItemList"))
				{	soap_flag_Parameters--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__Config *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Config, 0, sizeof(struct tt__Config), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Parameters > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Config(struct soap *soap, const struct tt__Config *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__Config);
	if (soap_out_tt__Config(soap, tag?tag:"tt:Config", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Config * SOAP_FMAC4 soap_get_tt__Config(struct soap *soap, struct tt__Config *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Config(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__AnalyticsEngineConfiguration(struct soap *soap, struct tt__AnalyticsEngineConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeAnalyticsModule = 0;
	a->AnalyticsModule = NULL;
	a->Extension = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__AnalyticsEngineConfiguration(struct soap *soap, const struct tt__AnalyticsEngineConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->AnalyticsModule)
	{	int i;
		for (i = 0; i < a->__sizeAnalyticsModule; i++)
		{
			soap_embedded(soap, a->AnalyticsModule + i, SOAP_TYPE_tt__Config);
			soap_serialize_tt__Config(soap, a->AnalyticsModule + i);
		}
	}
	soap_serialize_PointerTott__AnalyticsEngineConfigurationExtension(soap, &a->Extension);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AnalyticsEngineConfiguration(struct soap *soap, const char *tag, int id, const struct tt__AnalyticsEngineConfiguration *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AnalyticsEngineConfiguration), type))
		return soap->error;
	if (a->AnalyticsModule)
	{	int i;
		for (i = 0; i < a->__sizeAnalyticsModule; i++)
			if (soap_out_tt__Config(soap, "tt:AnalyticsModule", -1, a->AnalyticsModule + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTott__AnalyticsEngineConfigurationExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__AnalyticsEngineConfiguration * SOAP_FMAC4 soap_in_tt__AnalyticsEngineConfiguration(struct soap *soap, const char *tag, struct tt__AnalyticsEngineConfiguration *a, const char *type)
{
	struct soap_blist *soap_blist_AnalyticsModule = NULL;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__AnalyticsEngineConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AnalyticsEngineConfiguration, sizeof(struct tt__AnalyticsEngineConfiguration), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__AnalyticsEngineConfiguration(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:AnalyticsModule", 1, NULL))
			{	if (a->AnalyticsModule == NULL)
				{	if (soap_blist_AnalyticsModule == NULL)
						soap_blist_AnalyticsModule = soap_new_block(soap);
					a->AnalyticsModule = (struct tt__Config *)soap_push_block(soap, soap_blist_AnalyticsModule, sizeof(struct tt__Config));
					if (a->AnalyticsModule == NULL)
						return NULL;
					soap_default_tt__Config(soap, a->AnalyticsModule);
				}
				soap_revert(soap);
				if (soap_in_tt__Config(soap, "tt:AnalyticsModule", a->AnalyticsModule, "tt:Config"))
				{	a->__sizeAnalyticsModule++;
					a->AnalyticsModule = NULL;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__AnalyticsEngineConfigurationExtension(soap, "tt:Extension", &a->Extension, "tt:AnalyticsEngineConfigurationExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->AnalyticsModule)
			soap_pop_block(soap, soap_blist_AnalyticsModule);
		if (a->__sizeAnalyticsModule)
			a->AnalyticsModule = (struct tt__Config *)soap_save_block(soap, soap_blist_AnalyticsModule, NULL, 1);
		else
		{	a->AnalyticsModule = NULL;
			if (soap_blist_AnalyticsModule)
				soap_end_block(soap, soap_blist_AnalyticsModule);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__AnalyticsEngineConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AnalyticsEngineConfiguration, 0, sizeof(struct tt__AnalyticsEngineConfiguration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__AnalyticsEngineConfiguration(struct soap *soap, const struct tt__AnalyticsEngineConfiguration *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__AnalyticsEngineConfiguration);
	if (soap_out_tt__AnalyticsEngineConfiguration(soap, tag?tag:"tt:AnalyticsEngineConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AnalyticsEngineConfiguration * SOAP_FMAC4 soap_get_tt__AnalyticsEngineConfiguration(struct soap *soap, struct tt__AnalyticsEngineConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AnalyticsEngineConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__ObjectTreeExtension(struct soap *soap, struct tt__ObjectTreeExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__ObjectTreeExtension(struct soap *soap, const struct tt__ObjectTreeExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ObjectTreeExtension(struct soap *soap, const char *tag, int id, const struct tt__ObjectTreeExtension *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ObjectTreeExtension), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__ObjectTreeExtension * SOAP_FMAC4 soap_in_tt__ObjectTreeExtension(struct soap *soap, const char *tag, struct tt__ObjectTreeExtension *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__ObjectTreeExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ObjectTreeExtension, sizeof(struct tt__ObjectTreeExtension), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__ObjectTreeExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__ObjectTreeExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ObjectTreeExtension, 0, sizeof(struct tt__ObjectTreeExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ObjectTreeExtension(struct soap *soap, const struct tt__ObjectTreeExtension *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__ObjectTreeExtension);
	if (soap_out_tt__ObjectTreeExtension(soap, tag?tag:"tt:ObjectTreeExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ObjectTreeExtension * SOAP_FMAC4 soap_get_tt__ObjectTreeExtension(struct soap *soap, struct tt__ObjectTreeExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ObjectTreeExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__BehaviourExtension(struct soap *soap, struct tt__BehaviourExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__BehaviourExtension(struct soap *soap, const struct tt__BehaviourExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__BehaviourExtension(struct soap *soap, const char *tag, int id, const struct tt__BehaviourExtension *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__BehaviourExtension), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__BehaviourExtension * SOAP_FMAC4 soap_in_tt__BehaviourExtension(struct soap *soap, const char *tag, struct tt__BehaviourExtension *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__BehaviourExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__BehaviourExtension, sizeof(struct tt__BehaviourExtension), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__BehaviourExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__BehaviourExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__BehaviourExtension, 0, sizeof(struct tt__BehaviourExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__BehaviourExtension(struct soap *soap, const struct tt__BehaviourExtension *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__BehaviourExtension);
	if (soap_out_tt__BehaviourExtension(soap, tag?tag:"tt:BehaviourExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__BehaviourExtension * SOAP_FMAC4 soap_get_tt__BehaviourExtension(struct soap *soap, struct tt__BehaviourExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__BehaviourExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tt__Behaviour_Idle(struct soap *soap, struct _tt__Behaviour_Idle *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tt__Behaviour_Idle(struct soap *soap, const struct _tt__Behaviour_Idle *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tt__Behaviour_Idle(struct soap *soap, const char *tag, int id, const struct _tt__Behaviour_Idle *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tt__Behaviour_Idle), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tt__Behaviour_Idle * SOAP_FMAC4 soap_in__tt__Behaviour_Idle(struct soap *soap, const char *tag, struct _tt__Behaviour_Idle *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tt__Behaviour_Idle *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tt__Behaviour_Idle, sizeof(struct _tt__Behaviour_Idle), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tt__Behaviour_Idle(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tt__Behaviour_Idle *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tt__Behaviour_Idle, 0, sizeof(struct _tt__Behaviour_Idle), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tt__Behaviour_Idle(struct soap *soap, const struct _tt__Behaviour_Idle *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tt__Behaviour_Idle);
	if (soap_out__tt__Behaviour_Idle(soap, tag?tag:"tt:Behaviour-Idle", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tt__Behaviour_Idle * SOAP_FMAC4 soap_get__tt__Behaviour_Idle(struct soap *soap, struct _tt__Behaviour_Idle *p, const char *tag, const char *type)
{
	if ((p = soap_in__tt__Behaviour_Idle(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tt__Behaviour_Removed(struct soap *soap, struct _tt__Behaviour_Removed *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tt__Behaviour_Removed(struct soap *soap, const struct _tt__Behaviour_Removed *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tt__Behaviour_Removed(struct soap *soap, const char *tag, int id, const struct _tt__Behaviour_Removed *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tt__Behaviour_Removed), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tt__Behaviour_Removed * SOAP_FMAC4 soap_in__tt__Behaviour_Removed(struct soap *soap, const char *tag, struct _tt__Behaviour_Removed *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tt__Behaviour_Removed *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tt__Behaviour_Removed, sizeof(struct _tt__Behaviour_Removed), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tt__Behaviour_Removed(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tt__Behaviour_Removed *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tt__Behaviour_Removed, 0, sizeof(struct _tt__Behaviour_Removed), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tt__Behaviour_Removed(struct soap *soap, const struct _tt__Behaviour_Removed *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tt__Behaviour_Removed);
	if (soap_out__tt__Behaviour_Removed(soap, tag?tag:"tt:Behaviour-Removed", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tt__Behaviour_Removed * SOAP_FMAC4 soap_get__tt__Behaviour_Removed(struct soap *soap, struct _tt__Behaviour_Removed *p, const char *tag, const char *type)
{
	if ((p = soap_in__tt__Behaviour_Removed(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__Behaviour(struct soap *soap, struct tt__Behaviour *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Removed = NULL;
	a->Idle = NULL;
	a->Extension = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__Behaviour(struct soap *soap, const struct tt__Behaviour *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_tt__Behaviour_Removed(soap, &a->Removed);
	soap_serialize_PointerTo_tt__Behaviour_Idle(soap, &a->Idle);
	soap_serialize_PointerTott__BehaviourExtension(soap, &a->Extension);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Behaviour(struct soap *soap, const char *tag, int id, const struct tt__Behaviour *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Behaviour), type))
		return soap->error;
	if (soap_out_PointerTo_tt__Behaviour_Removed(soap, "tt:Removed", -1, &a->Removed, ""))
		return soap->error;
	if (soap_out_PointerTo_tt__Behaviour_Idle(soap, "tt:Idle", -1, &a->Idle, ""))
		return soap->error;
	if (soap_out_PointerTott__BehaviourExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__Behaviour * SOAP_FMAC4 soap_in_tt__Behaviour(struct soap *soap, const char *tag, struct tt__Behaviour *a, const char *type)
{
	size_t soap_flag_Removed = 1;
	size_t soap_flag_Idle = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__Behaviour *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Behaviour, sizeof(struct tt__Behaviour), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__Behaviour(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Removed && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_tt__Behaviour_Removed(soap, "tt:Removed", &a->Removed, ""))
				{	soap_flag_Removed--;
					continue;
				}
			if (soap_flag_Idle && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_tt__Behaviour_Idle(soap, "tt:Idle", &a->Idle, ""))
				{	soap_flag_Idle--;
					continue;
				}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__BehaviourExtension(soap, "tt:Extension", &a->Extension, "tt:BehaviourExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__Behaviour *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Behaviour, 0, sizeof(struct tt__Behaviour), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Behaviour(struct soap *soap, const struct tt__Behaviour *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__Behaviour);
	if (soap_out_tt__Behaviour(soap, tag?tag:"tt:Behaviour", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Behaviour * SOAP_FMAC4 soap_get_tt__Behaviour(struct soap *soap, struct tt__Behaviour *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Behaviour(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__Rename(struct soap *soap, struct tt__Rename *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->from = NULL;
	a->to = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__Rename(struct soap *soap, const struct tt__Rename *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTott__ObjectId(soap, &a->from);
	soap_serialize_PointerTott__ObjectId(soap, &a->to);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Rename(struct soap *soap, const char *tag, int id, const struct tt__Rename *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Rename), type))
		return soap->error;
	if (a->from)
	{	if (soap_out_PointerTott__ObjectId(soap, "tt:from", -1, &a->from, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:from"))
		return soap->error;
	if (a->to)
	{	if (soap_out_PointerTott__ObjectId(soap, "tt:to", -1, &a->to, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:to"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__Rename * SOAP_FMAC4 soap_in_tt__Rename(struct soap *soap, const char *tag, struct tt__Rename *a, const char *type)
{
	size_t soap_flag_from = 1;
	size_t soap_flag_to = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__Rename *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Rename, sizeof(struct tt__Rename), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__Rename(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_from && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__ObjectId(soap, "tt:from", &a->from, "tt:ObjectId"))
				{	soap_flag_from--;
					continue;
				}
			if (soap_flag_to && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__ObjectId(soap, "tt:to", &a->to, "tt:ObjectId"))
				{	soap_flag_to--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__Rename *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Rename, 0, sizeof(struct tt__Rename), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_from > 0 || soap_flag_to > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Rename(struct soap *soap, const struct tt__Rename *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__Rename);
	if (soap_out_tt__Rename(soap, tag?tag:"tt:Rename", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Rename * SOAP_FMAC4 soap_get_tt__Rename(struct soap *soap, struct tt__Rename *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Rename(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__Split(struct soap *soap, struct tt__Split *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->from = NULL;
	a->__sizeto = 0;
	a->to = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__Split(struct soap *soap, const struct tt__Split *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTott__ObjectId(soap, &a->from);
	if (a->to)
	{	int i;
		for (i = 0; i < a->__sizeto; i++)
		{
			soap_embedded(soap, a->to + i, SOAP_TYPE_tt__ObjectId);
			soap_serialize_tt__ObjectId(soap, a->to + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Split(struct soap *soap, const char *tag, int id, const struct tt__Split *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Split), type))
		return soap->error;
	if (a->from)
	{	if (soap_out_PointerTott__ObjectId(soap, "tt:from", -1, &a->from, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:from"))
		return soap->error;
	if (a->to)
	{	int i;
		for (i = 0; i < a->__sizeto; i++)
			if (soap_out_tt__ObjectId(soap, "tt:to", -1, a->to + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__Split * SOAP_FMAC4 soap_in_tt__Split(struct soap *soap, const char *tag, struct tt__Split *a, const char *type)
{
	size_t soap_flag_from = 1;
	struct soap_blist *soap_blist_to = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__Split *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Split, sizeof(struct tt__Split), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__Split(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_from && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__ObjectId(soap, "tt:from", &a->from, "tt:ObjectId"))
				{	soap_flag_from--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:to", 1, NULL))
			{	if (a->to == NULL)
				{	if (soap_blist_to == NULL)
						soap_blist_to = soap_new_block(soap);
					a->to = (struct tt__ObjectId *)soap_push_block(soap, soap_blist_to, sizeof(struct tt__ObjectId));
					if (a->to == NULL)
						return NULL;
					soap_default_tt__ObjectId(soap, a->to);
				}
				soap_revert(soap);
				if (soap_in_tt__ObjectId(soap, "tt:to", a->to, "tt:ObjectId"))
				{	a->__sizeto++;
					a->to = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->to)
			soap_pop_block(soap, soap_blist_to);
		if (a->__sizeto)
			a->to = (struct tt__ObjectId *)soap_save_block(soap, soap_blist_to, NULL, 1);
		else
		{	a->to = NULL;
			if (soap_blist_to)
				soap_end_block(soap, soap_blist_to);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__Split *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Split, 0, sizeof(struct tt__Split), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_from > 0 || a->__sizeto < 2))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Split(struct soap *soap, const struct tt__Split *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__Split);
	if (soap_out_tt__Split(soap, tag?tag:"tt:Split", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Split * SOAP_FMAC4 soap_get_tt__Split(struct soap *soap, struct tt__Split *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Split(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__ObjectId(struct soap *soap, struct tt__ObjectId *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ObjectId = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__ObjectId(struct soap *soap, const struct tt__ObjectId *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ObjectId(struct soap *soap, const char *tag, int id, const struct tt__ObjectId *a, const char *type)
{
	if (a->ObjectId)
		soap_set_attr(soap, "ObjectId", soap_int2s(soap, *a->ObjectId), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ObjectId), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__ObjectId * SOAP_FMAC4 soap_in_tt__ObjectId(struct soap *soap, const char *tag, struct tt__ObjectId *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__ObjectId *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ObjectId, sizeof(struct tt__ObjectId), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__ObjectId(soap, a);
	{	const char *t = soap_attr_value(soap, "ObjectId", 0);
		if (t)
		{
			if (!(a->ObjectId = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2int(soap, t, a->ObjectId))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__ObjectId *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ObjectId, 0, sizeof(struct tt__ObjectId), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ObjectId(struct soap *soap, const struct tt__ObjectId *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__ObjectId);
	if (soap_out_tt__ObjectId(soap, tag?tag:"tt:ObjectId", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ObjectId * SOAP_FMAC4 soap_get_tt__ObjectId(struct soap *soap, struct tt__ObjectId *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ObjectId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__Merge(struct soap *soap, struct tt__Merge *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizefrom = 0;
	a->from = NULL;
	a->to = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__Merge(struct soap *soap, const struct tt__Merge *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->from)
	{	int i;
		for (i = 0; i < a->__sizefrom; i++)
		{
			soap_embedded(soap, a->from + i, SOAP_TYPE_tt__ObjectId);
			soap_serialize_tt__ObjectId(soap, a->from + i);
		}
	}
	soap_serialize_PointerTott__ObjectId(soap, &a->to);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Merge(struct soap *soap, const char *tag, int id, const struct tt__Merge *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Merge), type))
		return soap->error;
	if (a->from)
	{	int i;
		for (i = 0; i < a->__sizefrom; i++)
			if (soap_out_tt__ObjectId(soap, "tt:from", -1, a->from + i, ""))
				return soap->error;
	}
	if (a->to)
	{	if (soap_out_PointerTott__ObjectId(soap, "tt:to", -1, &a->to, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:to"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__Merge * SOAP_FMAC4 soap_in_tt__Merge(struct soap *soap, const char *tag, struct tt__Merge *a, const char *type)
{
	struct soap_blist *soap_blist_from = NULL;
	size_t soap_flag_to = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__Merge *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Merge, sizeof(struct tt__Merge), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__Merge(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:from", 1, NULL))
			{	if (a->from == NULL)
				{	if (soap_blist_from == NULL)
						soap_blist_from = soap_new_block(soap);
					a->from = (struct tt__ObjectId *)soap_push_block(soap, soap_blist_from, sizeof(struct tt__ObjectId));
					if (a->from == NULL)
						return NULL;
					soap_default_tt__ObjectId(soap, a->from);
				}
				soap_revert(soap);
				if (soap_in_tt__ObjectId(soap, "tt:from", a->from, "tt:ObjectId"))
				{	a->__sizefrom++;
					a->from = NULL;
					continue;
				}
			}
			if (soap_flag_to && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__ObjectId(soap, "tt:to", &a->to, "tt:ObjectId"))
				{	soap_flag_to--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->from)
			soap_pop_block(soap, soap_blist_from);
		if (a->__sizefrom)
			a->from = (struct tt__ObjectId *)soap_save_block(soap, soap_blist_from, NULL, 1);
		else
		{	a->from = NULL;
			if (soap_blist_from)
				soap_end_block(soap, soap_blist_from);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__Merge *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Merge, 0, sizeof(struct tt__Merge), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->__sizefrom < 2 || soap_flag_to > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Merge(struct soap *soap, const struct tt__Merge *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__Merge);
	if (soap_out_tt__Merge(soap, tag?tag:"tt:Merge", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Merge * SOAP_FMAC4 soap_get_tt__Merge(struct soap *soap, struct tt__Merge *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Merge(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__FrameExtension(struct soap *soap, struct tt__FrameExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__FrameExtension(struct soap *soap, const struct tt__FrameExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__FrameExtension(struct soap *soap, const char *tag, int id, const struct tt__FrameExtension *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__FrameExtension), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__FrameExtension * SOAP_FMAC4 soap_in_tt__FrameExtension(struct soap *soap, const char *tag, struct tt__FrameExtension *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__FrameExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__FrameExtension, sizeof(struct tt__FrameExtension), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__FrameExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__FrameExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__FrameExtension, 0, sizeof(struct tt__FrameExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__FrameExtension(struct soap *soap, const struct tt__FrameExtension *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__FrameExtension);
	if (soap_out_tt__FrameExtension(soap, tag?tag:"tt:FrameExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__FrameExtension * SOAP_FMAC4 soap_get_tt__FrameExtension(struct soap *soap, struct tt__FrameExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__FrameExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__ObjectTree(struct soap *soap, struct tt__ObjectTree *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeRename = 0;
	a->Rename = NULL;
	a->__sizeSplit = 0;
	a->Split = NULL;
	a->__sizeMerge = 0;
	a->Merge = NULL;
	a->__sizeDelete = 0;
	a->Delete = NULL;
	a->Extension = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__ObjectTree(struct soap *soap, const struct tt__ObjectTree *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->Rename)
	{	int i;
		for (i = 0; i < a->__sizeRename; i++)
		{
			soap_embedded(soap, a->Rename + i, SOAP_TYPE_tt__Rename);
			soap_serialize_tt__Rename(soap, a->Rename + i);
		}
	}
	if (a->Split)
	{	int i;
		for (i = 0; i < a->__sizeSplit; i++)
		{
			soap_embedded(soap, a->Split + i, SOAP_TYPE_tt__Split);
			soap_serialize_tt__Split(soap, a->Split + i);
		}
	}
	if (a->Merge)
	{	int i;
		for (i = 0; i < a->__sizeMerge; i++)
		{
			soap_embedded(soap, a->Merge + i, SOAP_TYPE_tt__Merge);
			soap_serialize_tt__Merge(soap, a->Merge + i);
		}
	}
	if (a->Delete)
	{	int i;
		for (i = 0; i < a->__sizeDelete; i++)
		{
			soap_embedded(soap, a->Delete + i, SOAP_TYPE_tt__ObjectId);
			soap_serialize_tt__ObjectId(soap, a->Delete + i);
		}
	}
	soap_serialize_PointerTott__ObjectTreeExtension(soap, &a->Extension);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ObjectTree(struct soap *soap, const char *tag, int id, const struct tt__ObjectTree *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ObjectTree), type))
		return soap->error;
	if (a->Rename)
	{	int i;
		for (i = 0; i < a->__sizeRename; i++)
			if (soap_out_tt__Rename(soap, "tt:Rename", -1, a->Rename + i, ""))
				return soap->error;
	}
	if (a->Split)
	{	int i;
		for (i = 0; i < a->__sizeSplit; i++)
			if (soap_out_tt__Split(soap, "tt:Split", -1, a->Split + i, ""))
				return soap->error;
	}
	if (a->Merge)
	{	int i;
		for (i = 0; i < a->__sizeMerge; i++)
			if (soap_out_tt__Merge(soap, "tt:Merge", -1, a->Merge + i, ""))
				return soap->error;
	}
	if (a->Delete)
	{	int i;
		for (i = 0; i < a->__sizeDelete; i++)
			if (soap_out_tt__ObjectId(soap, "tt:Delete", -1, a->Delete + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTott__ObjectTreeExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__ObjectTree * SOAP_FMAC4 soap_in_tt__ObjectTree(struct soap *soap, const char *tag, struct tt__ObjectTree *a, const char *type)
{
	struct soap_blist *soap_blist_Rename = NULL;
	struct soap_blist *soap_blist_Split = NULL;
	struct soap_blist *soap_blist_Merge = NULL;
	struct soap_blist *soap_blist_Delete = NULL;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__ObjectTree *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ObjectTree, sizeof(struct tt__ObjectTree), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__ObjectTree(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Rename", 1, NULL))
			{	if (a->Rename == NULL)
				{	if (soap_blist_Rename == NULL)
						soap_blist_Rename = soap_new_block(soap);
					a->Rename = (struct tt__Rename *)soap_push_block(soap, soap_blist_Rename, sizeof(struct tt__Rename));
					if (a->Rename == NULL)
						return NULL;
					soap_default_tt__Rename(soap, a->Rename);
				}
				soap_revert(soap);
				if (soap_in_tt__Rename(soap, "tt:Rename", a->Rename, "tt:Rename"))
				{	a->__sizeRename++;
					a->Rename = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Split", 1, NULL))
			{	if (a->Split == NULL)
				{	if (soap_blist_Split == NULL)
						soap_blist_Split = soap_new_block(soap);
					a->Split = (struct tt__Split *)soap_push_block(soap, soap_blist_Split, sizeof(struct tt__Split));
					if (a->Split == NULL)
						return NULL;
					soap_default_tt__Split(soap, a->Split);
				}
				soap_revert(soap);
				if (soap_in_tt__Split(soap, "tt:Split", a->Split, "tt:Split"))
				{	a->__sizeSplit++;
					a->Split = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Merge", 1, NULL))
			{	if (a->Merge == NULL)
				{	if (soap_blist_Merge == NULL)
						soap_blist_Merge = soap_new_block(soap);
					a->Merge = (struct tt__Merge *)soap_push_block(soap, soap_blist_Merge, sizeof(struct tt__Merge));
					if (a->Merge == NULL)
						return NULL;
					soap_default_tt__Merge(soap, a->Merge);
				}
				soap_revert(soap);
				if (soap_in_tt__Merge(soap, "tt:Merge", a->Merge, "tt:Merge"))
				{	a->__sizeMerge++;
					a->Merge = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Delete", 1, NULL))
			{	if (a->Delete == NULL)
				{	if (soap_blist_Delete == NULL)
						soap_blist_Delete = soap_new_block(soap);
					a->Delete = (struct tt__ObjectId *)soap_push_block(soap, soap_blist_Delete, sizeof(struct tt__ObjectId));
					if (a->Delete == NULL)
						return NULL;
					soap_default_tt__ObjectId(soap, a->Delete);
				}
				soap_revert(soap);
				if (soap_in_tt__ObjectId(soap, "tt:Delete", a->Delete, "tt:ObjectId"))
				{	a->__sizeDelete++;
					a->Delete = NULL;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__ObjectTreeExtension(soap, "tt:Extension", &a->Extension, "tt:ObjectTreeExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Rename)
			soap_pop_block(soap, soap_blist_Rename);
		if (a->__sizeRename)
			a->Rename = (struct tt__Rename *)soap_save_block(soap, soap_blist_Rename, NULL, 1);
		else
		{	a->Rename = NULL;
			if (soap_blist_Rename)
				soap_end_block(soap, soap_blist_Rename);
		}
		if (a->Split)
			soap_pop_block(soap, soap_blist_Split);
		if (a->__sizeSplit)
			a->Split = (struct tt__Split *)soap_save_block(soap, soap_blist_Split, NULL, 1);
		else
		{	a->Split = NULL;
			if (soap_blist_Split)
				soap_end_block(soap, soap_blist_Split);
		}
		if (a->Merge)
			soap_pop_block(soap, soap_blist_Merge);
		if (a->__sizeMerge)
			a->Merge = (struct tt__Merge *)soap_save_block(soap, soap_blist_Merge, NULL, 1);
		else
		{	a->Merge = NULL;
			if (soap_blist_Merge)
				soap_end_block(soap, soap_blist_Merge);
		}
		if (a->Delete)
			soap_pop_block(soap, soap_blist_Delete);
		if (a->__sizeDelete)
			a->Delete = (struct tt__ObjectId *)soap_save_block(soap, soap_blist_Delete, NULL, 1);
		else
		{	a->Delete = NULL;
			if (soap_blist_Delete)
				soap_end_block(soap, soap_blist_Delete);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__ObjectTree *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ObjectTree, 0, sizeof(struct tt__ObjectTree), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ObjectTree(struct soap *soap, const struct tt__ObjectTree *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__ObjectTree);
	if (soap_out_tt__ObjectTree(soap, tag?tag:"tt:ObjectTree", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ObjectTree * SOAP_FMAC4 soap_get_tt__ObjectTree(struct soap *soap, struct tt__ObjectTree *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ObjectTree(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__Object(struct soap *soap, struct tt__Object *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ObjectId = NULL;
	a->Appearance = NULL;
	a->Behaviour = NULL;
	a->Extension = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__Object(struct soap *soap, const struct tt__Object *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTott__Appearance(soap, &a->Appearance);
	soap_serialize_PointerTott__Behaviour(soap, &a->Behaviour);
	soap_serialize_PointerTott__ObjectExtension(soap, &a->Extension);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Object(struct soap *soap, const char *tag, int id, const struct tt__Object *a, const char *type)
{
	if (a->ObjectId)
		soap_set_attr(soap, "ObjectId", soap_int2s(soap, *a->ObjectId), 1);
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Object), type))
		return soap->error;
	if (soap_out_PointerTott__Appearance(soap, "tt:Appearance", -1, &a->Appearance, ""))
		return soap->error;
	if (soap_out_PointerTott__Behaviour(soap, "tt:Behaviour", -1, &a->Behaviour, ""))
		return soap->error;
	if (soap_out_PointerTott__ObjectExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__Object * SOAP_FMAC4 soap_in_tt__Object(struct soap *soap, const char *tag, struct tt__Object *a, const char *type)
{
	size_t soap_flag_Appearance = 1;
	size_t soap_flag_Behaviour = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__Object *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Object, sizeof(struct tt__Object), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__Object(soap, a);
	{	const char *t = soap_attr_value(soap, "ObjectId", 0);
		if (t)
		{
			if (!(a->ObjectId = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2int(soap, t, a->ObjectId))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Appearance && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__Appearance(soap, "tt:Appearance", &a->Appearance, "tt:Appearance"))
				{	soap_flag_Appearance--;
					continue;
				}
			if (soap_flag_Behaviour && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__Behaviour(soap, "tt:Behaviour", &a->Behaviour, "tt:Behaviour"))
				{	soap_flag_Behaviour--;
					continue;
				}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__ObjectExtension(soap, "tt:Extension", &a->Extension, "tt:ObjectExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__Object *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Object, 0, sizeof(struct tt__Object), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Object(struct soap *soap, const struct tt__Object *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__Object);
	if (soap_out_tt__Object(soap, tag?tag:"tt:Object", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Object * SOAP_FMAC4 soap_get_tt__Object(struct soap *soap, struct tt__Object *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Object(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__Frame(struct soap *soap, struct tt__Frame *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->PTZStatus = NULL;
	a->Transformation = NULL;
	a->__sizeObject = 0;
	a->Object = NULL;
	a->ObjectTree = NULL;
	a->Extension = NULL;
	soap_default_time(soap, &a->UtcTime);
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__Frame(struct soap *soap, const struct tt__Frame *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTott__PTZStatus(soap, &a->PTZStatus);
	soap_serialize_PointerTott__Transformation(soap, &a->Transformation);
	if (a->Object)
	{	int i;
		for (i = 0; i < a->__sizeObject; i++)
		{
			soap_embedded(soap, a->Object + i, SOAP_TYPE_tt__Object);
			soap_serialize_tt__Object(soap, a->Object + i);
		}
	}
	soap_serialize_PointerTott__ObjectTree(soap, &a->ObjectTree);
	soap_serialize_PointerTott__FrameExtension(soap, &a->Extension);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Frame(struct soap *soap, const char *tag, int id, const struct tt__Frame *a, const char *type)
{
	soap_set_attr(soap, "UtcTime", soap_dateTime2s(soap, a->UtcTime), 1);
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Frame), type))
		return soap->error;
	if (soap_out_PointerTott__PTZStatus(soap, "tt:PTZStatus", -1, &a->PTZStatus, ""))
		return soap->error;
	if (soap_out_PointerTott__Transformation(soap, "tt:Transformation", -1, &a->Transformation, ""))
		return soap->error;
	if (a->Object)
	{	int i;
		for (i = 0; i < a->__sizeObject; i++)
			if (soap_out_tt__Object(soap, "tt:Object", -1, a->Object + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTott__ObjectTree(soap, "tt:ObjectTree", -1, &a->ObjectTree, ""))
		return soap->error;
	if (soap_out_PointerTott__FrameExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__Frame * SOAP_FMAC4 soap_in_tt__Frame(struct soap *soap, const char *tag, struct tt__Frame *a, const char *type)
{
	size_t soap_flag_PTZStatus = 1;
	size_t soap_flag_Transformation = 1;
	struct soap_blist *soap_blist_Object = NULL;
	size_t soap_flag_ObjectTree = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__Frame *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Frame, sizeof(struct tt__Frame), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__Frame(soap, a);
	if (soap_s2dateTime(soap, soap_attr_value(soap, "UtcTime", 1), &a->UtcTime))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_PTZStatus && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__PTZStatus(soap, "tt:PTZStatus", &a->PTZStatus, "tt:PTZStatus"))
				{	soap_flag_PTZStatus--;
					continue;
				}
			if (soap_flag_Transformation && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__Transformation(soap, "tt:Transformation", &a->Transformation, "tt:Transformation"))
				{	soap_flag_Transformation--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Object", 1, NULL))
			{	if (a->Object == NULL)
				{	if (soap_blist_Object == NULL)
						soap_blist_Object = soap_new_block(soap);
					a->Object = (struct tt__Object *)soap_push_block(soap, soap_blist_Object, sizeof(struct tt__Object));
					if (a->Object == NULL)
						return NULL;
					soap_default_tt__Object(soap, a->Object);
				}
				soap_revert(soap);
				if (soap_in_tt__Object(soap, "tt:Object", a->Object, "tt:Object"))
				{	a->__sizeObject++;
					a->Object = NULL;
					continue;
				}
			}
			if (soap_flag_ObjectTree && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__ObjectTree(soap, "tt:ObjectTree", &a->ObjectTree, "tt:ObjectTree"))
				{	soap_flag_ObjectTree--;
					continue;
				}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__FrameExtension(soap, "tt:Extension", &a->Extension, "tt:FrameExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Object)
			soap_pop_block(soap, soap_blist_Object);
		if (a->__sizeObject)
			a->Object = (struct tt__Object *)soap_save_block(soap, soap_blist_Object, NULL, 1);
		else
		{	a->Object = NULL;
			if (soap_blist_Object)
				soap_end_block(soap, soap_blist_Object);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__Frame *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Frame, 0, sizeof(struct tt__Frame), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Frame(struct soap *soap, const struct tt__Frame *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__Frame);
	if (soap_out_tt__Frame(soap, tag?tag:"tt:Frame", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Frame * SOAP_FMAC4 soap_get_tt__Frame(struct soap *soap, struct tt__Frame *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Frame(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__TransformationExtension(struct soap *soap, struct tt__TransformationExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__TransformationExtension(struct soap *soap, const struct tt__TransformationExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__TransformationExtension(struct soap *soap, const char *tag, int id, const struct tt__TransformationExtension *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__TransformationExtension), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__TransformationExtension * SOAP_FMAC4 soap_in_tt__TransformationExtension(struct soap *soap, const char *tag, struct tt__TransformationExtension *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__TransformationExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__TransformationExtension, sizeof(struct tt__TransformationExtension), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__TransformationExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__TransformationExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__TransformationExtension, 0, sizeof(struct tt__TransformationExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__TransformationExtension(struct soap *soap, const struct tt__TransformationExtension *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__TransformationExtension);
	if (soap_out_tt__TransformationExtension(soap, tag?tag:"tt:TransformationExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__TransformationExtension * SOAP_FMAC4 soap_get_tt__TransformationExtension(struct soap *soap, struct tt__TransformationExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__TransformationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__ObjectExtension(struct soap *soap, struct tt__ObjectExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__ObjectExtension(struct soap *soap, const struct tt__ObjectExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ObjectExtension(struct soap *soap, const char *tag, int id, const struct tt__ObjectExtension *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ObjectExtension), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__ObjectExtension * SOAP_FMAC4 soap_in_tt__ObjectExtension(struct soap *soap, const char *tag, struct tt__ObjectExtension *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__ObjectExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ObjectExtension, sizeof(struct tt__ObjectExtension), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__ObjectExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__ObjectExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ObjectExtension, 0, sizeof(struct tt__ObjectExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ObjectExtension(struct soap *soap, const struct tt__ObjectExtension *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__ObjectExtension);
	if (soap_out_tt__ObjectExtension(soap, tag?tag:"tt:ObjectExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ObjectExtension * SOAP_FMAC4 soap_get_tt__ObjectExtension(struct soap *soap, struct tt__ObjectExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ObjectExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__ClassDescriptorExtension(struct soap *soap, struct tt__ClassDescriptorExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__ClassDescriptorExtension(struct soap *soap, const struct tt__ClassDescriptorExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ClassDescriptorExtension(struct soap *soap, const char *tag, int id, const struct tt__ClassDescriptorExtension *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ClassDescriptorExtension), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__ClassDescriptorExtension * SOAP_FMAC4 soap_in_tt__ClassDescriptorExtension(struct soap *soap, const char *tag, struct tt__ClassDescriptorExtension *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__ClassDescriptorExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ClassDescriptorExtension, sizeof(struct tt__ClassDescriptorExtension), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__ClassDescriptorExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__ClassDescriptorExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ClassDescriptorExtension, 0, sizeof(struct tt__ClassDescriptorExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ClassDescriptorExtension(struct soap *soap, const struct tt__ClassDescriptorExtension *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__ClassDescriptorExtension);
	if (soap_out_tt__ClassDescriptorExtension(soap, tag?tag:"tt:ClassDescriptorExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ClassDescriptorExtension * SOAP_FMAC4 soap_get_tt__ClassDescriptorExtension(struct soap *soap, struct tt__ClassDescriptorExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ClassDescriptorExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tt__ClassDescriptor_ClassCandidate(struct soap *soap, struct _tt__ClassDescriptor_ClassCandidate *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ClassType(soap, &a->Type);
	soap_default_float(soap, &a->Likelihood);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tt__ClassDescriptor_ClassCandidate(struct soap *soap, const struct _tt__ClassDescriptor_ClassCandidate *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->Likelihood, SOAP_TYPE_float);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tt__ClassDescriptor_ClassCandidate(struct soap *soap, const char *tag, int id, const struct _tt__ClassDescriptor_ClassCandidate *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tt__ClassDescriptor_ClassCandidate), type))
		return soap->error;
	if (soap_out_tt__ClassType(soap, "tt:Type", -1, &a->Type, ""))
		return soap->error;
	if (soap_out_float(soap, "tt:Likelihood", -1, &a->Likelihood, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tt__ClassDescriptor_ClassCandidate * SOAP_FMAC4 soap_in__tt__ClassDescriptor_ClassCandidate(struct soap *soap, const char *tag, struct _tt__ClassDescriptor_ClassCandidate *a, const char *type)
{
	size_t soap_flag_Type = 1;
	size_t soap_flag_Likelihood = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tt__ClassDescriptor_ClassCandidate *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tt__ClassDescriptor_ClassCandidate, sizeof(struct _tt__ClassDescriptor_ClassCandidate), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tt__ClassDescriptor_ClassCandidate(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Type && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_tt__ClassType(soap, "tt:Type", &a->Type, "tt:ClassType"))
				{	soap_flag_Type--;
					continue;
				}
			if (soap_flag_Likelihood && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_float(soap, "tt:Likelihood", &a->Likelihood, "xsd:float"))
				{	soap_flag_Likelihood--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tt__ClassDescriptor_ClassCandidate *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tt__ClassDescriptor_ClassCandidate, 0, sizeof(struct _tt__ClassDescriptor_ClassCandidate), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Type > 0 || soap_flag_Likelihood > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tt__ClassDescriptor_ClassCandidate(struct soap *soap, const struct _tt__ClassDescriptor_ClassCandidate *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tt__ClassDescriptor_ClassCandidate);
	if (soap_out__tt__ClassDescriptor_ClassCandidate(soap, tag?tag:"tt:ClassDescriptor-ClassCandidate", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tt__ClassDescriptor_ClassCandidate * SOAP_FMAC4 soap_get__tt__ClassDescriptor_ClassCandidate(struct soap *soap, struct _tt__ClassDescriptor_ClassCandidate *p, const char *tag, const char *type)
{
	if ((p = soap_in__tt__ClassDescriptor_ClassCandidate(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__ColorDescriptorExtension(struct soap *soap, struct tt__ColorDescriptorExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__ColorDescriptorExtension(struct soap *soap, const struct tt__ColorDescriptorExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ColorDescriptorExtension(struct soap *soap, const char *tag, int id, const struct tt__ColorDescriptorExtension *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ColorDescriptorExtension), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__ColorDescriptorExtension * SOAP_FMAC4 soap_in_tt__ColorDescriptorExtension(struct soap *soap, const char *tag, struct tt__ColorDescriptorExtension *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__ColorDescriptorExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ColorDescriptorExtension, sizeof(struct tt__ColorDescriptorExtension), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__ColorDescriptorExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__ColorDescriptorExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ColorDescriptorExtension, 0, sizeof(struct tt__ColorDescriptorExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ColorDescriptorExtension(struct soap *soap, const struct tt__ColorDescriptorExtension *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__ColorDescriptorExtension);
	if (soap_out_tt__ColorDescriptorExtension(soap, tag?tag:"tt:ColorDescriptorExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ColorDescriptorExtension * SOAP_FMAC4 soap_get_tt__ColorDescriptorExtension(struct soap *soap, struct tt__ColorDescriptorExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ColorDescriptorExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tt__ColorDescriptor_ColorCluster(struct soap *soap, struct _tt__ColorDescriptor_ColorCluster *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Color = NULL;
	a->Weight = NULL;
	a->Covariance = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tt__ColorDescriptor_ColorCluster(struct soap *soap, const struct _tt__ColorDescriptor_ColorCluster *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTott__Color(soap, &a->Color);
	soap_serialize_PointerTofloat(soap, &a->Weight);
	soap_serialize_PointerTott__ColorCovariance(soap, &a->Covariance);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tt__ColorDescriptor_ColorCluster(struct soap *soap, const char *tag, int id, const struct _tt__ColorDescriptor_ColorCluster *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tt__ColorDescriptor_ColorCluster), type))
		return soap->error;
	if (a->Color)
	{	if (soap_out_PointerTott__Color(soap, "tt:Color", -1, &a->Color, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:Color"))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "tt:Weight", -1, &a->Weight, ""))
		return soap->error;
	if (soap_out_PointerTott__ColorCovariance(soap, "tt:Covariance", -1, &a->Covariance, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tt__ColorDescriptor_ColorCluster * SOAP_FMAC4 soap_in__tt__ColorDescriptor_ColorCluster(struct soap *soap, const char *tag, struct _tt__ColorDescriptor_ColorCluster *a, const char *type)
{
	size_t soap_flag_Color = 1;
	size_t soap_flag_Weight = 1;
	size_t soap_flag_Covariance = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tt__ColorDescriptor_ColorCluster *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tt__ColorDescriptor_ColorCluster, sizeof(struct _tt__ColorDescriptor_ColorCluster), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tt__ColorDescriptor_ColorCluster(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Color && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__Color(soap, "tt:Color", &a->Color, "tt:Color"))
				{	soap_flag_Color--;
					continue;
				}
			if (soap_flag_Weight && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofloat(soap, "tt:Weight", &a->Weight, "xsd:float"))
				{	soap_flag_Weight--;
					continue;
				}
			if (soap_flag_Covariance && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__ColorCovariance(soap, "tt:Covariance", &a->Covariance, "tt:ColorCovariance"))
				{	soap_flag_Covariance--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tt__ColorDescriptor_ColorCluster *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tt__ColorDescriptor_ColorCluster, 0, sizeof(struct _tt__ColorDescriptor_ColorCluster), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Color > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tt__ColorDescriptor_ColorCluster(struct soap *soap, const struct _tt__ColorDescriptor_ColorCluster *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tt__ColorDescriptor_ColorCluster);
	if (soap_out__tt__ColorDescriptor_ColorCluster(soap, tag?tag:"tt:ColorDescriptor-ColorCluster", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tt__ColorDescriptor_ColorCluster * SOAP_FMAC4 soap_get__tt__ColorDescriptor_ColorCluster(struct soap *soap, struct _tt__ColorDescriptor_ColorCluster *p, const char *tag, const char *type)
{
	if ((p = soap_in__tt__ColorDescriptor_ColorCluster(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__ShapeDescriptorExtension(struct soap *soap, struct tt__ShapeDescriptorExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__ShapeDescriptorExtension(struct soap *soap, const struct tt__ShapeDescriptorExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ShapeDescriptorExtension(struct soap *soap, const char *tag, int id, const struct tt__ShapeDescriptorExtension *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ShapeDescriptorExtension), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__ShapeDescriptorExtension * SOAP_FMAC4 soap_in_tt__ShapeDescriptorExtension(struct soap *soap, const char *tag, struct tt__ShapeDescriptorExtension *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__ShapeDescriptorExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ShapeDescriptorExtension, sizeof(struct tt__ShapeDescriptorExtension), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__ShapeDescriptorExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__ShapeDescriptorExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ShapeDescriptorExtension, 0, sizeof(struct tt__ShapeDescriptorExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ShapeDescriptorExtension(struct soap *soap, const struct tt__ShapeDescriptorExtension *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__ShapeDescriptorExtension);
	if (soap_out_tt__ShapeDescriptorExtension(soap, tag?tag:"tt:ShapeDescriptorExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ShapeDescriptorExtension * SOAP_FMAC4 soap_get_tt__ShapeDescriptorExtension(struct soap *soap, struct tt__ShapeDescriptorExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ShapeDescriptorExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__AppearanceExtension(struct soap *soap, struct tt__AppearanceExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__AppearanceExtension(struct soap *soap, const struct tt__AppearanceExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AppearanceExtension(struct soap *soap, const char *tag, int id, const struct tt__AppearanceExtension *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AppearanceExtension), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__AppearanceExtension * SOAP_FMAC4 soap_in_tt__AppearanceExtension(struct soap *soap, const char *tag, struct tt__AppearanceExtension *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__AppearanceExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AppearanceExtension, sizeof(struct tt__AppearanceExtension), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__AppearanceExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__AppearanceExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AppearanceExtension, 0, sizeof(struct tt__AppearanceExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__AppearanceExtension(struct soap *soap, const struct tt__AppearanceExtension *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__AppearanceExtension);
	if (soap_out_tt__AppearanceExtension(soap, tag?tag:"tt:AppearanceExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AppearanceExtension * SOAP_FMAC4 soap_get_tt__AppearanceExtension(struct soap *soap, struct tt__AppearanceExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AppearanceExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__ClassDescriptor(struct soap *soap, struct tt__ClassDescriptor *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeClassCandidate = 0;
	a->ClassCandidate = NULL;
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__ClassDescriptor(struct soap *soap, const struct tt__ClassDescriptor *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->ClassCandidate)
	{	int i;
		for (i = 0; i < a->__sizeClassCandidate; i++)
		{
			soap_embedded(soap, a->ClassCandidate + i, SOAP_TYPE__tt__ClassDescriptor_ClassCandidate);
			soap_serialize__tt__ClassDescriptor_ClassCandidate(soap, a->ClassCandidate + i);
		}
	}
	soap_serialize_PointerTott__ClassDescriptorExtension(soap, &a->Extension);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ClassDescriptor(struct soap *soap, const char *tag, int id, const struct tt__ClassDescriptor *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ClassDescriptor), type))
		return soap->error;
	if (a->ClassCandidate)
	{	int i;
		for (i = 0; i < a->__sizeClassCandidate; i++)
			if (soap_out__tt__ClassDescriptor_ClassCandidate(soap, "tt:ClassCandidate", -1, a->ClassCandidate + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTott__ClassDescriptorExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__ClassDescriptor * SOAP_FMAC4 soap_in_tt__ClassDescriptor(struct soap *soap, const char *tag, struct tt__ClassDescriptor *a, const char *type)
{
	struct soap_blist *soap_blist_ClassCandidate = NULL;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__ClassDescriptor *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ClassDescriptor, sizeof(struct tt__ClassDescriptor), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__ClassDescriptor(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:ClassCandidate", 1, NULL))
			{	if (a->ClassCandidate == NULL)
				{	if (soap_blist_ClassCandidate == NULL)
						soap_blist_ClassCandidate = soap_new_block(soap);
					a->ClassCandidate = (struct _tt__ClassDescriptor_ClassCandidate *)soap_push_block(soap, soap_blist_ClassCandidate, sizeof(struct _tt__ClassDescriptor_ClassCandidate));
					if (a->ClassCandidate == NULL)
						return NULL;
					soap_default__tt__ClassDescriptor_ClassCandidate(soap, a->ClassCandidate);
				}
				soap_revert(soap);
				if (soap_in__tt__ClassDescriptor_ClassCandidate(soap, "tt:ClassCandidate", a->ClassCandidate, ""))
				{	a->__sizeClassCandidate++;
					a->ClassCandidate = NULL;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__ClassDescriptorExtension(soap, "tt:Extension", &a->Extension, "tt:ClassDescriptorExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ClassCandidate)
			soap_pop_block(soap, soap_blist_ClassCandidate);
		if (a->__sizeClassCandidate)
			a->ClassCandidate = (struct _tt__ClassDescriptor_ClassCandidate *)soap_save_block(soap, soap_blist_ClassCandidate, NULL, 1);
		else
		{	a->ClassCandidate = NULL;
			if (soap_blist_ClassCandidate)
				soap_end_block(soap, soap_blist_ClassCandidate);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__ClassDescriptor *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ClassDescriptor, 0, sizeof(struct tt__ClassDescriptor), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ClassDescriptor(struct soap *soap, const struct tt__ClassDescriptor *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__ClassDescriptor);
	if (soap_out_tt__ClassDescriptor(soap, tag?tag:"tt:ClassDescriptor", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ClassDescriptor * SOAP_FMAC4 soap_get_tt__ClassDescriptor(struct soap *soap, struct tt__ClassDescriptor *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ClassDescriptor(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__ColorDescriptor(struct soap *soap, struct tt__ColorDescriptor *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeColorCluster = 0;
	a->ColorCluster = NULL;
	a->Extension = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__ColorDescriptor(struct soap *soap, const struct tt__ColorDescriptor *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->ColorCluster)
	{	int i;
		for (i = 0; i < a->__sizeColorCluster; i++)
		{
			soap_embedded(soap, a->ColorCluster + i, SOAP_TYPE__tt__ColorDescriptor_ColorCluster);
			soap_serialize__tt__ColorDescriptor_ColorCluster(soap, a->ColorCluster + i);
		}
	}
	soap_serialize_PointerTott__ColorDescriptorExtension(soap, &a->Extension);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ColorDescriptor(struct soap *soap, const char *tag, int id, const struct tt__ColorDescriptor *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ColorDescriptor), type))
		return soap->error;
	if (a->ColorCluster)
	{	int i;
		for (i = 0; i < a->__sizeColorCluster; i++)
			if (soap_out__tt__ColorDescriptor_ColorCluster(soap, "tt:ColorCluster", -1, a->ColorCluster + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTott__ColorDescriptorExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__ColorDescriptor * SOAP_FMAC4 soap_in_tt__ColorDescriptor(struct soap *soap, const char *tag, struct tt__ColorDescriptor *a, const char *type)
{
	struct soap_blist *soap_blist_ColorCluster = NULL;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__ColorDescriptor *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ColorDescriptor, sizeof(struct tt__ColorDescriptor), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__ColorDescriptor(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:ColorCluster", 1, NULL))
			{	if (a->ColorCluster == NULL)
				{	if (soap_blist_ColorCluster == NULL)
						soap_blist_ColorCluster = soap_new_block(soap);
					a->ColorCluster = (struct _tt__ColorDescriptor_ColorCluster *)soap_push_block(soap, soap_blist_ColorCluster, sizeof(struct _tt__ColorDescriptor_ColorCluster));
					if (a->ColorCluster == NULL)
						return NULL;
					soap_default__tt__ColorDescriptor_ColorCluster(soap, a->ColorCluster);
				}
				soap_revert(soap);
				if (soap_in__tt__ColorDescriptor_ColorCluster(soap, "tt:ColorCluster", a->ColorCluster, ""))
				{	a->__sizeColorCluster++;
					a->ColorCluster = NULL;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__ColorDescriptorExtension(soap, "tt:Extension", &a->Extension, "tt:ColorDescriptorExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ColorCluster)
			soap_pop_block(soap, soap_blist_ColorCluster);
		if (a->__sizeColorCluster)
			a->ColorCluster = (struct _tt__ColorDescriptor_ColorCluster *)soap_save_block(soap, soap_blist_ColorCluster, NULL, 1);
		else
		{	a->ColorCluster = NULL;
			if (soap_blist_ColorCluster)
				soap_end_block(soap, soap_blist_ColorCluster);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__ColorDescriptor *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ColorDescriptor, 0, sizeof(struct tt__ColorDescriptor), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ColorDescriptor(struct soap *soap, const struct tt__ColorDescriptor *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__ColorDescriptor);
	if (soap_out_tt__ColorDescriptor(soap, tag?tag:"tt:ColorDescriptor", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ColorDescriptor * SOAP_FMAC4 soap_get_tt__ColorDescriptor(struct soap *soap, struct tt__ColorDescriptor *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ColorDescriptor(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__ShapeDescriptor(struct soap *soap, struct tt__ShapeDescriptor *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->BoundingBox = NULL;
	a->CenterOfGravity = NULL;
	a->__sizePolygon = 0;
	a->Polygon = NULL;
	a->Extension = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__ShapeDescriptor(struct soap *soap, const struct tt__ShapeDescriptor *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTott__Rectangle(soap, &a->BoundingBox);
	soap_serialize_PointerTott__Vector(soap, &a->CenterOfGravity);
	if (a->Polygon)
	{	int i;
		for (i = 0; i < a->__sizePolygon; i++)
		{
			soap_embedded(soap, a->Polygon + i, SOAP_TYPE_tt__Polygon);
			soap_serialize_tt__Polygon(soap, a->Polygon + i);
		}
	}
	soap_serialize_PointerTott__ShapeDescriptorExtension(soap, &a->Extension);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ShapeDescriptor(struct soap *soap, const char *tag, int id, const struct tt__ShapeDescriptor *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ShapeDescriptor), type))
		return soap->error;
	if (a->BoundingBox)
	{	if (soap_out_PointerTott__Rectangle(soap, "tt:BoundingBox", -1, &a->BoundingBox, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:BoundingBox"))
		return soap->error;
	if (a->CenterOfGravity)
	{	if (soap_out_PointerTott__Vector(soap, "tt:CenterOfGravity", -1, &a->CenterOfGravity, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:CenterOfGravity"))
		return soap->error;
	if (a->Polygon)
	{	int i;
		for (i = 0; i < a->__sizePolygon; i++)
			if (soap_out_tt__Polygon(soap, "tt:Polygon", -1, a->Polygon + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTott__ShapeDescriptorExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__ShapeDescriptor * SOAP_FMAC4 soap_in_tt__ShapeDescriptor(struct soap *soap, const char *tag, struct tt__ShapeDescriptor *a, const char *type)
{
	size_t soap_flag_BoundingBox = 1;
	size_t soap_flag_CenterOfGravity = 1;
	struct soap_blist *soap_blist_Polygon = NULL;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__ShapeDescriptor *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ShapeDescriptor, sizeof(struct tt__ShapeDescriptor), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__ShapeDescriptor(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_BoundingBox && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__Rectangle(soap, "tt:BoundingBox", &a->BoundingBox, "tt:Rectangle"))
				{	soap_flag_BoundingBox--;
					continue;
				}
			if (soap_flag_CenterOfGravity && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__Vector(soap, "tt:CenterOfGravity", &a->CenterOfGravity, "tt:Vector"))
				{	soap_flag_CenterOfGravity--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Polygon", 1, NULL))
			{	if (a->Polygon == NULL)
				{	if (soap_blist_Polygon == NULL)
						soap_blist_Polygon = soap_new_block(soap);
					a->Polygon = (struct tt__Polygon *)soap_push_block(soap, soap_blist_Polygon, sizeof(struct tt__Polygon));
					if (a->Polygon == NULL)
						return NULL;
					soap_default_tt__Polygon(soap, a->Polygon);
				}
				soap_revert(soap);
				if (soap_in_tt__Polygon(soap, "tt:Polygon", a->Polygon, "tt:Polygon"))
				{	a->__sizePolygon++;
					a->Polygon = NULL;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__ShapeDescriptorExtension(soap, "tt:Extension", &a->Extension, "tt:ShapeDescriptorExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Polygon)
			soap_pop_block(soap, soap_blist_Polygon);
		if (a->__sizePolygon)
			a->Polygon = (struct tt__Polygon *)soap_save_block(soap, soap_blist_Polygon, NULL, 1);
		else
		{	a->Polygon = NULL;
			if (soap_blist_Polygon)
				soap_end_block(soap, soap_blist_Polygon);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__ShapeDescriptor *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ShapeDescriptor, 0, sizeof(struct tt__ShapeDescriptor), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_BoundingBox > 0 || soap_flag_CenterOfGravity > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ShapeDescriptor(struct soap *soap, const struct tt__ShapeDescriptor *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__ShapeDescriptor);
	if (soap_out_tt__ShapeDescriptor(soap, tag?tag:"tt:ShapeDescriptor", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ShapeDescriptor * SOAP_FMAC4 soap_get_tt__ShapeDescriptor(struct soap *soap, struct tt__ShapeDescriptor *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ShapeDescriptor(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__Transformation(struct soap *soap, struct tt__Transformation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Translate = NULL;
	a->Scale = NULL;
	a->Extension = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__Transformation(struct soap *soap, const struct tt__Transformation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTott__Vector(soap, &a->Translate);
	soap_serialize_PointerTott__Vector(soap, &a->Scale);
	soap_serialize_PointerTott__TransformationExtension(soap, &a->Extension);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Transformation(struct soap *soap, const char *tag, int id, const struct tt__Transformation *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Transformation), type))
		return soap->error;
	if (soap_out_PointerTott__Vector(soap, "tt:Translate", -1, &a->Translate, ""))
		return soap->error;
	if (soap_out_PointerTott__Vector(soap, "tt:Scale", -1, &a->Scale, ""))
		return soap->error;
	if (soap_out_PointerTott__TransformationExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__Transformation * SOAP_FMAC4 soap_in_tt__Transformation(struct soap *soap, const char *tag, struct tt__Transformation *a, const char *type)
{
	size_t soap_flag_Translate = 1;
	size_t soap_flag_Scale = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__Transformation *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Transformation, sizeof(struct tt__Transformation), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__Transformation(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Translate && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__Vector(soap, "tt:Translate", &a->Translate, "tt:Vector"))
				{	soap_flag_Translate--;
					continue;
				}
			if (soap_flag_Scale && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__Vector(soap, "tt:Scale", &a->Scale, "tt:Vector"))
				{	soap_flag_Scale--;
					continue;
				}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__TransformationExtension(soap, "tt:Extension", &a->Extension, "tt:TransformationExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__Transformation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Transformation, 0, sizeof(struct tt__Transformation), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Transformation(struct soap *soap, const struct tt__Transformation *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__Transformation);
	if (soap_out_tt__Transformation(soap, tag?tag:"tt:Transformation", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Transformation * SOAP_FMAC4 soap_get_tt__Transformation(struct soap *soap, struct tt__Transformation *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Transformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__Appearance(struct soap *soap, struct tt__Appearance *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Transformation = NULL;
	a->Shape = NULL;
	a->Color = NULL;
	a->Class = NULL;
	a->Extension = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__Appearance(struct soap *soap, const struct tt__Appearance *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTott__Transformation(soap, &a->Transformation);
	soap_serialize_PointerTott__ShapeDescriptor(soap, &a->Shape);
	soap_serialize_PointerTott__ColorDescriptor(soap, &a->Color);
	soap_serialize_PointerTott__ClassDescriptor(soap, &a->Class);
	soap_serialize_PointerTott__AppearanceExtension(soap, &a->Extension);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Appearance(struct soap *soap, const char *tag, int id, const struct tt__Appearance *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Appearance), type))
		return soap->error;
	if (soap_out_PointerTott__Transformation(soap, "tt:Transformation", -1, &a->Transformation, ""))
		return soap->error;
	if (soap_out_PointerTott__ShapeDescriptor(soap, "tt:Shape", -1, &a->Shape, ""))
		return soap->error;
	if (soap_out_PointerTott__ColorDescriptor(soap, "tt:Color", -1, &a->Color, ""))
		return soap->error;
	if (soap_out_PointerTott__ClassDescriptor(soap, "tt:Class", -1, &a->Class, ""))
		return soap->error;
	if (soap_out_PointerTott__AppearanceExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__Appearance * SOAP_FMAC4 soap_in_tt__Appearance(struct soap *soap, const char *tag, struct tt__Appearance *a, const char *type)
{
	size_t soap_flag_Transformation = 1;
	size_t soap_flag_Shape = 1;
	size_t soap_flag_Color = 1;
	size_t soap_flag_Class = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__Appearance *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Appearance, sizeof(struct tt__Appearance), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__Appearance(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Transformation && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__Transformation(soap, "tt:Transformation", &a->Transformation, "tt:Transformation"))
				{	soap_flag_Transformation--;
					continue;
				}
			if (soap_flag_Shape && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__ShapeDescriptor(soap, "tt:Shape", &a->Shape, "tt:ShapeDescriptor"))
				{	soap_flag_Shape--;
					continue;
				}
			if (soap_flag_Color && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__ColorDescriptor(soap, "tt:Color", &a->Color, "tt:ColorDescriptor"))
				{	soap_flag_Color--;
					continue;
				}
			if (soap_flag_Class && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__ClassDescriptor(soap, "tt:Class", &a->Class, "tt:ClassDescriptor"))
				{	soap_flag_Class--;
					continue;
				}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__AppearanceExtension(soap, "tt:Extension", &a->Extension, "tt:AppearanceExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__Appearance *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Appearance, 0, sizeof(struct tt__Appearance), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Appearance(struct soap *soap, const struct tt__Appearance *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__Appearance);
	if (soap_out_tt__Appearance(soap, tag?tag:"tt:Appearance", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Appearance * SOAP_FMAC4 soap_get_tt__Appearance(struct soap *soap, struct tt__Appearance *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Appearance(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__ColorCovariance(struct soap *soap, struct tt__ColorCovariance *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_float(soap, &a->XX);
	soap_default_float(soap, &a->YY);
	soap_default_float(soap, &a->ZZ);
	a->XY = NULL;
	a->XZ = NULL;
	a->YZ = NULL;
	soap_default_string(soap, &a->Colorspace);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__ColorCovariance(struct soap *soap, const struct tt__ColorCovariance *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ColorCovariance(struct soap *soap, const char *tag, int id, const struct tt__ColorCovariance *a, const char *type)
{
	soap_set_attr(soap, "XX", soap_float2s(soap, a->XX), 1);
	soap_set_attr(soap, "YY", soap_float2s(soap, a->YY), 1);
	soap_set_attr(soap, "ZZ", soap_float2s(soap, a->ZZ), 1);
	if (a->XY)
		soap_set_attr(soap, "XY", soap_float2s(soap, *a->XY), 1);
	if (a->XZ)
		soap_set_attr(soap, "XZ", soap_float2s(soap, *a->XZ), 1);
	if (a->YZ)
		soap_set_attr(soap, "YZ", soap_float2s(soap, *a->YZ), 1);
	if (a->Colorspace)
		soap_set_attr(soap, "Colorspace", a->Colorspace, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ColorCovariance), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__ColorCovariance * SOAP_FMAC4 soap_in_tt__ColorCovariance(struct soap *soap, const char *tag, struct tt__ColorCovariance *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__ColorCovariance *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ColorCovariance, sizeof(struct tt__ColorCovariance), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__ColorCovariance(soap, a);
	if (soap_s2float(soap, soap_attr_value(soap, "XX", 1), &a->XX))
		return NULL;
	if (soap_s2float(soap, soap_attr_value(soap, "YY", 1), &a->YY))
		return NULL;
	if (soap_s2float(soap, soap_attr_value(soap, "ZZ", 1), &a->ZZ))
		return NULL;
	{	const char *t = soap_attr_value(soap, "XY", 0);
		if (t)
		{
			if (!(a->XY = (float *)soap_malloc(soap, sizeof(float))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2float(soap, t, a->XY))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "XZ", 0);
		if (t)
		{
			if (!(a->XZ = (float *)soap_malloc(soap, sizeof(float))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2float(soap, t, a->XZ))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "YZ", 0);
		if (t)
		{
			if (!(a->YZ = (float *)soap_malloc(soap, sizeof(float))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2float(soap, t, a->YZ))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2string(soap, soap_attr_value(soap, "Colorspace", 0), &a->Colorspace, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__ColorCovariance *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ColorCovariance, 0, sizeof(struct tt__ColorCovariance), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ColorCovariance(struct soap *soap, const struct tt__ColorCovariance *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__ColorCovariance);
	if (soap_out_tt__ColorCovariance(soap, tag?tag:"tt:ColorCovariance", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ColorCovariance * SOAP_FMAC4 soap_get_tt__ColorCovariance(struct soap *soap, struct tt__ColorCovariance *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ColorCovariance(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__Color(struct soap *soap, struct tt__Color *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_float(soap, &a->X);
	soap_default_float(soap, &a->Y);
	soap_default_float(soap, &a->Z);
	soap_default_string(soap, &a->Colorspace);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__Color(struct soap *soap, const struct tt__Color *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Color(struct soap *soap, const char *tag, int id, const struct tt__Color *a, const char *type)
{
	soap_set_attr(soap, "X", soap_float2s(soap, a->X), 1);
	soap_set_attr(soap, "Y", soap_float2s(soap, a->Y), 1);
	soap_set_attr(soap, "Z", soap_float2s(soap, a->Z), 1);
	if (a->Colorspace)
		soap_set_attr(soap, "Colorspace", a->Colorspace, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Color), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__Color * SOAP_FMAC4 soap_in_tt__Color(struct soap *soap, const char *tag, struct tt__Color *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__Color *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Color, sizeof(struct tt__Color), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__Color(soap, a);
	if (soap_s2float(soap, soap_attr_value(soap, "X", 1), &a->X))
		return NULL;
	if (soap_s2float(soap, soap_attr_value(soap, "Y", 1), &a->Y))
		return NULL;
	if (soap_s2float(soap, soap_attr_value(soap, "Z", 1), &a->Z))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "Colorspace", 0), &a->Colorspace, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__Color *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Color, 0, sizeof(struct tt__Color), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Color(struct soap *soap, const struct tt__Color *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__Color);
	if (soap_out_tt__Color(soap, tag?tag:"tt:Color", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Color * SOAP_FMAC4 soap_get_tt__Color(struct soap *soap, struct tt__Color *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Color(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__Polyline(struct soap *soap, struct tt__Polyline *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizePoint = 0;
	a->Point = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__Polyline(struct soap *soap, const struct tt__Polyline *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->Point)
	{	int i;
		for (i = 0; i < a->__sizePoint; i++)
		{
			soap_embedded(soap, a->Point + i, SOAP_TYPE_tt__Vector);
			soap_serialize_tt__Vector(soap, a->Point + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Polyline(struct soap *soap, const char *tag, int id, const struct tt__Polyline *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Polyline), type))
		return soap->error;
	if (a->Point)
	{	int i;
		for (i = 0; i < a->__sizePoint; i++)
			if (soap_out_tt__Vector(soap, "tt:Point", -1, a->Point + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__Polyline * SOAP_FMAC4 soap_in_tt__Polyline(struct soap *soap, const char *tag, struct tt__Polyline *a, const char *type)
{
	struct soap_blist *soap_blist_Point = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__Polyline *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Polyline, sizeof(struct tt__Polyline), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__Polyline(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Point", 1, NULL))
			{	if (a->Point == NULL)
				{	if (soap_blist_Point == NULL)
						soap_blist_Point = soap_new_block(soap);
					a->Point = (struct tt__Vector *)soap_push_block(soap, soap_blist_Point, sizeof(struct tt__Vector));
					if (a->Point == NULL)
						return NULL;
					soap_default_tt__Vector(soap, a->Point);
				}
				soap_revert(soap);
				if (soap_in_tt__Vector(soap, "tt:Point", a->Point, "tt:Vector"))
				{	a->__sizePoint++;
					a->Point = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Point)
			soap_pop_block(soap, soap_blist_Point);
		if (a->__sizePoint)
			a->Point = (struct tt__Vector *)soap_save_block(soap, soap_blist_Point, NULL, 1);
		else
		{	a->Point = NULL;
			if (soap_blist_Point)
				soap_end_block(soap, soap_blist_Point);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__Polyline *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Polyline, 0, sizeof(struct tt__Polyline), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->__sizePoint < 2))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Polyline(struct soap *soap, const struct tt__Polyline *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__Polyline);
	if (soap_out_tt__Polyline(soap, tag?tag:"tt:Polyline", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Polyline * SOAP_FMAC4 soap_get_tt__Polyline(struct soap *soap, struct tt__Polyline *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Polyline(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__Polygon(struct soap *soap, struct tt__Polygon *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizePoint = 0;
	a->Point = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__Polygon(struct soap *soap, const struct tt__Polygon *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->Point)
	{	int i;
		for (i = 0; i < a->__sizePoint; i++)
		{
			soap_embedded(soap, a->Point + i, SOAP_TYPE_tt__Vector);
			soap_serialize_tt__Vector(soap, a->Point + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Polygon(struct soap *soap, const char *tag, int id, const struct tt__Polygon *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Polygon), type))
		return soap->error;
	if (a->Point)
	{	int i;
		for (i = 0; i < a->__sizePoint; i++)
			if (soap_out_tt__Vector(soap, "tt:Point", -1, a->Point + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__Polygon * SOAP_FMAC4 soap_in_tt__Polygon(struct soap *soap, const char *tag, struct tt__Polygon *a, const char *type)
{
	struct soap_blist *soap_blist_Point = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__Polygon *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Polygon, sizeof(struct tt__Polygon), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__Polygon(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Point", 1, NULL))
			{	if (a->Point == NULL)
				{	if (soap_blist_Point == NULL)
						soap_blist_Point = soap_new_block(soap);
					a->Point = (struct tt__Vector *)soap_push_block(soap, soap_blist_Point, sizeof(struct tt__Vector));
					if (a->Point == NULL)
						return NULL;
					soap_default_tt__Vector(soap, a->Point);
				}
				soap_revert(soap);
				if (soap_in_tt__Vector(soap, "tt:Point", a->Point, "tt:Vector"))
				{	a->__sizePoint++;
					a->Point = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Point)
			soap_pop_block(soap, soap_blist_Point);
		if (a->__sizePoint)
			a->Point = (struct tt__Vector *)soap_save_block(soap, soap_blist_Point, NULL, 1);
		else
		{	a->Point = NULL;
			if (soap_blist_Point)
				soap_end_block(soap, soap_blist_Point);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__Polygon *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Polygon, 0, sizeof(struct tt__Polygon), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->__sizePoint < 3))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Polygon(struct soap *soap, const struct tt__Polygon *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__Polygon);
	if (soap_out_tt__Polygon(soap, tag?tag:"tt:Polygon", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Polygon * SOAP_FMAC4 soap_get_tt__Polygon(struct soap *soap, struct tt__Polygon *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Polygon(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__Vector(struct soap *soap, struct tt__Vector *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->x = NULL;
	a->y = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__Vector(struct soap *soap, const struct tt__Vector *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Vector(struct soap *soap, const char *tag, int id, const struct tt__Vector *a, const char *type)
{
	if (a->x)
		soap_set_attr(soap, "x", soap_float2s(soap, *a->x), 1);
	if (a->y)
		soap_set_attr(soap, "y", soap_float2s(soap, *a->y), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Vector), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__Vector * SOAP_FMAC4 soap_in_tt__Vector(struct soap *soap, const char *tag, struct tt__Vector *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__Vector *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Vector, sizeof(struct tt__Vector), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__Vector(soap, a);
	{	const char *t = soap_attr_value(soap, "x", 0);
		if (t)
		{
			if (!(a->x = (float *)soap_malloc(soap, sizeof(float))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2float(soap, t, a->x))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "y", 0);
		if (t)
		{
			if (!(a->y = (float *)soap_malloc(soap, sizeof(float))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2float(soap, t, a->y))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__Vector *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Vector, 0, sizeof(struct tt__Vector), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Vector(struct soap *soap, const struct tt__Vector *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__Vector);
	if (soap_out_tt__Vector(soap, tag?tag:"tt:Vector", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Vector * SOAP_FMAC4 soap_get_tt__Vector(struct soap *soap, struct tt__Vector *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Vector(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__ItemListDescriptionExtension(struct soap *soap, struct tt__ItemListDescriptionExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__ItemListDescriptionExtension(struct soap *soap, const struct tt__ItemListDescriptionExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ItemListDescriptionExtension(struct soap *soap, const char *tag, int id, const struct tt__ItemListDescriptionExtension *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ItemListDescriptionExtension), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__ItemListDescriptionExtension * SOAP_FMAC4 soap_in_tt__ItemListDescriptionExtension(struct soap *soap, const char *tag, struct tt__ItemListDescriptionExtension *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__ItemListDescriptionExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ItemListDescriptionExtension, sizeof(struct tt__ItemListDescriptionExtension), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__ItemListDescriptionExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__ItemListDescriptionExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ItemListDescriptionExtension, 0, sizeof(struct tt__ItemListDescriptionExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ItemListDescriptionExtension(struct soap *soap, const struct tt__ItemListDescriptionExtension *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__ItemListDescriptionExtension);
	if (soap_out_tt__ItemListDescriptionExtension(soap, tag?tag:"tt:ItemListDescriptionExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ItemListDescriptionExtension * SOAP_FMAC4 soap_get_tt__ItemListDescriptionExtension(struct soap *soap, struct tt__ItemListDescriptionExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ItemListDescriptionExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tt__ItemListDescription_ElementItemDescription(struct soap *soap, struct _tt__ItemListDescription_ElementItemDescription *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Name);
	soap_default__QName(soap, &a->Type);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tt__ItemListDescription_ElementItemDescription(struct soap *soap, const struct _tt__ItemListDescription_ElementItemDescription *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tt__ItemListDescription_ElementItemDescription(struct soap *soap, const char *tag, int id, const struct _tt__ItemListDescription_ElementItemDescription *a, const char *type)
{
	if (a->Name)
		soap_set_attr(soap, "Name", a->Name, 1);
	if (a->Type)
		soap_set_attr(soap, "Type", soap_QName2s(soap, a->Type), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tt__ItemListDescription_ElementItemDescription), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tt__ItemListDescription_ElementItemDescription * SOAP_FMAC4 soap_in__tt__ItemListDescription_ElementItemDescription(struct soap *soap, const char *tag, struct _tt__ItemListDescription_ElementItemDescription *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tt__ItemListDescription_ElementItemDescription *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tt__ItemListDescription_ElementItemDescription, sizeof(struct _tt__ItemListDescription_ElementItemDescription), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tt__ItemListDescription_ElementItemDescription(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Name", 1), &a->Name, -1, -1))
		return NULL;
	if (soap_s2QName(soap, soap_attr_value(soap, "Type", 1), &a->Type, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tt__ItemListDescription_ElementItemDescription *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tt__ItemListDescription_ElementItemDescription, 0, sizeof(struct _tt__ItemListDescription_ElementItemDescription), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tt__ItemListDescription_ElementItemDescription(struct soap *soap, const struct _tt__ItemListDescription_ElementItemDescription *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tt__ItemListDescription_ElementItemDescription);
	if (soap_out__tt__ItemListDescription_ElementItemDescription(soap, tag?tag:"tt:ItemListDescription-ElementItemDescription", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tt__ItemListDescription_ElementItemDescription * SOAP_FMAC4 soap_get__tt__ItemListDescription_ElementItemDescription(struct soap *soap, struct _tt__ItemListDescription_ElementItemDescription *p, const char *tag, const char *type)
{
	if ((p = soap_in__tt__ItemListDescription_ElementItemDescription(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tt__ItemListDescription_SimpleItemDescription(struct soap *soap, struct _tt__ItemListDescription_SimpleItemDescription *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Name);
	soap_default__QName(soap, &a->Type);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tt__ItemListDescription_SimpleItemDescription(struct soap *soap, const struct _tt__ItemListDescription_SimpleItemDescription *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tt__ItemListDescription_SimpleItemDescription(struct soap *soap, const char *tag, int id, const struct _tt__ItemListDescription_SimpleItemDescription *a, const char *type)
{
	if (a->Name)
		soap_set_attr(soap, "Name", a->Name, 1);
	if (a->Type)
		soap_set_attr(soap, "Type", soap_QName2s(soap, a->Type), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tt__ItemListDescription_SimpleItemDescription), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tt__ItemListDescription_SimpleItemDescription * SOAP_FMAC4 soap_in__tt__ItemListDescription_SimpleItemDescription(struct soap *soap, const char *tag, struct _tt__ItemListDescription_SimpleItemDescription *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tt__ItemListDescription_SimpleItemDescription *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tt__ItemListDescription_SimpleItemDescription, sizeof(struct _tt__ItemListDescription_SimpleItemDescription), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tt__ItemListDescription_SimpleItemDescription(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Name", 1), &a->Name, -1, -1))
		return NULL;
	if (soap_s2QName(soap, soap_attr_value(soap, "Type", 1), &a->Type, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tt__ItemListDescription_SimpleItemDescription *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tt__ItemListDescription_SimpleItemDescription, 0, sizeof(struct _tt__ItemListDescription_SimpleItemDescription), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tt__ItemListDescription_SimpleItemDescription(struct soap *soap, const struct _tt__ItemListDescription_SimpleItemDescription *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tt__ItemListDescription_SimpleItemDescription);
	if (soap_out__tt__ItemListDescription_SimpleItemDescription(soap, tag?tag:"tt:ItemListDescription-SimpleItemDescription", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tt__ItemListDescription_SimpleItemDescription * SOAP_FMAC4 soap_get__tt__ItemListDescription_SimpleItemDescription(struct soap *soap, struct _tt__ItemListDescription_SimpleItemDescription *p, const char *tag, const char *type)
{
	if ((p = soap_in__tt__ItemListDescription_SimpleItemDescription(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__MessageDescriptionExtension(struct soap *soap, struct tt__MessageDescriptionExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__MessageDescriptionExtension(struct soap *soap, const struct tt__MessageDescriptionExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__MessageDescriptionExtension(struct soap *soap, const char *tag, int id, const struct tt__MessageDescriptionExtension *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__MessageDescriptionExtension), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__MessageDescriptionExtension * SOAP_FMAC4 soap_in_tt__MessageDescriptionExtension(struct soap *soap, const char *tag, struct tt__MessageDescriptionExtension *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__MessageDescriptionExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__MessageDescriptionExtension, sizeof(struct tt__MessageDescriptionExtension), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__MessageDescriptionExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__MessageDescriptionExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__MessageDescriptionExtension, 0, sizeof(struct tt__MessageDescriptionExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__MessageDescriptionExtension(struct soap *soap, const struct tt__MessageDescriptionExtension *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__MessageDescriptionExtension);
	if (soap_out_tt__MessageDescriptionExtension(soap, tag?tag:"tt:MessageDescriptionExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__MessageDescriptionExtension * SOAP_FMAC4 soap_get_tt__MessageDescriptionExtension(struct soap *soap, struct tt__MessageDescriptionExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__MessageDescriptionExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__ItemListDescription(struct soap *soap, struct tt__ItemListDescription *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeSimpleItemDescription = 0;
	a->SimpleItemDescription = NULL;
	a->__sizeElementItemDescription = 0;
	a->ElementItemDescription = NULL;
	a->Extension = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__ItemListDescription(struct soap *soap, const struct tt__ItemListDescription *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->SimpleItemDescription)
	{	int i;
		for (i = 0; i < a->__sizeSimpleItemDescription; i++)
		{
			soap_embedded(soap, a->SimpleItemDescription + i, SOAP_TYPE__tt__ItemListDescription_SimpleItemDescription);
			soap_serialize__tt__ItemListDescription_SimpleItemDescription(soap, a->SimpleItemDescription + i);
		}
	}
	if (a->ElementItemDescription)
	{	int i;
		for (i = 0; i < a->__sizeElementItemDescription; i++)
		{
			soap_embedded(soap, a->ElementItemDescription + i, SOAP_TYPE__tt__ItemListDescription_ElementItemDescription);
			soap_serialize__tt__ItemListDescription_ElementItemDescription(soap, a->ElementItemDescription + i);
		}
	}
	soap_serialize_PointerTott__ItemListDescriptionExtension(soap, &a->Extension);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ItemListDescription(struct soap *soap, const char *tag, int id, const struct tt__ItemListDescription *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ItemListDescription), type))
		return soap->error;
	if (a->SimpleItemDescription)
	{	int i;
		for (i = 0; i < a->__sizeSimpleItemDescription; i++)
			if (soap_out__tt__ItemListDescription_SimpleItemDescription(soap, "tt:SimpleItemDescription", -1, a->SimpleItemDescription + i, ""))
				return soap->error;
	}
	if (a->ElementItemDescription)
	{	int i;
		for (i = 0; i < a->__sizeElementItemDescription; i++)
			if (soap_out__tt__ItemListDescription_ElementItemDescription(soap, "tt:ElementItemDescription", -1, a->ElementItemDescription + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTott__ItemListDescriptionExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__ItemListDescription * SOAP_FMAC4 soap_in_tt__ItemListDescription(struct soap *soap, const char *tag, struct tt__ItemListDescription *a, const char *type)
{
	struct soap_blist *soap_blist_SimpleItemDescription = NULL;
	struct soap_blist *soap_blist_ElementItemDescription = NULL;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__ItemListDescription *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ItemListDescription, sizeof(struct tt__ItemListDescription), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__ItemListDescription(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:SimpleItemDescription", 1, NULL))
			{	if (a->SimpleItemDescription == NULL)
				{	if (soap_blist_SimpleItemDescription == NULL)
						soap_blist_SimpleItemDescription = soap_new_block(soap);
					a->SimpleItemDescription = (struct _tt__ItemListDescription_SimpleItemDescription *)soap_push_block(soap, soap_blist_SimpleItemDescription, sizeof(struct _tt__ItemListDescription_SimpleItemDescription));
					if (a->SimpleItemDescription == NULL)
						return NULL;
					soap_default__tt__ItemListDescription_SimpleItemDescription(soap, a->SimpleItemDescription);
				}
				soap_revert(soap);
				if (soap_in__tt__ItemListDescription_SimpleItemDescription(soap, "tt:SimpleItemDescription", a->SimpleItemDescription, ""))
				{	a->__sizeSimpleItemDescription++;
					a->SimpleItemDescription = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:ElementItemDescription", 1, NULL))
			{	if (a->ElementItemDescription == NULL)
				{	if (soap_blist_ElementItemDescription == NULL)
						soap_blist_ElementItemDescription = soap_new_block(soap);
					a->ElementItemDescription = (struct _tt__ItemListDescription_ElementItemDescription *)soap_push_block(soap, soap_blist_ElementItemDescription, sizeof(struct _tt__ItemListDescription_ElementItemDescription));
					if (a->ElementItemDescription == NULL)
						return NULL;
					soap_default__tt__ItemListDescription_ElementItemDescription(soap, a->ElementItemDescription);
				}
				soap_revert(soap);
				if (soap_in__tt__ItemListDescription_ElementItemDescription(soap, "tt:ElementItemDescription", a->ElementItemDescription, ""))
				{	a->__sizeElementItemDescription++;
					a->ElementItemDescription = NULL;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__ItemListDescriptionExtension(soap, "tt:Extension", &a->Extension, "tt:ItemListDescriptionExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->SimpleItemDescription)
			soap_pop_block(soap, soap_blist_SimpleItemDescription);
		if (a->__sizeSimpleItemDescription)
			a->SimpleItemDescription = (struct _tt__ItemListDescription_SimpleItemDescription *)soap_save_block(soap, soap_blist_SimpleItemDescription, NULL, 1);
		else
		{	a->SimpleItemDescription = NULL;
			if (soap_blist_SimpleItemDescription)
				soap_end_block(soap, soap_blist_SimpleItemDescription);
		}
		if (a->ElementItemDescription)
			soap_pop_block(soap, soap_blist_ElementItemDescription);
		if (a->__sizeElementItemDescription)
			a->ElementItemDescription = (struct _tt__ItemListDescription_ElementItemDescription *)soap_save_block(soap, soap_blist_ElementItemDescription, NULL, 1);
		else
		{	a->ElementItemDescription = NULL;
			if (soap_blist_ElementItemDescription)
				soap_end_block(soap, soap_blist_ElementItemDescription);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__ItemListDescription *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ItemListDescription, 0, sizeof(struct tt__ItemListDescription), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ItemListDescription(struct soap *soap, const struct tt__ItemListDescription *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__ItemListDescription);
	if (soap_out_tt__ItemListDescription(soap, tag?tag:"tt:ItemListDescription", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ItemListDescription * SOAP_FMAC4 soap_get_tt__ItemListDescription(struct soap *soap, struct tt__ItemListDescription *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ItemListDescription(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__MessageDescription(struct soap *soap, struct tt__MessageDescription *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Source = NULL;
	a->Key = NULL;
	a->Data = NULL;
	a->Extension = NULL;
	a->IsProperty = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__MessageDescription(struct soap *soap, const struct tt__MessageDescription *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTott__ItemListDescription(soap, &a->Source);
	soap_serialize_PointerTott__ItemListDescription(soap, &a->Key);
	soap_serialize_PointerTott__ItemListDescription(soap, &a->Data);
	soap_serialize_PointerTott__MessageDescriptionExtension(soap, &a->Extension);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__MessageDescription(struct soap *soap, const char *tag, int id, const struct tt__MessageDescription *a, const char *type)
{
	if (a->IsProperty)
		soap_set_attr(soap, "IsProperty", soap_xsd__boolean_2s(soap, *a->IsProperty), 1);
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__MessageDescription), type))
		return soap->error;
	if (soap_out_PointerTott__ItemListDescription(soap, "tt:Source", -1, &a->Source, ""))
		return soap->error;
	if (soap_out_PointerTott__ItemListDescription(soap, "tt:Key", -1, &a->Key, ""))
		return soap->error;
	if (soap_out_PointerTott__ItemListDescription(soap, "tt:Data", -1, &a->Data, ""))
		return soap->error;
	if (soap_out_PointerTott__MessageDescriptionExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__MessageDescription * SOAP_FMAC4 soap_in_tt__MessageDescription(struct soap *soap, const char *tag, struct tt__MessageDescription *a, const char *type)
{
	size_t soap_flag_Source = 1;
	size_t soap_flag_Key = 1;
	size_t soap_flag_Data = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__MessageDescription *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__MessageDescription, sizeof(struct tt__MessageDescription), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__MessageDescription(soap, a);
	{	const char *t = soap_attr_value(soap, "IsProperty", 0);
		if (t)
		{
			if (!(a->IsProperty = (enum xsd__boolean_ *)soap_malloc(soap, sizeof(enum xsd__boolean_))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean_(soap, t, a->IsProperty))
			return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Source && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__ItemListDescription(soap, "tt:Source", &a->Source, "tt:ItemListDescription"))
				{	soap_flag_Source--;
					continue;
				}
			if (soap_flag_Key && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__ItemListDescription(soap, "tt:Key", &a->Key, "tt:ItemListDescription"))
				{	soap_flag_Key--;
					continue;
				}
			if (soap_flag_Data && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__ItemListDescription(soap, "tt:Data", &a->Data, "tt:ItemListDescription"))
				{	soap_flag_Data--;
					continue;
				}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__MessageDescriptionExtension(soap, "tt:Extension", &a->Extension, "tt:MessageDescriptionExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__MessageDescription *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__MessageDescription, 0, sizeof(struct tt__MessageDescription), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__MessageDescription(struct soap *soap, const struct tt__MessageDescription *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__MessageDescription);
	if (soap_out_tt__MessageDescription(soap, tag?tag:"tt:MessageDescription", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__MessageDescription * SOAP_FMAC4 soap_get_tt__MessageDescription(struct soap *soap, struct tt__MessageDescription *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__MessageDescription(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__ItemListExtension(struct soap *soap, struct tt__ItemListExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__ItemListExtension(struct soap *soap, const struct tt__ItemListExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ItemListExtension(struct soap *soap, const char *tag, int id, const struct tt__ItemListExtension *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ItemListExtension), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__ItemListExtension * SOAP_FMAC4 soap_in_tt__ItemListExtension(struct soap *soap, const char *tag, struct tt__ItemListExtension *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__ItemListExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ItemListExtension, sizeof(struct tt__ItemListExtension), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__ItemListExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__ItemListExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ItemListExtension, 0, sizeof(struct tt__ItemListExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ItemListExtension(struct soap *soap, const struct tt__ItemListExtension *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__ItemListExtension);
	if (soap_out_tt__ItemListExtension(soap, tag?tag:"tt:ItemListExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ItemListExtension * SOAP_FMAC4 soap_get_tt__ItemListExtension(struct soap *soap, struct tt__ItemListExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ItemListExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tt__ItemList_ElementItem(struct soap *soap, struct _tt__ItemList_ElementItem *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
	soap_default_string(soap, &a->Name);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tt__ItemList_ElementItem(struct soap *soap, const struct _tt__ItemList_ElementItem *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tt__ItemList_ElementItem(struct soap *soap, const char *tag, int id, const struct _tt__ItemList_ElementItem *a, const char *type)
{
	if (a->Name)
		soap_set_attr(soap, "Name", a->Name, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tt__ItemList_ElementItem), type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tt__ItemList_ElementItem * SOAP_FMAC4 soap_in__tt__ItemList_ElementItem(struct soap *soap, const char *tag, struct _tt__ItemList_ElementItem *a, const char *type)
{
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tt__ItemList_ElementItem *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tt__ItemList_ElementItem, sizeof(struct _tt__ItemList_ElementItem), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tt__ItemList_ElementItem(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Name", 1), &a->Name, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tt__ItemList_ElementItem *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tt__ItemList_ElementItem, 0, sizeof(struct _tt__ItemList_ElementItem), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tt__ItemList_ElementItem(struct soap *soap, const struct _tt__ItemList_ElementItem *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tt__ItemList_ElementItem);
	if (soap_out__tt__ItemList_ElementItem(soap, tag?tag:"tt:ItemList-ElementItem", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tt__ItemList_ElementItem * SOAP_FMAC4 soap_get__tt__ItemList_ElementItem(struct soap *soap, struct _tt__ItemList_ElementItem *p, const char *tag, const char *type)
{
	if ((p = soap_in__tt__ItemList_ElementItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tt__ItemList_SimpleItem(struct soap *soap, struct _tt__ItemList_SimpleItem *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Name);
	soap_default_xsd__anySimpleType(soap, &a->Value);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tt__ItemList_SimpleItem(struct soap *soap, const struct _tt__ItemList_SimpleItem *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tt__ItemList_SimpleItem(struct soap *soap, const char *tag, int id, const struct _tt__ItemList_SimpleItem *a, const char *type)
{
	if (a->Name)
		soap_set_attr(soap, "Name", a->Name, 1);
	if (a->Value)
		soap_set_attr(soap, "Value", a->Value, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tt__ItemList_SimpleItem), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tt__ItemList_SimpleItem * SOAP_FMAC4 soap_in__tt__ItemList_SimpleItem(struct soap *soap, const char *tag, struct _tt__ItemList_SimpleItem *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tt__ItemList_SimpleItem *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tt__ItemList_SimpleItem, sizeof(struct _tt__ItemList_SimpleItem), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tt__ItemList_SimpleItem(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Name", 1), &a->Name, -1, -1))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "Value", 1), &a->Value, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tt__ItemList_SimpleItem *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tt__ItemList_SimpleItem, 0, sizeof(struct _tt__ItemList_SimpleItem), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tt__ItemList_SimpleItem(struct soap *soap, const struct _tt__ItemList_SimpleItem *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tt__ItemList_SimpleItem);
	if (soap_out__tt__ItemList_SimpleItem(soap, tag?tag:"tt:ItemList-SimpleItem", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tt__ItemList_SimpleItem * SOAP_FMAC4 soap_get__tt__ItemList_SimpleItem(struct soap *soap, struct _tt__ItemList_SimpleItem *p, const char *tag, const char *type)
{
	if ((p = soap_in__tt__ItemList_SimpleItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__ItemList(struct soap *soap, struct tt__ItemList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeSimpleItem = 0;
	a->SimpleItem = NULL;
	a->__sizeElementItem = 0;
	a->ElementItem = NULL;
	a->Extension = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__ItemList(struct soap *soap, const struct tt__ItemList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->SimpleItem)
	{	int i;
		for (i = 0; i < a->__sizeSimpleItem; i++)
		{
			soap_embedded(soap, a->SimpleItem + i, SOAP_TYPE__tt__ItemList_SimpleItem);
			soap_serialize__tt__ItemList_SimpleItem(soap, a->SimpleItem + i);
		}
	}
	if (a->ElementItem)
	{	int i;
		for (i = 0; i < a->__sizeElementItem; i++)
		{
			soap_embedded(soap, a->ElementItem + i, SOAP_TYPE__tt__ItemList_ElementItem);
			soap_serialize__tt__ItemList_ElementItem(soap, a->ElementItem + i);
		}
	}
	soap_serialize_PointerTott__ItemListExtension(soap, &a->Extension);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ItemList(struct soap *soap, const char *tag, int id, const struct tt__ItemList *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ItemList), type))
		return soap->error;
	if (a->SimpleItem)
	{	int i;
		for (i = 0; i < a->__sizeSimpleItem; i++)
			if (soap_out__tt__ItemList_SimpleItem(soap, "tt:SimpleItem", -1, a->SimpleItem + i, ""))
				return soap->error;
	}
	if (a->ElementItem)
	{	int i;
		for (i = 0; i < a->__sizeElementItem; i++)
			if (soap_out__tt__ItemList_ElementItem(soap, "tt:ElementItem", -1, a->ElementItem + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTott__ItemListExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__ItemList * SOAP_FMAC4 soap_in_tt__ItemList(struct soap *soap, const char *tag, struct tt__ItemList *a, const char *type)
{
	struct soap_blist *soap_blist_SimpleItem = NULL;
	struct soap_blist *soap_blist_ElementItem = NULL;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__ItemList *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ItemList, sizeof(struct tt__ItemList), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__ItemList(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:SimpleItem", 1, NULL))
			{	if (a->SimpleItem == NULL)
				{	if (soap_blist_SimpleItem == NULL)
						soap_blist_SimpleItem = soap_new_block(soap);
					a->SimpleItem = (struct _tt__ItemList_SimpleItem *)soap_push_block(soap, soap_blist_SimpleItem, sizeof(struct _tt__ItemList_SimpleItem));
					if (a->SimpleItem == NULL)
						return NULL;
					soap_default__tt__ItemList_SimpleItem(soap, a->SimpleItem);
				}
				soap_revert(soap);
				if (soap_in__tt__ItemList_SimpleItem(soap, "tt:SimpleItem", a->SimpleItem, ""))
				{	a->__sizeSimpleItem++;
					a->SimpleItem = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:ElementItem", 1, NULL))
			{	if (a->ElementItem == NULL)
				{	if (soap_blist_ElementItem == NULL)
						soap_blist_ElementItem = soap_new_block(soap);
					a->ElementItem = (struct _tt__ItemList_ElementItem *)soap_push_block(soap, soap_blist_ElementItem, sizeof(struct _tt__ItemList_ElementItem));
					if (a->ElementItem == NULL)
						return NULL;
					soap_default__tt__ItemList_ElementItem(soap, a->ElementItem);
				}
				soap_revert(soap);
				if (soap_in__tt__ItemList_ElementItem(soap, "tt:ElementItem", a->ElementItem, ""))
				{	a->__sizeElementItem++;
					a->ElementItem = NULL;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__ItemListExtension(soap, "tt:Extension", &a->Extension, "tt:ItemListExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->SimpleItem)
			soap_pop_block(soap, soap_blist_SimpleItem);
		if (a->__sizeSimpleItem)
			a->SimpleItem = (struct _tt__ItemList_SimpleItem *)soap_save_block(soap, soap_blist_SimpleItem, NULL, 1);
		else
		{	a->SimpleItem = NULL;
			if (soap_blist_SimpleItem)
				soap_end_block(soap, soap_blist_SimpleItem);
		}
		if (a->ElementItem)
			soap_pop_block(soap, soap_blist_ElementItem);
		if (a->__sizeElementItem)
			a->ElementItem = (struct _tt__ItemList_ElementItem *)soap_save_block(soap, soap_blist_ElementItem, NULL, 1);
		else
		{	a->ElementItem = NULL;
			if (soap_blist_ElementItem)
				soap_end_block(soap, soap_blist_ElementItem);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__ItemList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ItemList, 0, sizeof(struct tt__ItemList), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ItemList(struct soap *soap, const struct tt__ItemList *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__ItemList);
	if (soap_out_tt__ItemList(soap, tag?tag:"tt:ItemList", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ItemList * SOAP_FMAC4 soap_get_tt__ItemList(struct soap *soap, struct tt__ItemList *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ItemList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__MessageExtension(struct soap *soap, struct tt__MessageExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__MessageExtension(struct soap *soap, const struct tt__MessageExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__MessageExtension(struct soap *soap, const char *tag, int id, const struct tt__MessageExtension *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__MessageExtension), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__MessageExtension * SOAP_FMAC4 soap_in_tt__MessageExtension(struct soap *soap, const char *tag, struct tt__MessageExtension *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__MessageExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__MessageExtension, sizeof(struct tt__MessageExtension), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__MessageExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__MessageExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__MessageExtension, 0, sizeof(struct tt__MessageExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__MessageExtension(struct soap *soap, const struct tt__MessageExtension *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__MessageExtension);
	if (soap_out_tt__MessageExtension(soap, tag?tag:"tt:MessageExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__MessageExtension * SOAP_FMAC4 soap_get_tt__MessageExtension(struct soap *soap, struct tt__MessageExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__MessageExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__FocusOptions20Extension(struct soap *soap, struct tt__FocusOptions20Extension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__FocusOptions20Extension(struct soap *soap, const struct tt__FocusOptions20Extension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__FocusOptions20Extension(struct soap *soap, const char *tag, int id, const struct tt__FocusOptions20Extension *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__FocusOptions20Extension), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__FocusOptions20Extension * SOAP_FMAC4 soap_in_tt__FocusOptions20Extension(struct soap *soap, const char *tag, struct tt__FocusOptions20Extension *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__FocusOptions20Extension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__FocusOptions20Extension, sizeof(struct tt__FocusOptions20Extension), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__FocusOptions20Extension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__FocusOptions20Extension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__FocusOptions20Extension, 0, sizeof(struct tt__FocusOptions20Extension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__FocusOptions20Extension(struct soap *soap, const struct tt__FocusOptions20Extension *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__FocusOptions20Extension);
	if (soap_out_tt__FocusOptions20Extension(soap, tag?tag:"tt:FocusOptions20Extension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__FocusOptions20Extension * SOAP_FMAC4 soap_get_tt__FocusOptions20Extension(struct soap *soap, struct tt__FocusOptions20Extension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__FocusOptions20Extension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__WhiteBalanceOptions20Extension(struct soap *soap, struct tt__WhiteBalanceOptions20Extension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__WhiteBalanceOptions20Extension(struct soap *soap, const struct tt__WhiteBalanceOptions20Extension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__WhiteBalanceOptions20Extension(struct soap *soap, const char *tag, int id, const struct tt__WhiteBalanceOptions20Extension *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__WhiteBalanceOptions20Extension), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__WhiteBalanceOptions20Extension * SOAP_FMAC4 soap_in_tt__WhiteBalanceOptions20Extension(struct soap *soap, const char *tag, struct tt__WhiteBalanceOptions20Extension *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__WhiteBalanceOptions20Extension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__WhiteBalanceOptions20Extension, sizeof(struct tt__WhiteBalanceOptions20Extension), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__WhiteBalanceOptions20Extension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__WhiteBalanceOptions20Extension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__WhiteBalanceOptions20Extension, 0, sizeof(struct tt__WhiteBalanceOptions20Extension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__WhiteBalanceOptions20Extension(struct soap *soap, const struct tt__WhiteBalanceOptions20Extension *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__WhiteBalanceOptions20Extension);
	if (soap_out_tt__WhiteBalanceOptions20Extension(soap, tag?tag:"tt:WhiteBalanceOptions20Extension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__WhiteBalanceOptions20Extension * SOAP_FMAC4 soap_get_tt__WhiteBalanceOptions20Extension(struct soap *soap, struct tt__WhiteBalanceOptions20Extension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__WhiteBalanceOptions20Extension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__FocusConfiguration20Extension(struct soap *soap, struct tt__FocusConfiguration20Extension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__FocusConfiguration20Extension(struct soap *soap, const struct tt__FocusConfiguration20Extension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__FocusConfiguration20Extension(struct soap *soap, const char *tag, int id, const struct tt__FocusConfiguration20Extension *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__FocusConfiguration20Extension), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__FocusConfiguration20Extension * SOAP_FMAC4 soap_in_tt__FocusConfiguration20Extension(struct soap *soap, const char *tag, struct tt__FocusConfiguration20Extension *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__FocusConfiguration20Extension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__FocusConfiguration20Extension, sizeof(struct tt__FocusConfiguration20Extension), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__FocusConfiguration20Extension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__FocusConfiguration20Extension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__FocusConfiguration20Extension, 0, sizeof(struct tt__FocusConfiguration20Extension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__FocusConfiguration20Extension(struct soap *soap, const struct tt__FocusConfiguration20Extension *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__FocusConfiguration20Extension);
	if (soap_out_tt__FocusConfiguration20Extension(soap, tag?tag:"tt:FocusConfiguration20Extension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__FocusConfiguration20Extension * SOAP_FMAC4 soap_get_tt__FocusConfiguration20Extension(struct soap *soap, struct tt__FocusConfiguration20Extension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__FocusConfiguration20Extension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__WhiteBalance20Extension(struct soap *soap, struct tt__WhiteBalance20Extension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__WhiteBalance20Extension(struct soap *soap, const struct tt__WhiteBalance20Extension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__WhiteBalance20Extension(struct soap *soap, const char *tag, int id, const struct tt__WhiteBalance20Extension *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__WhiteBalance20Extension), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__WhiteBalance20Extension * SOAP_FMAC4 soap_in_tt__WhiteBalance20Extension(struct soap *soap, const char *tag, struct tt__WhiteBalance20Extension *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__WhiteBalance20Extension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__WhiteBalance20Extension, sizeof(struct tt__WhiteBalance20Extension), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__WhiteBalance20Extension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__WhiteBalance20Extension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__WhiteBalance20Extension, 0, sizeof(struct tt__WhiteBalance20Extension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__WhiteBalance20Extension(struct soap *soap, const struct tt__WhiteBalance20Extension *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__WhiteBalance20Extension);
	if (soap_out_tt__WhiteBalance20Extension(soap, tag?tag:"tt:WhiteBalance20Extension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__WhiteBalance20Extension * SOAP_FMAC4 soap_get_tt__WhiteBalance20Extension(struct soap *soap, struct tt__WhiteBalance20Extension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__WhiteBalance20Extension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__RelativeFocusOptions20(struct soap *soap, struct tt__RelativeFocusOptions20 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Distance = NULL;
	a->Speed = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__RelativeFocusOptions20(struct soap *soap, const struct tt__RelativeFocusOptions20 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTott__FloatRange(soap, &a->Distance);
	soap_serialize_PointerTott__FloatRange(soap, &a->Speed);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__RelativeFocusOptions20(struct soap *soap, const char *tag, int id, const struct tt__RelativeFocusOptions20 *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__RelativeFocusOptions20), type))
		return soap->error;
	if (a->Distance)
	{	if (soap_out_PointerTott__FloatRange(soap, "tt:Distance", -1, &a->Distance, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:Distance"))
		return soap->error;
	if (soap_out_PointerTott__FloatRange(soap, "tt:Speed", -1, &a->Speed, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__RelativeFocusOptions20 * SOAP_FMAC4 soap_in_tt__RelativeFocusOptions20(struct soap *soap, const char *tag, struct tt__RelativeFocusOptions20 *a, const char *type)
{
	size_t soap_flag_Distance = 1;
	size_t soap_flag_Speed = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__RelativeFocusOptions20 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RelativeFocusOptions20, sizeof(struct tt__RelativeFocusOptions20), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__RelativeFocusOptions20(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Distance && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__FloatRange(soap, "tt:Distance", &a->Distance, "tt:FloatRange"))
				{	soap_flag_Distance--;
					continue;
				}
			if (soap_flag_Speed && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__FloatRange(soap, "tt:Speed", &a->Speed, "tt:FloatRange"))
				{	soap_flag_Speed--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__RelativeFocusOptions20 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__RelativeFocusOptions20, 0, sizeof(struct tt__RelativeFocusOptions20), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Distance > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__RelativeFocusOptions20(struct soap *soap, const struct tt__RelativeFocusOptions20 *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__RelativeFocusOptions20);
	if (soap_out_tt__RelativeFocusOptions20(soap, tag?tag:"tt:RelativeFocusOptions20", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__RelativeFocusOptions20 * SOAP_FMAC4 soap_get_tt__RelativeFocusOptions20(struct soap *soap, struct tt__RelativeFocusOptions20 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__RelativeFocusOptions20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__MoveOptions20(struct soap *soap, struct tt__MoveOptions20 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Absolute = NULL;
	a->Relative = NULL;
	a->Continuous = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__MoveOptions20(struct soap *soap, const struct tt__MoveOptions20 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTott__AbsoluteFocusOptions(soap, &a->Absolute);
	soap_serialize_PointerTott__RelativeFocusOptions20(soap, &a->Relative);
	soap_serialize_PointerTott__ContinuousFocusOptions(soap, &a->Continuous);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__MoveOptions20(struct soap *soap, const char *tag, int id, const struct tt__MoveOptions20 *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__MoveOptions20), type))
		return soap->error;
	if (soap_out_PointerTott__AbsoluteFocusOptions(soap, "tt:Absolute", -1, &a->Absolute, ""))
		return soap->error;
	if (soap_out_PointerTott__RelativeFocusOptions20(soap, "tt:Relative", -1, &a->Relative, ""))
		return soap->error;
	if (soap_out_PointerTott__ContinuousFocusOptions(soap, "tt:Continuous", -1, &a->Continuous, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__MoveOptions20 * SOAP_FMAC4 soap_in_tt__MoveOptions20(struct soap *soap, const char *tag, struct tt__MoveOptions20 *a, const char *type)
{
	size_t soap_flag_Absolute = 1;
	size_t soap_flag_Relative = 1;
	size_t soap_flag_Continuous = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__MoveOptions20 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__MoveOptions20, sizeof(struct tt__MoveOptions20), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__MoveOptions20(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Absolute && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__AbsoluteFocusOptions(soap, "tt:Absolute", &a->Absolute, "tt:AbsoluteFocusOptions"))
				{	soap_flag_Absolute--;
					continue;
				}
			if (soap_flag_Relative && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__RelativeFocusOptions20(soap, "tt:Relative", &a->Relative, "tt:RelativeFocusOptions20"))
				{	soap_flag_Relative--;
					continue;
				}
			if (soap_flag_Continuous && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__ContinuousFocusOptions(soap, "tt:Continuous", &a->Continuous, "tt:ContinuousFocusOptions"))
				{	soap_flag_Continuous--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__MoveOptions20 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__MoveOptions20, 0, sizeof(struct tt__MoveOptions20), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__MoveOptions20(struct soap *soap, const struct tt__MoveOptions20 *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__MoveOptions20);
	if (soap_out_tt__MoveOptions20(soap, tag?tag:"tt:MoveOptions20", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__MoveOptions20 * SOAP_FMAC4 soap_get_tt__MoveOptions20(struct soap *soap, struct tt__MoveOptions20 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__MoveOptions20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__ImagingOptions20Extension(struct soap *soap, struct tt__ImagingOptions20Extension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__ImagingOptions20Extension(struct soap *soap, const struct tt__ImagingOptions20Extension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ImagingOptions20Extension(struct soap *soap, const char *tag, int id, const struct tt__ImagingOptions20Extension *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ImagingOptions20Extension), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__ImagingOptions20Extension * SOAP_FMAC4 soap_in_tt__ImagingOptions20Extension(struct soap *soap, const char *tag, struct tt__ImagingOptions20Extension *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__ImagingOptions20Extension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ImagingOptions20Extension, sizeof(struct tt__ImagingOptions20Extension), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__ImagingOptions20Extension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__ImagingOptions20Extension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ImagingOptions20Extension, 0, sizeof(struct tt__ImagingOptions20Extension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ImagingOptions20Extension(struct soap *soap, const struct tt__ImagingOptions20Extension *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__ImagingOptions20Extension);
	if (soap_out_tt__ImagingOptions20Extension(soap, tag?tag:"tt:ImagingOptions20Extension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ImagingOptions20Extension * SOAP_FMAC4 soap_get_tt__ImagingOptions20Extension(struct soap *soap, struct tt__ImagingOptions20Extension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ImagingOptions20Extension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__WhiteBalanceOptions20(struct soap *soap, struct tt__WhiteBalanceOptions20 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeMode = 0;
	a->Mode = NULL;
	a->YrGain = NULL;
	a->YbGain = NULL;
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__WhiteBalanceOptions20(struct soap *soap, const struct tt__WhiteBalanceOptions20 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->Mode)
	{	int i;
		for (i = 0; i < a->__sizeMode; i++)
		{
			soap_embedded(soap, a->Mode + i, SOAP_TYPE_tt__WhiteBalanceMode);
		}
	}
	soap_serialize_PointerTott__FloatRange(soap, &a->YrGain);
	soap_serialize_PointerTott__FloatRange(soap, &a->YbGain);
	soap_serialize_PointerTott__WhiteBalanceOptions20Extension(soap, &a->Extension);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__WhiteBalanceOptions20(struct soap *soap, const char *tag, int id, const struct tt__WhiteBalanceOptions20 *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__WhiteBalanceOptions20), type))
		return soap->error;
	if (a->Mode)
	{	int i;
		for (i = 0; i < a->__sizeMode; i++)
			if (soap_out_tt__WhiteBalanceMode(soap, "tt:Mode", -1, a->Mode + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTott__FloatRange(soap, "tt:YrGain", -1, &a->YrGain, ""))
		return soap->error;
	if (soap_out_PointerTott__FloatRange(soap, "tt:YbGain", -1, &a->YbGain, ""))
		return soap->error;
	if (soap_out_PointerTott__WhiteBalanceOptions20Extension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__WhiteBalanceOptions20 * SOAP_FMAC4 soap_in_tt__WhiteBalanceOptions20(struct soap *soap, const char *tag, struct tt__WhiteBalanceOptions20 *a, const char *type)
{
	struct soap_blist *soap_blist_Mode = NULL;
	size_t soap_flag_YrGain = 1;
	size_t soap_flag_YbGain = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__WhiteBalanceOptions20 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__WhiteBalanceOptions20, sizeof(struct tt__WhiteBalanceOptions20), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__WhiteBalanceOptions20(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Mode", 1, NULL))
			{	if (a->Mode == NULL)
				{	if (soap_blist_Mode == NULL)
						soap_blist_Mode = soap_new_block(soap);
					a->Mode = (enum tt__WhiteBalanceMode *)soap_push_block(soap, soap_blist_Mode, sizeof(enum tt__WhiteBalanceMode));
					if (a->Mode == NULL)
						return NULL;
					soap_default_tt__WhiteBalanceMode(soap, a->Mode);
				}
				soap_revert(soap);
				if (soap_in_tt__WhiteBalanceMode(soap, "tt:Mode", a->Mode, "tt:WhiteBalanceMode"))
				{	a->__sizeMode++;
					a->Mode = NULL;
					continue;
				}
			}
			if (soap_flag_YrGain && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__FloatRange(soap, "tt:YrGain", &a->YrGain, "tt:FloatRange"))
				{	soap_flag_YrGain--;
					continue;
				}
			if (soap_flag_YbGain && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__FloatRange(soap, "tt:YbGain", &a->YbGain, "tt:FloatRange"))
				{	soap_flag_YbGain--;
					continue;
				}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__WhiteBalanceOptions20Extension(soap, "tt:Extension", &a->Extension, "tt:WhiteBalanceOptions20Extension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Mode)
			soap_pop_block(soap, soap_blist_Mode);
		if (a->__sizeMode)
			a->Mode = (enum tt__WhiteBalanceMode *)soap_save_block(soap, soap_blist_Mode, NULL, 1);
		else
		{	a->Mode = NULL;
			if (soap_blist_Mode)
				soap_end_block(soap, soap_blist_Mode);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__WhiteBalanceOptions20 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__WhiteBalanceOptions20, 0, sizeof(struct tt__WhiteBalanceOptions20), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeMode < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__WhiteBalanceOptions20(struct soap *soap, const struct tt__WhiteBalanceOptions20 *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__WhiteBalanceOptions20);
	if (soap_out_tt__WhiteBalanceOptions20(soap, tag?tag:"tt:WhiteBalanceOptions20", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__WhiteBalanceOptions20 * SOAP_FMAC4 soap_get_tt__WhiteBalanceOptions20(struct soap *soap, struct tt__WhiteBalanceOptions20 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__WhiteBalanceOptions20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__WideDynamicRangeOptions20(struct soap *soap, struct tt__WideDynamicRangeOptions20 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeMode = 0;
	a->Mode = NULL;
	a->Level = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__WideDynamicRangeOptions20(struct soap *soap, const struct tt__WideDynamicRangeOptions20 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->Mode)
	{	int i;
		for (i = 0; i < a->__sizeMode; i++)
		{
			soap_embedded(soap, a->Mode + i, SOAP_TYPE_tt__WideDynamicMode);
		}
	}
	soap_serialize_PointerTott__FloatRange(soap, &a->Level);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__WideDynamicRangeOptions20(struct soap *soap, const char *tag, int id, const struct tt__WideDynamicRangeOptions20 *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__WideDynamicRangeOptions20), type))
		return soap->error;
	if (a->Mode)
	{	int i;
		for (i = 0; i < a->__sizeMode; i++)
			if (soap_out_tt__WideDynamicMode(soap, "tt:Mode", -1, a->Mode + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTott__FloatRange(soap, "tt:Level", -1, &a->Level, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__WideDynamicRangeOptions20 * SOAP_FMAC4 soap_in_tt__WideDynamicRangeOptions20(struct soap *soap, const char *tag, struct tt__WideDynamicRangeOptions20 *a, const char *type)
{
	struct soap_blist *soap_blist_Mode = NULL;
	size_t soap_flag_Level = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__WideDynamicRangeOptions20 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__WideDynamicRangeOptions20, sizeof(struct tt__WideDynamicRangeOptions20), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__WideDynamicRangeOptions20(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Mode", 1, NULL))
			{	if (a->Mode == NULL)
				{	if (soap_blist_Mode == NULL)
						soap_blist_Mode = soap_new_block(soap);
					a->Mode = (enum tt__WideDynamicMode *)soap_push_block(soap, soap_blist_Mode, sizeof(enum tt__WideDynamicMode));
					if (a->Mode == NULL)
						return NULL;
					soap_default_tt__WideDynamicMode(soap, a->Mode);
				}
				soap_revert(soap);
				if (soap_in_tt__WideDynamicMode(soap, "tt:Mode", a->Mode, "tt:WideDynamicMode"))
				{	a->__sizeMode++;
					a->Mode = NULL;
					continue;
				}
			}
			if (soap_flag_Level && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__FloatRange(soap, "tt:Level", &a->Level, "tt:FloatRange"))
				{	soap_flag_Level--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Mode)
			soap_pop_block(soap, soap_blist_Mode);
		if (a->__sizeMode)
			a->Mode = (enum tt__WideDynamicMode *)soap_save_block(soap, soap_blist_Mode, NULL, 1);
		else
		{	a->Mode = NULL;
			if (soap_blist_Mode)
				soap_end_block(soap, soap_blist_Mode);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__WideDynamicRangeOptions20 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__WideDynamicRangeOptions20, 0, sizeof(struct tt__WideDynamicRangeOptions20), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeMode < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__WideDynamicRangeOptions20(struct soap *soap, const struct tt__WideDynamicRangeOptions20 *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__WideDynamicRangeOptions20);
	if (soap_out_tt__WideDynamicRangeOptions20(soap, tag?tag:"tt:WideDynamicRangeOptions20", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__WideDynamicRangeOptions20 * SOAP_FMAC4 soap_get_tt__WideDynamicRangeOptions20(struct soap *soap, struct tt__WideDynamicRangeOptions20 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__WideDynamicRangeOptions20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__FocusOptions20(struct soap *soap, struct tt__FocusOptions20 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeAutoFocusModes = 0;
	a->AutoFocusModes = NULL;
	a->DefaultSpeed = NULL;
	a->NearLimit = NULL;
	a->FarLimit = NULL;
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__FocusOptions20(struct soap *soap, const struct tt__FocusOptions20 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->AutoFocusModes)
	{	int i;
		for (i = 0; i < a->__sizeAutoFocusModes; i++)
		{
			soap_embedded(soap, a->AutoFocusModes + i, SOAP_TYPE_tt__AutoFocusMode);
		}
	}
	soap_serialize_PointerTott__FloatRange(soap, &a->DefaultSpeed);
	soap_serialize_PointerTott__FloatRange(soap, &a->NearLimit);
	soap_serialize_PointerTott__FloatRange(soap, &a->FarLimit);
	soap_serialize_PointerTott__FocusOptions20Extension(soap, &a->Extension);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__FocusOptions20(struct soap *soap, const char *tag, int id, const struct tt__FocusOptions20 *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__FocusOptions20), type))
		return soap->error;
	if (a->AutoFocusModes)
	{	int i;
		for (i = 0; i < a->__sizeAutoFocusModes; i++)
			if (soap_out_tt__AutoFocusMode(soap, "tt:AutoFocusModes", -1, a->AutoFocusModes + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTott__FloatRange(soap, "tt:DefaultSpeed", -1, &a->DefaultSpeed, ""))
		return soap->error;
	if (soap_out_PointerTott__FloatRange(soap, "tt:NearLimit", -1, &a->NearLimit, ""))
		return soap->error;
	if (soap_out_PointerTott__FloatRange(soap, "tt:FarLimit", -1, &a->FarLimit, ""))
		return soap->error;
	if (soap_out_PointerTott__FocusOptions20Extension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__FocusOptions20 * SOAP_FMAC4 soap_in_tt__FocusOptions20(struct soap *soap, const char *tag, struct tt__FocusOptions20 *a, const char *type)
{
	struct soap_blist *soap_blist_AutoFocusModes = NULL;
	size_t soap_flag_DefaultSpeed = 1;
	size_t soap_flag_NearLimit = 1;
	size_t soap_flag_FarLimit = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__FocusOptions20 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__FocusOptions20, sizeof(struct tt__FocusOptions20), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__FocusOptions20(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:AutoFocusModes", 1, NULL))
			{	if (a->AutoFocusModes == NULL)
				{	if (soap_blist_AutoFocusModes == NULL)
						soap_blist_AutoFocusModes = soap_new_block(soap);
					a->AutoFocusModes = (enum tt__AutoFocusMode *)soap_push_block(soap, soap_blist_AutoFocusModes, sizeof(enum tt__AutoFocusMode));
					if (a->AutoFocusModes == NULL)
						return NULL;
					soap_default_tt__AutoFocusMode(soap, a->AutoFocusModes);
				}
				soap_revert(soap);
				if (soap_in_tt__AutoFocusMode(soap, "tt:AutoFocusModes", a->AutoFocusModes, "tt:AutoFocusMode"))
				{	a->__sizeAutoFocusModes++;
					a->AutoFocusModes = NULL;
					continue;
				}
			}
			if (soap_flag_DefaultSpeed && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__FloatRange(soap, "tt:DefaultSpeed", &a->DefaultSpeed, "tt:FloatRange"))
				{	soap_flag_DefaultSpeed--;
					continue;
				}
			if (soap_flag_NearLimit && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__FloatRange(soap, "tt:NearLimit", &a->NearLimit, "tt:FloatRange"))
				{	soap_flag_NearLimit--;
					continue;
				}
			if (soap_flag_FarLimit && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__FloatRange(soap, "tt:FarLimit", &a->FarLimit, "tt:FloatRange"))
				{	soap_flag_FarLimit--;
					continue;
				}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__FocusOptions20Extension(soap, "tt:Extension", &a->Extension, "tt:FocusOptions20Extension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->AutoFocusModes)
			soap_pop_block(soap, soap_blist_AutoFocusModes);
		if (a->__sizeAutoFocusModes)
			a->AutoFocusModes = (enum tt__AutoFocusMode *)soap_save_block(soap, soap_blist_AutoFocusModes, NULL, 1);
		else
		{	a->AutoFocusModes = NULL;
			if (soap_blist_AutoFocusModes)
				soap_end_block(soap, soap_blist_AutoFocusModes);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__FocusOptions20 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__FocusOptions20, 0, sizeof(struct tt__FocusOptions20), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__FocusOptions20(struct soap *soap, const struct tt__FocusOptions20 *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__FocusOptions20);
	if (soap_out_tt__FocusOptions20(soap, tag?tag:"tt:FocusOptions20", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__FocusOptions20 * SOAP_FMAC4 soap_get_tt__FocusOptions20(struct soap *soap, struct tt__FocusOptions20 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__FocusOptions20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__ExposureOptions20(struct soap *soap, struct tt__ExposureOptions20 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeMode = 0;
	a->Mode = NULL;
	a->__sizePriority = 0;
	a->Priority = NULL;
	a->MinExposureTime = NULL;
	a->MaxExposureTime = NULL;
	a->MinGain = NULL;
	a->MaxGain = NULL;
	a->MinIris = NULL;
	a->MaxIris = NULL;
	a->ExposureTime = NULL;
	a->Gain = NULL;
	a->Iris = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__ExposureOptions20(struct soap *soap, const struct tt__ExposureOptions20 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->Mode)
	{	int i;
		for (i = 0; i < a->__sizeMode; i++)
		{
			soap_embedded(soap, a->Mode + i, SOAP_TYPE_tt__ExposureMode);
		}
	}
	if (a->Priority)
	{	int i;
		for (i = 0; i < a->__sizePriority; i++)
		{
			soap_embedded(soap, a->Priority + i, SOAP_TYPE_tt__ExposurePriority);
		}
	}
	soap_serialize_PointerTott__FloatRange(soap, &a->MinExposureTime);
	soap_serialize_PointerTott__FloatRange(soap, &a->MaxExposureTime);
	soap_serialize_PointerTott__FloatRange(soap, &a->MinGain);
	soap_serialize_PointerTott__FloatRange(soap, &a->MaxGain);
	soap_serialize_PointerTott__FloatRange(soap, &a->MinIris);
	soap_serialize_PointerTott__FloatRange(soap, &a->MaxIris);
	soap_serialize_PointerTott__FloatRange(soap, &a->ExposureTime);
	soap_serialize_PointerTott__FloatRange(soap, &a->Gain);
	soap_serialize_PointerTott__FloatRange(soap, &a->Iris);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ExposureOptions20(struct soap *soap, const char *tag, int id, const struct tt__ExposureOptions20 *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ExposureOptions20), type))
		return soap->error;
	if (a->Mode)
	{	int i;
		for (i = 0; i < a->__sizeMode; i++)
			if (soap_out_tt__ExposureMode(soap, "tt:Mode", -1, a->Mode + i, ""))
				return soap->error;
	}
	if (a->Priority)
	{	int i;
		for (i = 0; i < a->__sizePriority; i++)
			if (soap_out_tt__ExposurePriority(soap, "tt:Priority", -1, a->Priority + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTott__FloatRange(soap, "tt:MinExposureTime", -1, &a->MinExposureTime, ""))
		return soap->error;
	if (soap_out_PointerTott__FloatRange(soap, "tt:MaxExposureTime", -1, &a->MaxExposureTime, ""))
		return soap->error;
	if (soap_out_PointerTott__FloatRange(soap, "tt:MinGain", -1, &a->MinGain, ""))
		return soap->error;
	if (soap_out_PointerTott__FloatRange(soap, "tt:MaxGain", -1, &a->MaxGain, ""))
		return soap->error;
	if (soap_out_PointerTott__FloatRange(soap, "tt:MinIris", -1, &a->MinIris, ""))
		return soap->error;
	if (soap_out_PointerTott__FloatRange(soap, "tt:MaxIris", -1, &a->MaxIris, ""))
		return soap->error;
	if (soap_out_PointerTott__FloatRange(soap, "tt:ExposureTime", -1, &a->ExposureTime, ""))
		return soap->error;
	if (soap_out_PointerTott__FloatRange(soap, "tt:Gain", -1, &a->Gain, ""))
		return soap->error;
	if (soap_out_PointerTott__FloatRange(soap, "tt:Iris", -1, &a->Iris, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__ExposureOptions20 * SOAP_FMAC4 soap_in_tt__ExposureOptions20(struct soap *soap, const char *tag, struct tt__ExposureOptions20 *a, const char *type)
{
	struct soap_blist *soap_blist_Mode = NULL;
	struct soap_blist *soap_blist_Priority = NULL;
	size_t soap_flag_MinExposureTime = 1;
	size_t soap_flag_MaxExposureTime = 1;
	size_t soap_flag_MinGain = 1;
	size_t soap_flag_MaxGain = 1;
	size_t soap_flag_MinIris = 1;
	size_t soap_flag_MaxIris = 1;
	size_t soap_flag_ExposureTime = 1;
	size_t soap_flag_Gain = 1;
	size_t soap_flag_Iris = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__ExposureOptions20 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ExposureOptions20, sizeof(struct tt__ExposureOptions20), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__ExposureOptions20(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Mode", 1, NULL))
			{	if (a->Mode == NULL)
				{	if (soap_blist_Mode == NULL)
						soap_blist_Mode = soap_new_block(soap);
					a->Mode = (enum tt__ExposureMode *)soap_push_block(soap, soap_blist_Mode, sizeof(enum tt__ExposureMode));
					if (a->Mode == NULL)
						return NULL;
					soap_default_tt__ExposureMode(soap, a->Mode);
				}
				soap_revert(soap);
				if (soap_in_tt__ExposureMode(soap, "tt:Mode", a->Mode, "tt:ExposureMode"))
				{	a->__sizeMode++;
					a->Mode = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Priority", 1, NULL))
			{	if (a->Priority == NULL)
				{	if (soap_blist_Priority == NULL)
						soap_blist_Priority = soap_new_block(soap);
					a->Priority = (enum tt__ExposurePriority *)soap_push_block(soap, soap_blist_Priority, sizeof(enum tt__ExposurePriority));
					if (a->Priority == NULL)
						return NULL;
					soap_default_tt__ExposurePriority(soap, a->Priority);
				}
				soap_revert(soap);
				if (soap_in_tt__ExposurePriority(soap, "tt:Priority", a->Priority, "tt:ExposurePriority"))
				{	a->__sizePriority++;
					a->Priority = NULL;
					continue;
				}
			}
			if (soap_flag_MinExposureTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__FloatRange(soap, "tt:MinExposureTime", &a->MinExposureTime, "tt:FloatRange"))
				{	soap_flag_MinExposureTime--;
					continue;
				}
			if (soap_flag_MaxExposureTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__FloatRange(soap, "tt:MaxExposureTime", &a->MaxExposureTime, "tt:FloatRange"))
				{	soap_flag_MaxExposureTime--;
					continue;
				}
			if (soap_flag_MinGain && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__FloatRange(soap, "tt:MinGain", &a->MinGain, "tt:FloatRange"))
				{	soap_flag_MinGain--;
					continue;
				}
			if (soap_flag_MaxGain && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__FloatRange(soap, "tt:MaxGain", &a->MaxGain, "tt:FloatRange"))
				{	soap_flag_MaxGain--;
					continue;
				}
			if (soap_flag_MinIris && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__FloatRange(soap, "tt:MinIris", &a->MinIris, "tt:FloatRange"))
				{	soap_flag_MinIris--;
					continue;
				}
			if (soap_flag_MaxIris && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__FloatRange(soap, "tt:MaxIris", &a->MaxIris, "tt:FloatRange"))
				{	soap_flag_MaxIris--;
					continue;
				}
			if (soap_flag_ExposureTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__FloatRange(soap, "tt:ExposureTime", &a->ExposureTime, "tt:FloatRange"))
				{	soap_flag_ExposureTime--;
					continue;
				}
			if (soap_flag_Gain && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__FloatRange(soap, "tt:Gain", &a->Gain, "tt:FloatRange"))
				{	soap_flag_Gain--;
					continue;
				}
			if (soap_flag_Iris && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__FloatRange(soap, "tt:Iris", &a->Iris, "tt:FloatRange"))
				{	soap_flag_Iris--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Mode)
			soap_pop_block(soap, soap_blist_Mode);
		if (a->__sizeMode)
			a->Mode = (enum tt__ExposureMode *)soap_save_block(soap, soap_blist_Mode, NULL, 1);
		else
		{	a->Mode = NULL;
			if (soap_blist_Mode)
				soap_end_block(soap, soap_blist_Mode);
		}
		if (a->Priority)
			soap_pop_block(soap, soap_blist_Priority);
		if (a->__sizePriority)
			a->Priority = (enum tt__ExposurePriority *)soap_save_block(soap, soap_blist_Priority, NULL, 1);
		else
		{	a->Priority = NULL;
			if (soap_blist_Priority)
				soap_end_block(soap, soap_blist_Priority);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__ExposureOptions20 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ExposureOptions20, 0, sizeof(struct tt__ExposureOptions20), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeMode < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ExposureOptions20(struct soap *soap, const struct tt__ExposureOptions20 *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__ExposureOptions20);
	if (soap_out_tt__ExposureOptions20(soap, tag?tag:"tt:ExposureOptions20", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ExposureOptions20 * SOAP_FMAC4 soap_get_tt__ExposureOptions20(struct soap *soap, struct tt__ExposureOptions20 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ExposureOptions20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__BacklightCompensationOptions20(struct soap *soap, struct tt__BacklightCompensationOptions20 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeMode = 0;
	a->Mode = NULL;
	a->Level = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__BacklightCompensationOptions20(struct soap *soap, const struct tt__BacklightCompensationOptions20 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->Mode)
	{	int i;
		for (i = 0; i < a->__sizeMode; i++)
		{
			soap_embedded(soap, a->Mode + i, SOAP_TYPE_tt__BacklightCompensationMode);
		}
	}
	soap_serialize_PointerTott__FloatRange(soap, &a->Level);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__BacklightCompensationOptions20(struct soap *soap, const char *tag, int id, const struct tt__BacklightCompensationOptions20 *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__BacklightCompensationOptions20), type))
		return soap->error;
	if (a->Mode)
	{	int i;
		for (i = 0; i < a->__sizeMode; i++)
			if (soap_out_tt__BacklightCompensationMode(soap, "tt:Mode", -1, a->Mode + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTott__FloatRange(soap, "tt:Level", -1, &a->Level, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__BacklightCompensationOptions20 * SOAP_FMAC4 soap_in_tt__BacklightCompensationOptions20(struct soap *soap, const char *tag, struct tt__BacklightCompensationOptions20 *a, const char *type)
{
	struct soap_blist *soap_blist_Mode = NULL;
	size_t soap_flag_Level = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__BacklightCompensationOptions20 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__BacklightCompensationOptions20, sizeof(struct tt__BacklightCompensationOptions20), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__BacklightCompensationOptions20(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Mode", 1, NULL))
			{	if (a->Mode == NULL)
				{	if (soap_blist_Mode == NULL)
						soap_blist_Mode = soap_new_block(soap);
					a->Mode = (enum tt__BacklightCompensationMode *)soap_push_block(soap, soap_blist_Mode, sizeof(enum tt__BacklightCompensationMode));
					if (a->Mode == NULL)
						return NULL;
					soap_default_tt__BacklightCompensationMode(soap, a->Mode);
				}
				soap_revert(soap);
				if (soap_in_tt__BacklightCompensationMode(soap, "tt:Mode", a->Mode, "tt:BacklightCompensationMode"))
				{	a->__sizeMode++;
					a->Mode = NULL;
					continue;
				}
			}
			if (soap_flag_Level && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__FloatRange(soap, "tt:Level", &a->Level, "tt:FloatRange"))
				{	soap_flag_Level--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Mode)
			soap_pop_block(soap, soap_blist_Mode);
		if (a->__sizeMode)
			a->Mode = (enum tt__BacklightCompensationMode *)soap_save_block(soap, soap_blist_Mode, NULL, 1);
		else
		{	a->Mode = NULL;
			if (soap_blist_Mode)
				soap_end_block(soap, soap_blist_Mode);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__BacklightCompensationOptions20 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__BacklightCompensationOptions20, 0, sizeof(struct tt__BacklightCompensationOptions20), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeMode < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__BacklightCompensationOptions20(struct soap *soap, const struct tt__BacklightCompensationOptions20 *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__BacklightCompensationOptions20);
	if (soap_out_tt__BacklightCompensationOptions20(soap, tag?tag:"tt:BacklightCompensationOptions20", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__BacklightCompensationOptions20 * SOAP_FMAC4 soap_get_tt__BacklightCompensationOptions20(struct soap *soap, struct tt__BacklightCompensationOptions20 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__BacklightCompensationOptions20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__ImagingOptions20(struct soap *soap, struct tt__ImagingOptions20 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->BacklightCompensation = NULL;
	a->Brightness = NULL;
	a->ColorSaturation = NULL;
	a->Contrast = NULL;
	a->Exposure = NULL;
	a->Focus = NULL;
	a->__sizeIrCutFilterModes = 0;
	a->IrCutFilterModes = NULL;
	a->Sharpness = NULL;
	a->WideDynamicRange = NULL;
	a->WhiteBalance = NULL;
	a->Extension = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__ImagingOptions20(struct soap *soap, const struct tt__ImagingOptions20 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTott__BacklightCompensationOptions20(soap, &a->BacklightCompensation);
	soap_serialize_PointerTott__FloatRange(soap, &a->Brightness);
	soap_serialize_PointerTott__FloatRange(soap, &a->ColorSaturation);
	soap_serialize_PointerTott__FloatRange(soap, &a->Contrast);
	soap_serialize_PointerTott__ExposureOptions20(soap, &a->Exposure);
	soap_serialize_PointerTott__FocusOptions20(soap, &a->Focus);
	if (a->IrCutFilterModes)
	{	int i;
		for (i = 0; i < a->__sizeIrCutFilterModes; i++)
		{
			soap_embedded(soap, a->IrCutFilterModes + i, SOAP_TYPE_tt__IrCutFilterMode);
		}
	}
	soap_serialize_PointerTott__FloatRange(soap, &a->Sharpness);
	soap_serialize_PointerTott__WideDynamicRangeOptions20(soap, &a->WideDynamicRange);
	soap_serialize_PointerTott__WhiteBalanceOptions20(soap, &a->WhiteBalance);
	soap_serialize_PointerTott__ImagingOptions20Extension(soap, &a->Extension);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ImagingOptions20(struct soap *soap, const char *tag, int id, const struct tt__ImagingOptions20 *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ImagingOptions20), type))
		return soap->error;
	if (soap_out_PointerTott__BacklightCompensationOptions20(soap, "tt:BacklightCompensation", -1, &a->BacklightCompensation, ""))
		return soap->error;
	if (soap_out_PointerTott__FloatRange(soap, "tt:Brightness", -1, &a->Brightness, ""))
		return soap->error;
	if (soap_out_PointerTott__FloatRange(soap, "tt:ColorSaturation", -1, &a->ColorSaturation, ""))
		return soap->error;
	if (soap_out_PointerTott__FloatRange(soap, "tt:Contrast", -1, &a->Contrast, ""))
		return soap->error;
	if (soap_out_PointerTott__ExposureOptions20(soap, "tt:Exposure", -1, &a->Exposure, ""))
		return soap->error;
	if (soap_out_PointerTott__FocusOptions20(soap, "tt:Focus", -1, &a->Focus, ""))
		return soap->error;
	if (a->IrCutFilterModes)
	{	int i;
		for (i = 0; i < a->__sizeIrCutFilterModes; i++)
			if (soap_out_tt__IrCutFilterMode(soap, "tt:IrCutFilterModes", -1, a->IrCutFilterModes + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTott__FloatRange(soap, "tt:Sharpness", -1, &a->Sharpness, ""))
		return soap->error;
	if (soap_out_PointerTott__WideDynamicRangeOptions20(soap, "tt:WideDynamicRange", -1, &a->WideDynamicRange, ""))
		return soap->error;
	if (soap_out_PointerTott__WhiteBalanceOptions20(soap, "tt:WhiteBalance", -1, &a->WhiteBalance, ""))
		return soap->error;
	if (soap_out_PointerTott__ImagingOptions20Extension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__ImagingOptions20 * SOAP_FMAC4 soap_in_tt__ImagingOptions20(struct soap *soap, const char *tag, struct tt__ImagingOptions20 *a, const char *type)
{
	size_t soap_flag_BacklightCompensation = 1;
	size_t soap_flag_Brightness = 1;
	size_t soap_flag_ColorSaturation = 1;
	size_t soap_flag_Contrast = 1;
	size_t soap_flag_Exposure = 1;
	size_t soap_flag_Focus = 1;
	struct soap_blist *soap_blist_IrCutFilterModes = NULL;
	size_t soap_flag_Sharpness = 1;
	size_t soap_flag_WideDynamicRange = 1;
	size_t soap_flag_WhiteBalance = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__ImagingOptions20 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ImagingOptions20, sizeof(struct tt__ImagingOptions20), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__ImagingOptions20(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_BacklightCompensation && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__BacklightCompensationOptions20(soap, "tt:BacklightCompensation", &a->BacklightCompensation, "tt:BacklightCompensationOptions20"))
				{	soap_flag_BacklightCompensation--;
					continue;
				}
			if (soap_flag_Brightness && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__FloatRange(soap, "tt:Brightness", &a->Brightness, "tt:FloatRange"))
				{	soap_flag_Brightness--;
					continue;
				}
			if (soap_flag_ColorSaturation && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__FloatRange(soap, "tt:ColorSaturation", &a->ColorSaturation, "tt:FloatRange"))
				{	soap_flag_ColorSaturation--;
					continue;
				}
			if (soap_flag_Contrast && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__FloatRange(soap, "tt:Contrast", &a->Contrast, "tt:FloatRange"))
				{	soap_flag_Contrast--;
					continue;
				}
			if (soap_flag_Exposure && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__ExposureOptions20(soap, "tt:Exposure", &a->Exposure, "tt:ExposureOptions20"))
				{	soap_flag_Exposure--;
					continue;
				}
			if (soap_flag_Focus && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__FocusOptions20(soap, "tt:Focus", &a->Focus, "tt:FocusOptions20"))
				{	soap_flag_Focus--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:IrCutFilterModes", 1, NULL))
			{	if (a->IrCutFilterModes == NULL)
				{	if (soap_blist_IrCutFilterModes == NULL)
						soap_blist_IrCutFilterModes = soap_new_block(soap);
					a->IrCutFilterModes = (enum tt__IrCutFilterMode *)soap_push_block(soap, soap_blist_IrCutFilterModes, sizeof(enum tt__IrCutFilterMode));
					if (a->IrCutFilterModes == NULL)
						return NULL;
					soap_default_tt__IrCutFilterMode(soap, a->IrCutFilterModes);
				}
				soap_revert(soap);
				if (soap_in_tt__IrCutFilterMode(soap, "tt:IrCutFilterModes", a->IrCutFilterModes, "tt:IrCutFilterMode"))
				{	a->__sizeIrCutFilterModes++;
					a->IrCutFilterModes = NULL;
					continue;
				}
			}
			if (soap_flag_Sharpness && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__FloatRange(soap, "tt:Sharpness", &a->Sharpness, "tt:FloatRange"))
				{	soap_flag_Sharpness--;
					continue;
				}
			if (soap_flag_WideDynamicRange && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__WideDynamicRangeOptions20(soap, "tt:WideDynamicRange", &a->WideDynamicRange, "tt:WideDynamicRangeOptions20"))
				{	soap_flag_WideDynamicRange--;
					continue;
				}
			if (soap_flag_WhiteBalance && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__WhiteBalanceOptions20(soap, "tt:WhiteBalance", &a->WhiteBalance, "tt:WhiteBalanceOptions20"))
				{	soap_flag_WhiteBalance--;
					continue;
				}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__ImagingOptions20Extension(soap, "tt:Extension", &a->Extension, "tt:ImagingOptions20Extension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->IrCutFilterModes)
			soap_pop_block(soap, soap_blist_IrCutFilterModes);
		if (a->__sizeIrCutFilterModes)
			a->IrCutFilterModes = (enum tt__IrCutFilterMode *)soap_save_block(soap, soap_blist_IrCutFilterModes, NULL, 1);
		else
		{	a->IrCutFilterModes = NULL;
			if (soap_blist_IrCutFilterModes)
				soap_end_block(soap, soap_blist_IrCutFilterModes);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__ImagingOptions20 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ImagingOptions20, 0, sizeof(struct tt__ImagingOptions20), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ImagingOptions20(struct soap *soap, const struct tt__ImagingOptions20 *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__ImagingOptions20);
	if (soap_out_tt__ImagingOptions20(soap, tag?tag:"tt:ImagingOptions20", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ImagingOptions20 * SOAP_FMAC4 soap_get_tt__ImagingOptions20(struct soap *soap, struct tt__ImagingOptions20 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ImagingOptions20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__ImagingSettingsExtension20(struct soap *soap, struct tt__ImagingSettingsExtension20 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__ImagingSettingsExtension20(struct soap *soap, const struct tt__ImagingSettingsExtension20 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ImagingSettingsExtension20(struct soap *soap, const char *tag, int id, const struct tt__ImagingSettingsExtension20 *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ImagingSettingsExtension20), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__ImagingSettingsExtension20 * SOAP_FMAC4 soap_in_tt__ImagingSettingsExtension20(struct soap *soap, const char *tag, struct tt__ImagingSettingsExtension20 *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__ImagingSettingsExtension20 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ImagingSettingsExtension20, sizeof(struct tt__ImagingSettingsExtension20), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__ImagingSettingsExtension20(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__ImagingSettingsExtension20 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ImagingSettingsExtension20, 0, sizeof(struct tt__ImagingSettingsExtension20), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ImagingSettingsExtension20(struct soap *soap, const struct tt__ImagingSettingsExtension20 *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__ImagingSettingsExtension20);
	if (soap_out_tt__ImagingSettingsExtension20(soap, tag?tag:"tt:ImagingSettingsExtension20", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ImagingSettingsExtension20 * SOAP_FMAC4 soap_get_tt__ImagingSettingsExtension20(struct soap *soap, struct tt__ImagingSettingsExtension20 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ImagingSettingsExtension20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__WhiteBalance20(struct soap *soap, struct tt__WhiteBalance20 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__WhiteBalanceMode(soap, &a->Mode);
	a->CrGain = NULL;
	a->CbGain = NULL;
	a->Extension = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__WhiteBalance20(struct soap *soap, const struct tt__WhiteBalance20 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->Mode, SOAP_TYPE_tt__WhiteBalanceMode);
	soap_serialize_PointerTofloat(soap, &a->CrGain);
	soap_serialize_PointerTofloat(soap, &a->CbGain);
	soap_serialize_PointerTott__WhiteBalance20Extension(soap, &a->Extension);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__WhiteBalance20(struct soap *soap, const char *tag, int id, const struct tt__WhiteBalance20 *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__WhiteBalance20), type))
		return soap->error;
	if (soap_out_tt__WhiteBalanceMode(soap, "tt:Mode", -1, &a->Mode, ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "tt:CrGain", -1, &a->CrGain, ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "tt:CbGain", -1, &a->CbGain, ""))
		return soap->error;
	if (soap_out_PointerTott__WhiteBalance20Extension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__WhiteBalance20 * SOAP_FMAC4 soap_in_tt__WhiteBalance20(struct soap *soap, const char *tag, struct tt__WhiteBalance20 *a, const char *type)
{
	size_t soap_flag_Mode = 1;
	size_t soap_flag_CrGain = 1;
	size_t soap_flag_CbGain = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__WhiteBalance20 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__WhiteBalance20, sizeof(struct tt__WhiteBalance20), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__WhiteBalance20(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Mode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_tt__WhiteBalanceMode(soap, "tt:Mode", &a->Mode, "tt:WhiteBalanceMode"))
				{	soap_flag_Mode--;
					continue;
				}
			if (soap_flag_CrGain && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofloat(soap, "tt:CrGain", &a->CrGain, "xsd:float"))
				{	soap_flag_CrGain--;
					continue;
				}
			if (soap_flag_CbGain && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofloat(soap, "tt:CbGain", &a->CbGain, "xsd:float"))
				{	soap_flag_CbGain--;
					continue;
				}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__WhiteBalance20Extension(soap, "tt:Extension", &a->Extension, "tt:WhiteBalance20Extension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__WhiteBalance20 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__WhiteBalance20, 0, sizeof(struct tt__WhiteBalance20), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Mode > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__WhiteBalance20(struct soap *soap, const struct tt__WhiteBalance20 *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__WhiteBalance20);
	if (soap_out_tt__WhiteBalance20(soap, tag?tag:"tt:WhiteBalance20", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__WhiteBalance20 * SOAP_FMAC4 soap_get_tt__WhiteBalance20(struct soap *soap, struct tt__WhiteBalance20 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__WhiteBalance20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__WideDynamicRange20(struct soap *soap, struct tt__WideDynamicRange20 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__WideDynamicMode(soap, &a->Mode);
	a->Level = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__WideDynamicRange20(struct soap *soap, const struct tt__WideDynamicRange20 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->Mode, SOAP_TYPE_tt__WideDynamicMode);
	soap_serialize_PointerTofloat(soap, &a->Level);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__WideDynamicRange20(struct soap *soap, const char *tag, int id, const struct tt__WideDynamicRange20 *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__WideDynamicRange20), type))
		return soap->error;
	if (soap_out_tt__WideDynamicMode(soap, "tt:Mode", -1, &a->Mode, ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "tt:Level", -1, &a->Level, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__WideDynamicRange20 * SOAP_FMAC4 soap_in_tt__WideDynamicRange20(struct soap *soap, const char *tag, struct tt__WideDynamicRange20 *a, const char *type)
{
	size_t soap_flag_Mode = 1;
	size_t soap_flag_Level = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__WideDynamicRange20 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__WideDynamicRange20, sizeof(struct tt__WideDynamicRange20), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__WideDynamicRange20(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Mode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_tt__WideDynamicMode(soap, "tt:Mode", &a->Mode, "tt:WideDynamicMode"))
				{	soap_flag_Mode--;
					continue;
				}
			if (soap_flag_Level && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofloat(soap, "tt:Level", &a->Level, "xsd:float"))
				{	soap_flag_Level--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__WideDynamicRange20 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__WideDynamicRange20, 0, sizeof(struct tt__WideDynamicRange20), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Mode > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__WideDynamicRange20(struct soap *soap, const struct tt__WideDynamicRange20 *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__WideDynamicRange20);
	if (soap_out_tt__WideDynamicRange20(soap, tag?tag:"tt:WideDynamicRange20", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__WideDynamicRange20 * SOAP_FMAC4 soap_get_tt__WideDynamicRange20(struct soap *soap, struct tt__WideDynamicRange20 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__WideDynamicRange20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__FocusConfiguration20(struct soap *soap, struct tt__FocusConfiguration20 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__AutoFocusMode(soap, &a->AutoFocusMode);
	a->DefaultSpeed = NULL;
	a->NearLimit = NULL;
	a->FarLimit = NULL;
	a->Extension = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__FocusConfiguration20(struct soap *soap, const struct tt__FocusConfiguration20 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->AutoFocusMode, SOAP_TYPE_tt__AutoFocusMode);
	soap_serialize_PointerTofloat(soap, &a->DefaultSpeed);
	soap_serialize_PointerTofloat(soap, &a->NearLimit);
	soap_serialize_PointerTofloat(soap, &a->FarLimit);
	soap_serialize_PointerTott__FocusConfiguration20Extension(soap, &a->Extension);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__FocusConfiguration20(struct soap *soap, const char *tag, int id, const struct tt__FocusConfiguration20 *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__FocusConfiguration20), type))
		return soap->error;
	if (soap_out_tt__AutoFocusMode(soap, "tt:AutoFocusMode", -1, &a->AutoFocusMode, ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "tt:DefaultSpeed", -1, &a->DefaultSpeed, ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "tt:NearLimit", -1, &a->NearLimit, ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "tt:FarLimit", -1, &a->FarLimit, ""))
		return soap->error;
	if (soap_out_PointerTott__FocusConfiguration20Extension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__FocusConfiguration20 * SOAP_FMAC4 soap_in_tt__FocusConfiguration20(struct soap *soap, const char *tag, struct tt__FocusConfiguration20 *a, const char *type)
{
	size_t soap_flag_AutoFocusMode = 1;
	size_t soap_flag_DefaultSpeed = 1;
	size_t soap_flag_NearLimit = 1;
	size_t soap_flag_FarLimit = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__FocusConfiguration20 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__FocusConfiguration20, sizeof(struct tt__FocusConfiguration20), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__FocusConfiguration20(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_AutoFocusMode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_tt__AutoFocusMode(soap, "tt:AutoFocusMode", &a->AutoFocusMode, "tt:AutoFocusMode"))
				{	soap_flag_AutoFocusMode--;
					continue;
				}
			if (soap_flag_DefaultSpeed && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofloat(soap, "tt:DefaultSpeed", &a->DefaultSpeed, "xsd:float"))
				{	soap_flag_DefaultSpeed--;
					continue;
				}
			if (soap_flag_NearLimit && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofloat(soap, "tt:NearLimit", &a->NearLimit, "xsd:float"))
				{	soap_flag_NearLimit--;
					continue;
				}
			if (soap_flag_FarLimit && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofloat(soap, "tt:FarLimit", &a->FarLimit, "xsd:float"))
				{	soap_flag_FarLimit--;
					continue;
				}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__FocusConfiguration20Extension(soap, "tt:Extension", &a->Extension, "tt:FocusConfiguration20Extension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__FocusConfiguration20 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__FocusConfiguration20, 0, sizeof(struct tt__FocusConfiguration20), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_AutoFocusMode > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__FocusConfiguration20(struct soap *soap, const struct tt__FocusConfiguration20 *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__FocusConfiguration20);
	if (soap_out_tt__FocusConfiguration20(soap, tag?tag:"tt:FocusConfiguration20", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__FocusConfiguration20 * SOAP_FMAC4 soap_get_tt__FocusConfiguration20(struct soap *soap, struct tt__FocusConfiguration20 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__FocusConfiguration20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__Exposure20(struct soap *soap, struct tt__Exposure20 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ExposureMode(soap, &a->Mode);
	a->Priority = NULL;
	a->Window = NULL;
	a->MinExposureTime = NULL;
	a->MaxExposureTime = NULL;
	a->MinGain = NULL;
	a->MaxGain = NULL;
	a->MinIris = NULL;
	a->MaxIris = NULL;
	a->ExposureTime = NULL;
	a->Gain = NULL;
	a->Iris = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__Exposure20(struct soap *soap, const struct tt__Exposure20 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->Mode, SOAP_TYPE_tt__ExposureMode);
	soap_serialize_PointerTott__ExposurePriority(soap, &a->Priority);
	soap_serialize_PointerTott__Rectangle(soap, &a->Window);
	soap_serialize_PointerTofloat(soap, &a->MinExposureTime);
	soap_serialize_PointerTofloat(soap, &a->MaxExposureTime);
	soap_serialize_PointerTofloat(soap, &a->MinGain);
	soap_serialize_PointerTofloat(soap, &a->MaxGain);
	soap_serialize_PointerTofloat(soap, &a->MinIris);
	soap_serialize_PointerTofloat(soap, &a->MaxIris);
	soap_serialize_PointerTofloat(soap, &a->ExposureTime);
	soap_serialize_PointerTofloat(soap, &a->Gain);
	soap_serialize_PointerTofloat(soap, &a->Iris);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Exposure20(struct soap *soap, const char *tag, int id, const struct tt__Exposure20 *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Exposure20), type))
		return soap->error;
	if (soap_out_tt__ExposureMode(soap, "tt:Mode", -1, &a->Mode, ""))
		return soap->error;
	if (soap_out_PointerTott__ExposurePriority(soap, "tt:Priority", -1, &a->Priority, ""))
		return soap->error;
	if (soap_out_PointerTott__Rectangle(soap, "tt:Window", -1, &a->Window, ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "tt:MinExposureTime", -1, &a->MinExposureTime, ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "tt:MaxExposureTime", -1, &a->MaxExposureTime, ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "tt:MinGain", -1, &a->MinGain, ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "tt:MaxGain", -1, &a->MaxGain, ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "tt:MinIris", -1, &a->MinIris, ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "tt:MaxIris", -1, &a->MaxIris, ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "tt:ExposureTime", -1, &a->ExposureTime, ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "tt:Gain", -1, &a->Gain, ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "tt:Iris", -1, &a->Iris, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__Exposure20 * SOAP_FMAC4 soap_in_tt__Exposure20(struct soap *soap, const char *tag, struct tt__Exposure20 *a, const char *type)
{
	size_t soap_flag_Mode = 1;
	size_t soap_flag_Priority = 1;
	size_t soap_flag_Window = 1;
	size_t soap_flag_MinExposureTime = 1;
	size_t soap_flag_MaxExposureTime = 1;
	size_t soap_flag_MinGain = 1;
	size_t soap_flag_MaxGain = 1;
	size_t soap_flag_MinIris = 1;
	size_t soap_flag_MaxIris = 1;
	size_t soap_flag_ExposureTime = 1;
	size_t soap_flag_Gain = 1;
	size_t soap_flag_Iris = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__Exposure20 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Exposure20, sizeof(struct tt__Exposure20), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__Exposure20(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Mode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_tt__ExposureMode(soap, "tt:Mode", &a->Mode, "tt:ExposureMode"))
				{	soap_flag_Mode--;
					continue;
				}
			if (soap_flag_Priority && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__ExposurePriority(soap, "tt:Priority", &a->Priority, "tt:ExposurePriority"))
				{	soap_flag_Priority--;
					continue;
				}
			if (soap_flag_Window && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__Rectangle(soap, "tt:Window", &a->Window, "tt:Rectangle"))
				{	soap_flag_Window--;
					continue;
				}
			if (soap_flag_MinExposureTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofloat(soap, "tt:MinExposureTime", &a->MinExposureTime, "xsd:float"))
				{	soap_flag_MinExposureTime--;
					continue;
				}
			if (soap_flag_MaxExposureTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofloat(soap, "tt:MaxExposureTime", &a->MaxExposureTime, "xsd:float"))
				{	soap_flag_MaxExposureTime--;
					continue;
				}
			if (soap_flag_MinGain && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofloat(soap, "tt:MinGain", &a->MinGain, "xsd:float"))
				{	soap_flag_MinGain--;
					continue;
				}
			if (soap_flag_MaxGain && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofloat(soap, "tt:MaxGain", &a->MaxGain, "xsd:float"))
				{	soap_flag_MaxGain--;
					continue;
				}
			if (soap_flag_MinIris && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofloat(soap, "tt:MinIris", &a->MinIris, "xsd:float"))
				{	soap_flag_MinIris--;
					continue;
				}
			if (soap_flag_MaxIris && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofloat(soap, "tt:MaxIris", &a->MaxIris, "xsd:float"))
				{	soap_flag_MaxIris--;
					continue;
				}
			if (soap_flag_ExposureTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofloat(soap, "tt:ExposureTime", &a->ExposureTime, "xsd:float"))
				{	soap_flag_ExposureTime--;
					continue;
				}
			if (soap_flag_Gain && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofloat(soap, "tt:Gain", &a->Gain, "xsd:float"))
				{	soap_flag_Gain--;
					continue;
				}
			if (soap_flag_Iris && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofloat(soap, "tt:Iris", &a->Iris, "xsd:float"))
				{	soap_flag_Iris--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__Exposure20 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Exposure20, 0, sizeof(struct tt__Exposure20), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Mode > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Exposure20(struct soap *soap, const struct tt__Exposure20 *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__Exposure20);
	if (soap_out_tt__Exposure20(soap, tag?tag:"tt:Exposure20", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Exposure20 * SOAP_FMAC4 soap_get_tt__Exposure20(struct soap *soap, struct tt__Exposure20 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Exposure20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__BacklightCompensation20(struct soap *soap, struct tt__BacklightCompensation20 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__BacklightCompensationMode(soap, &a->Mode);
	a->Level = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__BacklightCompensation20(struct soap *soap, const struct tt__BacklightCompensation20 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->Mode, SOAP_TYPE_tt__BacklightCompensationMode);
	soap_serialize_PointerTofloat(soap, &a->Level);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__BacklightCompensation20(struct soap *soap, const char *tag, int id, const struct tt__BacklightCompensation20 *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__BacklightCompensation20), type))
		return soap->error;
	if (soap_out_tt__BacklightCompensationMode(soap, "tt:Mode", -1, &a->Mode, ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "tt:Level", -1, &a->Level, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__BacklightCompensation20 * SOAP_FMAC4 soap_in_tt__BacklightCompensation20(struct soap *soap, const char *tag, struct tt__BacklightCompensation20 *a, const char *type)
{
	size_t soap_flag_Mode = 1;
	size_t soap_flag_Level = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__BacklightCompensation20 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__BacklightCompensation20, sizeof(struct tt__BacklightCompensation20), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__BacklightCompensation20(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Mode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_tt__BacklightCompensationMode(soap, "tt:Mode", &a->Mode, "tt:BacklightCompensationMode"))
				{	soap_flag_Mode--;
					continue;
				}
			if (soap_flag_Level && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofloat(soap, "tt:Level", &a->Level, "xsd:float"))
				{	soap_flag_Level--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__BacklightCompensation20 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__BacklightCompensation20, 0, sizeof(struct tt__BacklightCompensation20), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Mode > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__BacklightCompensation20(struct soap *soap, const struct tt__BacklightCompensation20 *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__BacklightCompensation20);
	if (soap_out_tt__BacklightCompensation20(soap, tag?tag:"tt:BacklightCompensation20", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__BacklightCompensation20 * SOAP_FMAC4 soap_get_tt__BacklightCompensation20(struct soap *soap, struct tt__BacklightCompensation20 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__BacklightCompensation20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__FocusStatus20Extension(struct soap *soap, struct tt__FocusStatus20Extension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__FocusStatus20Extension(struct soap *soap, const struct tt__FocusStatus20Extension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__FocusStatus20Extension(struct soap *soap, const char *tag, int id, const struct tt__FocusStatus20Extension *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__FocusStatus20Extension), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__FocusStatus20Extension * SOAP_FMAC4 soap_in_tt__FocusStatus20Extension(struct soap *soap, const char *tag, struct tt__FocusStatus20Extension *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__FocusStatus20Extension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__FocusStatus20Extension, sizeof(struct tt__FocusStatus20Extension), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__FocusStatus20Extension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__FocusStatus20Extension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__FocusStatus20Extension, 0, sizeof(struct tt__FocusStatus20Extension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__FocusStatus20Extension(struct soap *soap, const struct tt__FocusStatus20Extension *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__FocusStatus20Extension);
	if (soap_out_tt__FocusStatus20Extension(soap, tag?tag:"tt:FocusStatus20Extension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__FocusStatus20Extension * SOAP_FMAC4 soap_get_tt__FocusStatus20Extension(struct soap *soap, struct tt__FocusStatus20Extension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__FocusStatus20Extension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__ImagingStatus20Extension(struct soap *soap, struct tt__ImagingStatus20Extension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__ImagingStatus20Extension(struct soap *soap, const struct tt__ImagingStatus20Extension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ImagingStatus20Extension(struct soap *soap, const char *tag, int id, const struct tt__ImagingStatus20Extension *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ImagingStatus20Extension), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__ImagingStatus20Extension * SOAP_FMAC4 soap_in_tt__ImagingStatus20Extension(struct soap *soap, const char *tag, struct tt__ImagingStatus20Extension *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__ImagingStatus20Extension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ImagingStatus20Extension, sizeof(struct tt__ImagingStatus20Extension), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__ImagingStatus20Extension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__ImagingStatus20Extension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ImagingStatus20Extension, 0, sizeof(struct tt__ImagingStatus20Extension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ImagingStatus20Extension(struct soap *soap, const struct tt__ImagingStatus20Extension *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__ImagingStatus20Extension);
	if (soap_out_tt__ImagingStatus20Extension(soap, tag?tag:"tt:ImagingStatus20Extension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ImagingStatus20Extension * SOAP_FMAC4 soap_get_tt__ImagingStatus20Extension(struct soap *soap, struct tt__ImagingStatus20Extension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ImagingStatus20Extension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__FocusStatus20(struct soap *soap, struct tt__FocusStatus20 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_float(soap, &a->Position);
	soap_default_tt__MoveStatus(soap, &a->MoveStatus);
	soap_default_string(soap, &a->Error);
	a->Extension = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__FocusStatus20(struct soap *soap, const struct tt__FocusStatus20 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->Position, SOAP_TYPE_float);
	soap_embedded(soap, &a->MoveStatus, SOAP_TYPE_tt__MoveStatus);
	soap_serialize_string(soap, &a->Error);
	soap_serialize_PointerTott__FocusStatus20Extension(soap, &a->Extension);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__FocusStatus20(struct soap *soap, const char *tag, int id, const struct tt__FocusStatus20 *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__FocusStatus20), type))
		return soap->error;
	if (soap_out_float(soap, "tt:Position", -1, &a->Position, ""))
		return soap->error;
	if (soap_out_tt__MoveStatus(soap, "tt:MoveStatus", -1, &a->MoveStatus, ""))
		return soap->error;
	if (soap_out_string(soap, "tt:Error", -1, &a->Error, ""))
		return soap->error;
	if (soap_out_PointerTott__FocusStatus20Extension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__FocusStatus20 * SOAP_FMAC4 soap_in_tt__FocusStatus20(struct soap *soap, const char *tag, struct tt__FocusStatus20 *a, const char *type)
{
	size_t soap_flag_Position = 1;
	size_t soap_flag_MoveStatus = 1;
	size_t soap_flag_Error = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__FocusStatus20 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__FocusStatus20, sizeof(struct tt__FocusStatus20), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__FocusStatus20(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Position && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_float(soap, "tt:Position", &a->Position, "xsd:float"))
				{	soap_flag_Position--;
					continue;
				}
			if (soap_flag_MoveStatus && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_tt__MoveStatus(soap, "tt:MoveStatus", &a->MoveStatus, "tt:MoveStatus"))
				{	soap_flag_MoveStatus--;
					continue;
				}
			if (soap_flag_Error && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "tt:Error", &a->Error, "xsd:string"))
				{	soap_flag_Error--;
					continue;
				}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__FocusStatus20Extension(soap, "tt:Extension", &a->Extension, "tt:FocusStatus20Extension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__FocusStatus20 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__FocusStatus20, 0, sizeof(struct tt__FocusStatus20), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Position > 0 || soap_flag_MoveStatus > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__FocusStatus20(struct soap *soap, const struct tt__FocusStatus20 *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__FocusStatus20);
	if (soap_out_tt__FocusStatus20(soap, tag?tag:"tt:FocusStatus20", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__FocusStatus20 * SOAP_FMAC4 soap_get_tt__FocusStatus20(struct soap *soap, struct tt__FocusStatus20 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__FocusStatus20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__ImagingStatus20(struct soap *soap, struct tt__ImagingStatus20 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->FocusStatus20 = NULL;
	a->Extension = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__ImagingStatus20(struct soap *soap, const struct tt__ImagingStatus20 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTott__FocusStatus20(soap, &a->FocusStatus20);
	soap_serialize_PointerTott__ImagingStatus20Extension(soap, &a->Extension);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ImagingStatus20(struct soap *soap, const char *tag, int id, const struct tt__ImagingStatus20 *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ImagingStatus20), type))
		return soap->error;
	if (soap_out_PointerTott__FocusStatus20(soap, "tt:FocusStatus20", -1, &a->FocusStatus20, ""))
		return soap->error;
	if (soap_out_PointerTott__ImagingStatus20Extension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__ImagingStatus20 * SOAP_FMAC4 soap_in_tt__ImagingStatus20(struct soap *soap, const char *tag, struct tt__ImagingStatus20 *a, const char *type)
{
	size_t soap_flag_FocusStatus20 = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__ImagingStatus20 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ImagingStatus20, sizeof(struct tt__ImagingStatus20), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__ImagingStatus20(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_FocusStatus20 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__FocusStatus20(soap, "tt:FocusStatus20", &a->FocusStatus20, "tt:FocusStatus20"))
				{	soap_flag_FocusStatus20--;
					continue;
				}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__ImagingStatus20Extension(soap, "tt:Extension", &a->Extension, "tt:ImagingStatus20Extension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__ImagingStatus20 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ImagingStatus20, 0, sizeof(struct tt__ImagingStatus20), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ImagingStatus20(struct soap *soap, const struct tt__ImagingStatus20 *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__ImagingStatus20);
	if (soap_out_tt__ImagingStatus20(soap, tag?tag:"tt:ImagingStatus20", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ImagingStatus20 * SOAP_FMAC4 soap_get_tt__ImagingStatus20(struct soap *soap, struct tt__ImagingStatus20 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ImagingStatus20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__ContinuousFocusOptions(struct soap *soap, struct tt__ContinuousFocusOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Speed = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__ContinuousFocusOptions(struct soap *soap, const struct tt__ContinuousFocusOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTott__FloatRange(soap, &a->Speed);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ContinuousFocusOptions(struct soap *soap, const char *tag, int id, const struct tt__ContinuousFocusOptions *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ContinuousFocusOptions), type))
		return soap->error;
	if (a->Speed)
	{	if (soap_out_PointerTott__FloatRange(soap, "tt:Speed", -1, &a->Speed, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:Speed"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__ContinuousFocusOptions * SOAP_FMAC4 soap_in_tt__ContinuousFocusOptions(struct soap *soap, const char *tag, struct tt__ContinuousFocusOptions *a, const char *type)
{
	size_t soap_flag_Speed = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__ContinuousFocusOptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ContinuousFocusOptions, sizeof(struct tt__ContinuousFocusOptions), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__ContinuousFocusOptions(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Speed && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__FloatRange(soap, "tt:Speed", &a->Speed, "tt:FloatRange"))
				{	soap_flag_Speed--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__ContinuousFocusOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ContinuousFocusOptions, 0, sizeof(struct tt__ContinuousFocusOptions), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Speed > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ContinuousFocusOptions(struct soap *soap, const struct tt__ContinuousFocusOptions *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__ContinuousFocusOptions);
	if (soap_out_tt__ContinuousFocusOptions(soap, tag?tag:"tt:ContinuousFocusOptions", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ContinuousFocusOptions * SOAP_FMAC4 soap_get_tt__ContinuousFocusOptions(struct soap *soap, struct tt__ContinuousFocusOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ContinuousFocusOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__RelativeFocusOptions(struct soap *soap, struct tt__RelativeFocusOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Distance = NULL;
	a->Speed = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__RelativeFocusOptions(struct soap *soap, const struct tt__RelativeFocusOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTott__FloatRange(soap, &a->Distance);
	soap_serialize_PointerTott__FloatRange(soap, &a->Speed);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__RelativeFocusOptions(struct soap *soap, const char *tag, int id, const struct tt__RelativeFocusOptions *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__RelativeFocusOptions), type))
		return soap->error;
	if (a->Distance)
	{	if (soap_out_PointerTott__FloatRange(soap, "tt:Distance", -1, &a->Distance, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:Distance"))
		return soap->error;
	if (a->Speed)
	{	if (soap_out_PointerTott__FloatRange(soap, "tt:Speed", -1, &a->Speed, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:Speed"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__RelativeFocusOptions * SOAP_FMAC4 soap_in_tt__RelativeFocusOptions(struct soap *soap, const char *tag, struct tt__RelativeFocusOptions *a, const char *type)
{
	size_t soap_flag_Distance = 1;
	size_t soap_flag_Speed = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__RelativeFocusOptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RelativeFocusOptions, sizeof(struct tt__RelativeFocusOptions), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__RelativeFocusOptions(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Distance && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__FloatRange(soap, "tt:Distance", &a->Distance, "tt:FloatRange"))
				{	soap_flag_Distance--;
					continue;
				}
			if (soap_flag_Speed && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__FloatRange(soap, "tt:Speed", &a->Speed, "tt:FloatRange"))
				{	soap_flag_Speed--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__RelativeFocusOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__RelativeFocusOptions, 0, sizeof(struct tt__RelativeFocusOptions), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Distance > 0 || soap_flag_Speed > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__RelativeFocusOptions(struct soap *soap, const struct tt__RelativeFocusOptions *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__RelativeFocusOptions);
	if (soap_out_tt__RelativeFocusOptions(soap, tag?tag:"tt:RelativeFocusOptions", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__RelativeFocusOptions * SOAP_FMAC4 soap_get_tt__RelativeFocusOptions(struct soap *soap, struct tt__RelativeFocusOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__RelativeFocusOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__AbsoluteFocusOptions(struct soap *soap, struct tt__AbsoluteFocusOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Position = NULL;
	a->Speed = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__AbsoluteFocusOptions(struct soap *soap, const struct tt__AbsoluteFocusOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTott__FloatRange(soap, &a->Position);
	soap_serialize_PointerTott__FloatRange(soap, &a->Speed);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AbsoluteFocusOptions(struct soap *soap, const char *tag, int id, const struct tt__AbsoluteFocusOptions *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AbsoluteFocusOptions), type))
		return soap->error;
	if (a->Position)
	{	if (soap_out_PointerTott__FloatRange(soap, "tt:Position", -1, &a->Position, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:Position"))
		return soap->error;
	if (soap_out_PointerTott__FloatRange(soap, "tt:Speed", -1, &a->Speed, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__AbsoluteFocusOptions * SOAP_FMAC4 soap_in_tt__AbsoluteFocusOptions(struct soap *soap, const char *tag, struct tt__AbsoluteFocusOptions *a, const char *type)
{
	size_t soap_flag_Position = 1;
	size_t soap_flag_Speed = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__AbsoluteFocusOptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AbsoluteFocusOptions, sizeof(struct tt__AbsoluteFocusOptions), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__AbsoluteFocusOptions(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Position && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__FloatRange(soap, "tt:Position", &a->Position, "tt:FloatRange"))
				{	soap_flag_Position--;
					continue;
				}
			if (soap_flag_Speed && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__FloatRange(soap, "tt:Speed", &a->Speed, "tt:FloatRange"))
				{	soap_flag_Speed--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__AbsoluteFocusOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AbsoluteFocusOptions, 0, sizeof(struct tt__AbsoluteFocusOptions), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Position > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__AbsoluteFocusOptions(struct soap *soap, const struct tt__AbsoluteFocusOptions *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__AbsoluteFocusOptions);
	if (soap_out_tt__AbsoluteFocusOptions(soap, tag?tag:"tt:AbsoluteFocusOptions", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AbsoluteFocusOptions * SOAP_FMAC4 soap_get_tt__AbsoluteFocusOptions(struct soap *soap, struct tt__AbsoluteFocusOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AbsoluteFocusOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__MoveOptions(struct soap *soap, struct tt__MoveOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Absolute = NULL;
	a->Relative = NULL;
	a->Continuous = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__MoveOptions(struct soap *soap, const struct tt__MoveOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTott__AbsoluteFocusOptions(soap, &a->Absolute);
	soap_serialize_PointerTott__RelativeFocusOptions(soap, &a->Relative);
	soap_serialize_PointerTott__ContinuousFocusOptions(soap, &a->Continuous);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__MoveOptions(struct soap *soap, const char *tag, int id, const struct tt__MoveOptions *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__MoveOptions), type))
		return soap->error;
	if (soap_out_PointerTott__AbsoluteFocusOptions(soap, "tt:Absolute", -1, &a->Absolute, ""))
		return soap->error;
	if (soap_out_PointerTott__RelativeFocusOptions(soap, "tt:Relative", -1, &a->Relative, ""))
		return soap->error;
	if (soap_out_PointerTott__ContinuousFocusOptions(soap, "tt:Continuous", -1, &a->Continuous, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__MoveOptions * SOAP_FMAC4 soap_in_tt__MoveOptions(struct soap *soap, const char *tag, struct tt__MoveOptions *a, const char *type)
{
	size_t soap_flag_Absolute = 1;
	size_t soap_flag_Relative = 1;
	size_t soap_flag_Continuous = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__MoveOptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__MoveOptions, sizeof(struct tt__MoveOptions), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__MoveOptions(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Absolute && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__AbsoluteFocusOptions(soap, "tt:Absolute", &a->Absolute, "tt:AbsoluteFocusOptions"))
				{	soap_flag_Absolute--;
					continue;
				}
			if (soap_flag_Relative && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__RelativeFocusOptions(soap, "tt:Relative", &a->Relative, "tt:RelativeFocusOptions"))
				{	soap_flag_Relative--;
					continue;
				}
			if (soap_flag_Continuous && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__ContinuousFocusOptions(soap, "tt:Continuous", &a->Continuous, "tt:ContinuousFocusOptions"))
				{	soap_flag_Continuous--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__MoveOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__MoveOptions, 0, sizeof(struct tt__MoveOptions), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__MoveOptions(struct soap *soap, const struct tt__MoveOptions *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__MoveOptions);
	if (soap_out_tt__MoveOptions(soap, tag?tag:"tt:MoveOptions", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__MoveOptions * SOAP_FMAC4 soap_get_tt__MoveOptions(struct soap *soap, struct tt__MoveOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__MoveOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__ContinuousFocus(struct soap *soap, struct tt__ContinuousFocus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_float(soap, &a->Speed);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__ContinuousFocus(struct soap *soap, const struct tt__ContinuousFocus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->Speed, SOAP_TYPE_float);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ContinuousFocus(struct soap *soap, const char *tag, int id, const struct tt__ContinuousFocus *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ContinuousFocus), type))
		return soap->error;
	if (soap_out_float(soap, "tt:Speed", -1, &a->Speed, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__ContinuousFocus * SOAP_FMAC4 soap_in_tt__ContinuousFocus(struct soap *soap, const char *tag, struct tt__ContinuousFocus *a, const char *type)
{
	size_t soap_flag_Speed = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__ContinuousFocus *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ContinuousFocus, sizeof(struct tt__ContinuousFocus), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__ContinuousFocus(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Speed && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_float(soap, "tt:Speed", &a->Speed, "xsd:float"))
				{	soap_flag_Speed--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__ContinuousFocus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ContinuousFocus, 0, sizeof(struct tt__ContinuousFocus), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Speed > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ContinuousFocus(struct soap *soap, const struct tt__ContinuousFocus *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__ContinuousFocus);
	if (soap_out_tt__ContinuousFocus(soap, tag?tag:"tt:ContinuousFocus", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ContinuousFocus * SOAP_FMAC4 soap_get_tt__ContinuousFocus(struct soap *soap, struct tt__ContinuousFocus *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ContinuousFocus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__RelativeFocus(struct soap *soap, struct tt__RelativeFocus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_float(soap, &a->Distance);
	a->Speed = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__RelativeFocus(struct soap *soap, const struct tt__RelativeFocus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->Distance, SOAP_TYPE_float);
	soap_serialize_PointerTofloat(soap, &a->Speed);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__RelativeFocus(struct soap *soap, const char *tag, int id, const struct tt__RelativeFocus *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__RelativeFocus), type))
		return soap->error;
	if (soap_out_float(soap, "tt:Distance", -1, &a->Distance, ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "tt:Speed", -1, &a->Speed, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__RelativeFocus * SOAP_FMAC4 soap_in_tt__RelativeFocus(struct soap *soap, const char *tag, struct tt__RelativeFocus *a, const char *type)
{
	size_t soap_flag_Distance = 1;
	size_t soap_flag_Speed = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__RelativeFocus *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RelativeFocus, sizeof(struct tt__RelativeFocus), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__RelativeFocus(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Distance && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_float(soap, "tt:Distance", &a->Distance, "xsd:float"))
				{	soap_flag_Distance--;
					continue;
				}
			if (soap_flag_Speed && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofloat(soap, "tt:Speed", &a->Speed, "xsd:float"))
				{	soap_flag_Speed--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__RelativeFocus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__RelativeFocus, 0, sizeof(struct tt__RelativeFocus), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Distance > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__RelativeFocus(struct soap *soap, const struct tt__RelativeFocus *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__RelativeFocus);
	if (soap_out_tt__RelativeFocus(soap, tag?tag:"tt:RelativeFocus", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__RelativeFocus * SOAP_FMAC4 soap_get_tt__RelativeFocus(struct soap *soap, struct tt__RelativeFocus *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__RelativeFocus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__AbsoluteFocus(struct soap *soap, struct tt__AbsoluteFocus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_float(soap, &a->Position);
	a->Speed = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__AbsoluteFocus(struct soap *soap, const struct tt__AbsoluteFocus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->Position, SOAP_TYPE_float);
	soap_serialize_PointerTofloat(soap, &a->Speed);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AbsoluteFocus(struct soap *soap, const char *tag, int id, const struct tt__AbsoluteFocus *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AbsoluteFocus), type))
		return soap->error;
	if (soap_out_float(soap, "tt:Position", -1, &a->Position, ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "tt:Speed", -1, &a->Speed, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__AbsoluteFocus * SOAP_FMAC4 soap_in_tt__AbsoluteFocus(struct soap *soap, const char *tag, struct tt__AbsoluteFocus *a, const char *type)
{
	size_t soap_flag_Position = 1;
	size_t soap_flag_Speed = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__AbsoluteFocus *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AbsoluteFocus, sizeof(struct tt__AbsoluteFocus), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__AbsoluteFocus(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Position && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_float(soap, "tt:Position", &a->Position, "xsd:float"))
				{	soap_flag_Position--;
					continue;
				}
			if (soap_flag_Speed && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofloat(soap, "tt:Speed", &a->Speed, "xsd:float"))
				{	soap_flag_Speed--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__AbsoluteFocus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AbsoluteFocus, 0, sizeof(struct tt__AbsoluteFocus), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Position > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__AbsoluteFocus(struct soap *soap, const struct tt__AbsoluteFocus *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__AbsoluteFocus);
	if (soap_out_tt__AbsoluteFocus(soap, tag?tag:"tt:AbsoluteFocus", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AbsoluteFocus * SOAP_FMAC4 soap_get_tt__AbsoluteFocus(struct soap *soap, struct tt__AbsoluteFocus *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AbsoluteFocus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__FocusMove(struct soap *soap, struct tt__FocusMove *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Absolute = NULL;
	a->Relative = NULL;
	a->Continuous = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__FocusMove(struct soap *soap, const struct tt__FocusMove *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTott__AbsoluteFocus(soap, &a->Absolute);
	soap_serialize_PointerTott__RelativeFocus(soap, &a->Relative);
	soap_serialize_PointerTott__ContinuousFocus(soap, &a->Continuous);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__FocusMove(struct soap *soap, const char *tag, int id, const struct tt__FocusMove *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__FocusMove), type))
		return soap->error;
	if (soap_out_PointerTott__AbsoluteFocus(soap, "tt:Absolute", -1, &a->Absolute, ""))
		return soap->error;
	if (soap_out_PointerTott__RelativeFocus(soap, "tt:Relative", -1, &a->Relative, ""))
		return soap->error;
	if (soap_out_PointerTott__ContinuousFocus(soap, "tt:Continuous", -1, &a->Continuous, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__FocusMove * SOAP_FMAC4 soap_in_tt__FocusMove(struct soap *soap, const char *tag, struct tt__FocusMove *a, const char *type)
{
	size_t soap_flag_Absolute = 1;
	size_t soap_flag_Relative = 1;
	size_t soap_flag_Continuous = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__FocusMove *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__FocusMove, sizeof(struct tt__FocusMove), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__FocusMove(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Absolute && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__AbsoluteFocus(soap, "tt:Absolute", &a->Absolute, "tt:AbsoluteFocus"))
				{	soap_flag_Absolute--;
					continue;
				}
			if (soap_flag_Relative && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__RelativeFocus(soap, "tt:Relative", &a->Relative, "tt:RelativeFocus"))
				{	soap_flag_Relative--;
					continue;
				}
			if (soap_flag_Continuous && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__ContinuousFocus(soap, "tt:Continuous", &a->Continuous, "tt:ContinuousFocus"))
				{	soap_flag_Continuous--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__FocusMove *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__FocusMove, 0, sizeof(struct tt__FocusMove), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__FocusMove(struct soap *soap, const struct tt__FocusMove *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__FocusMove);
	if (soap_out_tt__FocusMove(soap, tag?tag:"tt:FocusMove", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__FocusMove * SOAP_FMAC4 soap_get_tt__FocusMove(struct soap *soap, struct tt__FocusMove *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__FocusMove(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__WhiteBalanceOptions(struct soap *soap, struct tt__WhiteBalanceOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeMode = 0;
	a->Mode = NULL;
	a->YrGain = NULL;
	a->YbGain = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__WhiteBalanceOptions(struct soap *soap, const struct tt__WhiteBalanceOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->Mode)
	{	int i;
		for (i = 0; i < a->__sizeMode; i++)
		{
			soap_embedded(soap, a->Mode + i, SOAP_TYPE_tt__WhiteBalanceMode);
		}
	}
	soap_serialize_PointerTott__FloatRange(soap, &a->YrGain);
	soap_serialize_PointerTott__FloatRange(soap, &a->YbGain);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__WhiteBalanceOptions(struct soap *soap, const char *tag, int id, const struct tt__WhiteBalanceOptions *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__WhiteBalanceOptions), type))
		return soap->error;
	if (a->Mode)
	{	int i;
		for (i = 0; i < a->__sizeMode; i++)
			if (soap_out_tt__WhiteBalanceMode(soap, "tt:Mode", -1, a->Mode + i, ""))
				return soap->error;
	}
	if (a->YrGain)
	{	if (soap_out_PointerTott__FloatRange(soap, "tt:YrGain", -1, &a->YrGain, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:YrGain"))
		return soap->error;
	if (a->YbGain)
	{	if (soap_out_PointerTott__FloatRange(soap, "tt:YbGain", -1, &a->YbGain, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:YbGain"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__WhiteBalanceOptions * SOAP_FMAC4 soap_in_tt__WhiteBalanceOptions(struct soap *soap, const char *tag, struct tt__WhiteBalanceOptions *a, const char *type)
{
	struct soap_blist *soap_blist_Mode = NULL;
	size_t soap_flag_YrGain = 1;
	size_t soap_flag_YbGain = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__WhiteBalanceOptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__WhiteBalanceOptions, sizeof(struct tt__WhiteBalanceOptions), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__WhiteBalanceOptions(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Mode", 1, NULL))
			{	if (a->Mode == NULL)
				{	if (soap_blist_Mode == NULL)
						soap_blist_Mode = soap_new_block(soap);
					a->Mode = (enum tt__WhiteBalanceMode *)soap_push_block(soap, soap_blist_Mode, sizeof(enum tt__WhiteBalanceMode));
					if (a->Mode == NULL)
						return NULL;
					soap_default_tt__WhiteBalanceMode(soap, a->Mode);
				}
				soap_revert(soap);
				if (soap_in_tt__WhiteBalanceMode(soap, "tt:Mode", a->Mode, "tt:WhiteBalanceMode"))
				{	a->__sizeMode++;
					a->Mode = NULL;
					continue;
				}
			}
			if (soap_flag_YrGain && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__FloatRange(soap, "tt:YrGain", &a->YrGain, "tt:FloatRange"))
				{	soap_flag_YrGain--;
					continue;
				}
			if (soap_flag_YbGain && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__FloatRange(soap, "tt:YbGain", &a->YbGain, "tt:FloatRange"))
				{	soap_flag_YbGain--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Mode)
			soap_pop_block(soap, soap_blist_Mode);
		if (a->__sizeMode)
			a->Mode = (enum tt__WhiteBalanceMode *)soap_save_block(soap, soap_blist_Mode, NULL, 1);
		else
		{	a->Mode = NULL;
			if (soap_blist_Mode)
				soap_end_block(soap, soap_blist_Mode);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__WhiteBalanceOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__WhiteBalanceOptions, 0, sizeof(struct tt__WhiteBalanceOptions), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeMode < 1 || soap_flag_YrGain > 0 || soap_flag_YbGain > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__WhiteBalanceOptions(struct soap *soap, const struct tt__WhiteBalanceOptions *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__WhiteBalanceOptions);
	if (soap_out_tt__WhiteBalanceOptions(soap, tag?tag:"tt:WhiteBalanceOptions", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__WhiteBalanceOptions * SOAP_FMAC4 soap_get_tt__WhiteBalanceOptions(struct soap *soap, struct tt__WhiteBalanceOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__WhiteBalanceOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__WideDynamicRangeOptions(struct soap *soap, struct tt__WideDynamicRangeOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeMode = 0;
	a->Mode = NULL;
	a->Level = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__WideDynamicRangeOptions(struct soap *soap, const struct tt__WideDynamicRangeOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->Mode)
	{	int i;
		for (i = 0; i < a->__sizeMode; i++)
		{
			soap_embedded(soap, a->Mode + i, SOAP_TYPE_tt__WideDynamicMode);
		}
	}
	soap_serialize_PointerTott__FloatRange(soap, &a->Level);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__WideDynamicRangeOptions(struct soap *soap, const char *tag, int id, const struct tt__WideDynamicRangeOptions *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__WideDynamicRangeOptions), type))
		return soap->error;
	if (a->Mode)
	{	int i;
		for (i = 0; i < a->__sizeMode; i++)
			if (soap_out_tt__WideDynamicMode(soap, "tt:Mode", -1, a->Mode + i, ""))
				return soap->error;
	}
	if (a->Level)
	{	if (soap_out_PointerTott__FloatRange(soap, "tt:Level", -1, &a->Level, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:Level"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__WideDynamicRangeOptions * SOAP_FMAC4 soap_in_tt__WideDynamicRangeOptions(struct soap *soap, const char *tag, struct tt__WideDynamicRangeOptions *a, const char *type)
{
	struct soap_blist *soap_blist_Mode = NULL;
	size_t soap_flag_Level = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__WideDynamicRangeOptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__WideDynamicRangeOptions, sizeof(struct tt__WideDynamicRangeOptions), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__WideDynamicRangeOptions(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Mode", 1, NULL))
			{	if (a->Mode == NULL)
				{	if (soap_blist_Mode == NULL)
						soap_blist_Mode = soap_new_block(soap);
					a->Mode = (enum tt__WideDynamicMode *)soap_push_block(soap, soap_blist_Mode, sizeof(enum tt__WideDynamicMode));
					if (a->Mode == NULL)
						return NULL;
					soap_default_tt__WideDynamicMode(soap, a->Mode);
				}
				soap_revert(soap);
				if (soap_in_tt__WideDynamicMode(soap, "tt:Mode", a->Mode, "tt:WideDynamicMode"))
				{	a->__sizeMode++;
					a->Mode = NULL;
					continue;
				}
			}
			if (soap_flag_Level && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__FloatRange(soap, "tt:Level", &a->Level, "tt:FloatRange"))
				{	soap_flag_Level--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Mode)
			soap_pop_block(soap, soap_blist_Mode);
		if (a->__sizeMode)
			a->Mode = (enum tt__WideDynamicMode *)soap_save_block(soap, soap_blist_Mode, NULL, 1);
		else
		{	a->Mode = NULL;
			if (soap_blist_Mode)
				soap_end_block(soap, soap_blist_Mode);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__WideDynamicRangeOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__WideDynamicRangeOptions, 0, sizeof(struct tt__WideDynamicRangeOptions), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeMode < 1 || soap_flag_Level > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__WideDynamicRangeOptions(struct soap *soap, const struct tt__WideDynamicRangeOptions *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__WideDynamicRangeOptions);
	if (soap_out_tt__WideDynamicRangeOptions(soap, tag?tag:"tt:WideDynamicRangeOptions", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__WideDynamicRangeOptions * SOAP_FMAC4 soap_get_tt__WideDynamicRangeOptions(struct soap *soap, struct tt__WideDynamicRangeOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__WideDynamicRangeOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__FocusOptions(struct soap *soap, struct tt__FocusOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeAutoFocusModes = 0;
	a->AutoFocusModes = NULL;
	a->DefaultSpeed = NULL;
	a->NearLimit = NULL;
	a->FarLimit = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__FocusOptions(struct soap *soap, const struct tt__FocusOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->AutoFocusModes)
	{	int i;
		for (i = 0; i < a->__sizeAutoFocusModes; i++)
		{
			soap_embedded(soap, a->AutoFocusModes + i, SOAP_TYPE_tt__AutoFocusMode);
		}
	}
	soap_serialize_PointerTott__FloatRange(soap, &a->DefaultSpeed);
	soap_serialize_PointerTott__FloatRange(soap, &a->NearLimit);
	soap_serialize_PointerTott__FloatRange(soap, &a->FarLimit);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__FocusOptions(struct soap *soap, const char *tag, int id, const struct tt__FocusOptions *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__FocusOptions), type))
		return soap->error;
	if (a->AutoFocusModes)
	{	int i;
		for (i = 0; i < a->__sizeAutoFocusModes; i++)
			if (soap_out_tt__AutoFocusMode(soap, "tt:AutoFocusModes", -1, a->AutoFocusModes + i, ""))
				return soap->error;
	}
	if (a->DefaultSpeed)
	{	if (soap_out_PointerTott__FloatRange(soap, "tt:DefaultSpeed", -1, &a->DefaultSpeed, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:DefaultSpeed"))
		return soap->error;
	if (a->NearLimit)
	{	if (soap_out_PointerTott__FloatRange(soap, "tt:NearLimit", -1, &a->NearLimit, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:NearLimit"))
		return soap->error;
	if (a->FarLimit)
	{	if (soap_out_PointerTott__FloatRange(soap, "tt:FarLimit", -1, &a->FarLimit, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:FarLimit"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__FocusOptions * SOAP_FMAC4 soap_in_tt__FocusOptions(struct soap *soap, const char *tag, struct tt__FocusOptions *a, const char *type)
{
	struct soap_blist *soap_blist_AutoFocusModes = NULL;
	size_t soap_flag_DefaultSpeed = 1;
	size_t soap_flag_NearLimit = 1;
	size_t soap_flag_FarLimit = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__FocusOptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__FocusOptions, sizeof(struct tt__FocusOptions), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__FocusOptions(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:AutoFocusModes", 1, NULL))
			{	if (a->AutoFocusModes == NULL)
				{	if (soap_blist_AutoFocusModes == NULL)
						soap_blist_AutoFocusModes = soap_new_block(soap);
					a->AutoFocusModes = (enum tt__AutoFocusMode *)soap_push_block(soap, soap_blist_AutoFocusModes, sizeof(enum tt__AutoFocusMode));
					if (a->AutoFocusModes == NULL)
						return NULL;
					soap_default_tt__AutoFocusMode(soap, a->AutoFocusModes);
				}
				soap_revert(soap);
				if (soap_in_tt__AutoFocusMode(soap, "tt:AutoFocusModes", a->AutoFocusModes, "tt:AutoFocusMode"))
				{	a->__sizeAutoFocusModes++;
					a->AutoFocusModes = NULL;
					continue;
				}
			}
			if (soap_flag_DefaultSpeed && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__FloatRange(soap, "tt:DefaultSpeed", &a->DefaultSpeed, "tt:FloatRange"))
				{	soap_flag_DefaultSpeed--;
					continue;
				}
			if (soap_flag_NearLimit && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__FloatRange(soap, "tt:NearLimit", &a->NearLimit, "tt:FloatRange"))
				{	soap_flag_NearLimit--;
					continue;
				}
			if (soap_flag_FarLimit && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__FloatRange(soap, "tt:FarLimit", &a->FarLimit, "tt:FloatRange"))
				{	soap_flag_FarLimit--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->AutoFocusModes)
			soap_pop_block(soap, soap_blist_AutoFocusModes);
		if (a->__sizeAutoFocusModes)
			a->AutoFocusModes = (enum tt__AutoFocusMode *)soap_save_block(soap, soap_blist_AutoFocusModes, NULL, 1);
		else
		{	a->AutoFocusModes = NULL;
			if (soap_blist_AutoFocusModes)
				soap_end_block(soap, soap_blist_AutoFocusModes);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__FocusOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__FocusOptions, 0, sizeof(struct tt__FocusOptions), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_DefaultSpeed > 0 || soap_flag_NearLimit > 0 || soap_flag_FarLimit > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__FocusOptions(struct soap *soap, const struct tt__FocusOptions *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__FocusOptions);
	if (soap_out_tt__FocusOptions(soap, tag?tag:"tt:FocusOptions", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__FocusOptions * SOAP_FMAC4 soap_get_tt__FocusOptions(struct soap *soap, struct tt__FocusOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__FocusOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__ExposureOptions(struct soap *soap, struct tt__ExposureOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeMode = 0;
	a->Mode = NULL;
	a->__sizePriority = 0;
	a->Priority = NULL;
	a->MinExposureTime = NULL;
	a->MaxExposureTime = NULL;
	a->MinGain = NULL;
	a->MaxGain = NULL;
	a->MinIris = NULL;
	a->MaxIris = NULL;
	a->ExposureTime = NULL;
	a->Gain = NULL;
	a->Iris = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__ExposureOptions(struct soap *soap, const struct tt__ExposureOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->Mode)
	{	int i;
		for (i = 0; i < a->__sizeMode; i++)
		{
			soap_embedded(soap, a->Mode + i, SOAP_TYPE_tt__ExposureMode);
		}
	}
	if (a->Priority)
	{	int i;
		for (i = 0; i < a->__sizePriority; i++)
		{
			soap_embedded(soap, a->Priority + i, SOAP_TYPE_tt__ExposurePriority);
		}
	}
	soap_serialize_PointerTott__FloatRange(soap, &a->MinExposureTime);
	soap_serialize_PointerTott__FloatRange(soap, &a->MaxExposureTime);
	soap_serialize_PointerTott__FloatRange(soap, &a->MinGain);
	soap_serialize_PointerTott__FloatRange(soap, &a->MaxGain);
	soap_serialize_PointerTott__FloatRange(soap, &a->MinIris);
	soap_serialize_PointerTott__FloatRange(soap, &a->MaxIris);
	soap_serialize_PointerTott__FloatRange(soap, &a->ExposureTime);
	soap_serialize_PointerTott__FloatRange(soap, &a->Gain);
	soap_serialize_PointerTott__FloatRange(soap, &a->Iris);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ExposureOptions(struct soap *soap, const char *tag, int id, const struct tt__ExposureOptions *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ExposureOptions), type))
		return soap->error;
	if (a->Mode)
	{	int i;
		for (i = 0; i < a->__sizeMode; i++)
			if (soap_out_tt__ExposureMode(soap, "tt:Mode", -1, a->Mode + i, ""))
				return soap->error;
	}
	if (a->Priority)
	{	int i;
		for (i = 0; i < a->__sizePriority; i++)
			if (soap_out_tt__ExposurePriority(soap, "tt:Priority", -1, a->Priority + i, ""))
				return soap->error;
	}
	if (a->MinExposureTime)
	{	if (soap_out_PointerTott__FloatRange(soap, "tt:MinExposureTime", -1, &a->MinExposureTime, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:MinExposureTime"))
		return soap->error;
	if (a->MaxExposureTime)
	{	if (soap_out_PointerTott__FloatRange(soap, "tt:MaxExposureTime", -1, &a->MaxExposureTime, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:MaxExposureTime"))
		return soap->error;
	if (a->MinGain)
	{	if (soap_out_PointerTott__FloatRange(soap, "tt:MinGain", -1, &a->MinGain, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:MinGain"))
		return soap->error;
	if (a->MaxGain)
	{	if (soap_out_PointerTott__FloatRange(soap, "tt:MaxGain", -1, &a->MaxGain, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:MaxGain"))
		return soap->error;
	if (a->MinIris)
	{	if (soap_out_PointerTott__FloatRange(soap, "tt:MinIris", -1, &a->MinIris, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:MinIris"))
		return soap->error;
	if (a->MaxIris)
	{	if (soap_out_PointerTott__FloatRange(soap, "tt:MaxIris", -1, &a->MaxIris, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:MaxIris"))
		return soap->error;
	if (a->ExposureTime)
	{	if (soap_out_PointerTott__FloatRange(soap, "tt:ExposureTime", -1, &a->ExposureTime, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:ExposureTime"))
		return soap->error;
	if (a->Gain)
	{	if (soap_out_PointerTott__FloatRange(soap, "tt:Gain", -1, &a->Gain, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:Gain"))
		return soap->error;
	if (a->Iris)
	{	if (soap_out_PointerTott__FloatRange(soap, "tt:Iris", -1, &a->Iris, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:Iris"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__ExposureOptions * SOAP_FMAC4 soap_in_tt__ExposureOptions(struct soap *soap, const char *tag, struct tt__ExposureOptions *a, const char *type)
{
	struct soap_blist *soap_blist_Mode = NULL;
	struct soap_blist *soap_blist_Priority = NULL;
	size_t soap_flag_MinExposureTime = 1;
	size_t soap_flag_MaxExposureTime = 1;
	size_t soap_flag_MinGain = 1;
	size_t soap_flag_MaxGain = 1;
	size_t soap_flag_MinIris = 1;
	size_t soap_flag_MaxIris = 1;
	size_t soap_flag_ExposureTime = 1;
	size_t soap_flag_Gain = 1;
	size_t soap_flag_Iris = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__ExposureOptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ExposureOptions, sizeof(struct tt__ExposureOptions), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__ExposureOptions(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Mode", 1, NULL))
			{	if (a->Mode == NULL)
				{	if (soap_blist_Mode == NULL)
						soap_blist_Mode = soap_new_block(soap);
					a->Mode = (enum tt__ExposureMode *)soap_push_block(soap, soap_blist_Mode, sizeof(enum tt__ExposureMode));
					if (a->Mode == NULL)
						return NULL;
					soap_default_tt__ExposureMode(soap, a->Mode);
				}
				soap_revert(soap);
				if (soap_in_tt__ExposureMode(soap, "tt:Mode", a->Mode, "tt:ExposureMode"))
				{	a->__sizeMode++;
					a->Mode = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Priority", 1, NULL))
			{	if (a->Priority == NULL)
				{	if (soap_blist_Priority == NULL)
						soap_blist_Priority = soap_new_block(soap);
					a->Priority = (enum tt__ExposurePriority *)soap_push_block(soap, soap_blist_Priority, sizeof(enum tt__ExposurePriority));
					if (a->Priority == NULL)
						return NULL;
					soap_default_tt__ExposurePriority(soap, a->Priority);
				}
				soap_revert(soap);
				if (soap_in_tt__ExposurePriority(soap, "tt:Priority", a->Priority, "tt:ExposurePriority"))
				{	a->__sizePriority++;
					a->Priority = NULL;
					continue;
				}
			}
			if (soap_flag_MinExposureTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__FloatRange(soap, "tt:MinExposureTime", &a->MinExposureTime, "tt:FloatRange"))
				{	soap_flag_MinExposureTime--;
					continue;
				}
			if (soap_flag_MaxExposureTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__FloatRange(soap, "tt:MaxExposureTime", &a->MaxExposureTime, "tt:FloatRange"))
				{	soap_flag_MaxExposureTime--;
					continue;
				}
			if (soap_flag_MinGain && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__FloatRange(soap, "tt:MinGain", &a->MinGain, "tt:FloatRange"))
				{	soap_flag_MinGain--;
					continue;
				}
			if (soap_flag_MaxGain && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__FloatRange(soap, "tt:MaxGain", &a->MaxGain, "tt:FloatRange"))
				{	soap_flag_MaxGain--;
					continue;
				}
			if (soap_flag_MinIris && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__FloatRange(soap, "tt:MinIris", &a->MinIris, "tt:FloatRange"))
				{	soap_flag_MinIris--;
					continue;
				}
			if (soap_flag_MaxIris && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__FloatRange(soap, "tt:MaxIris", &a->MaxIris, "tt:FloatRange"))
				{	soap_flag_MaxIris--;
					continue;
				}
			if (soap_flag_ExposureTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__FloatRange(soap, "tt:ExposureTime", &a->ExposureTime, "tt:FloatRange"))
				{	soap_flag_ExposureTime--;
					continue;
				}
			if (soap_flag_Gain && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__FloatRange(soap, "tt:Gain", &a->Gain, "tt:FloatRange"))
				{	soap_flag_Gain--;
					continue;
				}
			if (soap_flag_Iris && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__FloatRange(soap, "tt:Iris", &a->Iris, "tt:FloatRange"))
				{	soap_flag_Iris--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Mode)
			soap_pop_block(soap, soap_blist_Mode);
		if (a->__sizeMode)
			a->Mode = (enum tt__ExposureMode *)soap_save_block(soap, soap_blist_Mode, NULL, 1);
		else
		{	a->Mode = NULL;
			if (soap_blist_Mode)
				soap_end_block(soap, soap_blist_Mode);
		}
		if (a->Priority)
			soap_pop_block(soap, soap_blist_Priority);
		if (a->__sizePriority)
			a->Priority = (enum tt__ExposurePriority *)soap_save_block(soap, soap_blist_Priority, NULL, 1);
		else
		{	a->Priority = NULL;
			if (soap_blist_Priority)
				soap_end_block(soap, soap_blist_Priority);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__ExposureOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ExposureOptions, 0, sizeof(struct tt__ExposureOptions), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeMode < 1 || a->__sizePriority < 1 || soap_flag_MinExposureTime > 0 || soap_flag_MaxExposureTime > 0 || soap_flag_MinGain > 0 || soap_flag_MaxGain > 0 || soap_flag_MinIris > 0 || soap_flag_MaxIris > 0 || soap_flag_ExposureTime > 0 || soap_flag_Gain > 0 || soap_flag_Iris > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ExposureOptions(struct soap *soap, const struct tt__ExposureOptions *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__ExposureOptions);
	if (soap_out_tt__ExposureOptions(soap, tag?tag:"tt:ExposureOptions", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ExposureOptions * SOAP_FMAC4 soap_get_tt__ExposureOptions(struct soap *soap, struct tt__ExposureOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ExposureOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__BacklightCompensationOptions(struct soap *soap, struct tt__BacklightCompensationOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeMode = 0;
	a->Mode = NULL;
	a->Level = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__BacklightCompensationOptions(struct soap *soap, const struct tt__BacklightCompensationOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->Mode)
	{	int i;
		for (i = 0; i < a->__sizeMode; i++)
		{
			soap_embedded(soap, a->Mode + i, SOAP_TYPE_tt__WideDynamicMode);
		}
	}
	soap_serialize_PointerTott__FloatRange(soap, &a->Level);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__BacklightCompensationOptions(struct soap *soap, const char *tag, int id, const struct tt__BacklightCompensationOptions *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__BacklightCompensationOptions), type))
		return soap->error;
	if (a->Mode)
	{	int i;
		for (i = 0; i < a->__sizeMode; i++)
			if (soap_out_tt__WideDynamicMode(soap, "tt:Mode", -1, a->Mode + i, ""))
				return soap->error;
	}
	if (a->Level)
	{	if (soap_out_PointerTott__FloatRange(soap, "tt:Level", -1, &a->Level, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:Level"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__BacklightCompensationOptions * SOAP_FMAC4 soap_in_tt__BacklightCompensationOptions(struct soap *soap, const char *tag, struct tt__BacklightCompensationOptions *a, const char *type)
{
	struct soap_blist *soap_blist_Mode = NULL;
	size_t soap_flag_Level = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__BacklightCompensationOptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__BacklightCompensationOptions, sizeof(struct tt__BacklightCompensationOptions), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__BacklightCompensationOptions(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Mode", 1, NULL))
			{	if (a->Mode == NULL)
				{	if (soap_blist_Mode == NULL)
						soap_blist_Mode = soap_new_block(soap);
					a->Mode = (enum tt__WideDynamicMode *)soap_push_block(soap, soap_blist_Mode, sizeof(enum tt__WideDynamicMode));
					if (a->Mode == NULL)
						return NULL;
					soap_default_tt__WideDynamicMode(soap, a->Mode);
				}
				soap_revert(soap);
				if (soap_in_tt__WideDynamicMode(soap, "tt:Mode", a->Mode, "tt:WideDynamicMode"))
				{	a->__sizeMode++;
					a->Mode = NULL;
					continue;
				}
			}
			if (soap_flag_Level && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__FloatRange(soap, "tt:Level", &a->Level, "tt:FloatRange"))
				{	soap_flag_Level--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Mode)
			soap_pop_block(soap, soap_blist_Mode);
		if (a->__sizeMode)
			a->Mode = (enum tt__WideDynamicMode *)soap_save_block(soap, soap_blist_Mode, NULL, 1);
		else
		{	a->Mode = NULL;
			if (soap_blist_Mode)
				soap_end_block(soap, soap_blist_Mode);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__BacklightCompensationOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__BacklightCompensationOptions, 0, sizeof(struct tt__BacklightCompensationOptions), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeMode < 1 || soap_flag_Level > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__BacklightCompensationOptions(struct soap *soap, const struct tt__BacklightCompensationOptions *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__BacklightCompensationOptions);
	if (soap_out_tt__BacklightCompensationOptions(soap, tag?tag:"tt:BacklightCompensationOptions", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__BacklightCompensationOptions * SOAP_FMAC4 soap_get_tt__BacklightCompensationOptions(struct soap *soap, struct tt__BacklightCompensationOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__BacklightCompensationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__ImagingOptions(struct soap *soap, struct tt__ImagingOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->BacklightCompensation = NULL;
	a->Brightness = NULL;
	a->ColorSaturation = NULL;
	a->Contrast = NULL;
	a->Exposure = NULL;
	a->Focus = NULL;
	a->__sizeIrCutFilterModes = 0;
	a->IrCutFilterModes = NULL;
	a->Sharpness = NULL;
	a->WideDynamicRange = NULL;
	a->WhiteBalance = NULL;
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__ImagingOptions(struct soap *soap, const struct tt__ImagingOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTott__BacklightCompensationOptions(soap, &a->BacklightCompensation);
	soap_serialize_PointerTott__FloatRange(soap, &a->Brightness);
	soap_serialize_PointerTott__FloatRange(soap, &a->ColorSaturation);
	soap_serialize_PointerTott__FloatRange(soap, &a->Contrast);
	soap_serialize_PointerTott__ExposureOptions(soap, &a->Exposure);
	soap_serialize_PointerTott__FocusOptions(soap, &a->Focus);
	if (a->IrCutFilterModes)
	{	int i;
		for (i = 0; i < a->__sizeIrCutFilterModes; i++)
		{
			soap_embedded(soap, a->IrCutFilterModes + i, SOAP_TYPE_tt__IrCutFilterMode);
		}
	}
	soap_serialize_PointerTott__FloatRange(soap, &a->Sharpness);
	soap_serialize_PointerTott__WideDynamicRangeOptions(soap, &a->WideDynamicRange);
	soap_serialize_PointerTott__WhiteBalanceOptions(soap, &a->WhiteBalance);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ImagingOptions(struct soap *soap, const char *tag, int id, const struct tt__ImagingOptions *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ImagingOptions), type))
		return soap->error;
	if (a->BacklightCompensation)
	{	if (soap_out_PointerTott__BacklightCompensationOptions(soap, "tt:BacklightCompensation", -1, &a->BacklightCompensation, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:BacklightCompensation"))
		return soap->error;
	if (a->Brightness)
	{	if (soap_out_PointerTott__FloatRange(soap, "tt:Brightness", -1, &a->Brightness, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:Brightness"))
		return soap->error;
	if (a->ColorSaturation)
	{	if (soap_out_PointerTott__FloatRange(soap, "tt:ColorSaturation", -1, &a->ColorSaturation, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:ColorSaturation"))
		return soap->error;
	if (a->Contrast)
	{	if (soap_out_PointerTott__FloatRange(soap, "tt:Contrast", -1, &a->Contrast, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:Contrast"))
		return soap->error;
	if (a->Exposure)
	{	if (soap_out_PointerTott__ExposureOptions(soap, "tt:Exposure", -1, &a->Exposure, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:Exposure"))
		return soap->error;
	if (a->Focus)
	{	if (soap_out_PointerTott__FocusOptions(soap, "tt:Focus", -1, &a->Focus, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:Focus"))
		return soap->error;
	if (a->IrCutFilterModes)
	{	int i;
		for (i = 0; i < a->__sizeIrCutFilterModes; i++)
			if (soap_out_tt__IrCutFilterMode(soap, "tt:IrCutFilterModes", -1, a->IrCutFilterModes + i, ""))
				return soap->error;
	}
	if (a->Sharpness)
	{	if (soap_out_PointerTott__FloatRange(soap, "tt:Sharpness", -1, &a->Sharpness, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:Sharpness"))
		return soap->error;
	if (a->WideDynamicRange)
	{	if (soap_out_PointerTott__WideDynamicRangeOptions(soap, "tt:WideDynamicRange", -1, &a->WideDynamicRange, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:WideDynamicRange"))
		return soap->error;
	if (a->WhiteBalance)
	{	if (soap_out_PointerTott__WhiteBalanceOptions(soap, "tt:WhiteBalance", -1, &a->WhiteBalance, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:WhiteBalance"))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__ImagingOptions * SOAP_FMAC4 soap_in_tt__ImagingOptions(struct soap *soap, const char *tag, struct tt__ImagingOptions *a, const char *type)
{
	size_t soap_flag_BacklightCompensation = 1;
	size_t soap_flag_Brightness = 1;
	size_t soap_flag_ColorSaturation = 1;
	size_t soap_flag_Contrast = 1;
	size_t soap_flag_Exposure = 1;
	size_t soap_flag_Focus = 1;
	struct soap_blist *soap_blist_IrCutFilterModes = NULL;
	size_t soap_flag_Sharpness = 1;
	size_t soap_flag_WideDynamicRange = 1;
	size_t soap_flag_WhiteBalance = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__ImagingOptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ImagingOptions, sizeof(struct tt__ImagingOptions), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__ImagingOptions(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_BacklightCompensation && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__BacklightCompensationOptions(soap, "tt:BacklightCompensation", &a->BacklightCompensation, "tt:BacklightCompensationOptions"))
				{	soap_flag_BacklightCompensation--;
					continue;
				}
			if (soap_flag_Brightness && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__FloatRange(soap, "tt:Brightness", &a->Brightness, "tt:FloatRange"))
				{	soap_flag_Brightness--;
					continue;
				}
			if (soap_flag_ColorSaturation && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__FloatRange(soap, "tt:ColorSaturation", &a->ColorSaturation, "tt:FloatRange"))
				{	soap_flag_ColorSaturation--;
					continue;
				}
			if (soap_flag_Contrast && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__FloatRange(soap, "tt:Contrast", &a->Contrast, "tt:FloatRange"))
				{	soap_flag_Contrast--;
					continue;
				}
			if (soap_flag_Exposure && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__ExposureOptions(soap, "tt:Exposure", &a->Exposure, "tt:ExposureOptions"))
				{	soap_flag_Exposure--;
					continue;
				}
			if (soap_flag_Focus && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__FocusOptions(soap, "tt:Focus", &a->Focus, "tt:FocusOptions"))
				{	soap_flag_Focus--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:IrCutFilterModes", 1, NULL))
			{	if (a->IrCutFilterModes == NULL)
				{	if (soap_blist_IrCutFilterModes == NULL)
						soap_blist_IrCutFilterModes = soap_new_block(soap);
					a->IrCutFilterModes = (enum tt__IrCutFilterMode *)soap_push_block(soap, soap_blist_IrCutFilterModes, sizeof(enum tt__IrCutFilterMode));
					if (a->IrCutFilterModes == NULL)
						return NULL;
					soap_default_tt__IrCutFilterMode(soap, a->IrCutFilterModes);
				}
				soap_revert(soap);
				if (soap_in_tt__IrCutFilterMode(soap, "tt:IrCutFilterModes", a->IrCutFilterModes, "tt:IrCutFilterMode"))
				{	a->__sizeIrCutFilterModes++;
					a->IrCutFilterModes = NULL;
					continue;
				}
			}
			if (soap_flag_Sharpness && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__FloatRange(soap, "tt:Sharpness", &a->Sharpness, "tt:FloatRange"))
				{	soap_flag_Sharpness--;
					continue;
				}
			if (soap_flag_WideDynamicRange && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__WideDynamicRangeOptions(soap, "tt:WideDynamicRange", &a->WideDynamicRange, "tt:WideDynamicRangeOptions"))
				{	soap_flag_WideDynamicRange--;
					continue;
				}
			if (soap_flag_WhiteBalance && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__WhiteBalanceOptions(soap, "tt:WhiteBalance", &a->WhiteBalance, "tt:WhiteBalanceOptions"))
				{	soap_flag_WhiteBalance--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->IrCutFilterModes)
			soap_pop_block(soap, soap_blist_IrCutFilterModes);
		if (a->__sizeIrCutFilterModes)
			a->IrCutFilterModes = (enum tt__IrCutFilterMode *)soap_save_block(soap, soap_blist_IrCutFilterModes, NULL, 1);
		else
		{	a->IrCutFilterModes = NULL;
			if (soap_blist_IrCutFilterModes)
				soap_end_block(soap, soap_blist_IrCutFilterModes);
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__ImagingOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ImagingOptions, 0, sizeof(struct tt__ImagingOptions), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_BacklightCompensation > 0 || soap_flag_Brightness > 0 || soap_flag_ColorSaturation > 0 || soap_flag_Contrast > 0 || soap_flag_Exposure > 0 || soap_flag_Focus > 0 || a->__sizeIrCutFilterModes < 1 || soap_flag_Sharpness > 0 || soap_flag_WideDynamicRange > 0 || soap_flag_WhiteBalance > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ImagingOptions(struct soap *soap, const struct tt__ImagingOptions *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__ImagingOptions);
	if (soap_out_tt__ImagingOptions(soap, tag?tag:"tt:ImagingOptions", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ImagingOptions * SOAP_FMAC4 soap_get_tt__ImagingOptions(struct soap *soap, struct tt__ImagingOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ImagingOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__Rectangle(struct soap *soap, struct tt__Rectangle *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->bottom = NULL;
	a->top = NULL;
	a->right = NULL;
	a->left = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__Rectangle(struct soap *soap, const struct tt__Rectangle *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Rectangle(struct soap *soap, const char *tag, int id, const struct tt__Rectangle *a, const char *type)
{
	if (a->bottom)
		soap_set_attr(soap, "bottom", soap_float2s(soap, *a->bottom), 1);
	if (a->top)
		soap_set_attr(soap, "top", soap_float2s(soap, *a->top), 1);
	if (a->right)
		soap_set_attr(soap, "right", soap_float2s(soap, *a->right), 1);
	if (a->left)
		soap_set_attr(soap, "left", soap_float2s(soap, *a->left), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Rectangle), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__Rectangle * SOAP_FMAC4 soap_in_tt__Rectangle(struct soap *soap, const char *tag, struct tt__Rectangle *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__Rectangle *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Rectangle, sizeof(struct tt__Rectangle), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__Rectangle(soap, a);
	{	const char *t = soap_attr_value(soap, "bottom", 0);
		if (t)
		{
			if (!(a->bottom = (float *)soap_malloc(soap, sizeof(float))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2float(soap, t, a->bottom))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "top", 0);
		if (t)
		{
			if (!(a->top = (float *)soap_malloc(soap, sizeof(float))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2float(soap, t, a->top))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "right", 0);
		if (t)
		{
			if (!(a->right = (float *)soap_malloc(soap, sizeof(float))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2float(soap, t, a->right))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "left", 0);
		if (t)
		{
			if (!(a->left = (float *)soap_malloc(soap, sizeof(float))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2float(soap, t, a->left))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__Rectangle *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Rectangle, 0, sizeof(struct tt__Rectangle), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Rectangle(struct soap *soap, const struct tt__Rectangle *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__Rectangle);
	if (soap_out_tt__Rectangle(soap, tag?tag:"tt:Rectangle", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Rectangle * SOAP_FMAC4 soap_get_tt__Rectangle(struct soap *soap, struct tt__Rectangle *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Rectangle(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__ImagingSettingsExtension(struct soap *soap, struct tt__ImagingSettingsExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__ImagingSettingsExtension(struct soap *soap, const struct tt__ImagingSettingsExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ImagingSettingsExtension(struct soap *soap, const char *tag, int id, const struct tt__ImagingSettingsExtension *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ImagingSettingsExtension), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__ImagingSettingsExtension * SOAP_FMAC4 soap_in_tt__ImagingSettingsExtension(struct soap *soap, const char *tag, struct tt__ImagingSettingsExtension *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__ImagingSettingsExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ImagingSettingsExtension, sizeof(struct tt__ImagingSettingsExtension), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__ImagingSettingsExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__ImagingSettingsExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ImagingSettingsExtension, 0, sizeof(struct tt__ImagingSettingsExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ImagingSettingsExtension(struct soap *soap, const struct tt__ImagingSettingsExtension *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__ImagingSettingsExtension);
	if (soap_out_tt__ImagingSettingsExtension(soap, tag?tag:"tt:ImagingSettingsExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ImagingSettingsExtension * SOAP_FMAC4 soap_get_tt__ImagingSettingsExtension(struct soap *soap, struct tt__ImagingSettingsExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ImagingSettingsExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__WhiteBalance(struct soap *soap, struct tt__WhiteBalance *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__WhiteBalanceMode(soap, &a->Mode);
	soap_default_float(soap, &a->CrGain);
	soap_default_float(soap, &a->CbGain);
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__WhiteBalance(struct soap *soap, const struct tt__WhiteBalance *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->Mode, SOAP_TYPE_tt__WhiteBalanceMode);
	soap_embedded(soap, &a->CrGain, SOAP_TYPE_float);
	soap_embedded(soap, &a->CbGain, SOAP_TYPE_float);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__WhiteBalance(struct soap *soap, const char *tag, int id, const struct tt__WhiteBalance *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__WhiteBalance), type))
		return soap->error;
	if (soap_out_tt__WhiteBalanceMode(soap, "tt:Mode", -1, &a->Mode, ""))
		return soap->error;
	if (soap_out_float(soap, "tt:CrGain", -1, &a->CrGain, ""))
		return soap->error;
	if (soap_out_float(soap, "tt:CbGain", -1, &a->CbGain, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__WhiteBalance * SOAP_FMAC4 soap_in_tt__WhiteBalance(struct soap *soap, const char *tag, struct tt__WhiteBalance *a, const char *type)
{
	size_t soap_flag_Mode = 1;
	size_t soap_flag_CrGain = 1;
	size_t soap_flag_CbGain = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__WhiteBalance *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__WhiteBalance, sizeof(struct tt__WhiteBalance), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__WhiteBalance(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Mode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_tt__WhiteBalanceMode(soap, "tt:Mode", &a->Mode, "tt:WhiteBalanceMode"))
				{	soap_flag_Mode--;
					continue;
				}
			if (soap_flag_CrGain && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_float(soap, "tt:CrGain", &a->CrGain, "xsd:float"))
				{	soap_flag_CrGain--;
					continue;
				}
			if (soap_flag_CbGain && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_float(soap, "tt:CbGain", &a->CbGain, "xsd:float"))
				{	soap_flag_CbGain--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__WhiteBalance *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__WhiteBalance, 0, sizeof(struct tt__WhiteBalance), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Mode > 0 || soap_flag_CrGain > 0 || soap_flag_CbGain > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__WhiteBalance(struct soap *soap, const struct tt__WhiteBalance *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__WhiteBalance);
	if (soap_out_tt__WhiteBalance(soap, tag?tag:"tt:WhiteBalance", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__WhiteBalance * SOAP_FMAC4 soap_get_tt__WhiteBalance(struct soap *soap, struct tt__WhiteBalance *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__WhiteBalance(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__WideDynamicRange(struct soap *soap, struct tt__WideDynamicRange *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__WideDynamicMode(soap, &a->Mode);
	soap_default_float(soap, &a->Level);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__WideDynamicRange(struct soap *soap, const struct tt__WideDynamicRange *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->Mode, SOAP_TYPE_tt__WideDynamicMode);
	soap_embedded(soap, &a->Level, SOAP_TYPE_float);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__WideDynamicRange(struct soap *soap, const char *tag, int id, const struct tt__WideDynamicRange *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__WideDynamicRange), type))
		return soap->error;
	if (soap_out_tt__WideDynamicMode(soap, "tt:Mode", -1, &a->Mode, ""))
		return soap->error;
	if (soap_out_float(soap, "tt:Level", -1, &a->Level, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__WideDynamicRange * SOAP_FMAC4 soap_in_tt__WideDynamicRange(struct soap *soap, const char *tag, struct tt__WideDynamicRange *a, const char *type)
{
	size_t soap_flag_Mode = 1;
	size_t soap_flag_Level = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__WideDynamicRange *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__WideDynamicRange, sizeof(struct tt__WideDynamicRange), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__WideDynamicRange(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Mode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_tt__WideDynamicMode(soap, "tt:Mode", &a->Mode, "tt:WideDynamicMode"))
				{	soap_flag_Mode--;
					continue;
				}
			if (soap_flag_Level && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_float(soap, "tt:Level", &a->Level, "xsd:float"))
				{	soap_flag_Level--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__WideDynamicRange *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__WideDynamicRange, 0, sizeof(struct tt__WideDynamicRange), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Mode > 0 || soap_flag_Level > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__WideDynamicRange(struct soap *soap, const struct tt__WideDynamicRange *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__WideDynamicRange);
	if (soap_out_tt__WideDynamicRange(soap, tag?tag:"tt:WideDynamicRange", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__WideDynamicRange * SOAP_FMAC4 soap_get_tt__WideDynamicRange(struct soap *soap, struct tt__WideDynamicRange *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__WideDynamicRange(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__Exposure(struct soap *soap, struct tt__Exposure *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ExposureMode(soap, &a->Mode);
	soap_default_tt__ExposurePriority(soap, &a->Priority);
	a->Window = NULL;
	soap_default_float(soap, &a->MinExposureTime);
	soap_default_float(soap, &a->MaxExposureTime);
	soap_default_float(soap, &a->MinGain);
	soap_default_float(soap, &a->MaxGain);
	soap_default_float(soap, &a->MinIris);
	soap_default_float(soap, &a->MaxIris);
	soap_default_float(soap, &a->ExposureTime);
	soap_default_float(soap, &a->Gain);
	soap_default_float(soap, &a->Iris);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__Exposure(struct soap *soap, const struct tt__Exposure *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->Mode, SOAP_TYPE_tt__ExposureMode);
	soap_embedded(soap, &a->Priority, SOAP_TYPE_tt__ExposurePriority);
	soap_serialize_PointerTott__Rectangle(soap, &a->Window);
	soap_embedded(soap, &a->MinExposureTime, SOAP_TYPE_float);
	soap_embedded(soap, &a->MaxExposureTime, SOAP_TYPE_float);
	soap_embedded(soap, &a->MinGain, SOAP_TYPE_float);
	soap_embedded(soap, &a->MaxGain, SOAP_TYPE_float);
	soap_embedded(soap, &a->MinIris, SOAP_TYPE_float);
	soap_embedded(soap, &a->MaxIris, SOAP_TYPE_float);
	soap_embedded(soap, &a->ExposureTime, SOAP_TYPE_float);
	soap_embedded(soap, &a->Gain, SOAP_TYPE_float);
	soap_embedded(soap, &a->Iris, SOAP_TYPE_float);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Exposure(struct soap *soap, const char *tag, int id, const struct tt__Exposure *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Exposure), type))
		return soap->error;
	if (soap_out_tt__ExposureMode(soap, "tt:Mode", -1, &a->Mode, ""))
		return soap->error;
	if (soap_out_tt__ExposurePriority(soap, "tt:Priority", -1, &a->Priority, ""))
		return soap->error;
	if (a->Window)
	{	if (soap_out_PointerTott__Rectangle(soap, "tt:Window", -1, &a->Window, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:Window"))
		return soap->error;
	if (soap_out_float(soap, "tt:MinExposureTime", -1, &a->MinExposureTime, ""))
		return soap->error;
	if (soap_out_float(soap, "tt:MaxExposureTime", -1, &a->MaxExposureTime, ""))
		return soap->error;
	if (soap_out_float(soap, "tt:MinGain", -1, &a->MinGain, ""))
		return soap->error;
	if (soap_out_float(soap, "tt:MaxGain", -1, &a->MaxGain, ""))
		return soap->error;
	if (soap_out_float(soap, "tt:MinIris", -1, &a->MinIris, ""))
		return soap->error;
	if (soap_out_float(soap, "tt:MaxIris", -1, &a->MaxIris, ""))
		return soap->error;
	if (soap_out_float(soap, "tt:ExposureTime", -1, &a->ExposureTime, ""))
		return soap->error;
	if (soap_out_float(soap, "tt:Gain", -1, &a->Gain, ""))
		return soap->error;
	if (soap_out_float(soap, "tt:Iris", -1, &a->Iris, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__Exposure * SOAP_FMAC4 soap_in_tt__Exposure(struct soap *soap, const char *tag, struct tt__Exposure *a, const char *type)
{
	size_t soap_flag_Mode = 1;
	size_t soap_flag_Priority = 1;
	size_t soap_flag_Window = 1;
	size_t soap_flag_MinExposureTime = 1;
	size_t soap_flag_MaxExposureTime = 1;
	size_t soap_flag_MinGain = 1;
	size_t soap_flag_MaxGain = 1;
	size_t soap_flag_MinIris = 1;
	size_t soap_flag_MaxIris = 1;
	size_t soap_flag_ExposureTime = 1;
	size_t soap_flag_Gain = 1;
	size_t soap_flag_Iris = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__Exposure *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Exposure, sizeof(struct tt__Exposure), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__Exposure(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Mode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_tt__ExposureMode(soap, "tt:Mode", &a->Mode, "tt:ExposureMode"))
				{	soap_flag_Mode--;
					continue;
				}
			if (soap_flag_Priority && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_tt__ExposurePriority(soap, "tt:Priority", &a->Priority, "tt:ExposurePriority"))
				{	soap_flag_Priority--;
					continue;
				}
			if (soap_flag_Window && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__Rectangle(soap, "tt:Window", &a->Window, "tt:Rectangle"))
				{	soap_flag_Window--;
					continue;
				}
			if (soap_flag_MinExposureTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_float(soap, "tt:MinExposureTime", &a->MinExposureTime, "xsd:float"))
				{	soap_flag_MinExposureTime--;
					continue;
				}
			if (soap_flag_MaxExposureTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_float(soap, "tt:MaxExposureTime", &a->MaxExposureTime, "xsd:float"))
				{	soap_flag_MaxExposureTime--;
					continue;
				}
			if (soap_flag_MinGain && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_float(soap, "tt:MinGain", &a->MinGain, "xsd:float"))
				{	soap_flag_MinGain--;
					continue;
				}
			if (soap_flag_MaxGain && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_float(soap, "tt:MaxGain", &a->MaxGain, "xsd:float"))
				{	soap_flag_MaxGain--;
					continue;
				}
			if (soap_flag_MinIris && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_float(soap, "tt:MinIris", &a->MinIris, "xsd:float"))
				{	soap_flag_MinIris--;
					continue;
				}
			if (soap_flag_MaxIris && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_float(soap, "tt:MaxIris", &a->MaxIris, "xsd:float"))
				{	soap_flag_MaxIris--;
					continue;
				}
			if (soap_flag_ExposureTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_float(soap, "tt:ExposureTime", &a->ExposureTime, "xsd:float"))
				{	soap_flag_ExposureTime--;
					continue;
				}
			if (soap_flag_Gain && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_float(soap, "tt:Gain", &a->Gain, "xsd:float"))
				{	soap_flag_Gain--;
					continue;
				}
			if (soap_flag_Iris && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_float(soap, "tt:Iris", &a->Iris, "xsd:float"))
				{	soap_flag_Iris--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__Exposure *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Exposure, 0, sizeof(struct tt__Exposure), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Mode > 0 || soap_flag_Priority > 0 || soap_flag_Window > 0 || soap_flag_MinExposureTime > 0 || soap_flag_MaxExposureTime > 0 || soap_flag_MinGain > 0 || soap_flag_MaxGain > 0 || soap_flag_MinIris > 0 || soap_flag_MaxIris > 0 || soap_flag_ExposureTime > 0 || soap_flag_Gain > 0 || soap_flag_Iris > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Exposure(struct soap *soap, const struct tt__Exposure *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__Exposure);
	if (soap_out_tt__Exposure(soap, tag?tag:"tt:Exposure", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Exposure * SOAP_FMAC4 soap_get_tt__Exposure(struct soap *soap, struct tt__Exposure *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Exposure(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__BacklightCompensation(struct soap *soap, struct tt__BacklightCompensation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__BacklightCompensationMode(soap, &a->Mode);
	soap_default_float(soap, &a->Level);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__BacklightCompensation(struct soap *soap, const struct tt__BacklightCompensation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->Mode, SOAP_TYPE_tt__BacklightCompensationMode);
	soap_embedded(soap, &a->Level, SOAP_TYPE_float);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__BacklightCompensation(struct soap *soap, const char *tag, int id, const struct tt__BacklightCompensation *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__BacklightCompensation), type))
		return soap->error;
	if (soap_out_tt__BacklightCompensationMode(soap, "tt:Mode", -1, &a->Mode, ""))
		return soap->error;
	if (soap_out_float(soap, "tt:Level", -1, &a->Level, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__BacklightCompensation * SOAP_FMAC4 soap_in_tt__BacklightCompensation(struct soap *soap, const char *tag, struct tt__BacklightCompensation *a, const char *type)
{
	size_t soap_flag_Mode = 1;
	size_t soap_flag_Level = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__BacklightCompensation *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__BacklightCompensation, sizeof(struct tt__BacklightCompensation), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__BacklightCompensation(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Mode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_tt__BacklightCompensationMode(soap, "tt:Mode", &a->Mode, "tt:BacklightCompensationMode"))
				{	soap_flag_Mode--;
					continue;
				}
			if (soap_flag_Level && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_float(soap, "tt:Level", &a->Level, "xsd:float"))
				{	soap_flag_Level--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__BacklightCompensation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__BacklightCompensation, 0, sizeof(struct tt__BacklightCompensation), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Mode > 0 || soap_flag_Level > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__BacklightCompensation(struct soap *soap, const struct tt__BacklightCompensation *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__BacklightCompensation);
	if (soap_out_tt__BacklightCompensation(soap, tag?tag:"tt:BacklightCompensation", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__BacklightCompensation * SOAP_FMAC4 soap_get_tt__BacklightCompensation(struct soap *soap, struct tt__BacklightCompensation *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__BacklightCompensation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__ImagingSettings(struct soap *soap, struct tt__ImagingSettings *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->BacklightCompensation = NULL;
	a->Brightness = NULL;
	a->ColorSaturation = NULL;
	a->Contrast = NULL;
	a->Exposure = NULL;
	a->Focus = NULL;
	a->IrCutFilter = NULL;
	a->Sharpness = NULL;
	a->WideDynamicRange = NULL;
	a->WhiteBalance = NULL;
	a->Extension = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__ImagingSettings(struct soap *soap, const struct tt__ImagingSettings *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTott__BacklightCompensation(soap, &a->BacklightCompensation);
	soap_serialize_PointerTofloat(soap, &a->Brightness);
	soap_serialize_PointerTofloat(soap, &a->ColorSaturation);
	soap_serialize_PointerTofloat(soap, &a->Contrast);
	soap_serialize_PointerTott__Exposure(soap, &a->Exposure);
	soap_serialize_PointerTott__FocusConfiguration(soap, &a->Focus);
	soap_serialize_PointerTott__IrCutFilterMode(soap, &a->IrCutFilter);
	soap_serialize_PointerTofloat(soap, &a->Sharpness);
	soap_serialize_PointerTott__WideDynamicRange(soap, &a->WideDynamicRange);
	soap_serialize_PointerTott__WhiteBalance(soap, &a->WhiteBalance);
	soap_serialize_PointerTott__ImagingSettingsExtension(soap, &a->Extension);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ImagingSettings(struct soap *soap, const char *tag, int id, const struct tt__ImagingSettings *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ImagingSettings), type))
		return soap->error;
	if (soap_out_PointerTott__BacklightCompensation(soap, "tt:BacklightCompensation", -1, &a->BacklightCompensation, ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "tt:Brightness", -1, &a->Brightness, ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "tt:ColorSaturation", -1, &a->ColorSaturation, ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "tt:Contrast", -1, &a->Contrast, ""))
		return soap->error;
	if (soap_out_PointerTott__Exposure(soap, "tt:Exposure", -1, &a->Exposure, ""))
		return soap->error;
	if (soap_out_PointerTott__FocusConfiguration(soap, "tt:Focus", -1, &a->Focus, ""))
		return soap->error;
	if (soap_out_PointerTott__IrCutFilterMode(soap, "tt:IrCutFilter", -1, &a->IrCutFilter, ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "tt:Sharpness", -1, &a->Sharpness, ""))
		return soap->error;
	if (soap_out_PointerTott__WideDynamicRange(soap, "tt:WideDynamicRange", -1, &a->WideDynamicRange, ""))
		return soap->error;
	if (soap_out_PointerTott__WhiteBalance(soap, "tt:WhiteBalance", -1, &a->WhiteBalance, ""))
		return soap->error;
	if (soap_out_PointerTott__ImagingSettingsExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__ImagingSettings * SOAP_FMAC4 soap_in_tt__ImagingSettings(struct soap *soap, const char *tag, struct tt__ImagingSettings *a, const char *type)
{
	size_t soap_flag_BacklightCompensation = 1;
	size_t soap_flag_Brightness = 1;
	size_t soap_flag_ColorSaturation = 1;
	size_t soap_flag_Contrast = 1;
	size_t soap_flag_Exposure = 1;
	size_t soap_flag_Focus = 1;
	size_t soap_flag_IrCutFilter = 1;
	size_t soap_flag_Sharpness = 1;
	size_t soap_flag_WideDynamicRange = 1;
	size_t soap_flag_WhiteBalance = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__ImagingSettings *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ImagingSettings, sizeof(struct tt__ImagingSettings), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__ImagingSettings(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_BacklightCompensation && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__BacklightCompensation(soap, "tt:BacklightCompensation", &a->BacklightCompensation, "tt:BacklightCompensation"))
				{	soap_flag_BacklightCompensation--;
					continue;
				}
			if (soap_flag_Brightness && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofloat(soap, "tt:Brightness", &a->Brightness, "xsd:float"))
				{	soap_flag_Brightness--;
					continue;
				}
			if (soap_flag_ColorSaturation && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofloat(soap, "tt:ColorSaturation", &a->ColorSaturation, "xsd:float"))
				{	soap_flag_ColorSaturation--;
					continue;
				}
			if (soap_flag_Contrast && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofloat(soap, "tt:Contrast", &a->Contrast, "xsd:float"))
				{	soap_flag_Contrast--;
					continue;
				}
			if (soap_flag_Exposure && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__Exposure(soap, "tt:Exposure", &a->Exposure, "tt:Exposure"))
				{	soap_flag_Exposure--;
					continue;
				}
			if (soap_flag_Focus && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__FocusConfiguration(soap, "tt:Focus", &a->Focus, "tt:FocusConfiguration"))
				{	soap_flag_Focus--;
					continue;
				}
			if (soap_flag_IrCutFilter && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IrCutFilterMode(soap, "tt:IrCutFilter", &a->IrCutFilter, "tt:IrCutFilterMode"))
				{	soap_flag_IrCutFilter--;
					continue;
				}
			if (soap_flag_Sharpness && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofloat(soap, "tt:Sharpness", &a->Sharpness, "xsd:float"))
				{	soap_flag_Sharpness--;
					continue;
				}
			if (soap_flag_WideDynamicRange && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__WideDynamicRange(soap, "tt:WideDynamicRange", &a->WideDynamicRange, "tt:WideDynamicRange"))
				{	soap_flag_WideDynamicRange--;
					continue;
				}
			if (soap_flag_WhiteBalance && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__WhiteBalance(soap, "tt:WhiteBalance", &a->WhiteBalance, "tt:WhiteBalance"))
				{	soap_flag_WhiteBalance--;
					continue;
				}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__ImagingSettingsExtension(soap, "tt:Extension", &a->Extension, "tt:ImagingSettingsExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__ImagingSettings *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ImagingSettings, 0, sizeof(struct tt__ImagingSettings), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ImagingSettings(struct soap *soap, const struct tt__ImagingSettings *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__ImagingSettings);
	if (soap_out_tt__ImagingSettings(soap, tag?tag:"tt:ImagingSettings", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ImagingSettings * SOAP_FMAC4 soap_get_tt__ImagingSettings(struct soap *soap, struct tt__ImagingSettings *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ImagingSettings(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__FocusConfiguration(struct soap *soap, struct tt__FocusConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__AutoFocusMode(soap, &a->AutoFocusMode);
	soap_default_float(soap, &a->DefaultSpeed);
	soap_default_float(soap, &a->NearLimit);
	soap_default_float(soap, &a->FarLimit);
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__FocusConfiguration(struct soap *soap, const struct tt__FocusConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->AutoFocusMode, SOAP_TYPE_tt__AutoFocusMode);
	soap_embedded(soap, &a->DefaultSpeed, SOAP_TYPE_float);
	soap_embedded(soap, &a->NearLimit, SOAP_TYPE_float);
	soap_embedded(soap, &a->FarLimit, SOAP_TYPE_float);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__FocusConfiguration(struct soap *soap, const char *tag, int id, const struct tt__FocusConfiguration *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__FocusConfiguration), type))
		return soap->error;
	if (soap_out_tt__AutoFocusMode(soap, "tt:AutoFocusMode", -1, &a->AutoFocusMode, ""))
		return soap->error;
	if (soap_out_float(soap, "tt:DefaultSpeed", -1, &a->DefaultSpeed, ""))
		return soap->error;
	if (soap_out_float(soap, "tt:NearLimit", -1, &a->NearLimit, ""))
		return soap->error;
	if (soap_out_float(soap, "tt:FarLimit", -1, &a->FarLimit, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__FocusConfiguration * SOAP_FMAC4 soap_in_tt__FocusConfiguration(struct soap *soap, const char *tag, struct tt__FocusConfiguration *a, const char *type)
{
	size_t soap_flag_AutoFocusMode = 1;
	size_t soap_flag_DefaultSpeed = 1;
	size_t soap_flag_NearLimit = 1;
	size_t soap_flag_FarLimit = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__FocusConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__FocusConfiguration, sizeof(struct tt__FocusConfiguration), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__FocusConfiguration(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_AutoFocusMode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_tt__AutoFocusMode(soap, "tt:AutoFocusMode", &a->AutoFocusMode, "tt:AutoFocusMode"))
				{	soap_flag_AutoFocusMode--;
					continue;
				}
			if (soap_flag_DefaultSpeed && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_float(soap, "tt:DefaultSpeed", &a->DefaultSpeed, "xsd:float"))
				{	soap_flag_DefaultSpeed--;
					continue;
				}
			if (soap_flag_NearLimit && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_float(soap, "tt:NearLimit", &a->NearLimit, "xsd:float"))
				{	soap_flag_NearLimit--;
					continue;
				}
			if (soap_flag_FarLimit && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_float(soap, "tt:FarLimit", &a->FarLimit, "xsd:float"))
				{	soap_flag_FarLimit--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__FocusConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__FocusConfiguration, 0, sizeof(struct tt__FocusConfiguration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_AutoFocusMode > 0 || soap_flag_DefaultSpeed > 0 || soap_flag_NearLimit > 0 || soap_flag_FarLimit > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__FocusConfiguration(struct soap *soap, const struct tt__FocusConfiguration *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__FocusConfiguration);
	if (soap_out_tt__FocusConfiguration(soap, tag?tag:"tt:FocusConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__FocusConfiguration * SOAP_FMAC4 soap_get_tt__FocusConfiguration(struct soap *soap, struct tt__FocusConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__FocusConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__FocusStatus(struct soap *soap, struct tt__FocusStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_float(soap, &a->Position);
	soap_default_tt__MoveStatus(soap, &a->MoveStatus);
	soap_default_string(soap, &a->Error);
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__FocusStatus(struct soap *soap, const struct tt__FocusStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->Position, SOAP_TYPE_float);
	soap_embedded(soap, &a->MoveStatus, SOAP_TYPE_tt__MoveStatus);
	soap_serialize_string(soap, &a->Error);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__FocusStatus(struct soap *soap, const char *tag, int id, const struct tt__FocusStatus *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__FocusStatus), type))
		return soap->error;
	if (soap_out_float(soap, "tt:Position", -1, &a->Position, ""))
		return soap->error;
	if (soap_out_tt__MoveStatus(soap, "tt:MoveStatus", -1, &a->MoveStatus, ""))
		return soap->error;
	if (a->Error)
	{	if (soap_out_string(soap, "tt:Error", -1, &a->Error, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:Error"))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__FocusStatus * SOAP_FMAC4 soap_in_tt__FocusStatus(struct soap *soap, const char *tag, struct tt__FocusStatus *a, const char *type)
{
	size_t soap_flag_Position = 1;
	size_t soap_flag_MoveStatus = 1;
	size_t soap_flag_Error = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__FocusStatus *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__FocusStatus, sizeof(struct tt__FocusStatus), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__FocusStatus(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Position && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_float(soap, "tt:Position", &a->Position, "xsd:float"))
				{	soap_flag_Position--;
					continue;
				}
			if (soap_flag_MoveStatus && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_tt__MoveStatus(soap, "tt:MoveStatus", &a->MoveStatus, "tt:MoveStatus"))
				{	soap_flag_MoveStatus--;
					continue;
				}
			if (soap_flag_Error && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "tt:Error", &a->Error, "xsd:string"))
				{	soap_flag_Error--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__FocusStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__FocusStatus, 0, sizeof(struct tt__FocusStatus), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Position > 0 || soap_flag_MoveStatus > 0 || soap_flag_Error > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__FocusStatus(struct soap *soap, const struct tt__FocusStatus *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__FocusStatus);
	if (soap_out_tt__FocusStatus(soap, tag?tag:"tt:FocusStatus", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__FocusStatus * SOAP_FMAC4 soap_get_tt__FocusStatus(struct soap *soap, struct tt__FocusStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__FocusStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__ImagingStatus(struct soap *soap, struct tt__ImagingStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->FocusStatus = NULL;
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__ImagingStatus(struct soap *soap, const struct tt__ImagingStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTott__FocusStatus(soap, &a->FocusStatus);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ImagingStatus(struct soap *soap, const char *tag, int id, const struct tt__ImagingStatus *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ImagingStatus), type))
		return soap->error;
	if (a->FocusStatus)
	{	if (soap_out_PointerTott__FocusStatus(soap, "tt:FocusStatus", -1, &a->FocusStatus, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:FocusStatus"))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__ImagingStatus * SOAP_FMAC4 soap_in_tt__ImagingStatus(struct soap *soap, const char *tag, struct tt__ImagingStatus *a, const char *type)
{
	size_t soap_flag_FocusStatus = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__ImagingStatus *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ImagingStatus, sizeof(struct tt__ImagingStatus), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__ImagingStatus(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_FocusStatus && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__FocusStatus(soap, "tt:FocusStatus", &a->FocusStatus, "tt:FocusStatus"))
				{	soap_flag_FocusStatus--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__ImagingStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ImagingStatus, 0, sizeof(struct tt__ImagingStatus), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_FocusStatus > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ImagingStatus(struct soap *soap, const struct tt__ImagingStatus *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__ImagingStatus);
	if (soap_out_tt__ImagingStatus(soap, tag?tag:"tt:ImagingStatus", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ImagingStatus * SOAP_FMAC4 soap_get_tt__ImagingStatus(struct soap *soap, struct tt__ImagingStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ImagingStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__PTZPreset(struct soap *soap, struct tt__PTZPreset *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__Name(soap, &a->Name);
	a->PTZPosition = NULL;
	soap_default_tt__ReferenceToken(soap, &a->token);
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__PTZPreset(struct soap *soap, const struct tt__PTZPreset *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_tt__Name(soap, &a->Name);
	soap_serialize_PointerTott__PTZVector(soap, &a->PTZPosition);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZPreset(struct soap *soap, const char *tag, int id, const struct tt__PTZPreset *a, const char *type)
{
	if (a->token)
		soap_set_attr(soap, "token", a->token, 1);
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTZPreset), type))
		return soap->error;
	if (soap_out_tt__Name(soap, "tt:Name", -1, &a->Name, ""))
		return soap->error;
	if (soap_out_PointerTott__PTZVector(soap, "tt:PTZPosition", -1, &a->PTZPosition, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__PTZPreset * SOAP_FMAC4 soap_in_tt__PTZPreset(struct soap *soap, const char *tag, struct tt__PTZPreset *a, const char *type)
{
	size_t soap_flag_Name = 1;
	size_t soap_flag_PTZPosition = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__PTZPreset *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZPreset, sizeof(struct tt__PTZPreset), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__PTZPreset(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "token", 0), &a->token, -1, 64))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__Name(soap, "tt:Name", &a->Name, "tt:Name"))
				{	soap_flag_Name--;
					continue;
				}
			if (soap_flag_PTZPosition && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__PTZVector(soap, "tt:PTZPosition", &a->PTZPosition, "tt:PTZVector"))
				{	soap_flag_PTZPosition--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__PTZPreset *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZPreset, 0, sizeof(struct tt__PTZPreset), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__PTZPreset(struct soap *soap, const struct tt__PTZPreset *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__PTZPreset);
	if (soap_out_tt__PTZPreset(soap, tag?tag:"tt:PTZPreset", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PTZPreset * SOAP_FMAC4 soap_get_tt__PTZPreset(struct soap *soap, struct tt__PTZPreset *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTZPreset(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__PTZMoveStatus(struct soap *soap, struct tt__PTZMoveStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->PanTilt = NULL;
	a->Zoom = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__PTZMoveStatus(struct soap *soap, const struct tt__PTZMoveStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTott__MoveStatus(soap, &a->PanTilt);
	soap_serialize_PointerTott__MoveStatus(soap, &a->Zoom);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZMoveStatus(struct soap *soap, const char *tag, int id, const struct tt__PTZMoveStatus *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTZMoveStatus), type))
		return soap->error;
	if (soap_out_PointerTott__MoveStatus(soap, "tt:PanTilt", -1, &a->PanTilt, ""))
		return soap->error;
	if (soap_out_PointerTott__MoveStatus(soap, "tt:Zoom", -1, &a->Zoom, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__PTZMoveStatus * SOAP_FMAC4 soap_in_tt__PTZMoveStatus(struct soap *soap, const char *tag, struct tt__PTZMoveStatus *a, const char *type)
{
	size_t soap_flag_PanTilt = 1;
	size_t soap_flag_Zoom = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__PTZMoveStatus *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZMoveStatus, sizeof(struct tt__PTZMoveStatus), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__PTZMoveStatus(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_PanTilt && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__MoveStatus(soap, "tt:PanTilt", &a->PanTilt, "tt:MoveStatus"))
				{	soap_flag_PanTilt--;
					continue;
				}
			if (soap_flag_Zoom && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__MoveStatus(soap, "tt:Zoom", &a->Zoom, "tt:MoveStatus"))
				{	soap_flag_Zoom--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__PTZMoveStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZMoveStatus, 0, sizeof(struct tt__PTZMoveStatus), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__PTZMoveStatus(struct soap *soap, const struct tt__PTZMoveStatus *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__PTZMoveStatus);
	if (soap_out_tt__PTZMoveStatus(soap, tag?tag:"tt:PTZMoveStatus", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PTZMoveStatus * SOAP_FMAC4 soap_get_tt__PTZMoveStatus(struct soap *soap, struct tt__PTZMoveStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTZMoveStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__PTZStatus(struct soap *soap, struct tt__PTZStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Position = NULL;
	a->MoveStatus = NULL;
	soap_default_string(soap, &a->Error);
	soap_default_time(soap, &a->UtcTime);
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__PTZStatus(struct soap *soap, const struct tt__PTZStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTott__PTZVector(soap, &a->Position);
	soap_serialize_PointerTott__PTZMoveStatus(soap, &a->MoveStatus);
	soap_serialize_string(soap, &a->Error);
	soap_embedded(soap, &a->UtcTime, SOAP_TYPE_time);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZStatus(struct soap *soap, const char *tag, int id, const struct tt__PTZStatus *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTZStatus), type))
		return soap->error;
	if (soap_out_PointerTott__PTZVector(soap, "tt:Position", -1, &a->Position, ""))
		return soap->error;
	if (soap_out_PointerTott__PTZMoveStatus(soap, "tt:MoveStatus", -1, &a->MoveStatus, ""))
		return soap->error;
	if (soap_out_string(soap, "tt:Error", -1, &a->Error, ""))
		return soap->error;
	if (soap_out_time(soap, "tt:UtcTime", -1, &a->UtcTime, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__PTZStatus * SOAP_FMAC4 soap_in_tt__PTZStatus(struct soap *soap, const char *tag, struct tt__PTZStatus *a, const char *type)
{
	size_t soap_flag_Position = 1;
	size_t soap_flag_MoveStatus = 1;
	size_t soap_flag_Error = 1;
	size_t soap_flag_UtcTime = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__PTZStatus *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZStatus, sizeof(struct tt__PTZStatus), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__PTZStatus(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Position && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__PTZVector(soap, "tt:Position", &a->Position, "tt:PTZVector"))
				{	soap_flag_Position--;
					continue;
				}
			if (soap_flag_MoveStatus && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__PTZMoveStatus(soap, "tt:MoveStatus", &a->MoveStatus, "tt:PTZMoveStatus"))
				{	soap_flag_MoveStatus--;
					continue;
				}
			if (soap_flag_Error && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "tt:Error", &a->Error, "xsd:string"))
				{	soap_flag_Error--;
					continue;
				}
			if (soap_flag_UtcTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "tt:UtcTime", &a->UtcTime, "xsd:dateTime"))
				{	soap_flag_UtcTime--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__PTZStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZStatus, 0, sizeof(struct tt__PTZStatus), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_UtcTime > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__PTZStatus(struct soap *soap, const struct tt__PTZStatus *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__PTZStatus);
	if (soap_out_tt__PTZStatus(soap, tag?tag:"tt:PTZStatus", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PTZStatus * SOAP_FMAC4 soap_get_tt__PTZStatus(struct soap *soap, struct tt__PTZStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTZStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__PTZSpeed(struct soap *soap, struct tt__PTZSpeed *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->PanTilt = NULL;
	a->Zoom = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__PTZSpeed(struct soap *soap, const struct tt__PTZSpeed *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTott__Vector2D(soap, &a->PanTilt);
	soap_serialize_PointerTott__Vector1D(soap, &a->Zoom);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZSpeed(struct soap *soap, const char *tag, int id, const struct tt__PTZSpeed *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTZSpeed), type))
		return soap->error;
	if (soap_out_PointerTott__Vector2D(soap, "tt:PanTilt", -1, &a->PanTilt, ""))
		return soap->error;
	if (soap_out_PointerTott__Vector1D(soap, "tt:Zoom", -1, &a->Zoom, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__PTZSpeed * SOAP_FMAC4 soap_in_tt__PTZSpeed(struct soap *soap, const char *tag, struct tt__PTZSpeed *a, const char *type)
{
	size_t soap_flag_PanTilt = 1;
	size_t soap_flag_Zoom = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__PTZSpeed *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZSpeed, sizeof(struct tt__PTZSpeed), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__PTZSpeed(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_PanTilt && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__Vector2D(soap, "tt:PanTilt", &a->PanTilt, "tt:Vector2D"))
				{	soap_flag_PanTilt--;
					continue;
				}
			if (soap_flag_Zoom && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__Vector1D(soap, "tt:Zoom", &a->Zoom, "tt:Vector1D"))
				{	soap_flag_Zoom--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__PTZSpeed *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZSpeed, 0, sizeof(struct tt__PTZSpeed), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__PTZSpeed(struct soap *soap, const struct tt__PTZSpeed *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__PTZSpeed);
	if (soap_out_tt__PTZSpeed(soap, tag?tag:"tt:PTZSpeed", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PTZSpeed * SOAP_FMAC4 soap_get_tt__PTZSpeed(struct soap *soap, struct tt__PTZSpeed *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTZSpeed(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__PTZVector(struct soap *soap, struct tt__PTZVector *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->PanTilt = NULL;
	a->Zoom = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__PTZVector(struct soap *soap, const struct tt__PTZVector *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTott__Vector2D(soap, &a->PanTilt);
	soap_serialize_PointerTott__Vector1D(soap, &a->Zoom);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZVector(struct soap *soap, const char *tag, int id, const struct tt__PTZVector *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTZVector), type))
		return soap->error;
	if (soap_out_PointerTott__Vector2D(soap, "tt:PanTilt", -1, &a->PanTilt, ""))
		return soap->error;
	if (soap_out_PointerTott__Vector1D(soap, "tt:Zoom", -1, &a->Zoom, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__PTZVector * SOAP_FMAC4 soap_in_tt__PTZVector(struct soap *soap, const char *tag, struct tt__PTZVector *a, const char *type)
{
	size_t soap_flag_PanTilt = 1;
	size_t soap_flag_Zoom = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__PTZVector *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZVector, sizeof(struct tt__PTZVector), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__PTZVector(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_PanTilt && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__Vector2D(soap, "tt:PanTilt", &a->PanTilt, "tt:Vector2D"))
				{	soap_flag_PanTilt--;
					continue;
				}
			if (soap_flag_Zoom && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__Vector1D(soap, "tt:Zoom", &a->Zoom, "tt:Vector1D"))
				{	soap_flag_Zoom--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__PTZVector *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZVector, 0, sizeof(struct tt__PTZVector), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__PTZVector(struct soap *soap, const struct tt__PTZVector *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__PTZVector);
	if (soap_out_tt__PTZVector(soap, tag?tag:"tt:PTZVector", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PTZVector * SOAP_FMAC4 soap_get_tt__PTZVector(struct soap *soap, struct tt__PTZVector *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTZVector(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__Vector1D(struct soap *soap, struct tt__Vector1D *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_float(soap, &a->x);
	soap_default_string(soap, &a->space);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__Vector1D(struct soap *soap, const struct tt__Vector1D *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Vector1D(struct soap *soap, const char *tag, int id, const struct tt__Vector1D *a, const char *type)
{
	soap_set_attr(soap, "x", soap_float2s(soap, a->x), 1);
	if (a->space)
		soap_set_attr(soap, "space", a->space, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Vector1D), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__Vector1D * SOAP_FMAC4 soap_in_tt__Vector1D(struct soap *soap, const char *tag, struct tt__Vector1D *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__Vector1D *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Vector1D, sizeof(struct tt__Vector1D), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__Vector1D(soap, a);
	if (soap_s2float(soap, soap_attr_value(soap, "x", 1), &a->x))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "space", 0), &a->space, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__Vector1D *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Vector1D, 0, sizeof(struct tt__Vector1D), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Vector1D(struct soap *soap, const struct tt__Vector1D *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__Vector1D);
	if (soap_out_tt__Vector1D(soap, tag?tag:"tt:Vector1D", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Vector1D * SOAP_FMAC4 soap_get_tt__Vector1D(struct soap *soap, struct tt__Vector1D *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Vector1D(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__Vector2D(struct soap *soap, struct tt__Vector2D *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_float(soap, &a->x);
	soap_default_float(soap, &a->y);
	soap_default_string(soap, &a->space);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__Vector2D(struct soap *soap, const struct tt__Vector2D *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Vector2D(struct soap *soap, const char *tag, int id, const struct tt__Vector2D *a, const char *type)
{
	soap_set_attr(soap, "x", soap_float2s(soap, a->x), 1);
	soap_set_attr(soap, "y", soap_float2s(soap, a->y), 1);
	if (a->space)
		soap_set_attr(soap, "space", a->space, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Vector2D), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__Vector2D * SOAP_FMAC4 soap_in_tt__Vector2D(struct soap *soap, const char *tag, struct tt__Vector2D *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__Vector2D *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Vector2D, sizeof(struct tt__Vector2D), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__Vector2D(soap, a);
	if (soap_s2float(soap, soap_attr_value(soap, "x", 1), &a->x))
		return NULL;
	if (soap_s2float(soap, soap_attr_value(soap, "y", 1), &a->y))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "space", 0), &a->space, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__Vector2D *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Vector2D, 0, sizeof(struct tt__Vector2D), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Vector2D(struct soap *soap, const struct tt__Vector2D *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__Vector2D);
	if (soap_out_tt__Vector2D(soap, tag?tag:"tt:Vector2D", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Vector2D * SOAP_FMAC4 soap_get_tt__Vector2D(struct soap *soap, struct tt__Vector2D *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Vector2D(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__PTZSpacesExtension(struct soap *soap, struct tt__PTZSpacesExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__PTZSpacesExtension(struct soap *soap, const struct tt__PTZSpacesExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZSpacesExtension(struct soap *soap, const char *tag, int id, const struct tt__PTZSpacesExtension *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTZSpacesExtension), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__PTZSpacesExtension * SOAP_FMAC4 soap_in_tt__PTZSpacesExtension(struct soap *soap, const char *tag, struct tt__PTZSpacesExtension *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__PTZSpacesExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZSpacesExtension, sizeof(struct tt__PTZSpacesExtension), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__PTZSpacesExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__PTZSpacesExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZSpacesExtension, 0, sizeof(struct tt__PTZSpacesExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__PTZSpacesExtension(struct soap *soap, const struct tt__PTZSpacesExtension *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__PTZSpacesExtension);
	if (soap_out_tt__PTZSpacesExtension(soap, tag?tag:"tt:PTZSpacesExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PTZSpacesExtension * SOAP_FMAC4 soap_get_tt__PTZSpacesExtension(struct soap *soap, struct tt__PTZSpacesExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTZSpacesExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__Space1DDescription(struct soap *soap, struct tt__Space1DDescription *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->URI);
	a->XRange = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__Space1DDescription(struct soap *soap, const struct tt__Space1DDescription *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->URI);
	soap_serialize_PointerTott__FloatRange(soap, &a->XRange);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Space1DDescription(struct soap *soap, const char *tag, int id, const struct tt__Space1DDescription *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Space1DDescription), type))
		return soap->error;
	if (a->URI)
	{	if (soap_out_string(soap, "tt:URI", -1, &a->URI, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:URI"))
		return soap->error;
	if (a->XRange)
	{	if (soap_out_PointerTott__FloatRange(soap, "tt:XRange", -1, &a->XRange, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:XRange"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__Space1DDescription * SOAP_FMAC4 soap_in_tt__Space1DDescription(struct soap *soap, const char *tag, struct tt__Space1DDescription *a, const char *type)
{
	size_t soap_flag_URI = 1;
	size_t soap_flag_XRange = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__Space1DDescription *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Space1DDescription, sizeof(struct tt__Space1DDescription), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__Space1DDescription(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_URI && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "tt:URI", &a->URI, "xsd:string"))
				{	soap_flag_URI--;
					continue;
				}
			if (soap_flag_XRange && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__FloatRange(soap, "tt:XRange", &a->XRange, "tt:FloatRange"))
				{	soap_flag_XRange--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__Space1DDescription *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Space1DDescription, 0, sizeof(struct tt__Space1DDescription), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_URI > 0 || soap_flag_XRange > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Space1DDescription(struct soap *soap, const struct tt__Space1DDescription *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__Space1DDescription);
	if (soap_out_tt__Space1DDescription(soap, tag?tag:"tt:Space1DDescription", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Space1DDescription * SOAP_FMAC4 soap_get_tt__Space1DDescription(struct soap *soap, struct tt__Space1DDescription *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Space1DDescription(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__ZoomLimits(struct soap *soap, struct tt__ZoomLimits *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Range = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__ZoomLimits(struct soap *soap, const struct tt__ZoomLimits *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTott__Space1DDescription(soap, &a->Range);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ZoomLimits(struct soap *soap, const char *tag, int id, const struct tt__ZoomLimits *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ZoomLimits), type))
		return soap->error;
	if (a->Range)
	{	if (soap_out_PointerTott__Space1DDescription(soap, "tt:Range", -1, &a->Range, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:Range"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__ZoomLimits * SOAP_FMAC4 soap_in_tt__ZoomLimits(struct soap *soap, const char *tag, struct tt__ZoomLimits *a, const char *type)
{
	size_t soap_flag_Range = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__ZoomLimits *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ZoomLimits, sizeof(struct tt__ZoomLimits), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__ZoomLimits(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Range && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__Space1DDescription(soap, "tt:Range", &a->Range, "tt:Space1DDescription"))
				{	soap_flag_Range--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__ZoomLimits *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ZoomLimits, 0, sizeof(struct tt__ZoomLimits), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Range > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ZoomLimits(struct soap *soap, const struct tt__ZoomLimits *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__ZoomLimits);
	if (soap_out_tt__ZoomLimits(soap, tag?tag:"tt:ZoomLimits", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ZoomLimits * SOAP_FMAC4 soap_get_tt__ZoomLimits(struct soap *soap, struct tt__ZoomLimits *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ZoomLimits(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__Space2DDescription(struct soap *soap, struct tt__Space2DDescription *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->URI);
	a->XRange = NULL;
	a->YRange = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__Space2DDescription(struct soap *soap, const struct tt__Space2DDescription *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->URI);
	soap_serialize_PointerTott__FloatRange(soap, &a->XRange);
	soap_serialize_PointerTott__FloatRange(soap, &a->YRange);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Space2DDescription(struct soap *soap, const char *tag, int id, const struct tt__Space2DDescription *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Space2DDescription), type))
		return soap->error;
	if (a->URI)
	{	if (soap_out_string(soap, "tt:URI", -1, &a->URI, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:URI"))
		return soap->error;
	if (a->XRange)
	{	if (soap_out_PointerTott__FloatRange(soap, "tt:XRange", -1, &a->XRange, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:XRange"))
		return soap->error;
	if (a->YRange)
	{	if (soap_out_PointerTott__FloatRange(soap, "tt:YRange", -1, &a->YRange, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:YRange"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__Space2DDescription * SOAP_FMAC4 soap_in_tt__Space2DDescription(struct soap *soap, const char *tag, struct tt__Space2DDescription *a, const char *type)
{
	size_t soap_flag_URI = 1;
	size_t soap_flag_XRange = 1;
	size_t soap_flag_YRange = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__Space2DDescription *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Space2DDescription, sizeof(struct tt__Space2DDescription), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__Space2DDescription(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_URI && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "tt:URI", &a->URI, "xsd:string"))
				{	soap_flag_URI--;
					continue;
				}
			if (soap_flag_XRange && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__FloatRange(soap, "tt:XRange", &a->XRange, "tt:FloatRange"))
				{	soap_flag_XRange--;
					continue;
				}
			if (soap_flag_YRange && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__FloatRange(soap, "tt:YRange", &a->YRange, "tt:FloatRange"))
				{	soap_flag_YRange--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__Space2DDescription *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Space2DDescription, 0, sizeof(struct tt__Space2DDescription), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_URI > 0 || soap_flag_XRange > 0 || soap_flag_YRange > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Space2DDescription(struct soap *soap, const struct tt__Space2DDescription *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__Space2DDescription);
	if (soap_out_tt__Space2DDescription(soap, tag?tag:"tt:Space2DDescription", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Space2DDescription * SOAP_FMAC4 soap_get_tt__Space2DDescription(struct soap *soap, struct tt__Space2DDescription *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Space2DDescription(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__PanTiltLimits(struct soap *soap, struct tt__PanTiltLimits *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Range = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__PanTiltLimits(struct soap *soap, const struct tt__PanTiltLimits *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTott__Space2DDescription(soap, &a->Range);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PanTiltLimits(struct soap *soap, const char *tag, int id, const struct tt__PanTiltLimits *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PanTiltLimits), type))
		return soap->error;
	if (a->Range)
	{	if (soap_out_PointerTott__Space2DDescription(soap, "tt:Range", -1, &a->Range, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:Range"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__PanTiltLimits * SOAP_FMAC4 soap_in_tt__PanTiltLimits(struct soap *soap, const char *tag, struct tt__PanTiltLimits *a, const char *type)
{
	size_t soap_flag_Range = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__PanTiltLimits *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PanTiltLimits, sizeof(struct tt__PanTiltLimits), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__PanTiltLimits(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Range && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__Space2DDescription(soap, "tt:Range", &a->Range, "tt:Space2DDescription"))
				{	soap_flag_Range--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__PanTiltLimits *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PanTiltLimits, 0, sizeof(struct tt__PanTiltLimits), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Range > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__PanTiltLimits(struct soap *soap, const struct tt__PanTiltLimits *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__PanTiltLimits);
	if (soap_out_tt__PanTiltLimits(soap, tag?tag:"tt:PanTiltLimits", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PanTiltLimits * SOAP_FMAC4 soap_get_tt__PanTiltLimits(struct soap *soap, struct tt__PanTiltLimits *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PanTiltLimits(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__PTZSpaces(struct soap *soap, struct tt__PTZSpaces *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeAbsolutePanTiltPositionSpace = 0;
	a->AbsolutePanTiltPositionSpace = NULL;
	a->__sizeAbsoluteZoomPositionSpace = 0;
	a->AbsoluteZoomPositionSpace = NULL;
	a->__sizeRelativePanTiltTranslationSpace = 0;
	a->RelativePanTiltTranslationSpace = NULL;
	a->__sizeRelativeZoomTranslationSpace = 0;
	a->RelativeZoomTranslationSpace = NULL;
	a->__sizeContinuousPanTiltVelocitySpace = 0;
	a->ContinuousPanTiltVelocitySpace = NULL;
	a->__sizeContinuousZoomVelocitySpace = 0;
	a->ContinuousZoomVelocitySpace = NULL;
	a->__sizePanTiltSpeedSpace = 0;
	a->PanTiltSpeedSpace = NULL;
	a->__sizeZoomSpeedSpace = 0;
	a->ZoomSpeedSpace = NULL;
	a->Extension = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__PTZSpaces(struct soap *soap, const struct tt__PTZSpaces *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->AbsolutePanTiltPositionSpace)
	{	int i;
		for (i = 0; i < a->__sizeAbsolutePanTiltPositionSpace; i++)
		{
			soap_embedded(soap, a->AbsolutePanTiltPositionSpace + i, SOAP_TYPE_tt__Space2DDescription);
			soap_serialize_tt__Space2DDescription(soap, a->AbsolutePanTiltPositionSpace + i);
		}
	}
	if (a->AbsoluteZoomPositionSpace)
	{	int i;
		for (i = 0; i < a->__sizeAbsoluteZoomPositionSpace; i++)
		{
			soap_embedded(soap, a->AbsoluteZoomPositionSpace + i, SOAP_TYPE_tt__Space1DDescription);
			soap_serialize_tt__Space1DDescription(soap, a->AbsoluteZoomPositionSpace + i);
		}
	}
	if (a->RelativePanTiltTranslationSpace)
	{	int i;
		for (i = 0; i < a->__sizeRelativePanTiltTranslationSpace; i++)
		{
			soap_embedded(soap, a->RelativePanTiltTranslationSpace + i, SOAP_TYPE_tt__Space2DDescription);
			soap_serialize_tt__Space2DDescription(soap, a->RelativePanTiltTranslationSpace + i);
		}
	}
	if (a->RelativeZoomTranslationSpace)
	{	int i;
		for (i = 0; i < a->__sizeRelativeZoomTranslationSpace; i++)
		{
			soap_embedded(soap, a->RelativeZoomTranslationSpace + i, SOAP_TYPE_tt__Space1DDescription);
			soap_serialize_tt__Space1DDescription(soap, a->RelativeZoomTranslationSpace + i);
		}
	}
	if (a->ContinuousPanTiltVelocitySpace)
	{	int i;
		for (i = 0; i < a->__sizeContinuousPanTiltVelocitySpace; i++)
		{
			soap_embedded(soap, a->ContinuousPanTiltVelocitySpace + i, SOAP_TYPE_tt__Space2DDescription);
			soap_serialize_tt__Space2DDescription(soap, a->ContinuousPanTiltVelocitySpace + i);
		}
	}
	if (a->ContinuousZoomVelocitySpace)
	{	int i;
		for (i = 0; i < a->__sizeContinuousZoomVelocitySpace; i++)
		{
			soap_embedded(soap, a->ContinuousZoomVelocitySpace + i, SOAP_TYPE_tt__Space1DDescription);
			soap_serialize_tt__Space1DDescription(soap, a->ContinuousZoomVelocitySpace + i);
		}
	}
	if (a->PanTiltSpeedSpace)
	{	int i;
		for (i = 0; i < a->__sizePanTiltSpeedSpace; i++)
		{
			soap_embedded(soap, a->PanTiltSpeedSpace + i, SOAP_TYPE_tt__Space1DDescription);
			soap_serialize_tt__Space1DDescription(soap, a->PanTiltSpeedSpace + i);
		}
	}
	if (a->ZoomSpeedSpace)
	{	int i;
		for (i = 0; i < a->__sizeZoomSpeedSpace; i++)
		{
			soap_embedded(soap, a->ZoomSpeedSpace + i, SOAP_TYPE_tt__Space1DDescription);
			soap_serialize_tt__Space1DDescription(soap, a->ZoomSpeedSpace + i);
		}
	}
	soap_serialize_PointerTott__PTZSpacesExtension(soap, &a->Extension);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZSpaces(struct soap *soap, const char *tag, int id, const struct tt__PTZSpaces *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTZSpaces), type))
		return soap->error;
	if (a->AbsolutePanTiltPositionSpace)
	{	int i;
		for (i = 0; i < a->__sizeAbsolutePanTiltPositionSpace; i++)
			if (soap_out_tt__Space2DDescription(soap, "tt:AbsolutePanTiltPositionSpace", -1, a->AbsolutePanTiltPositionSpace + i, ""))
				return soap->error;
	}
	if (a->AbsoluteZoomPositionSpace)
	{	int i;
		for (i = 0; i < a->__sizeAbsoluteZoomPositionSpace; i++)
			if (soap_out_tt__Space1DDescription(soap, "tt:AbsoluteZoomPositionSpace", -1, a->AbsoluteZoomPositionSpace + i, ""))
				return soap->error;
	}
	if (a->RelativePanTiltTranslationSpace)
	{	int i;
		for (i = 0; i < a->__sizeRelativePanTiltTranslationSpace; i++)
			if (soap_out_tt__Space2DDescription(soap, "tt:RelativePanTiltTranslationSpace", -1, a->RelativePanTiltTranslationSpace + i, ""))
				return soap->error;
	}
	if (a->RelativeZoomTranslationSpace)
	{	int i;
		for (i = 0; i < a->__sizeRelativeZoomTranslationSpace; i++)
			if (soap_out_tt__Space1DDescription(soap, "tt:RelativeZoomTranslationSpace", -1, a->RelativeZoomTranslationSpace + i, ""))
				return soap->error;
	}
	if (a->ContinuousPanTiltVelocitySpace)
	{	int i;
		for (i = 0; i < a->__sizeContinuousPanTiltVelocitySpace; i++)
			if (soap_out_tt__Space2DDescription(soap, "tt:ContinuousPanTiltVelocitySpace", -1, a->ContinuousPanTiltVelocitySpace + i, ""))
				return soap->error;
	}
	if (a->ContinuousZoomVelocitySpace)
	{	int i;
		for (i = 0; i < a->__sizeContinuousZoomVelocitySpace; i++)
			if (soap_out_tt__Space1DDescription(soap, "tt:ContinuousZoomVelocitySpace", -1, a->ContinuousZoomVelocitySpace + i, ""))
				return soap->error;
	}
	if (a->PanTiltSpeedSpace)
	{	int i;
		for (i = 0; i < a->__sizePanTiltSpeedSpace; i++)
			if (soap_out_tt__Space1DDescription(soap, "tt:PanTiltSpeedSpace", -1, a->PanTiltSpeedSpace + i, ""))
				return soap->error;
	}
	if (a->ZoomSpeedSpace)
	{	int i;
		for (i = 0; i < a->__sizeZoomSpeedSpace; i++)
			if (soap_out_tt__Space1DDescription(soap, "tt:ZoomSpeedSpace", -1, a->ZoomSpeedSpace + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTott__PTZSpacesExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__PTZSpaces * SOAP_FMAC4 soap_in_tt__PTZSpaces(struct soap *soap, const char *tag, struct tt__PTZSpaces *a, const char *type)
{
	struct soap_blist *soap_blist_AbsolutePanTiltPositionSpace = NULL;
	struct soap_blist *soap_blist_AbsoluteZoomPositionSpace = NULL;
	struct soap_blist *soap_blist_RelativePanTiltTranslationSpace = NULL;
	struct soap_blist *soap_blist_RelativeZoomTranslationSpace = NULL;
	struct soap_blist *soap_blist_ContinuousPanTiltVelocitySpace = NULL;
	struct soap_blist *soap_blist_ContinuousZoomVelocitySpace = NULL;
	struct soap_blist *soap_blist_PanTiltSpeedSpace = NULL;
	struct soap_blist *soap_blist_ZoomSpeedSpace = NULL;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__PTZSpaces *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZSpaces, sizeof(struct tt__PTZSpaces), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__PTZSpaces(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:AbsolutePanTiltPositionSpace", 1, NULL))
			{	if (a->AbsolutePanTiltPositionSpace == NULL)
				{	if (soap_blist_AbsolutePanTiltPositionSpace == NULL)
						soap_blist_AbsolutePanTiltPositionSpace = soap_new_block(soap);
					a->AbsolutePanTiltPositionSpace = (struct tt__Space2DDescription *)soap_push_block(soap, soap_blist_AbsolutePanTiltPositionSpace, sizeof(struct tt__Space2DDescription));
					if (a->AbsolutePanTiltPositionSpace == NULL)
						return NULL;
					soap_default_tt__Space2DDescription(soap, a->AbsolutePanTiltPositionSpace);
				}
				soap_revert(soap);
				if (soap_in_tt__Space2DDescription(soap, "tt:AbsolutePanTiltPositionSpace", a->AbsolutePanTiltPositionSpace, "tt:Space2DDescription"))
				{	a->__sizeAbsolutePanTiltPositionSpace++;
					a->AbsolutePanTiltPositionSpace = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:AbsoluteZoomPositionSpace", 1, NULL))
			{	if (a->AbsoluteZoomPositionSpace == NULL)
				{	if (soap_blist_AbsoluteZoomPositionSpace == NULL)
						soap_blist_AbsoluteZoomPositionSpace = soap_new_block(soap);
					a->AbsoluteZoomPositionSpace = (struct tt__Space1DDescription *)soap_push_block(soap, soap_blist_AbsoluteZoomPositionSpace, sizeof(struct tt__Space1DDescription));
					if (a->AbsoluteZoomPositionSpace == NULL)
						return NULL;
					soap_default_tt__Space1DDescription(soap, a->AbsoluteZoomPositionSpace);
				}
				soap_revert(soap);
				if (soap_in_tt__Space1DDescription(soap, "tt:AbsoluteZoomPositionSpace", a->AbsoluteZoomPositionSpace, "tt:Space1DDescription"))
				{	a->__sizeAbsoluteZoomPositionSpace++;
					a->AbsoluteZoomPositionSpace = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:RelativePanTiltTranslationSpace", 1, NULL))
			{	if (a->RelativePanTiltTranslationSpace == NULL)
				{	if (soap_blist_RelativePanTiltTranslationSpace == NULL)
						soap_blist_RelativePanTiltTranslationSpace = soap_new_block(soap);
					a->RelativePanTiltTranslationSpace = (struct tt__Space2DDescription *)soap_push_block(soap, soap_blist_RelativePanTiltTranslationSpace, sizeof(struct tt__Space2DDescription));
					if (a->RelativePanTiltTranslationSpace == NULL)
						return NULL;
					soap_default_tt__Space2DDescription(soap, a->RelativePanTiltTranslationSpace);
				}
				soap_revert(soap);
				if (soap_in_tt__Space2DDescription(soap, "tt:RelativePanTiltTranslationSpace", a->RelativePanTiltTranslationSpace, "tt:Space2DDescription"))
				{	a->__sizeRelativePanTiltTranslationSpace++;
					a->RelativePanTiltTranslationSpace = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:RelativeZoomTranslationSpace", 1, NULL))
			{	if (a->RelativeZoomTranslationSpace == NULL)
				{	if (soap_blist_RelativeZoomTranslationSpace == NULL)
						soap_blist_RelativeZoomTranslationSpace = soap_new_block(soap);
					a->RelativeZoomTranslationSpace = (struct tt__Space1DDescription *)soap_push_block(soap, soap_blist_RelativeZoomTranslationSpace, sizeof(struct tt__Space1DDescription));
					if (a->RelativeZoomTranslationSpace == NULL)
						return NULL;
					soap_default_tt__Space1DDescription(soap, a->RelativeZoomTranslationSpace);
				}
				soap_revert(soap);
				if (soap_in_tt__Space1DDescription(soap, "tt:RelativeZoomTranslationSpace", a->RelativeZoomTranslationSpace, "tt:Space1DDescription"))
				{	a->__sizeRelativeZoomTranslationSpace++;
					a->RelativeZoomTranslationSpace = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:ContinuousPanTiltVelocitySpace", 1, NULL))
			{	if (a->ContinuousPanTiltVelocitySpace == NULL)
				{	if (soap_blist_ContinuousPanTiltVelocitySpace == NULL)
						soap_blist_ContinuousPanTiltVelocitySpace = soap_new_block(soap);
					a->ContinuousPanTiltVelocitySpace = (struct tt__Space2DDescription *)soap_push_block(soap, soap_blist_ContinuousPanTiltVelocitySpace, sizeof(struct tt__Space2DDescription));
					if (a->ContinuousPanTiltVelocitySpace == NULL)
						return NULL;
					soap_default_tt__Space2DDescription(soap, a->ContinuousPanTiltVelocitySpace);
				}
				soap_revert(soap);
				if (soap_in_tt__Space2DDescription(soap, "tt:ContinuousPanTiltVelocitySpace", a->ContinuousPanTiltVelocitySpace, "tt:Space2DDescription"))
				{	a->__sizeContinuousPanTiltVelocitySpace++;
					a->ContinuousPanTiltVelocitySpace = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:ContinuousZoomVelocitySpace", 1, NULL))
			{	if (a->ContinuousZoomVelocitySpace == NULL)
				{	if (soap_blist_ContinuousZoomVelocitySpace == NULL)
						soap_blist_ContinuousZoomVelocitySpace = soap_new_block(soap);
					a->ContinuousZoomVelocitySpace = (struct tt__Space1DDescription *)soap_push_block(soap, soap_blist_ContinuousZoomVelocitySpace, sizeof(struct tt__Space1DDescription));
					if (a->ContinuousZoomVelocitySpace == NULL)
						return NULL;
					soap_default_tt__Space1DDescription(soap, a->ContinuousZoomVelocitySpace);
				}
				soap_revert(soap);
				if (soap_in_tt__Space1DDescription(soap, "tt:ContinuousZoomVelocitySpace", a->ContinuousZoomVelocitySpace, "tt:Space1DDescription"))
				{	a->__sizeContinuousZoomVelocitySpace++;
					a->ContinuousZoomVelocitySpace = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:PanTiltSpeedSpace", 1, NULL))
			{	if (a->PanTiltSpeedSpace == NULL)
				{	if (soap_blist_PanTiltSpeedSpace == NULL)
						soap_blist_PanTiltSpeedSpace = soap_new_block(soap);
					a->PanTiltSpeedSpace = (struct tt__Space1DDescription *)soap_push_block(soap, soap_blist_PanTiltSpeedSpace, sizeof(struct tt__Space1DDescription));
					if (a->PanTiltSpeedSpace == NULL)
						return NULL;
					soap_default_tt__Space1DDescription(soap, a->PanTiltSpeedSpace);
				}
				soap_revert(soap);
				if (soap_in_tt__Space1DDescription(soap, "tt:PanTiltSpeedSpace", a->PanTiltSpeedSpace, "tt:Space1DDescription"))
				{	a->__sizePanTiltSpeedSpace++;
					a->PanTiltSpeedSpace = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:ZoomSpeedSpace", 1, NULL))
			{	if (a->ZoomSpeedSpace == NULL)
				{	if (soap_blist_ZoomSpeedSpace == NULL)
						soap_blist_ZoomSpeedSpace = soap_new_block(soap);
					a->ZoomSpeedSpace = (struct tt__Space1DDescription *)soap_push_block(soap, soap_blist_ZoomSpeedSpace, sizeof(struct tt__Space1DDescription));
					if (a->ZoomSpeedSpace == NULL)
						return NULL;
					soap_default_tt__Space1DDescription(soap, a->ZoomSpeedSpace);
				}
				soap_revert(soap);
				if (soap_in_tt__Space1DDescription(soap, "tt:ZoomSpeedSpace", a->ZoomSpeedSpace, "tt:Space1DDescription"))
				{	a->__sizeZoomSpeedSpace++;
					a->ZoomSpeedSpace = NULL;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__PTZSpacesExtension(soap, "tt:Extension", &a->Extension, "tt:PTZSpacesExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->AbsolutePanTiltPositionSpace)
			soap_pop_block(soap, soap_blist_AbsolutePanTiltPositionSpace);
		if (a->__sizeAbsolutePanTiltPositionSpace)
			a->AbsolutePanTiltPositionSpace = (struct tt__Space2DDescription *)soap_save_block(soap, soap_blist_AbsolutePanTiltPositionSpace, NULL, 1);
		else
		{	a->AbsolutePanTiltPositionSpace = NULL;
			if (soap_blist_AbsolutePanTiltPositionSpace)
				soap_end_block(soap, soap_blist_AbsolutePanTiltPositionSpace);
		}
		if (a->AbsoluteZoomPositionSpace)
			soap_pop_block(soap, soap_blist_AbsoluteZoomPositionSpace);
		if (a->__sizeAbsoluteZoomPositionSpace)
			a->AbsoluteZoomPositionSpace = (struct tt__Space1DDescription *)soap_save_block(soap, soap_blist_AbsoluteZoomPositionSpace, NULL, 1);
		else
		{	a->AbsoluteZoomPositionSpace = NULL;
			if (soap_blist_AbsoluteZoomPositionSpace)
				soap_end_block(soap, soap_blist_AbsoluteZoomPositionSpace);
		}
		if (a->RelativePanTiltTranslationSpace)
			soap_pop_block(soap, soap_blist_RelativePanTiltTranslationSpace);
		if (a->__sizeRelativePanTiltTranslationSpace)
			a->RelativePanTiltTranslationSpace = (struct tt__Space2DDescription *)soap_save_block(soap, soap_blist_RelativePanTiltTranslationSpace, NULL, 1);
		else
		{	a->RelativePanTiltTranslationSpace = NULL;
			if (soap_blist_RelativePanTiltTranslationSpace)
				soap_end_block(soap, soap_blist_RelativePanTiltTranslationSpace);
		}
		if (a->RelativeZoomTranslationSpace)
			soap_pop_block(soap, soap_blist_RelativeZoomTranslationSpace);
		if (a->__sizeRelativeZoomTranslationSpace)
			a->RelativeZoomTranslationSpace = (struct tt__Space1DDescription *)soap_save_block(soap, soap_blist_RelativeZoomTranslationSpace, NULL, 1);
		else
		{	a->RelativeZoomTranslationSpace = NULL;
			if (soap_blist_RelativeZoomTranslationSpace)
				soap_end_block(soap, soap_blist_RelativeZoomTranslationSpace);
		}
		if (a->ContinuousPanTiltVelocitySpace)
			soap_pop_block(soap, soap_blist_ContinuousPanTiltVelocitySpace);
		if (a->__sizeContinuousPanTiltVelocitySpace)
			a->ContinuousPanTiltVelocitySpace = (struct tt__Space2DDescription *)soap_save_block(soap, soap_blist_ContinuousPanTiltVelocitySpace, NULL, 1);
		else
		{	a->ContinuousPanTiltVelocitySpace = NULL;
			if (soap_blist_ContinuousPanTiltVelocitySpace)
				soap_end_block(soap, soap_blist_ContinuousPanTiltVelocitySpace);
		}
		if (a->ContinuousZoomVelocitySpace)
			soap_pop_block(soap, soap_blist_ContinuousZoomVelocitySpace);
		if (a->__sizeContinuousZoomVelocitySpace)
			a->ContinuousZoomVelocitySpace = (struct tt__Space1DDescription *)soap_save_block(soap, soap_blist_ContinuousZoomVelocitySpace, NULL, 1);
		else
		{	a->ContinuousZoomVelocitySpace = NULL;
			if (soap_blist_ContinuousZoomVelocitySpace)
				soap_end_block(soap, soap_blist_ContinuousZoomVelocitySpace);
		}
		if (a->PanTiltSpeedSpace)
			soap_pop_block(soap, soap_blist_PanTiltSpeedSpace);
		if (a->__sizePanTiltSpeedSpace)
			a->PanTiltSpeedSpace = (struct tt__Space1DDescription *)soap_save_block(soap, soap_blist_PanTiltSpeedSpace, NULL, 1);
		else
		{	a->PanTiltSpeedSpace = NULL;
			if (soap_blist_PanTiltSpeedSpace)
				soap_end_block(soap, soap_blist_PanTiltSpeedSpace);
		}
		if (a->ZoomSpeedSpace)
			soap_pop_block(soap, soap_blist_ZoomSpeedSpace);
		if (a->__sizeZoomSpeedSpace)
			a->ZoomSpeedSpace = (struct tt__Space1DDescription *)soap_save_block(soap, soap_blist_ZoomSpeedSpace, NULL, 1);
		else
		{	a->ZoomSpeedSpace = NULL;
			if (soap_blist_ZoomSpeedSpace)
				soap_end_block(soap, soap_blist_ZoomSpeedSpace);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__PTZSpaces *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZSpaces, 0, sizeof(struct tt__PTZSpaces), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__PTZSpaces(struct soap *soap, const struct tt__PTZSpaces *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__PTZSpaces);
	if (soap_out_tt__PTZSpaces(soap, tag?tag:"tt:PTZSpaces", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PTZSpaces * SOAP_FMAC4 soap_get_tt__PTZSpaces(struct soap *soap, struct tt__PTZSpaces *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTZSpaces(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__PTZConfigurationOptions(struct soap *soap, struct tt__PTZConfigurationOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Spaces = NULL;
	a->PTZTimeout = NULL;
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__PTZConfigurationOptions(struct soap *soap, const struct tt__PTZConfigurationOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTott__PTZSpaces(soap, &a->Spaces);
	soap_serialize_PointerTott__DurationRange(soap, &a->PTZTimeout);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZConfigurationOptions(struct soap *soap, const char *tag, int id, const struct tt__PTZConfigurationOptions *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTZConfigurationOptions), type))
		return soap->error;
	if (a->Spaces)
	{	if (soap_out_PointerTott__PTZSpaces(soap, "tt:Spaces", -1, &a->Spaces, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:Spaces"))
		return soap->error;
	if (a->PTZTimeout)
	{	if (soap_out_PointerTott__DurationRange(soap, "tt:PTZTimeout", -1, &a->PTZTimeout, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:PTZTimeout"))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__PTZConfigurationOptions * SOAP_FMAC4 soap_in_tt__PTZConfigurationOptions(struct soap *soap, const char *tag, struct tt__PTZConfigurationOptions *a, const char *type)
{
	size_t soap_flag_Spaces = 1;
	size_t soap_flag_PTZTimeout = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__PTZConfigurationOptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZConfigurationOptions, sizeof(struct tt__PTZConfigurationOptions), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__PTZConfigurationOptions(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Spaces && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__PTZSpaces(soap, "tt:Spaces", &a->Spaces, "tt:PTZSpaces"))
				{	soap_flag_Spaces--;
					continue;
				}
			if (soap_flag_PTZTimeout && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__DurationRange(soap, "tt:PTZTimeout", &a->PTZTimeout, "tt:DurationRange"))
				{	soap_flag_PTZTimeout--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__PTZConfigurationOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZConfigurationOptions, 0, sizeof(struct tt__PTZConfigurationOptions), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Spaces > 0 || soap_flag_PTZTimeout > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__PTZConfigurationOptions(struct soap *soap, const struct tt__PTZConfigurationOptions *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__PTZConfigurationOptions);
	if (soap_out_tt__PTZConfigurationOptions(soap, tag?tag:"tt:PTZConfigurationOptions", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PTZConfigurationOptions * SOAP_FMAC4 soap_get_tt__PTZConfigurationOptions(struct soap *soap, struct tt__PTZConfigurationOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTZConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__PTZConfigurationExtension(struct soap *soap, struct tt__PTZConfigurationExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__PTZConfigurationExtension(struct soap *soap, const struct tt__PTZConfigurationExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZConfigurationExtension(struct soap *soap, const char *tag, int id, const struct tt__PTZConfigurationExtension *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTZConfigurationExtension), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__PTZConfigurationExtension * SOAP_FMAC4 soap_in_tt__PTZConfigurationExtension(struct soap *soap, const char *tag, struct tt__PTZConfigurationExtension *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__PTZConfigurationExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZConfigurationExtension, sizeof(struct tt__PTZConfigurationExtension), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__PTZConfigurationExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__PTZConfigurationExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZConfigurationExtension, 0, sizeof(struct tt__PTZConfigurationExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__PTZConfigurationExtension(struct soap *soap, const struct tt__PTZConfigurationExtension *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__PTZConfigurationExtension);
	if (soap_out_tt__PTZConfigurationExtension(soap, tag?tag:"tt:PTZConfigurationExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PTZConfigurationExtension * SOAP_FMAC4 soap_get_tt__PTZConfigurationExtension(struct soap *soap, struct tt__PTZConfigurationExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTZConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__PTZNodeExtension(struct soap *soap, struct tt__PTZNodeExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__PTZNodeExtension(struct soap *soap, const struct tt__PTZNodeExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZNodeExtension(struct soap *soap, const char *tag, int id, const struct tt__PTZNodeExtension *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTZNodeExtension), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__PTZNodeExtension * SOAP_FMAC4 soap_in_tt__PTZNodeExtension(struct soap *soap, const char *tag, struct tt__PTZNodeExtension *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__PTZNodeExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZNodeExtension, sizeof(struct tt__PTZNodeExtension), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__PTZNodeExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__PTZNodeExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZNodeExtension, 0, sizeof(struct tt__PTZNodeExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__PTZNodeExtension(struct soap *soap, const struct tt__PTZNodeExtension *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__PTZNodeExtension);
	if (soap_out_tt__PTZNodeExtension(soap, tag?tag:"tt:PTZNodeExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PTZNodeExtension * SOAP_FMAC4 soap_get_tt__PTZNodeExtension(struct soap *soap, struct tt__PTZNodeExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTZNodeExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__GenericEapPwdConfigurationExtension(struct soap *soap, struct tt__GenericEapPwdConfigurationExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__GenericEapPwdConfigurationExtension(struct soap *soap, const struct tt__GenericEapPwdConfigurationExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__GenericEapPwdConfigurationExtension(struct soap *soap, const char *tag, int id, const struct tt__GenericEapPwdConfigurationExtension *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__GenericEapPwdConfigurationExtension), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__GenericEapPwdConfigurationExtension * SOAP_FMAC4 soap_in_tt__GenericEapPwdConfigurationExtension(struct soap *soap, const char *tag, struct tt__GenericEapPwdConfigurationExtension *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__GenericEapPwdConfigurationExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__GenericEapPwdConfigurationExtension, sizeof(struct tt__GenericEapPwdConfigurationExtension), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__GenericEapPwdConfigurationExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__GenericEapPwdConfigurationExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__GenericEapPwdConfigurationExtension, 0, sizeof(struct tt__GenericEapPwdConfigurationExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__GenericEapPwdConfigurationExtension(struct soap *soap, const struct tt__GenericEapPwdConfigurationExtension *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__GenericEapPwdConfigurationExtension);
	if (soap_out_tt__GenericEapPwdConfigurationExtension(soap, tag?tag:"tt:GenericEapPwdConfigurationExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__GenericEapPwdConfigurationExtension * SOAP_FMAC4 soap_get_tt__GenericEapPwdConfigurationExtension(struct soap *soap, struct tt__GenericEapPwdConfigurationExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__GenericEapPwdConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__EapMethodExtension(struct soap *soap, struct tt__EapMethodExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__EapMethodExtension(struct soap *soap, const struct tt__EapMethodExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__EapMethodExtension(struct soap *soap, const char *tag, int id, const struct tt__EapMethodExtension *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__EapMethodExtension), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__EapMethodExtension * SOAP_FMAC4 soap_in_tt__EapMethodExtension(struct soap *soap, const char *tag, struct tt__EapMethodExtension *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__EapMethodExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__EapMethodExtension, sizeof(struct tt__EapMethodExtension), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__EapMethodExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__EapMethodExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__EapMethodExtension, 0, sizeof(struct tt__EapMethodExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__EapMethodExtension(struct soap *soap, const struct tt__EapMethodExtension *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__EapMethodExtension);
	if (soap_out_tt__EapMethodExtension(soap, tag?tag:"tt:EapMethodExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__EapMethodExtension * SOAP_FMAC4 soap_get_tt__EapMethodExtension(struct soap *soap, struct tt__EapMethodExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__EapMethodExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__TLSConfiguration(struct soap *soap, struct tt__TLSConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__token(soap, &a->CertificateID);
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__TLSConfiguration(struct soap *soap, const struct tt__TLSConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_xsd__token(soap, &a->CertificateID);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__TLSConfiguration(struct soap *soap, const char *tag, int id, const struct tt__TLSConfiguration *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__TLSConfiguration), type))
		return soap->error;
	if (a->CertificateID)
	{	if (soap_out_xsd__token(soap, "tt:CertificateID", -1, &a->CertificateID, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:CertificateID"))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__TLSConfiguration * SOAP_FMAC4 soap_in_tt__TLSConfiguration(struct soap *soap, const char *tag, struct tt__TLSConfiguration *a, const char *type)
{
	size_t soap_flag_CertificateID = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__TLSConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__TLSConfiguration, sizeof(struct tt__TLSConfiguration), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__TLSConfiguration(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CertificateID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__token(soap, "tt:CertificateID", &a->CertificateID, "xsd:token"))
				{	soap_flag_CertificateID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__TLSConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__TLSConfiguration, 0, sizeof(struct tt__TLSConfiguration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_CertificateID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__TLSConfiguration(struct soap *soap, const struct tt__TLSConfiguration *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__TLSConfiguration);
	if (soap_out_tt__TLSConfiguration(soap, tag?tag:"tt:TLSConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__TLSConfiguration * SOAP_FMAC4 soap_get_tt__TLSConfiguration(struct soap *soap, struct tt__TLSConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__TLSConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__Dot1XConfigurationExtension(struct soap *soap, struct tt__Dot1XConfigurationExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__Dot1XConfigurationExtension(struct soap *soap, const struct tt__Dot1XConfigurationExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Dot1XConfigurationExtension(struct soap *soap, const char *tag, int id, const struct tt__Dot1XConfigurationExtension *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Dot1XConfigurationExtension), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__Dot1XConfigurationExtension * SOAP_FMAC4 soap_in_tt__Dot1XConfigurationExtension(struct soap *soap, const char *tag, struct tt__Dot1XConfigurationExtension *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__Dot1XConfigurationExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Dot1XConfigurationExtension, sizeof(struct tt__Dot1XConfigurationExtension), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__Dot1XConfigurationExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__Dot1XConfigurationExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Dot1XConfigurationExtension, 0, sizeof(struct tt__Dot1XConfigurationExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Dot1XConfigurationExtension(struct soap *soap, const struct tt__Dot1XConfigurationExtension *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__Dot1XConfigurationExtension);
	if (soap_out_tt__Dot1XConfigurationExtension(soap, tag?tag:"tt:Dot1XConfigurationExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Dot1XConfigurationExtension * SOAP_FMAC4 soap_get_tt__Dot1XConfigurationExtension(struct soap *soap, struct tt__Dot1XConfigurationExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Dot1XConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__EAPMethodConfiguration(struct soap *soap, struct tt__EAPMethodConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->TLSConfiguration = NULL;
	soap_default_string(soap, &a->Password);
	a->Extension = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__EAPMethodConfiguration(struct soap *soap, const struct tt__EAPMethodConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTott__TLSConfiguration(soap, &a->TLSConfiguration);
	soap_serialize_string(soap, &a->Password);
	soap_serialize_PointerTott__EapMethodExtension(soap, &a->Extension);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__EAPMethodConfiguration(struct soap *soap, const char *tag, int id, const struct tt__EAPMethodConfiguration *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__EAPMethodConfiguration), type))
		return soap->error;
	if (soap_out_PointerTott__TLSConfiguration(soap, "tt:TLSConfiguration", -1, &a->TLSConfiguration, ""))
		return soap->error;
	if (soap_out_string(soap, "tt:Password", -1, &a->Password, ""))
		return soap->error;
	if (soap_out_PointerTott__EapMethodExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__EAPMethodConfiguration * SOAP_FMAC4 soap_in_tt__EAPMethodConfiguration(struct soap *soap, const char *tag, struct tt__EAPMethodConfiguration *a, const char *type)
{
	size_t soap_flag_TLSConfiguration = 1;
	size_t soap_flag_Password = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__EAPMethodConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__EAPMethodConfiguration, sizeof(struct tt__EAPMethodConfiguration), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__EAPMethodConfiguration(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_TLSConfiguration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__TLSConfiguration(soap, "tt:TLSConfiguration", &a->TLSConfiguration, "tt:TLSConfiguration"))
				{	soap_flag_TLSConfiguration--;
					continue;
				}
			if (soap_flag_Password && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "tt:Password", &a->Password, "xsd:string"))
				{	soap_flag_Password--;
					continue;
				}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__EapMethodExtension(soap, "tt:Extension", &a->Extension, "tt:EapMethodExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__EAPMethodConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__EAPMethodConfiguration, 0, sizeof(struct tt__EAPMethodConfiguration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__EAPMethodConfiguration(struct soap *soap, const struct tt__EAPMethodConfiguration *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__EAPMethodConfiguration);
	if (soap_out_tt__EAPMethodConfiguration(soap, tag?tag:"tt:EAPMethodConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__EAPMethodConfiguration * SOAP_FMAC4 soap_get_tt__EAPMethodConfiguration(struct soap *soap, struct tt__EAPMethodConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__EAPMethodConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__CertificateInformationExtension(struct soap *soap, struct tt__CertificateInformationExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__CertificateInformationExtension(struct soap *soap, const struct tt__CertificateInformationExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__CertificateInformationExtension(struct soap *soap, const char *tag, int id, const struct tt__CertificateInformationExtension *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__CertificateInformationExtension), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__CertificateInformationExtension * SOAP_FMAC4 soap_in_tt__CertificateInformationExtension(struct soap *soap, const char *tag, struct tt__CertificateInformationExtension *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__CertificateInformationExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__CertificateInformationExtension, sizeof(struct tt__CertificateInformationExtension), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__CertificateInformationExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__CertificateInformationExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__CertificateInformationExtension, 0, sizeof(struct tt__CertificateInformationExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__CertificateInformationExtension(struct soap *soap, const struct tt__CertificateInformationExtension *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__CertificateInformationExtension);
	if (soap_out_tt__CertificateInformationExtension(soap, tag?tag:"tt:CertificateInformationExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__CertificateInformationExtension * SOAP_FMAC4 soap_get_tt__CertificateInformationExtension(struct soap *soap, struct tt__CertificateInformationExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__CertificateInformationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__DateTimeRange(struct soap *soap, struct tt__DateTimeRange *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_time(soap, &a->From);
	soap_default_time(soap, &a->Until);
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__DateTimeRange(struct soap *soap, const struct tt__DateTimeRange *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->From, SOAP_TYPE_time);
	soap_embedded(soap, &a->Until, SOAP_TYPE_time);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__DateTimeRange(struct soap *soap, const char *tag, int id, const struct tt__DateTimeRange *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__DateTimeRange), type))
		return soap->error;
	if (soap_out_time(soap, "tt:From", -1, &a->From, ""))
		return soap->error;
	if (soap_out_time(soap, "tt:Until", -1, &a->Until, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__DateTimeRange * SOAP_FMAC4 soap_in_tt__DateTimeRange(struct soap *soap, const char *tag, struct tt__DateTimeRange *a, const char *type)
{
	size_t soap_flag_From = 1;
	size_t soap_flag_Until = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__DateTimeRange *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__DateTimeRange, sizeof(struct tt__DateTimeRange), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__DateTimeRange(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_From && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "tt:From", &a->From, "xsd:dateTime"))
				{	soap_flag_From--;
					continue;
				}
			if (soap_flag_Until && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "tt:Until", &a->Until, "xsd:dateTime"))
				{	soap_flag_Until--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__DateTimeRange *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__DateTimeRange, 0, sizeof(struct tt__DateTimeRange), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_From > 0 || soap_flag_Until > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__DateTimeRange(struct soap *soap, const struct tt__DateTimeRange *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__DateTimeRange);
	if (soap_out_tt__DateTimeRange(soap, tag?tag:"tt:DateTimeRange", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__DateTimeRange * SOAP_FMAC4 soap_get_tt__DateTimeRange(struct soap *soap, struct tt__DateTimeRange *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__DateTimeRange(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__CertificateUsage(struct soap *soap, struct tt__CertificateUsage *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default_xsd__boolean_(soap, &a->Critical);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__CertificateUsage(struct soap *soap, const struct tt__CertificateUsage *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->__item);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__CertificateUsage(struct soap *soap, const char *tag, int id, const struct tt__CertificateUsage *a, const char *type)
{
	soap_set_attr(soap, "Critical", soap_xsd__boolean_2s(soap, a->Critical), 1);
	return soap_out_string(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct tt__CertificateUsage * SOAP_FMAC4 soap_in_tt__CertificateUsage(struct soap *soap, const char *tag, struct tt__CertificateUsage *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct tt__CertificateUsage *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__CertificateUsage, sizeof(struct tt__CertificateUsage), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default_tt__CertificateUsage(soap, a);
	if (soap_s2xsd__boolean_(soap, soap_attr_value(soap, "Critical", 1), &a->Critical))
		return NULL;
	if (!soap_in_string(soap, tag, &a->__item, "tt:CertificateUsage"))
		return NULL;
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__CertificateUsage(struct soap *soap, const struct tt__CertificateUsage *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__CertificateUsage);
	if (soap_out_tt__CertificateUsage(soap, tag?tag:"tt:CertificateUsage", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__CertificateUsage * SOAP_FMAC4 soap_get_tt__CertificateUsage(struct soap *soap, struct tt__CertificateUsage *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__CertificateUsage(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__CertificateGenerationParametersExtension(struct soap *soap, struct tt__CertificateGenerationParametersExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__CertificateGenerationParametersExtension(struct soap *soap, const struct tt__CertificateGenerationParametersExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__CertificateGenerationParametersExtension(struct soap *soap, const char *tag, int id, const struct tt__CertificateGenerationParametersExtension *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__CertificateGenerationParametersExtension), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__CertificateGenerationParametersExtension * SOAP_FMAC4 soap_in_tt__CertificateGenerationParametersExtension(struct soap *soap, const char *tag, struct tt__CertificateGenerationParametersExtension *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__CertificateGenerationParametersExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__CertificateGenerationParametersExtension, sizeof(struct tt__CertificateGenerationParametersExtension), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__CertificateGenerationParametersExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__CertificateGenerationParametersExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__CertificateGenerationParametersExtension, 0, sizeof(struct tt__CertificateGenerationParametersExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__CertificateGenerationParametersExtension(struct soap *soap, const struct tt__CertificateGenerationParametersExtension *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__CertificateGenerationParametersExtension);
	if (soap_out_tt__CertificateGenerationParametersExtension(soap, tag?tag:"tt:CertificateGenerationParametersExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__CertificateGenerationParametersExtension * SOAP_FMAC4 soap_get_tt__CertificateGenerationParametersExtension(struct soap *soap, struct tt__CertificateGenerationParametersExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__CertificateGenerationParametersExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__CertificateGenerationParameters(struct soap *soap, struct tt__CertificateGenerationParameters *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__token(soap, &a->CertificateID);
	soap_default_string(soap, &a->Subject);
	soap_default_xsd__token(soap, &a->ValidNotBefore);
	soap_default_xsd__token(soap, &a->ValidNotAfter);
	a->Extension = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__CertificateGenerationParameters(struct soap *soap, const struct tt__CertificateGenerationParameters *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_xsd__token(soap, &a->CertificateID);
	soap_serialize_string(soap, &a->Subject);
	soap_serialize_xsd__token(soap, &a->ValidNotBefore);
	soap_serialize_xsd__token(soap, &a->ValidNotAfter);
	soap_serialize_PointerTott__CertificateGenerationParametersExtension(soap, &a->Extension);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__CertificateGenerationParameters(struct soap *soap, const char *tag, int id, const struct tt__CertificateGenerationParameters *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__CertificateGenerationParameters), type))
		return soap->error;
	if (soap_out_xsd__token(soap, "tt:CertificateID", -1, &a->CertificateID, ""))
		return soap->error;
	if (soap_out_string(soap, "tt:Subject", -1, &a->Subject, ""))
		return soap->error;
	if (soap_out_xsd__token(soap, "tt:ValidNotBefore", -1, &a->ValidNotBefore, ""))
		return soap->error;
	if (soap_out_xsd__token(soap, "tt:ValidNotAfter", -1, &a->ValidNotAfter, ""))
		return soap->error;
	if (soap_out_PointerTott__CertificateGenerationParametersExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__CertificateGenerationParameters * SOAP_FMAC4 soap_in_tt__CertificateGenerationParameters(struct soap *soap, const char *tag, struct tt__CertificateGenerationParameters *a, const char *type)
{
	size_t soap_flag_CertificateID = 1;
	size_t soap_flag_Subject = 1;
	size_t soap_flag_ValidNotBefore = 1;
	size_t soap_flag_ValidNotAfter = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__CertificateGenerationParameters *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__CertificateGenerationParameters, sizeof(struct tt__CertificateGenerationParameters), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__CertificateGenerationParameters(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CertificateID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__token(soap, "tt:CertificateID", &a->CertificateID, "xsd:token"))
				{	soap_flag_CertificateID--;
					continue;
				}
			if (soap_flag_Subject && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "tt:Subject", &a->Subject, "xsd:string"))
				{	soap_flag_Subject--;
					continue;
				}
			if (soap_flag_ValidNotBefore && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__token(soap, "tt:ValidNotBefore", &a->ValidNotBefore, "xsd:token"))
				{	soap_flag_ValidNotBefore--;
					continue;
				}
			if (soap_flag_ValidNotAfter && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__token(soap, "tt:ValidNotAfter", &a->ValidNotAfter, "xsd:token"))
				{	soap_flag_ValidNotAfter--;
					continue;
				}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__CertificateGenerationParametersExtension(soap, "tt:Extension", &a->Extension, "tt:CertificateGenerationParametersExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__CertificateGenerationParameters *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__CertificateGenerationParameters, 0, sizeof(struct tt__CertificateGenerationParameters), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__CertificateGenerationParameters(struct soap *soap, const struct tt__CertificateGenerationParameters *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__CertificateGenerationParameters);
	if (soap_out_tt__CertificateGenerationParameters(soap, tag?tag:"tt:CertificateGenerationParameters", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__CertificateGenerationParameters * SOAP_FMAC4 soap_get_tt__CertificateGenerationParameters(struct soap *soap, struct tt__CertificateGenerationParameters *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__CertificateGenerationParameters(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__UserExtension(struct soap *soap, struct tt__UserExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__UserExtension(struct soap *soap, const struct tt__UserExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__UserExtension(struct soap *soap, const char *tag, int id, const struct tt__UserExtension *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__UserExtension), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__UserExtension * SOAP_FMAC4 soap_in_tt__UserExtension(struct soap *soap, const char *tag, struct tt__UserExtension *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__UserExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__UserExtension, sizeof(struct tt__UserExtension), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__UserExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__UserExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__UserExtension, 0, sizeof(struct tt__UserExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__UserExtension(struct soap *soap, const struct tt__UserExtension *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__UserExtension);
	if (soap_out_tt__UserExtension(soap, tag?tag:"tt:UserExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__UserExtension * SOAP_FMAC4 soap_get_tt__UserExtension(struct soap *soap, struct tt__UserExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__UserExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__Date(struct soap *soap, struct tt__Date *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->Year);
	soap_default_int(soap, &a->Month);
	soap_default_int(soap, &a->Day);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__Date(struct soap *soap, const struct tt__Date *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->Year, SOAP_TYPE_int);
	soap_embedded(soap, &a->Month, SOAP_TYPE_int);
	soap_embedded(soap, &a->Day, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Date(struct soap *soap, const char *tag, int id, const struct tt__Date *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Date), type))
		return soap->error;
	if (soap_out_int(soap, "tt:Year", -1, &a->Year, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:Month", -1, &a->Month, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:Day", -1, &a->Day, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__Date * SOAP_FMAC4 soap_in_tt__Date(struct soap *soap, const char *tag, struct tt__Date *a, const char *type)
{
	size_t soap_flag_Year = 1;
	size_t soap_flag_Month = 1;
	size_t soap_flag_Day = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__Date *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Date, sizeof(struct tt__Date), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__Date(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Year && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "tt:Year", &a->Year, "xsd:int"))
				{	soap_flag_Year--;
					continue;
				}
			if (soap_flag_Month && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "tt:Month", &a->Month, "xsd:int"))
				{	soap_flag_Month--;
					continue;
				}
			if (soap_flag_Day && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "tt:Day", &a->Day, "xsd:int"))
				{	soap_flag_Day--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__Date *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Date, 0, sizeof(struct tt__Date), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Year > 0 || soap_flag_Month > 0 || soap_flag_Day > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Date(struct soap *soap, const struct tt__Date *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__Date);
	if (soap_out_tt__Date(soap, tag?tag:"tt:Date", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Date * SOAP_FMAC4 soap_get_tt__Date(struct soap *soap, struct tt__Date *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Date(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__Time(struct soap *soap, struct tt__Time *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->Hour);
	soap_default_int(soap, &a->Minute);
	soap_default_int(soap, &a->Second);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__Time(struct soap *soap, const struct tt__Time *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->Hour, SOAP_TYPE_int);
	soap_embedded(soap, &a->Minute, SOAP_TYPE_int);
	soap_embedded(soap, &a->Second, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Time(struct soap *soap, const char *tag, int id, const struct tt__Time *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Time), type))
		return soap->error;
	if (soap_out_int(soap, "tt:Hour", -1, &a->Hour, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:Minute", -1, &a->Minute, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:Second", -1, &a->Second, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__Time * SOAP_FMAC4 soap_in_tt__Time(struct soap *soap, const char *tag, struct tt__Time *a, const char *type)
{
	size_t soap_flag_Hour = 1;
	size_t soap_flag_Minute = 1;
	size_t soap_flag_Second = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__Time *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Time, sizeof(struct tt__Time), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__Time(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Hour && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "tt:Hour", &a->Hour, "xsd:int"))
				{	soap_flag_Hour--;
					continue;
				}
			if (soap_flag_Minute && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "tt:Minute", &a->Minute, "xsd:int"))
				{	soap_flag_Minute--;
					continue;
				}
			if (soap_flag_Second && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "tt:Second", &a->Second, "xsd:int"))
				{	soap_flag_Second--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__Time *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Time, 0, sizeof(struct tt__Time), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Hour > 0 || soap_flag_Minute > 0 || soap_flag_Second > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Time(struct soap *soap, const struct tt__Time *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__Time);
	if (soap_out_tt__Time(soap, tag?tag:"tt:Time", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Time * SOAP_FMAC4 soap_get_tt__Time(struct soap *soap, struct tt__Time *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Time(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__SystemDateTimeExtension(struct soap *soap, struct tt__SystemDateTimeExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__SystemDateTimeExtension(struct soap *soap, const struct tt__SystemDateTimeExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__SystemDateTimeExtension(struct soap *soap, const char *tag, int id, const struct tt__SystemDateTimeExtension *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__SystemDateTimeExtension), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__SystemDateTimeExtension * SOAP_FMAC4 soap_in_tt__SystemDateTimeExtension(struct soap *soap, const char *tag, struct tt__SystemDateTimeExtension *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__SystemDateTimeExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__SystemDateTimeExtension, sizeof(struct tt__SystemDateTimeExtension), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__SystemDateTimeExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__SystemDateTimeExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__SystemDateTimeExtension, 0, sizeof(struct tt__SystemDateTimeExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__SystemDateTimeExtension(struct soap *soap, const struct tt__SystemDateTimeExtension *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__SystemDateTimeExtension);
	if (soap_out_tt__SystemDateTimeExtension(soap, tag?tag:"tt:SystemDateTimeExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__SystemDateTimeExtension * SOAP_FMAC4 soap_get_tt__SystemDateTimeExtension(struct soap *soap, struct tt__SystemDateTimeExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__SystemDateTimeExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__SystemLogUri(struct soap *soap, struct tt__SystemLogUri *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__SystemLogType(soap, &a->Type);
	soap_default_string(soap, &a->Uri);
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__SystemLogUri(struct soap *soap, const struct tt__SystemLogUri *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Uri);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__SystemLogUri(struct soap *soap, const char *tag, int id, const struct tt__SystemLogUri *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__SystemLogUri), type))
		return soap->error;
	if (soap_out_tt__SystemLogType(soap, "tt:Type", -1, &a->Type, ""))
		return soap->error;
	if (a->Uri)
	{	if (soap_out_string(soap, "tt:Uri", -1, &a->Uri, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:Uri"))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__SystemLogUri * SOAP_FMAC4 soap_in_tt__SystemLogUri(struct soap *soap, const char *tag, struct tt__SystemLogUri *a, const char *type)
{
	size_t soap_flag_Type = 1;
	size_t soap_flag_Uri = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__SystemLogUri *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__SystemLogUri, sizeof(struct tt__SystemLogUri), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__SystemLogUri(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Type && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_tt__SystemLogType(soap, "tt:Type", &a->Type, "tt:SystemLogType"))
				{	soap_flag_Type--;
					continue;
				}
			if (soap_flag_Uri && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "tt:Uri", &a->Uri, "xsd:string"))
				{	soap_flag_Uri--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__SystemLogUri *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__SystemLogUri, 0, sizeof(struct tt__SystemLogUri), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Type > 0 || soap_flag_Uri > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__SystemLogUri(struct soap *soap, const struct tt__SystemLogUri *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__SystemLogUri);
	if (soap_out_tt__SystemLogUri(soap, tag?tag:"tt:SystemLogUri", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__SystemLogUri * SOAP_FMAC4 soap_get_tt__SystemLogUri(struct soap *soap, struct tt__SystemLogUri *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__SystemLogUri(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xop__Include(struct soap *soap, struct xop__Include *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
	soap_default_string(soap, &a->href);
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xop__Include(struct soap *soap, const struct xop__Include *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xop__Include(struct soap *soap, const char *tag, int id, const struct xop__Include *a, const char *type)
{
	if (a->href)
		soap_set_attr(soap, "href", a->href, 1);
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_xop__Include), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct xop__Include * SOAP_FMAC4 soap_in_xop__Include(struct soap *soap, const char *tag, struct xop__Include *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct xop__Include *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xop__Include, sizeof(struct xop__Include), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_xop__Include(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "href", 1), &a->href, -1, -1))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct xop__Include *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xop__Include, 0, sizeof(struct xop__Include), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xop__Include(struct soap *soap, const struct xop__Include *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xop__Include);
	if (soap_out_xop__Include(soap, tag?tag:"xop:Include", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct xop__Include * SOAP_FMAC4 soap_get_xop__Include(struct soap *soap, struct xop__Include *p, const char *tag, const char *type)
{
	if ((p = soap_in_xop__Include(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__AnalyticsDeviceExtension(struct soap *soap, struct tt__AnalyticsDeviceExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__AnalyticsDeviceExtension(struct soap *soap, const struct tt__AnalyticsDeviceExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AnalyticsDeviceExtension(struct soap *soap, const char *tag, int id, const struct tt__AnalyticsDeviceExtension *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AnalyticsDeviceExtension), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__AnalyticsDeviceExtension * SOAP_FMAC4 soap_in_tt__AnalyticsDeviceExtension(struct soap *soap, const char *tag, struct tt__AnalyticsDeviceExtension *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__AnalyticsDeviceExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AnalyticsDeviceExtension, sizeof(struct tt__AnalyticsDeviceExtension), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__AnalyticsDeviceExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__AnalyticsDeviceExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AnalyticsDeviceExtension, 0, sizeof(struct tt__AnalyticsDeviceExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__AnalyticsDeviceExtension(struct soap *soap, const struct tt__AnalyticsDeviceExtension *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__AnalyticsDeviceExtension);
	if (soap_out_tt__AnalyticsDeviceExtension(soap, tag?tag:"tt:AnalyticsDeviceExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AnalyticsDeviceExtension * SOAP_FMAC4 soap_get_tt__AnalyticsDeviceExtension(struct soap *soap, struct tt__AnalyticsDeviceExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AnalyticsDeviceExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__SystemCapabilitiesExtension2(struct soap *soap, struct tt__SystemCapabilitiesExtension2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__SystemCapabilitiesExtension2(struct soap *soap, const struct tt__SystemCapabilitiesExtension2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__SystemCapabilitiesExtension2(struct soap *soap, const char *tag, int id, const struct tt__SystemCapabilitiesExtension2 *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__SystemCapabilitiesExtension2), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__SystemCapabilitiesExtension2 * SOAP_FMAC4 soap_in_tt__SystemCapabilitiesExtension2(struct soap *soap, const char *tag, struct tt__SystemCapabilitiesExtension2 *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__SystemCapabilitiesExtension2 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__SystemCapabilitiesExtension2, sizeof(struct tt__SystemCapabilitiesExtension2), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__SystemCapabilitiesExtension2(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__SystemCapabilitiesExtension2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__SystemCapabilitiesExtension2, 0, sizeof(struct tt__SystemCapabilitiesExtension2), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__SystemCapabilitiesExtension2(struct soap *soap, const struct tt__SystemCapabilitiesExtension2 *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__SystemCapabilitiesExtension2);
	if (soap_out_tt__SystemCapabilitiesExtension2(soap, tag?tag:"tt:SystemCapabilitiesExtension2", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__SystemCapabilitiesExtension2 * SOAP_FMAC4 soap_get_tt__SystemCapabilitiesExtension2(struct soap *soap, struct tt__SystemCapabilitiesExtension2 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__SystemCapabilitiesExtension2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__SystemCapabilitiesExtension(struct soap *soap, struct tt__SystemCapabilitiesExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
	a->HttpFirmwareUpgrade = NULL;
	a->HttpSystemBackup = NULL;
	a->HttpSystemLogging = NULL;
	a->HttpSupportInformation = NULL;
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__SystemCapabilitiesExtension(struct soap *soap, const struct tt__SystemCapabilitiesExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__boolean_(soap, &a->HttpFirmwareUpgrade);
	soap_serialize_PointerToxsd__boolean_(soap, &a->HttpSystemBackup);
	soap_serialize_PointerToxsd__boolean_(soap, &a->HttpSystemLogging);
	soap_serialize_PointerToxsd__boolean_(soap, &a->HttpSupportInformation);
	soap_serialize_PointerTott__SystemCapabilitiesExtension2(soap, &a->Extension);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__SystemCapabilitiesExtension(struct soap *soap, const char *tag, int id, const struct tt__SystemCapabilitiesExtension *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__SystemCapabilitiesExtension), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	if (soap_out_PointerToxsd__boolean_(soap, "tt:HttpFirmwareUpgrade", -1, &a->HttpFirmwareUpgrade, ""))
		return soap->error;
	if (soap_out_PointerToxsd__boolean_(soap, "tt:HttpSystemBackup", -1, &a->HttpSystemBackup, ""))
		return soap->error;
	if (soap_out_PointerToxsd__boolean_(soap, "tt:HttpSystemLogging", -1, &a->HttpSystemLogging, ""))
		return soap->error;
	if (soap_out_PointerToxsd__boolean_(soap, "tt:HttpSupportInformation", -1, &a->HttpSupportInformation, ""))
		return soap->error;
	if (soap_out_PointerTott__SystemCapabilitiesExtension2(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__SystemCapabilitiesExtension * SOAP_FMAC4 soap_in_tt__SystemCapabilitiesExtension(struct soap *soap, const char *tag, struct tt__SystemCapabilitiesExtension *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	size_t soap_flag_HttpFirmwareUpgrade = 1;
	size_t soap_flag_HttpSystemBackup = 1;
	size_t soap_flag_HttpSystemLogging = 1;
	size_t soap_flag_HttpSupportInformation = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__SystemCapabilitiesExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__SystemCapabilitiesExtension, sizeof(struct tt__SystemCapabilitiesExtension), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__SystemCapabilitiesExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap_flag_HttpFirmwareUpgrade && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__boolean_(soap, "tt:HttpFirmwareUpgrade", &a->HttpFirmwareUpgrade, "xsd:boolean"))
				{	soap_flag_HttpFirmwareUpgrade--;
					continue;
				}
			if (soap_flag_HttpSystemBackup && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__boolean_(soap, "tt:HttpSystemBackup", &a->HttpSystemBackup, "xsd:boolean"))
				{	soap_flag_HttpSystemBackup--;
					continue;
				}
			if (soap_flag_HttpSystemLogging && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__boolean_(soap, "tt:HttpSystemLogging", &a->HttpSystemLogging, "xsd:boolean"))
				{	soap_flag_HttpSystemLogging--;
					continue;
				}
			if (soap_flag_HttpSupportInformation && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__boolean_(soap, "tt:HttpSupportInformation", &a->HttpSupportInformation, "xsd:boolean"))
				{	soap_flag_HttpSupportInformation--;
					continue;
				}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__SystemCapabilitiesExtension2(soap, "tt:Extension", &a->Extension, "tt:SystemCapabilitiesExtension2"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__SystemCapabilitiesExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__SystemCapabilitiesExtension, 0, sizeof(struct tt__SystemCapabilitiesExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__SystemCapabilitiesExtension(struct soap *soap, const struct tt__SystemCapabilitiesExtension *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__SystemCapabilitiesExtension);
	if (soap_out_tt__SystemCapabilitiesExtension(soap, tag?tag:"tt:SystemCapabilitiesExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__SystemCapabilitiesExtension * SOAP_FMAC4 soap_get_tt__SystemCapabilitiesExtension(struct soap *soap, struct tt__SystemCapabilitiesExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__SystemCapabilitiesExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__SecurityCapabilitiesExtension2(struct soap *soap, struct tt__SecurityCapabilitiesExtension2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__boolean_(soap, &a->Dot1X);
	a->__sizeSupportedEAPMethod = 0;
	a->SupportedEAPMethod = NULL;
	soap_default_xsd__boolean_(soap, &a->RemoteUserHandling);
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__SecurityCapabilitiesExtension2(struct soap *soap, const struct tt__SecurityCapabilitiesExtension2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->Dot1X, SOAP_TYPE_xsd__boolean_);
	if (a->SupportedEAPMethod)
	{	int i;
		for (i = 0; i < a->__sizeSupportedEAPMethod; i++)
		{
			soap_embedded(soap, a->SupportedEAPMethod + i, SOAP_TYPE_int);
		}
	}
	soap_embedded(soap, &a->RemoteUserHandling, SOAP_TYPE_xsd__boolean_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__SecurityCapabilitiesExtension2(struct soap *soap, const char *tag, int id, const struct tt__SecurityCapabilitiesExtension2 *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__SecurityCapabilitiesExtension2), type))
		return soap->error;
	if (soap_out_xsd__boolean_(soap, "tt:Dot1X", -1, &a->Dot1X, ""))
		return soap->error;
	if (a->SupportedEAPMethod)
	{	int i;
		for (i = 0; i < a->__sizeSupportedEAPMethod; i++)
			if (soap_out_int(soap, "tt:SupportedEAPMethod", -1, a->SupportedEAPMethod + i, ""))
				return soap->error;
	}
	if (soap_out_xsd__boolean_(soap, "tt:RemoteUserHandling", -1, &a->RemoteUserHandling, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__SecurityCapabilitiesExtension2 * SOAP_FMAC4 soap_in_tt__SecurityCapabilitiesExtension2(struct soap *soap, const char *tag, struct tt__SecurityCapabilitiesExtension2 *a, const char *type)
{
	size_t soap_flag_Dot1X = 1;
	struct soap_blist *soap_blist_SupportedEAPMethod = NULL;
	size_t soap_flag_RemoteUserHandling = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__SecurityCapabilitiesExtension2 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__SecurityCapabilitiesExtension2, sizeof(struct tt__SecurityCapabilitiesExtension2), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__SecurityCapabilitiesExtension2(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Dot1X && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean_(soap, "tt:Dot1X", &a->Dot1X, "xsd:boolean"))
				{	soap_flag_Dot1X--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:SupportedEAPMethod", 1, NULL))
			{	if (a->SupportedEAPMethod == NULL)
				{	if (soap_blist_SupportedEAPMethod == NULL)
						soap_blist_SupportedEAPMethod = soap_new_block(soap);
					a->SupportedEAPMethod = (int *)soap_push_block(soap, soap_blist_SupportedEAPMethod, sizeof(int));
					if (a->SupportedEAPMethod == NULL)
						return NULL;
					soap_default_int(soap, a->SupportedEAPMethod);
				}
				soap_revert(soap);
				if (soap_in_int(soap, "tt:SupportedEAPMethod", a->SupportedEAPMethod, "xsd:int"))
				{	a->__sizeSupportedEAPMethod++;
					a->SupportedEAPMethod = NULL;
					continue;
				}
			}
			if (soap_flag_RemoteUserHandling && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean_(soap, "tt:RemoteUserHandling", &a->RemoteUserHandling, "xsd:boolean"))
				{	soap_flag_RemoteUserHandling--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->SupportedEAPMethod)
			soap_pop_block(soap, soap_blist_SupportedEAPMethod);
		if (a->__sizeSupportedEAPMethod)
			a->SupportedEAPMethod = (int *)soap_save_block(soap, soap_blist_SupportedEAPMethod, NULL, 1);
		else
		{	a->SupportedEAPMethod = NULL;
			if (soap_blist_SupportedEAPMethod)
				soap_end_block(soap, soap_blist_SupportedEAPMethod);
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__SecurityCapabilitiesExtension2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__SecurityCapabilitiesExtension2, 0, sizeof(struct tt__SecurityCapabilitiesExtension2), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Dot1X > 0 || soap_flag_RemoteUserHandling > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__SecurityCapabilitiesExtension2(struct soap *soap, const struct tt__SecurityCapabilitiesExtension2 *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__SecurityCapabilitiesExtension2);
	if (soap_out_tt__SecurityCapabilitiesExtension2(soap, tag?tag:"tt:SecurityCapabilitiesExtension2", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__SecurityCapabilitiesExtension2 * SOAP_FMAC4 soap_get_tt__SecurityCapabilitiesExtension2(struct soap *soap, struct tt__SecurityCapabilitiesExtension2 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__SecurityCapabilitiesExtension2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__SecurityCapabilitiesExtension(struct soap *soap, struct tt__SecurityCapabilitiesExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__boolean_(soap, &a->TLS1_x002e0);
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__SecurityCapabilitiesExtension(struct soap *soap, const struct tt__SecurityCapabilitiesExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->TLS1_x002e0, SOAP_TYPE_xsd__boolean_);
	soap_serialize_PointerTott__SecurityCapabilitiesExtension2(soap, &a->Extension);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__SecurityCapabilitiesExtension(struct soap *soap, const char *tag, int id, const struct tt__SecurityCapabilitiesExtension *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__SecurityCapabilitiesExtension), type))
		return soap->error;
	if (soap_out_xsd__boolean_(soap, "tt:TLS1.0", -1, &a->TLS1_x002e0, ""))
		return soap->error;
	if (soap_out_PointerTott__SecurityCapabilitiesExtension2(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__SecurityCapabilitiesExtension * SOAP_FMAC4 soap_in_tt__SecurityCapabilitiesExtension(struct soap *soap, const char *tag, struct tt__SecurityCapabilitiesExtension *a, const char *type)
{
	size_t soap_flag_TLS1_x002e0 = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__SecurityCapabilitiesExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__SecurityCapabilitiesExtension, sizeof(struct tt__SecurityCapabilitiesExtension), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__SecurityCapabilitiesExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_TLS1_x002e0 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean_(soap, "tt:TLS1.0", &a->TLS1_x002e0, "xsd:boolean"))
				{	soap_flag_TLS1_x002e0--;
					continue;
				}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__SecurityCapabilitiesExtension2(soap, "tt:Extension", &a->Extension, "tt:SecurityCapabilitiesExtension2"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__SecurityCapabilitiesExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__SecurityCapabilitiesExtension, 0, sizeof(struct tt__SecurityCapabilitiesExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_TLS1_x002e0 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__SecurityCapabilitiesExtension(struct soap *soap, const struct tt__SecurityCapabilitiesExtension *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__SecurityCapabilitiesExtension);
	if (soap_out_tt__SecurityCapabilitiesExtension(soap, tag?tag:"tt:SecurityCapabilitiesExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__SecurityCapabilitiesExtension * SOAP_FMAC4 soap_get_tt__SecurityCapabilitiesExtension(struct soap *soap, struct tt__SecurityCapabilitiesExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__SecurityCapabilitiesExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__NetworkCapabilitiesExtension2(struct soap *soap, struct tt__NetworkCapabilitiesExtension2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__NetworkCapabilitiesExtension2(struct soap *soap, const struct tt__NetworkCapabilitiesExtension2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__NetworkCapabilitiesExtension2(struct soap *soap, const char *tag, int id, const struct tt__NetworkCapabilitiesExtension2 *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__NetworkCapabilitiesExtension2), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__NetworkCapabilitiesExtension2 * SOAP_FMAC4 soap_in_tt__NetworkCapabilitiesExtension2(struct soap *soap, const char *tag, struct tt__NetworkCapabilitiesExtension2 *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__NetworkCapabilitiesExtension2 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__NetworkCapabilitiesExtension2, sizeof(struct tt__NetworkCapabilitiesExtension2), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__NetworkCapabilitiesExtension2(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__NetworkCapabilitiesExtension2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__NetworkCapabilitiesExtension2, 0, sizeof(struct tt__NetworkCapabilitiesExtension2), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__NetworkCapabilitiesExtension2(struct soap *soap, const struct tt__NetworkCapabilitiesExtension2 *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__NetworkCapabilitiesExtension2);
	if (soap_out_tt__NetworkCapabilitiesExtension2(soap, tag?tag:"tt:NetworkCapabilitiesExtension2", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__NetworkCapabilitiesExtension2 * SOAP_FMAC4 soap_get_tt__NetworkCapabilitiesExtension2(struct soap *soap, struct tt__NetworkCapabilitiesExtension2 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__NetworkCapabilitiesExtension2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__NetworkCapabilitiesExtension(struct soap *soap, struct tt__NetworkCapabilitiesExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
	a->Dot11Configuration = NULL;
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__NetworkCapabilitiesExtension(struct soap *soap, const struct tt__NetworkCapabilitiesExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__boolean_(soap, &a->Dot11Configuration);
	soap_serialize_PointerTott__NetworkCapabilitiesExtension2(soap, &a->Extension);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__NetworkCapabilitiesExtension(struct soap *soap, const char *tag, int id, const struct tt__NetworkCapabilitiesExtension *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__NetworkCapabilitiesExtension), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	if (soap_out_PointerToxsd__boolean_(soap, "tt:Dot11Configuration", -1, &a->Dot11Configuration, ""))
		return soap->error;
	if (soap_out_PointerTott__NetworkCapabilitiesExtension2(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__NetworkCapabilitiesExtension * SOAP_FMAC4 soap_in_tt__NetworkCapabilitiesExtension(struct soap *soap, const char *tag, struct tt__NetworkCapabilitiesExtension *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	size_t soap_flag_Dot11Configuration = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__NetworkCapabilitiesExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__NetworkCapabilitiesExtension, sizeof(struct tt__NetworkCapabilitiesExtension), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__NetworkCapabilitiesExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap_flag_Dot11Configuration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__boolean_(soap, "tt:Dot11Configuration", &a->Dot11Configuration, "xsd:boolean"))
				{	soap_flag_Dot11Configuration--;
					continue;
				}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__NetworkCapabilitiesExtension2(soap, "tt:Extension", &a->Extension, "tt:NetworkCapabilitiesExtension2"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__NetworkCapabilitiesExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__NetworkCapabilitiesExtension, 0, sizeof(struct tt__NetworkCapabilitiesExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__NetworkCapabilitiesExtension(struct soap *soap, const struct tt__NetworkCapabilitiesExtension *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__NetworkCapabilitiesExtension);
	if (soap_out_tt__NetworkCapabilitiesExtension(soap, tag?tag:"tt:NetworkCapabilitiesExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__NetworkCapabilitiesExtension * SOAP_FMAC4 soap_get_tt__NetworkCapabilitiesExtension(struct soap *soap, struct tt__NetworkCapabilitiesExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__NetworkCapabilitiesExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__RealTimeStreamingCapabilitiesExtension(struct soap *soap, struct tt__RealTimeStreamingCapabilitiesExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__RealTimeStreamingCapabilitiesExtension(struct soap *soap, const struct tt__RealTimeStreamingCapabilitiesExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__RealTimeStreamingCapabilitiesExtension(struct soap *soap, const char *tag, int id, const struct tt__RealTimeStreamingCapabilitiesExtension *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__RealTimeStreamingCapabilitiesExtension), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__RealTimeStreamingCapabilitiesExtension * SOAP_FMAC4 soap_in_tt__RealTimeStreamingCapabilitiesExtension(struct soap *soap, const char *tag, struct tt__RealTimeStreamingCapabilitiesExtension *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__RealTimeStreamingCapabilitiesExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RealTimeStreamingCapabilitiesExtension, sizeof(struct tt__RealTimeStreamingCapabilitiesExtension), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__RealTimeStreamingCapabilitiesExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__RealTimeStreamingCapabilitiesExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__RealTimeStreamingCapabilitiesExtension, 0, sizeof(struct tt__RealTimeStreamingCapabilitiesExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__RealTimeStreamingCapabilitiesExtension(struct soap *soap, const struct tt__RealTimeStreamingCapabilitiesExtension *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__RealTimeStreamingCapabilitiesExtension);
	if (soap_out_tt__RealTimeStreamingCapabilitiesExtension(soap, tag?tag:"tt:RealTimeStreamingCapabilitiesExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__RealTimeStreamingCapabilitiesExtension * SOAP_FMAC4 soap_get_tt__RealTimeStreamingCapabilitiesExtension(struct soap *soap, struct tt__RealTimeStreamingCapabilitiesExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__RealTimeStreamingCapabilitiesExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__ProfileCapabilities(struct soap *soap, struct tt__ProfileCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->MaximumNumberOfProfiles);
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__ProfileCapabilities(struct soap *soap, const struct tt__ProfileCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->MaximumNumberOfProfiles, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ProfileCapabilities(struct soap *soap, const char *tag, int id, const struct tt__ProfileCapabilities *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ProfileCapabilities), type))
		return soap->error;
	if (soap_out_int(soap, "tt:MaximumNumberOfProfiles", -1, &a->MaximumNumberOfProfiles, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__ProfileCapabilities * SOAP_FMAC4 soap_in_tt__ProfileCapabilities(struct soap *soap, const char *tag, struct tt__ProfileCapabilities *a, const char *type)
{
	size_t soap_flag_MaximumNumberOfProfiles = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__ProfileCapabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ProfileCapabilities, sizeof(struct tt__ProfileCapabilities), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__ProfileCapabilities(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_MaximumNumberOfProfiles && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "tt:MaximumNumberOfProfiles", &a->MaximumNumberOfProfiles, "xsd:int"))
				{	soap_flag_MaximumNumberOfProfiles--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__ProfileCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ProfileCapabilities, 0, sizeof(struct tt__ProfileCapabilities), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_MaximumNumberOfProfiles > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ProfileCapabilities(struct soap *soap, const struct tt__ProfileCapabilities *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__ProfileCapabilities);
	if (soap_out_tt__ProfileCapabilities(soap, tag?tag:"tt:ProfileCapabilities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ProfileCapabilities * SOAP_FMAC4 soap_get_tt__ProfileCapabilities(struct soap *soap, struct tt__ProfileCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ProfileCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__MediaCapabilitiesExtension(struct soap *soap, struct tt__MediaCapabilitiesExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ProfileCapabilities = NULL;
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__MediaCapabilitiesExtension(struct soap *soap, const struct tt__MediaCapabilitiesExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTott__ProfileCapabilities(soap, &a->ProfileCapabilities);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__MediaCapabilitiesExtension(struct soap *soap, const char *tag, int id, const struct tt__MediaCapabilitiesExtension *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__MediaCapabilitiesExtension), type))
		return soap->error;
	if (a->ProfileCapabilities)
	{	if (soap_out_PointerTott__ProfileCapabilities(soap, "tt:ProfileCapabilities", -1, &a->ProfileCapabilities, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:ProfileCapabilities"))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__MediaCapabilitiesExtension * SOAP_FMAC4 soap_in_tt__MediaCapabilitiesExtension(struct soap *soap, const char *tag, struct tt__MediaCapabilitiesExtension *a, const char *type)
{
	size_t soap_flag_ProfileCapabilities = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__MediaCapabilitiesExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__MediaCapabilitiesExtension, sizeof(struct tt__MediaCapabilitiesExtension), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__MediaCapabilitiesExtension(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ProfileCapabilities && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__ProfileCapabilities(soap, "tt:ProfileCapabilities", &a->ProfileCapabilities, "tt:ProfileCapabilities"))
				{	soap_flag_ProfileCapabilities--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__MediaCapabilitiesExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__MediaCapabilitiesExtension, 0, sizeof(struct tt__MediaCapabilitiesExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ProfileCapabilities > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__MediaCapabilitiesExtension(struct soap *soap, const struct tt__MediaCapabilitiesExtension *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__MediaCapabilitiesExtension);
	if (soap_out_tt__MediaCapabilitiesExtension(soap, tag?tag:"tt:MediaCapabilitiesExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__MediaCapabilitiesExtension * SOAP_FMAC4 soap_get_tt__MediaCapabilitiesExtension(struct soap *soap, struct tt__MediaCapabilitiesExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__MediaCapabilitiesExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__RealTimeStreamingCapabilities(struct soap *soap, struct tt__RealTimeStreamingCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->RTPMulticast = NULL;
	a->RTP_USCORETCP = NULL;
	a->RTP_USCORERTSP_USCORETCP = NULL;
	a->Extension = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__RealTimeStreamingCapabilities(struct soap *soap, const struct tt__RealTimeStreamingCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__boolean_(soap, &a->RTPMulticast);
	soap_serialize_PointerToxsd__boolean_(soap, &a->RTP_USCORETCP);
	soap_serialize_PointerToxsd__boolean_(soap, &a->RTP_USCORERTSP_USCORETCP);
	soap_serialize_PointerTott__RealTimeStreamingCapabilitiesExtension(soap, &a->Extension);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__RealTimeStreamingCapabilities(struct soap *soap, const char *tag, int id, const struct tt__RealTimeStreamingCapabilities *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__RealTimeStreamingCapabilities), type))
		return soap->error;
	if (soap_out_PointerToxsd__boolean_(soap, "tt:RTPMulticast", -1, &a->RTPMulticast, ""))
		return soap->error;
	if (soap_out_PointerToxsd__boolean_(soap, "tt:RTP_TCP", -1, &a->RTP_USCORETCP, ""))
		return soap->error;
	if (soap_out_PointerToxsd__boolean_(soap, "tt:RTP_RTSP_TCP", -1, &a->RTP_USCORERTSP_USCORETCP, ""))
		return soap->error;
	if (soap_out_PointerTott__RealTimeStreamingCapabilitiesExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__RealTimeStreamingCapabilities * SOAP_FMAC4 soap_in_tt__RealTimeStreamingCapabilities(struct soap *soap, const char *tag, struct tt__RealTimeStreamingCapabilities *a, const char *type)
{
	size_t soap_flag_RTPMulticast = 1;
	size_t soap_flag_RTP_USCORETCP = 1;
	size_t soap_flag_RTP_USCORERTSP_USCORETCP = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__RealTimeStreamingCapabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RealTimeStreamingCapabilities, sizeof(struct tt__RealTimeStreamingCapabilities), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__RealTimeStreamingCapabilities(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RTPMulticast && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__boolean_(soap, "tt:RTPMulticast", &a->RTPMulticast, "xsd:boolean"))
				{	soap_flag_RTPMulticast--;
					continue;
				}
			if (soap_flag_RTP_USCORETCP && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__boolean_(soap, "tt:RTP_TCP", &a->RTP_USCORETCP, "xsd:boolean"))
				{	soap_flag_RTP_USCORETCP--;
					continue;
				}
			if (soap_flag_RTP_USCORERTSP_USCORETCP && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__boolean_(soap, "tt:RTP_RTSP_TCP", &a->RTP_USCORERTSP_USCORETCP, "xsd:boolean"))
				{	soap_flag_RTP_USCORERTSP_USCORETCP--;
					continue;
				}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__RealTimeStreamingCapabilitiesExtension(soap, "tt:Extension", &a->Extension, "tt:RealTimeStreamingCapabilitiesExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__RealTimeStreamingCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__RealTimeStreamingCapabilities, 0, sizeof(struct tt__RealTimeStreamingCapabilities), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__RealTimeStreamingCapabilities(struct soap *soap, const struct tt__RealTimeStreamingCapabilities *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__RealTimeStreamingCapabilities);
	if (soap_out_tt__RealTimeStreamingCapabilities(soap, tag?tag:"tt:RealTimeStreamingCapabilities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__RealTimeStreamingCapabilities * SOAP_FMAC4 soap_get_tt__RealTimeStreamingCapabilities(struct soap *soap, struct tt__RealTimeStreamingCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__RealTimeStreamingCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__IOCapabilitiesExtension2(struct soap *soap, struct tt__IOCapabilitiesExtension2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__IOCapabilitiesExtension2(struct soap *soap, const struct tt__IOCapabilitiesExtension2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IOCapabilitiesExtension2(struct soap *soap, const char *tag, int id, const struct tt__IOCapabilitiesExtension2 *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__IOCapabilitiesExtension2), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__IOCapabilitiesExtension2 * SOAP_FMAC4 soap_in_tt__IOCapabilitiesExtension2(struct soap *soap, const char *tag, struct tt__IOCapabilitiesExtension2 *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__IOCapabilitiesExtension2 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IOCapabilitiesExtension2, sizeof(struct tt__IOCapabilitiesExtension2), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__IOCapabilitiesExtension2(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__IOCapabilitiesExtension2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__IOCapabilitiesExtension2, 0, sizeof(struct tt__IOCapabilitiesExtension2), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__IOCapabilitiesExtension2(struct soap *soap, const struct tt__IOCapabilitiesExtension2 *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__IOCapabilitiesExtension2);
	if (soap_out_tt__IOCapabilitiesExtension2(soap, tag?tag:"tt:IOCapabilitiesExtension2", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__IOCapabilitiesExtension2 * SOAP_FMAC4 soap_get_tt__IOCapabilitiesExtension2(struct soap *soap, struct tt__IOCapabilitiesExtension2 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__IOCapabilitiesExtension2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__IOCapabilitiesExtension(struct soap *soap, struct tt__IOCapabilitiesExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
	a->Auxiliary = NULL;
	a->__sizeAuxiliaryCommands = 0;
	a->AuxiliaryCommands = NULL;
	a->Extension = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__IOCapabilitiesExtension(struct soap *soap, const struct tt__IOCapabilitiesExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__boolean_(soap, &a->Auxiliary);
	if (a->AuxiliaryCommands)
	{	int i;
		for (i = 0; i < a->__sizeAuxiliaryCommands; i++)
		{
			soap_serialize_tt__AuxiliaryData(soap, a->AuxiliaryCommands + i);
		}
	}
	soap_serialize_PointerTott__IOCapabilitiesExtension2(soap, &a->Extension);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IOCapabilitiesExtension(struct soap *soap, const char *tag, int id, const struct tt__IOCapabilitiesExtension *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__IOCapabilitiesExtension), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	if (soap_out_PointerToxsd__boolean_(soap, "tt:Auxiliary", -1, &a->Auxiliary, ""))
		return soap->error;
	if (a->AuxiliaryCommands)
	{	int i;
		for (i = 0; i < a->__sizeAuxiliaryCommands; i++)
			if (soap_out_tt__AuxiliaryData(soap, "tt:AuxiliaryCommands", -1, a->AuxiliaryCommands + i, ""))
				return soap->error;
	}
	if (a->Extension)
	{	if (soap_out_PointerTott__IOCapabilitiesExtension2(soap, "tt:Extension", -1, &a->Extension, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:Extension"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__IOCapabilitiesExtension * SOAP_FMAC4 soap_in_tt__IOCapabilitiesExtension(struct soap *soap, const char *tag, struct tt__IOCapabilitiesExtension *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	size_t soap_flag_Auxiliary = 1;
	struct soap_blist *soap_blist_AuxiliaryCommands = NULL;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__IOCapabilitiesExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IOCapabilitiesExtension, sizeof(struct tt__IOCapabilitiesExtension), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__IOCapabilitiesExtension(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap_flag_Auxiliary && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__boolean_(soap, "tt:Auxiliary", &a->Auxiliary, "xsd:boolean"))
				{	soap_flag_Auxiliary--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:AuxiliaryCommands", 1, NULL))
			{	if (a->AuxiliaryCommands == NULL)
				{	if (soap_blist_AuxiliaryCommands == NULL)
						soap_blist_AuxiliaryCommands = soap_new_block(soap);
					a->AuxiliaryCommands = (char **)soap_push_block(soap, soap_blist_AuxiliaryCommands, sizeof(char *));
					if (a->AuxiliaryCommands == NULL)
						return NULL;
					*a->AuxiliaryCommands = NULL;
				}
				soap_revert(soap);
				if (soap_in_tt__AuxiliaryData(soap, "tt:AuxiliaryCommands", a->AuxiliaryCommands, "tt:AuxiliaryData"))
				{	a->__sizeAuxiliaryCommands++;
					a->AuxiliaryCommands = NULL;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IOCapabilitiesExtension2(soap, "tt:Extension", &a->Extension, "tt:IOCapabilitiesExtension2"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (a->AuxiliaryCommands)
			soap_pop_block(soap, soap_blist_AuxiliaryCommands);
		if (a->__sizeAuxiliaryCommands)
			a->AuxiliaryCommands = (char **)soap_save_block(soap, soap_blist_AuxiliaryCommands, NULL, 1);
		else
		{	a->AuxiliaryCommands = NULL;
			if (soap_blist_AuxiliaryCommands)
				soap_end_block(soap, soap_blist_AuxiliaryCommands);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__IOCapabilitiesExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__IOCapabilitiesExtension, 0, sizeof(struct tt__IOCapabilitiesExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Extension > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__IOCapabilitiesExtension(struct soap *soap, const struct tt__IOCapabilitiesExtension *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__IOCapabilitiesExtension);
	if (soap_out_tt__IOCapabilitiesExtension(soap, tag?tag:"tt:IOCapabilitiesExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__IOCapabilitiesExtension * SOAP_FMAC4 soap_get_tt__IOCapabilitiesExtension(struct soap *soap, struct tt__IOCapabilitiesExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__IOCapabilitiesExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__DeviceCapabilitiesExtension(struct soap *soap, struct tt__DeviceCapabilitiesExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__DeviceCapabilitiesExtension(struct soap *soap, const struct tt__DeviceCapabilitiesExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__DeviceCapabilitiesExtension(struct soap *soap, const char *tag, int id, const struct tt__DeviceCapabilitiesExtension *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__DeviceCapabilitiesExtension), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__DeviceCapabilitiesExtension * SOAP_FMAC4 soap_in_tt__DeviceCapabilitiesExtension(struct soap *soap, const char *tag, struct tt__DeviceCapabilitiesExtension *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__DeviceCapabilitiesExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__DeviceCapabilitiesExtension, sizeof(struct tt__DeviceCapabilitiesExtension), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__DeviceCapabilitiesExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__DeviceCapabilitiesExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__DeviceCapabilitiesExtension, 0, sizeof(struct tt__DeviceCapabilitiesExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__DeviceCapabilitiesExtension(struct soap *soap, const struct tt__DeviceCapabilitiesExtension *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__DeviceCapabilitiesExtension);
	if (soap_out_tt__DeviceCapabilitiesExtension(soap, tag?tag:"tt:DeviceCapabilitiesExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__DeviceCapabilitiesExtension * SOAP_FMAC4 soap_get_tt__DeviceCapabilitiesExtension(struct soap *soap, struct tt__DeviceCapabilitiesExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__DeviceCapabilitiesExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__SecurityCapabilities(struct soap *soap, struct tt__SecurityCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__boolean_(soap, &a->TLS1_x002e1);
	soap_default_xsd__boolean_(soap, &a->TLS1_x002e2);
	soap_default_xsd__boolean_(soap, &a->OnboardKeyGeneration);
	soap_default_xsd__boolean_(soap, &a->AccessPolicyConfig);
	soap_default_xsd__boolean_(soap, &a->X_x002e509Token);
	soap_default_xsd__boolean_(soap, &a->SAMLToken);
	soap_default_xsd__boolean_(soap, &a->KerberosToken);
	soap_default_xsd__boolean_(soap, &a->RELToken);
	a->__size = 0;
	a->__any = NULL;
	a->Extension = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__SecurityCapabilities(struct soap *soap, const struct tt__SecurityCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->TLS1_x002e1, SOAP_TYPE_xsd__boolean_);
	soap_embedded(soap, &a->TLS1_x002e2, SOAP_TYPE_xsd__boolean_);
	soap_embedded(soap, &a->OnboardKeyGeneration, SOAP_TYPE_xsd__boolean_);
	soap_embedded(soap, &a->AccessPolicyConfig, SOAP_TYPE_xsd__boolean_);
	soap_embedded(soap, &a->X_x002e509Token, SOAP_TYPE_xsd__boolean_);
	soap_embedded(soap, &a->SAMLToken, SOAP_TYPE_xsd__boolean_);
	soap_embedded(soap, &a->KerberosToken, SOAP_TYPE_xsd__boolean_);
	soap_embedded(soap, &a->RELToken, SOAP_TYPE_xsd__boolean_);
	soap_serialize_PointerTott__SecurityCapabilitiesExtension(soap, &a->Extension);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__SecurityCapabilities(struct soap *soap, const char *tag, int id, const struct tt__SecurityCapabilities *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__SecurityCapabilities), type))
		return soap->error;
	if (soap_out_xsd__boolean_(soap, "tt:TLS1.1", -1, &a->TLS1_x002e1, ""))
		return soap->error;
	if (soap_out_xsd__boolean_(soap, "tt:TLS1.2", -1, &a->TLS1_x002e2, ""))
		return soap->error;
	if (soap_out_xsd__boolean_(soap, "tt:OnboardKeyGeneration", -1, &a->OnboardKeyGeneration, ""))
		return soap->error;
	if (soap_out_xsd__boolean_(soap, "tt:AccessPolicyConfig", -1, &a->AccessPolicyConfig, ""))
		return soap->error;
	if (soap_out_xsd__boolean_(soap, "tt:X.509Token", -1, &a->X_x002e509Token, ""))
		return soap->error;
	if (soap_out_xsd__boolean_(soap, "tt:SAMLToken", -1, &a->SAMLToken, ""))
		return soap->error;
	if (soap_out_xsd__boolean_(soap, "tt:KerberosToken", -1, &a->KerberosToken, ""))
		return soap->error;
	if (soap_out_xsd__boolean_(soap, "tt:RELToken", -1, &a->RELToken, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	if (soap_out_PointerTott__SecurityCapabilitiesExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__SecurityCapabilities * SOAP_FMAC4 soap_in_tt__SecurityCapabilities(struct soap *soap, const char *tag, struct tt__SecurityCapabilities *a, const char *type)
{
	size_t soap_flag_TLS1_x002e1 = 1;
	size_t soap_flag_TLS1_x002e2 = 1;
	size_t soap_flag_OnboardKeyGeneration = 1;
	size_t soap_flag_AccessPolicyConfig = 1;
	size_t soap_flag_X_x002e509Token = 1;
	size_t soap_flag_SAMLToken = 1;
	size_t soap_flag_KerberosToken = 1;
	size_t soap_flag_RELToken = 1;
	struct soap_blist *soap_blist___any = NULL;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__SecurityCapabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__SecurityCapabilities, sizeof(struct tt__SecurityCapabilities), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__SecurityCapabilities(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_TLS1_x002e1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean_(soap, "tt:TLS1.1", &a->TLS1_x002e1, "xsd:boolean"))
				{	soap_flag_TLS1_x002e1--;
					continue;
				}
			if (soap_flag_TLS1_x002e2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean_(soap, "tt:TLS1.2", &a->TLS1_x002e2, "xsd:boolean"))
				{	soap_flag_TLS1_x002e2--;
					continue;
				}
			if (soap_flag_OnboardKeyGeneration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean_(soap, "tt:OnboardKeyGeneration", &a->OnboardKeyGeneration, "xsd:boolean"))
				{	soap_flag_OnboardKeyGeneration--;
					continue;
				}
			if (soap_flag_AccessPolicyConfig && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean_(soap, "tt:AccessPolicyConfig", &a->AccessPolicyConfig, "xsd:boolean"))
				{	soap_flag_AccessPolicyConfig--;
					continue;
				}
			if (soap_flag_X_x002e509Token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean_(soap, "tt:X.509Token", &a->X_x002e509Token, "xsd:boolean"))
				{	soap_flag_X_x002e509Token--;
					continue;
				}
			if (soap_flag_SAMLToken && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean_(soap, "tt:SAMLToken", &a->SAMLToken, "xsd:boolean"))
				{	soap_flag_SAMLToken--;
					continue;
				}
			if (soap_flag_KerberosToken && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean_(soap, "tt:KerberosToken", &a->KerberosToken, "xsd:boolean"))
				{	soap_flag_KerberosToken--;
					continue;
				}
			if (soap_flag_RELToken && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean_(soap, "tt:RELToken", &a->RELToken, "xsd:boolean"))
				{	soap_flag_RELToken--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__SecurityCapabilitiesExtension(soap, "tt:Extension", &a->Extension, "tt:SecurityCapabilitiesExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__SecurityCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__SecurityCapabilities, 0, sizeof(struct tt__SecurityCapabilities), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_TLS1_x002e1 > 0 || soap_flag_TLS1_x002e2 > 0 || soap_flag_OnboardKeyGeneration > 0 || soap_flag_AccessPolicyConfig > 0 || soap_flag_X_x002e509Token > 0 || soap_flag_SAMLToken > 0 || soap_flag_KerberosToken > 0 || soap_flag_RELToken > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__SecurityCapabilities(struct soap *soap, const struct tt__SecurityCapabilities *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__SecurityCapabilities);
	if (soap_out_tt__SecurityCapabilities(soap, tag?tag:"tt:SecurityCapabilities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__SecurityCapabilities * SOAP_FMAC4 soap_get_tt__SecurityCapabilities(struct soap *soap, struct tt__SecurityCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__SecurityCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__IOCapabilities(struct soap *soap, struct tt__IOCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->InputConnectors = NULL;
	a->RelayOutputs = NULL;
	a->Extension = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__IOCapabilities(struct soap *soap, const struct tt__IOCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToint(soap, &a->InputConnectors);
	soap_serialize_PointerToint(soap, &a->RelayOutputs);
	soap_serialize_PointerTott__IOCapabilitiesExtension(soap, &a->Extension);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IOCapabilities(struct soap *soap, const char *tag, int id, const struct tt__IOCapabilities *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__IOCapabilities), type))
		return soap->error;
	if (soap_out_PointerToint(soap, "tt:InputConnectors", -1, &a->InputConnectors, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "tt:RelayOutputs", -1, &a->RelayOutputs, ""))
		return soap->error;
	if (soap_out_PointerTott__IOCapabilitiesExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__IOCapabilities * SOAP_FMAC4 soap_in_tt__IOCapabilities(struct soap *soap, const char *tag, struct tt__IOCapabilities *a, const char *type)
{
	size_t soap_flag_InputConnectors = 1;
	size_t soap_flag_RelayOutputs = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__IOCapabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IOCapabilities, sizeof(struct tt__IOCapabilities), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__IOCapabilities(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_InputConnectors && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "tt:InputConnectors", &a->InputConnectors, "xsd:int"))
				{	soap_flag_InputConnectors--;
					continue;
				}
			if (soap_flag_RelayOutputs && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "tt:RelayOutputs", &a->RelayOutputs, "xsd:int"))
				{	soap_flag_RelayOutputs--;
					continue;
				}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IOCapabilitiesExtension(soap, "tt:Extension", &a->Extension, "tt:IOCapabilitiesExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__IOCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__IOCapabilities, 0, sizeof(struct tt__IOCapabilities), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__IOCapabilities(struct soap *soap, const struct tt__IOCapabilities *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__IOCapabilities);
	if (soap_out_tt__IOCapabilities(soap, tag?tag:"tt:IOCapabilities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__IOCapabilities * SOAP_FMAC4 soap_get_tt__IOCapabilities(struct soap *soap, struct tt__IOCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__IOCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__SystemCapabilities(struct soap *soap, struct tt__SystemCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__boolean_(soap, &a->DiscoveryResolve);
	soap_default_xsd__boolean_(soap, &a->DiscoveryBye);
	soap_default_xsd__boolean_(soap, &a->RemoteDiscovery);
	soap_default_xsd__boolean_(soap, &a->SystemBackup);
	soap_default_xsd__boolean_(soap, &a->SystemLogging);
	soap_default_xsd__boolean_(soap, &a->FirmwareUpgrade);
	a->__sizeSupportedVersions = 0;
	a->SupportedVersions = NULL;
	a->Extension = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__SystemCapabilities(struct soap *soap, const struct tt__SystemCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->DiscoveryResolve, SOAP_TYPE_xsd__boolean_);
	soap_embedded(soap, &a->DiscoveryBye, SOAP_TYPE_xsd__boolean_);
	soap_embedded(soap, &a->RemoteDiscovery, SOAP_TYPE_xsd__boolean_);
	soap_embedded(soap, &a->SystemBackup, SOAP_TYPE_xsd__boolean_);
	soap_embedded(soap, &a->SystemLogging, SOAP_TYPE_xsd__boolean_);
	soap_embedded(soap, &a->FirmwareUpgrade, SOAP_TYPE_xsd__boolean_);
	if (a->SupportedVersions)
	{	int i;
		for (i = 0; i < a->__sizeSupportedVersions; i++)
		{
			soap_embedded(soap, a->SupportedVersions + i, SOAP_TYPE_tt__OnvifVersion);
			soap_serialize_tt__OnvifVersion(soap, a->SupportedVersions + i);
		}
	}
	soap_serialize_PointerTott__SystemCapabilitiesExtension(soap, &a->Extension);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__SystemCapabilities(struct soap *soap, const char *tag, int id, const struct tt__SystemCapabilities *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__SystemCapabilities), type))
		return soap->error;
	if (soap_out_xsd__boolean_(soap, "tt:DiscoveryResolve", -1, &a->DiscoveryResolve, ""))
		return soap->error;
	if (soap_out_xsd__boolean_(soap, "tt:DiscoveryBye", -1, &a->DiscoveryBye, ""))
		return soap->error;
	if (soap_out_xsd__boolean_(soap, "tt:RemoteDiscovery", -1, &a->RemoteDiscovery, ""))
		return soap->error;
	if (soap_out_xsd__boolean_(soap, "tt:SystemBackup", -1, &a->SystemBackup, ""))
		return soap->error;
	if (soap_out_xsd__boolean_(soap, "tt:SystemLogging", -1, &a->SystemLogging, ""))
		return soap->error;
	if (soap_out_xsd__boolean_(soap, "tt:FirmwareUpgrade", -1, &a->FirmwareUpgrade, ""))
		return soap->error;
	if (a->SupportedVersions)
	{	int i;
		for (i = 0; i < a->__sizeSupportedVersions; i++)
			if (soap_out_tt__OnvifVersion(soap, "tt:SupportedVersions", -1, a->SupportedVersions + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTott__SystemCapabilitiesExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__SystemCapabilities * SOAP_FMAC4 soap_in_tt__SystemCapabilities(struct soap *soap, const char *tag, struct tt__SystemCapabilities *a, const char *type)
{
	size_t soap_flag_DiscoveryResolve = 1;
	size_t soap_flag_DiscoveryBye = 1;
	size_t soap_flag_RemoteDiscovery = 1;
	size_t soap_flag_SystemBackup = 1;
	size_t soap_flag_SystemLogging = 1;
	size_t soap_flag_FirmwareUpgrade = 1;
	struct soap_blist *soap_blist_SupportedVersions = NULL;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__SystemCapabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__SystemCapabilities, sizeof(struct tt__SystemCapabilities), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__SystemCapabilities(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_DiscoveryResolve && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean_(soap, "tt:DiscoveryResolve", &a->DiscoveryResolve, "xsd:boolean"))
				{	soap_flag_DiscoveryResolve--;
					continue;
				}
			if (soap_flag_DiscoveryBye && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean_(soap, "tt:DiscoveryBye", &a->DiscoveryBye, "xsd:boolean"))
				{	soap_flag_DiscoveryBye--;
					continue;
				}
			if (soap_flag_RemoteDiscovery && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean_(soap, "tt:RemoteDiscovery", &a->RemoteDiscovery, "xsd:boolean"))
				{	soap_flag_RemoteDiscovery--;
					continue;
				}
			if (soap_flag_SystemBackup && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean_(soap, "tt:SystemBackup", &a->SystemBackup, "xsd:boolean"))
				{	soap_flag_SystemBackup--;
					continue;
				}
			if (soap_flag_SystemLogging && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean_(soap, "tt:SystemLogging", &a->SystemLogging, "xsd:boolean"))
				{	soap_flag_SystemLogging--;
					continue;
				}
			if (soap_flag_FirmwareUpgrade && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean_(soap, "tt:FirmwareUpgrade", &a->FirmwareUpgrade, "xsd:boolean"))
				{	soap_flag_FirmwareUpgrade--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:SupportedVersions", 1, NULL))
			{	if (a->SupportedVersions == NULL)
				{	if (soap_blist_SupportedVersions == NULL)
						soap_blist_SupportedVersions = soap_new_block(soap);
					a->SupportedVersions = (struct tt__OnvifVersion *)soap_push_block(soap, soap_blist_SupportedVersions, sizeof(struct tt__OnvifVersion));
					if (a->SupportedVersions == NULL)
						return NULL;
					soap_default_tt__OnvifVersion(soap, a->SupportedVersions);
				}
				soap_revert(soap);
				if (soap_in_tt__OnvifVersion(soap, "tt:SupportedVersions", a->SupportedVersions, "tt:OnvifVersion"))
				{	a->__sizeSupportedVersions++;
					a->SupportedVersions = NULL;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__SystemCapabilitiesExtension(soap, "tt:Extension", &a->Extension, "tt:SystemCapabilitiesExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->SupportedVersions)
			soap_pop_block(soap, soap_blist_SupportedVersions);
		if (a->__sizeSupportedVersions)
			a->SupportedVersions = (struct tt__OnvifVersion *)soap_save_block(soap, soap_blist_SupportedVersions, NULL, 1);
		else
		{	a->SupportedVersions = NULL;
			if (soap_blist_SupportedVersions)
				soap_end_block(soap, soap_blist_SupportedVersions);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__SystemCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__SystemCapabilities, 0, sizeof(struct tt__SystemCapabilities), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_DiscoveryResolve > 0 || soap_flag_DiscoveryBye > 0 || soap_flag_RemoteDiscovery > 0 || soap_flag_SystemBackup > 0 || soap_flag_SystemLogging > 0 || soap_flag_FirmwareUpgrade > 0 || a->__sizeSupportedVersions < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__SystemCapabilities(struct soap *soap, const struct tt__SystemCapabilities *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__SystemCapabilities);
	if (soap_out_tt__SystemCapabilities(soap, tag?tag:"tt:SystemCapabilities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__SystemCapabilities * SOAP_FMAC4 soap_get_tt__SystemCapabilities(struct soap *soap, struct tt__SystemCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__SystemCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__NetworkCapabilities(struct soap *soap, struct tt__NetworkCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->IPFilter = NULL;
	a->ZeroConfiguration = NULL;
	a->IPVersion6 = NULL;
	a->DynDNS = NULL;
	a->Extension = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__NetworkCapabilities(struct soap *soap, const struct tt__NetworkCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__boolean_(soap, &a->IPFilter);
	soap_serialize_PointerToxsd__boolean_(soap, &a->ZeroConfiguration);
	soap_serialize_PointerToxsd__boolean_(soap, &a->IPVersion6);
	soap_serialize_PointerToxsd__boolean_(soap, &a->DynDNS);
	soap_serialize_PointerTott__NetworkCapabilitiesExtension(soap, &a->Extension);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__NetworkCapabilities(struct soap *soap, const char *tag, int id, const struct tt__NetworkCapabilities *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__NetworkCapabilities), type))
		return soap->error;
	if (soap_out_PointerToxsd__boolean_(soap, "tt:IPFilter", -1, &a->IPFilter, ""))
		return soap->error;
	if (soap_out_PointerToxsd__boolean_(soap, "tt:ZeroConfiguration", -1, &a->ZeroConfiguration, ""))
		return soap->error;
	if (soap_out_PointerToxsd__boolean_(soap, "tt:IPVersion6", -1, &a->IPVersion6, ""))
		return soap->error;
	if (soap_out_PointerToxsd__boolean_(soap, "tt:DynDNS", -1, &a->DynDNS, ""))
		return soap->error;
	if (soap_out_PointerTott__NetworkCapabilitiesExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__NetworkCapabilities * SOAP_FMAC4 soap_in_tt__NetworkCapabilities(struct soap *soap, const char *tag, struct tt__NetworkCapabilities *a, const char *type)
{
	size_t soap_flag_IPFilter = 1;
	size_t soap_flag_ZeroConfiguration = 1;
	size_t soap_flag_IPVersion6 = 1;
	size_t soap_flag_DynDNS = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__NetworkCapabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__NetworkCapabilities, sizeof(struct tt__NetworkCapabilities), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__NetworkCapabilities(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_IPFilter && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__boolean_(soap, "tt:IPFilter", &a->IPFilter, "xsd:boolean"))
				{	soap_flag_IPFilter--;
					continue;
				}
			if (soap_flag_ZeroConfiguration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__boolean_(soap, "tt:ZeroConfiguration", &a->ZeroConfiguration, "xsd:boolean"))
				{	soap_flag_ZeroConfiguration--;
					continue;
				}
			if (soap_flag_IPVersion6 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__boolean_(soap, "tt:IPVersion6", &a->IPVersion6, "xsd:boolean"))
				{	soap_flag_IPVersion6--;
					continue;
				}
			if (soap_flag_DynDNS && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__boolean_(soap, "tt:DynDNS", &a->DynDNS, "xsd:boolean"))
				{	soap_flag_DynDNS--;
					continue;
				}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__NetworkCapabilitiesExtension(soap, "tt:Extension", &a->Extension, "tt:NetworkCapabilitiesExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__NetworkCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__NetworkCapabilities, 0, sizeof(struct tt__NetworkCapabilities), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__NetworkCapabilities(struct soap *soap, const struct tt__NetworkCapabilities *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__NetworkCapabilities);
	if (soap_out_tt__NetworkCapabilities(soap, tag?tag:"tt:NetworkCapabilities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__NetworkCapabilities * SOAP_FMAC4 soap_get_tt__NetworkCapabilities(struct soap *soap, struct tt__NetworkCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__NetworkCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__CapabilitiesExtension2(struct soap *soap, struct tt__CapabilitiesExtension2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__CapabilitiesExtension2(struct soap *soap, const struct tt__CapabilitiesExtension2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__CapabilitiesExtension2(struct soap *soap, const char *tag, int id, const struct tt__CapabilitiesExtension2 *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__CapabilitiesExtension2), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__CapabilitiesExtension2 * SOAP_FMAC4 soap_in_tt__CapabilitiesExtension2(struct soap *soap, const char *tag, struct tt__CapabilitiesExtension2 *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__CapabilitiesExtension2 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__CapabilitiesExtension2, sizeof(struct tt__CapabilitiesExtension2), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__CapabilitiesExtension2(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__CapabilitiesExtension2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__CapabilitiesExtension2, 0, sizeof(struct tt__CapabilitiesExtension2), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__CapabilitiesExtension2(struct soap *soap, const struct tt__CapabilitiesExtension2 *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__CapabilitiesExtension2);
	if (soap_out_tt__CapabilitiesExtension2(soap, tag?tag:"tt:CapabilitiesExtension2", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__CapabilitiesExtension2 * SOAP_FMAC4 soap_get_tt__CapabilitiesExtension2(struct soap *soap, struct tt__CapabilitiesExtension2 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__CapabilitiesExtension2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__AnalyticsDeviceCapabilities(struct soap *soap, struct tt__AnalyticsDeviceCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->XAddr);
	a->RuleSupport = NULL;
	a->Extension = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__AnalyticsDeviceCapabilities(struct soap *soap, const struct tt__AnalyticsDeviceCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->XAddr);
	soap_serialize_PointerToxsd__boolean_(soap, &a->RuleSupport);
	soap_serialize_PointerTott__AnalyticsDeviceExtension(soap, &a->Extension);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AnalyticsDeviceCapabilities(struct soap *soap, const char *tag, int id, const struct tt__AnalyticsDeviceCapabilities *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AnalyticsDeviceCapabilities), type))
		return soap->error;
	if (a->XAddr)
	{	if (soap_out_string(soap, "tt:XAddr", -1, &a->XAddr, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:XAddr"))
		return soap->error;
	if (soap_out_PointerToxsd__boolean_(soap, "tt:RuleSupport", -1, &a->RuleSupport, ""))
		return soap->error;
	if (soap_out_PointerTott__AnalyticsDeviceExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__AnalyticsDeviceCapabilities * SOAP_FMAC4 soap_in_tt__AnalyticsDeviceCapabilities(struct soap *soap, const char *tag, struct tt__AnalyticsDeviceCapabilities *a, const char *type)
{
	size_t soap_flag_XAddr = 1;
	size_t soap_flag_RuleSupport = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__AnalyticsDeviceCapabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AnalyticsDeviceCapabilities, sizeof(struct tt__AnalyticsDeviceCapabilities), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__AnalyticsDeviceCapabilities(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_XAddr && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "tt:XAddr", &a->XAddr, "xsd:string"))
				{	soap_flag_XAddr--;
					continue;
				}
			if (soap_flag_RuleSupport && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__boolean_(soap, "tt:RuleSupport", &a->RuleSupport, "xsd:boolean"))
				{	soap_flag_RuleSupport--;
					continue;
				}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__AnalyticsDeviceExtension(soap, "tt:Extension", &a->Extension, "tt:AnalyticsDeviceExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__AnalyticsDeviceCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AnalyticsDeviceCapabilities, 0, sizeof(struct tt__AnalyticsDeviceCapabilities), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_XAddr > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__AnalyticsDeviceCapabilities(struct soap *soap, const struct tt__AnalyticsDeviceCapabilities *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__AnalyticsDeviceCapabilities);
	if (soap_out_tt__AnalyticsDeviceCapabilities(soap, tag?tag:"tt:AnalyticsDeviceCapabilities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AnalyticsDeviceCapabilities * SOAP_FMAC4 soap_get_tt__AnalyticsDeviceCapabilities(struct soap *soap, struct tt__AnalyticsDeviceCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AnalyticsDeviceCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__ReceiverCapabilities(struct soap *soap, struct tt__ReceiverCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->XAddr);
	soap_default_xsd__boolean_(soap, &a->RTP_USCOREMulticast);
	soap_default_xsd__boolean_(soap, &a->RTP_USCORETCP);
	soap_default_xsd__boolean_(soap, &a->RTP_USCORERTSP_USCORETCP);
	soap_default_int(soap, &a->SupportedReceivers);
	soap_default_int(soap, &a->MaximumRTSPURILength);
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__ReceiverCapabilities(struct soap *soap, const struct tt__ReceiverCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->XAddr);
	soap_embedded(soap, &a->RTP_USCOREMulticast, SOAP_TYPE_xsd__boolean_);
	soap_embedded(soap, &a->RTP_USCORETCP, SOAP_TYPE_xsd__boolean_);
	soap_embedded(soap, &a->RTP_USCORERTSP_USCORETCP, SOAP_TYPE_xsd__boolean_);
	soap_embedded(soap, &a->SupportedReceivers, SOAP_TYPE_int);
	soap_embedded(soap, &a->MaximumRTSPURILength, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ReceiverCapabilities(struct soap *soap, const char *tag, int id, const struct tt__ReceiverCapabilities *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ReceiverCapabilities), type))
		return soap->error;
	if (a->XAddr)
	{	if (soap_out_string(soap, "tt:XAddr", -1, &a->XAddr, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:XAddr"))
		return soap->error;
	if (soap_out_xsd__boolean_(soap, "tt:RTP_Multicast", -1, &a->RTP_USCOREMulticast, ""))
		return soap->error;
	if (soap_out_xsd__boolean_(soap, "tt:RTP_TCP", -1, &a->RTP_USCORETCP, ""))
		return soap->error;
	if (soap_out_xsd__boolean_(soap, "tt:RTP_RTSP_TCP", -1, &a->RTP_USCORERTSP_USCORETCP, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:SupportedReceivers", -1, &a->SupportedReceivers, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:MaximumRTSPURILength", -1, &a->MaximumRTSPURILength, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__ReceiverCapabilities * SOAP_FMAC4 soap_in_tt__ReceiverCapabilities(struct soap *soap, const char *tag, struct tt__ReceiverCapabilities *a, const char *type)
{
	size_t soap_flag_XAddr = 1;
	size_t soap_flag_RTP_USCOREMulticast = 1;
	size_t soap_flag_RTP_USCORETCP = 1;
	size_t soap_flag_RTP_USCORERTSP_USCORETCP = 1;
	size_t soap_flag_SupportedReceivers = 1;
	size_t soap_flag_MaximumRTSPURILength = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__ReceiverCapabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ReceiverCapabilities, sizeof(struct tt__ReceiverCapabilities), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__ReceiverCapabilities(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_XAddr && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "tt:XAddr", &a->XAddr, "xsd:string"))
				{	soap_flag_XAddr--;
					continue;
				}
			if (soap_flag_RTP_USCOREMulticast && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean_(soap, "tt:RTP_Multicast", &a->RTP_USCOREMulticast, "xsd:boolean"))
				{	soap_flag_RTP_USCOREMulticast--;
					continue;
				}
			if (soap_flag_RTP_USCORETCP && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean_(soap, "tt:RTP_TCP", &a->RTP_USCORETCP, "xsd:boolean"))
				{	soap_flag_RTP_USCORETCP--;
					continue;
				}
			if (soap_flag_RTP_USCORERTSP_USCORETCP && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean_(soap, "tt:RTP_RTSP_TCP", &a->RTP_USCORERTSP_USCORETCP, "xsd:boolean"))
				{	soap_flag_RTP_USCORERTSP_USCORETCP--;
					continue;
				}
			if (soap_flag_SupportedReceivers && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "tt:SupportedReceivers", &a->SupportedReceivers, "xsd:int"))
				{	soap_flag_SupportedReceivers--;
					continue;
				}
			if (soap_flag_MaximumRTSPURILength && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "tt:MaximumRTSPURILength", &a->MaximumRTSPURILength, "xsd:int"))
				{	soap_flag_MaximumRTSPURILength--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__ReceiverCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ReceiverCapabilities, 0, sizeof(struct tt__ReceiverCapabilities), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_XAddr > 0 || soap_flag_RTP_USCOREMulticast > 0 || soap_flag_RTP_USCORETCP > 0 || soap_flag_RTP_USCORERTSP_USCORETCP > 0 || soap_flag_SupportedReceivers > 0 || soap_flag_MaximumRTSPURILength > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ReceiverCapabilities(struct soap *soap, const struct tt__ReceiverCapabilities *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__ReceiverCapabilities);
	if (soap_out_tt__ReceiverCapabilities(soap, tag?tag:"tt:ReceiverCapabilities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ReceiverCapabilities * SOAP_FMAC4 soap_get_tt__ReceiverCapabilities(struct soap *soap, struct tt__ReceiverCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ReceiverCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__ReplayCapabilities(struct soap *soap, struct tt__ReplayCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->XAddr);
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__ReplayCapabilities(struct soap *soap, const struct tt__ReplayCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->XAddr);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ReplayCapabilities(struct soap *soap, const char *tag, int id, const struct tt__ReplayCapabilities *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ReplayCapabilities), type))
		return soap->error;
	if (a->XAddr)
	{	if (soap_out_string(soap, "tt:XAddr", -1, &a->XAddr, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:XAddr"))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__ReplayCapabilities * SOAP_FMAC4 soap_in_tt__ReplayCapabilities(struct soap *soap, const char *tag, struct tt__ReplayCapabilities *a, const char *type)
{
	size_t soap_flag_XAddr = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__ReplayCapabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ReplayCapabilities, sizeof(struct tt__ReplayCapabilities), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__ReplayCapabilities(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_XAddr && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "tt:XAddr", &a->XAddr, "xsd:string"))
				{	soap_flag_XAddr--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__ReplayCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ReplayCapabilities, 0, sizeof(struct tt__ReplayCapabilities), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_XAddr > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ReplayCapabilities(struct soap *soap, const struct tt__ReplayCapabilities *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__ReplayCapabilities);
	if (soap_out_tt__ReplayCapabilities(soap, tag?tag:"tt:ReplayCapabilities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ReplayCapabilities * SOAP_FMAC4 soap_get_tt__ReplayCapabilities(struct soap *soap, struct tt__ReplayCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ReplayCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__SearchCapabilities(struct soap *soap, struct tt__SearchCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->XAddr);
	soap_default_xsd__boolean_(soap, &a->MetadataSearch);
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__SearchCapabilities(struct soap *soap, const struct tt__SearchCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->XAddr);
	soap_embedded(soap, &a->MetadataSearch, SOAP_TYPE_xsd__boolean_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__SearchCapabilities(struct soap *soap, const char *tag, int id, const struct tt__SearchCapabilities *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__SearchCapabilities), type))
		return soap->error;
	if (a->XAddr)
	{	if (soap_out_string(soap, "tt:XAddr", -1, &a->XAddr, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:XAddr"))
		return soap->error;
	if (soap_out_xsd__boolean_(soap, "tt:MetadataSearch", -1, &a->MetadataSearch, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__SearchCapabilities * SOAP_FMAC4 soap_in_tt__SearchCapabilities(struct soap *soap, const char *tag, struct tt__SearchCapabilities *a, const char *type)
{
	size_t soap_flag_XAddr = 1;
	size_t soap_flag_MetadataSearch = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__SearchCapabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__SearchCapabilities, sizeof(struct tt__SearchCapabilities), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__SearchCapabilities(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_XAddr && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "tt:XAddr", &a->XAddr, "xsd:string"))
				{	soap_flag_XAddr--;
					continue;
				}
			if (soap_flag_MetadataSearch && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean_(soap, "tt:MetadataSearch", &a->MetadataSearch, "xsd:boolean"))
				{	soap_flag_MetadataSearch--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__SearchCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__SearchCapabilities, 0, sizeof(struct tt__SearchCapabilities), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_XAddr > 0 || soap_flag_MetadataSearch > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__SearchCapabilities(struct soap *soap, const struct tt__SearchCapabilities *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__SearchCapabilities);
	if (soap_out_tt__SearchCapabilities(soap, tag?tag:"tt:SearchCapabilities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__SearchCapabilities * SOAP_FMAC4 soap_get_tt__SearchCapabilities(struct soap *soap, struct tt__SearchCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__SearchCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__RecordingCapabilities(struct soap *soap, struct tt__RecordingCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->XAddr);
	soap_default_xsd__boolean_(soap, &a->ReceiverSource);
	soap_default_xsd__boolean_(soap, &a->MediaProfileSource);
	soap_default_xsd__boolean_(soap, &a->DynamicRecordings);
	soap_default_xsd__boolean_(soap, &a->DynamicTracks);
	soap_default_int(soap, &a->MaxStringLength);
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__RecordingCapabilities(struct soap *soap, const struct tt__RecordingCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->XAddr);
	soap_embedded(soap, &a->ReceiverSource, SOAP_TYPE_xsd__boolean_);
	soap_embedded(soap, &a->MediaProfileSource, SOAP_TYPE_xsd__boolean_);
	soap_embedded(soap, &a->DynamicRecordings, SOAP_TYPE_xsd__boolean_);
	soap_embedded(soap, &a->DynamicTracks, SOAP_TYPE_xsd__boolean_);
	soap_embedded(soap, &a->MaxStringLength, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__RecordingCapabilities(struct soap *soap, const char *tag, int id, const struct tt__RecordingCapabilities *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__RecordingCapabilities), type))
		return soap->error;
	if (a->XAddr)
	{	if (soap_out_string(soap, "tt:XAddr", -1, &a->XAddr, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:XAddr"))
		return soap->error;
	if (soap_out_xsd__boolean_(soap, "tt:ReceiverSource", -1, &a->ReceiverSource, ""))
		return soap->error;
	if (soap_out_xsd__boolean_(soap, "tt:MediaProfileSource", -1, &a->MediaProfileSource, ""))
		return soap->error;
	if (soap_out_xsd__boolean_(soap, "tt:DynamicRecordings", -1, &a->DynamicRecordings, ""))
		return soap->error;
	if (soap_out_xsd__boolean_(soap, "tt:DynamicTracks", -1, &a->DynamicTracks, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:MaxStringLength", -1, &a->MaxStringLength, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__RecordingCapabilities * SOAP_FMAC4 soap_in_tt__RecordingCapabilities(struct soap *soap, const char *tag, struct tt__RecordingCapabilities *a, const char *type)
{
	size_t soap_flag_XAddr = 1;
	size_t soap_flag_ReceiverSource = 1;
	size_t soap_flag_MediaProfileSource = 1;
	size_t soap_flag_DynamicRecordings = 1;
	size_t soap_flag_DynamicTracks = 1;
	size_t soap_flag_MaxStringLength = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__RecordingCapabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RecordingCapabilities, sizeof(struct tt__RecordingCapabilities), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__RecordingCapabilities(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_XAddr && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "tt:XAddr", &a->XAddr, "xsd:string"))
				{	soap_flag_XAddr--;
					continue;
				}
			if (soap_flag_ReceiverSource && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean_(soap, "tt:ReceiverSource", &a->ReceiverSource, "xsd:boolean"))
				{	soap_flag_ReceiverSource--;
					continue;
				}
			if (soap_flag_MediaProfileSource && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean_(soap, "tt:MediaProfileSource", &a->MediaProfileSource, "xsd:boolean"))
				{	soap_flag_MediaProfileSource--;
					continue;
				}
			if (soap_flag_DynamicRecordings && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean_(soap, "tt:DynamicRecordings", &a->DynamicRecordings, "xsd:boolean"))
				{	soap_flag_DynamicRecordings--;
					continue;
				}
			if (soap_flag_DynamicTracks && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean_(soap, "tt:DynamicTracks", &a->DynamicTracks, "xsd:boolean"))
				{	soap_flag_DynamicTracks--;
					continue;
				}
			if (soap_flag_MaxStringLength && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "tt:MaxStringLength", &a->MaxStringLength, "xsd:int"))
				{	soap_flag_MaxStringLength--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__RecordingCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__RecordingCapabilities, 0, sizeof(struct tt__RecordingCapabilities), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_XAddr > 0 || soap_flag_ReceiverSource > 0 || soap_flag_MediaProfileSource > 0 || soap_flag_DynamicRecordings > 0 || soap_flag_DynamicTracks > 0 || soap_flag_MaxStringLength > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__RecordingCapabilities(struct soap *soap, const struct tt__RecordingCapabilities *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__RecordingCapabilities);
	if (soap_out_tt__RecordingCapabilities(soap, tag?tag:"tt:RecordingCapabilities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__RecordingCapabilities * SOAP_FMAC4 soap_get_tt__RecordingCapabilities(struct soap *soap, struct tt__RecordingCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__RecordingCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__DisplayCapabilities(struct soap *soap, struct tt__DisplayCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->XAddr);
	soap_default_xsd__boolean_(soap, &a->FixedLayout);
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__DisplayCapabilities(struct soap *soap, const struct tt__DisplayCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->XAddr);
	soap_embedded(soap, &a->FixedLayout, SOAP_TYPE_xsd__boolean_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__DisplayCapabilities(struct soap *soap, const char *tag, int id, const struct tt__DisplayCapabilities *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__DisplayCapabilities), type))
		return soap->error;
	if (a->XAddr)
	{	if (soap_out_string(soap, "tt:XAddr", -1, &a->XAddr, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:XAddr"))
		return soap->error;
	if (soap_out_xsd__boolean_(soap, "tt:FixedLayout", -1, &a->FixedLayout, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__DisplayCapabilities * SOAP_FMAC4 soap_in_tt__DisplayCapabilities(struct soap *soap, const char *tag, struct tt__DisplayCapabilities *a, const char *type)
{
	size_t soap_flag_XAddr = 1;
	size_t soap_flag_FixedLayout = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__DisplayCapabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__DisplayCapabilities, sizeof(struct tt__DisplayCapabilities), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__DisplayCapabilities(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_XAddr && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "tt:XAddr", &a->XAddr, "xsd:string"))
				{	soap_flag_XAddr--;
					continue;
				}
			if (soap_flag_FixedLayout && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean_(soap, "tt:FixedLayout", &a->FixedLayout, "xsd:boolean"))
				{	soap_flag_FixedLayout--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__DisplayCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__DisplayCapabilities, 0, sizeof(struct tt__DisplayCapabilities), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_XAddr > 0 || soap_flag_FixedLayout > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__DisplayCapabilities(struct soap *soap, const struct tt__DisplayCapabilities *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__DisplayCapabilities);
	if (soap_out_tt__DisplayCapabilities(soap, tag?tag:"tt:DisplayCapabilities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__DisplayCapabilities * SOAP_FMAC4 soap_get_tt__DisplayCapabilities(struct soap *soap, struct tt__DisplayCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__DisplayCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__DeviceIOCapabilities(struct soap *soap, struct tt__DeviceIOCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->XAddr);
	soap_default_int(soap, &a->VideoSources);
	soap_default_int(soap, &a->VideoOutputs);
	soap_default_int(soap, &a->AudioSources);
	soap_default_int(soap, &a->AudioOutputs);
	soap_default_int(soap, &a->RelayOutputs);
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__DeviceIOCapabilities(struct soap *soap, const struct tt__DeviceIOCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->XAddr);
	soap_embedded(soap, &a->VideoSources, SOAP_TYPE_int);
	soap_embedded(soap, &a->VideoOutputs, SOAP_TYPE_int);
	soap_embedded(soap, &a->AudioSources, SOAP_TYPE_int);
	soap_embedded(soap, &a->AudioOutputs, SOAP_TYPE_int);
	soap_embedded(soap, &a->RelayOutputs, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__DeviceIOCapabilities(struct soap *soap, const char *tag, int id, const struct tt__DeviceIOCapabilities *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__DeviceIOCapabilities), type))
		return soap->error;
	if (a->XAddr)
	{	if (soap_out_string(soap, "tt:XAddr", -1, &a->XAddr, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:XAddr"))
		return soap->error;
	if (soap_out_int(soap, "tt:VideoSources", -1, &a->VideoSources, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:VideoOutputs", -1, &a->VideoOutputs, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:AudioSources", -1, &a->AudioSources, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:AudioOutputs", -1, &a->AudioOutputs, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:RelayOutputs", -1, &a->RelayOutputs, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__DeviceIOCapabilities * SOAP_FMAC4 soap_in_tt__DeviceIOCapabilities(struct soap *soap, const char *tag, struct tt__DeviceIOCapabilities *a, const char *type)
{
	size_t soap_flag_XAddr = 1;
	size_t soap_flag_VideoSources = 1;
	size_t soap_flag_VideoOutputs = 1;
	size_t soap_flag_AudioSources = 1;
	size_t soap_flag_AudioOutputs = 1;
	size_t soap_flag_RelayOutputs = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__DeviceIOCapabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__DeviceIOCapabilities, sizeof(struct tt__DeviceIOCapabilities), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__DeviceIOCapabilities(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_XAddr && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "tt:XAddr", &a->XAddr, "xsd:string"))
				{	soap_flag_XAddr--;
					continue;
				}
			if (soap_flag_VideoSources && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "tt:VideoSources", &a->VideoSources, "xsd:int"))
				{	soap_flag_VideoSources--;
					continue;
				}
			if (soap_flag_VideoOutputs && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "tt:VideoOutputs", &a->VideoOutputs, "xsd:int"))
				{	soap_flag_VideoOutputs--;
					continue;
				}
			if (soap_flag_AudioSources && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "tt:AudioSources", &a->AudioSources, "xsd:int"))
				{	soap_flag_AudioSources--;
					continue;
				}
			if (soap_flag_AudioOutputs && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "tt:AudioOutputs", &a->AudioOutputs, "xsd:int"))
				{	soap_flag_AudioOutputs--;
					continue;
				}
			if (soap_flag_RelayOutputs && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "tt:RelayOutputs", &a->RelayOutputs, "xsd:int"))
				{	soap_flag_RelayOutputs--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__DeviceIOCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__DeviceIOCapabilities, 0, sizeof(struct tt__DeviceIOCapabilities), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_XAddr > 0 || soap_flag_VideoSources > 0 || soap_flag_VideoOutputs > 0 || soap_flag_AudioSources > 0 || soap_flag_AudioOutputs > 0 || soap_flag_RelayOutputs > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__DeviceIOCapabilities(struct soap *soap, const struct tt__DeviceIOCapabilities *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__DeviceIOCapabilities);
	if (soap_out_tt__DeviceIOCapabilities(soap, tag?tag:"tt:DeviceIOCapabilities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__DeviceIOCapabilities * SOAP_FMAC4 soap_get_tt__DeviceIOCapabilities(struct soap *soap, struct tt__DeviceIOCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__DeviceIOCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__CapabilitiesExtension(struct soap *soap, struct tt__CapabilitiesExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
	a->DeviceIO = NULL;
	a->Display = NULL;
	a->Recording = NULL;
	a->Search = NULL;
	a->Replay = NULL;
	a->Receiver = NULL;
	a->AnalyticsDevice = NULL;
	a->Extensions = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__CapabilitiesExtension(struct soap *soap, const struct tt__CapabilitiesExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTott__DeviceIOCapabilities(soap, &a->DeviceIO);
	soap_serialize_PointerTott__DisplayCapabilities(soap, &a->Display);
	soap_serialize_PointerTott__RecordingCapabilities(soap, &a->Recording);
	soap_serialize_PointerTott__SearchCapabilities(soap, &a->Search);
	soap_serialize_PointerTott__ReplayCapabilities(soap, &a->Replay);
	soap_serialize_PointerTott__ReceiverCapabilities(soap, &a->Receiver);
	soap_serialize_PointerTott__AnalyticsDeviceCapabilities(soap, &a->AnalyticsDevice);
	soap_serialize_PointerTott__CapabilitiesExtension2(soap, &a->Extensions);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__CapabilitiesExtension(struct soap *soap, const char *tag, int id, const struct tt__CapabilitiesExtension *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__CapabilitiesExtension), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	if (soap_out_PointerTott__DeviceIOCapabilities(soap, "tt:DeviceIO", -1, &a->DeviceIO, ""))
		return soap->error;
	if (soap_out_PointerTott__DisplayCapabilities(soap, "tt:Display", -1, &a->Display, ""))
		return soap->error;
	if (soap_out_PointerTott__RecordingCapabilities(soap, "tt:Recording", -1, &a->Recording, ""))
		return soap->error;
	if (soap_out_PointerTott__SearchCapabilities(soap, "tt:Search", -1, &a->Search, ""))
		return soap->error;
	if (soap_out_PointerTott__ReplayCapabilities(soap, "tt:Replay", -1, &a->Replay, ""))
		return soap->error;
	if (soap_out_PointerTott__ReceiverCapabilities(soap, "tt:Receiver", -1, &a->Receiver, ""))
		return soap->error;
	if (soap_out_PointerTott__AnalyticsDeviceCapabilities(soap, "tt:AnalyticsDevice", -1, &a->AnalyticsDevice, ""))
		return soap->error;
	if (soap_out_PointerTott__CapabilitiesExtension2(soap, "tt:Extensions", -1, &a->Extensions, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__CapabilitiesExtension * SOAP_FMAC4 soap_in_tt__CapabilitiesExtension(struct soap *soap, const char *tag, struct tt__CapabilitiesExtension *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	size_t soap_flag_DeviceIO = 1;
	size_t soap_flag_Display = 1;
	size_t soap_flag_Recording = 1;
	size_t soap_flag_Search = 1;
	size_t soap_flag_Replay = 1;
	size_t soap_flag_Receiver = 1;
	size_t soap_flag_AnalyticsDevice = 1;
	size_t soap_flag_Extensions = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__CapabilitiesExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__CapabilitiesExtension, sizeof(struct tt__CapabilitiesExtension), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__CapabilitiesExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap_flag_DeviceIO && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__DeviceIOCapabilities(soap, "tt:DeviceIO", &a->DeviceIO, "tt:DeviceIOCapabilities"))
				{	soap_flag_DeviceIO--;
					continue;
				}
			if (soap_flag_Display && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__DisplayCapabilities(soap, "tt:Display", &a->Display, "tt:DisplayCapabilities"))
				{	soap_flag_Display--;
					continue;
				}
			if (soap_flag_Recording && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__RecordingCapabilities(soap, "tt:Recording", &a->Recording, "tt:RecordingCapabilities"))
				{	soap_flag_Recording--;
					continue;
				}
			if (soap_flag_Search && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__SearchCapabilities(soap, "tt:Search", &a->Search, "tt:SearchCapabilities"))
				{	soap_flag_Search--;
					continue;
				}
			if (soap_flag_Replay && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__ReplayCapabilities(soap, "tt:Replay", &a->Replay, "tt:ReplayCapabilities"))
				{	soap_flag_Replay--;
					continue;
				}
			if (soap_flag_Receiver && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__ReceiverCapabilities(soap, "tt:Receiver", &a->Receiver, "tt:ReceiverCapabilities"))
				{	soap_flag_Receiver--;
					continue;
				}
			if (soap_flag_AnalyticsDevice && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__AnalyticsDeviceCapabilities(soap, "tt:AnalyticsDevice", &a->AnalyticsDevice, "tt:AnalyticsDeviceCapabilities"))
				{	soap_flag_AnalyticsDevice--;
					continue;
				}
			if (soap_flag_Extensions && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__CapabilitiesExtension2(soap, "tt:Extensions", &a->Extensions, "tt:CapabilitiesExtension2"))
				{	soap_flag_Extensions--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__CapabilitiesExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__CapabilitiesExtension, 0, sizeof(struct tt__CapabilitiesExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__CapabilitiesExtension(struct soap *soap, const struct tt__CapabilitiesExtension *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__CapabilitiesExtension);
	if (soap_out_tt__CapabilitiesExtension(soap, tag?tag:"tt:CapabilitiesExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__CapabilitiesExtension * SOAP_FMAC4 soap_get_tt__CapabilitiesExtension(struct soap *soap, struct tt__CapabilitiesExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__CapabilitiesExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__PTZCapabilities(struct soap *soap, struct tt__PTZCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->XAddr);
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__PTZCapabilities(struct soap *soap, const struct tt__PTZCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->XAddr);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZCapabilities(struct soap *soap, const char *tag, int id, const struct tt__PTZCapabilities *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTZCapabilities), type))
		return soap->error;
	if (a->XAddr)
	{	if (soap_out_string(soap, "tt:XAddr", -1, &a->XAddr, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:XAddr"))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__PTZCapabilities * SOAP_FMAC4 soap_in_tt__PTZCapabilities(struct soap *soap, const char *tag, struct tt__PTZCapabilities *a, const char *type)
{
	size_t soap_flag_XAddr = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__PTZCapabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZCapabilities, sizeof(struct tt__PTZCapabilities), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__PTZCapabilities(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_XAddr && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "tt:XAddr", &a->XAddr, "xsd:string"))
				{	soap_flag_XAddr--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__PTZCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZCapabilities, 0, sizeof(struct tt__PTZCapabilities), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_XAddr > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__PTZCapabilities(struct soap *soap, const struct tt__PTZCapabilities *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__PTZCapabilities);
	if (soap_out_tt__PTZCapabilities(soap, tag?tag:"tt:PTZCapabilities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PTZCapabilities * SOAP_FMAC4 soap_get_tt__PTZCapabilities(struct soap *soap, struct tt__PTZCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTZCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__MediaCapabilities(struct soap *soap, struct tt__MediaCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->XAddr);
	a->StreamingCapabilities = NULL;
	a->__size = 0;
	a->__any = NULL;
	a->Extension = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__MediaCapabilities(struct soap *soap, const struct tt__MediaCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->XAddr);
	soap_serialize_PointerTott__RealTimeStreamingCapabilities(soap, &a->StreamingCapabilities);
	soap_serialize_PointerTott__MediaCapabilitiesExtension(soap, &a->Extension);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__MediaCapabilities(struct soap *soap, const char *tag, int id, const struct tt__MediaCapabilities *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__MediaCapabilities), type))
		return soap->error;
	if (a->XAddr)
	{	if (soap_out_string(soap, "tt:XAddr", -1, &a->XAddr, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:XAddr"))
		return soap->error;
	if (a->StreamingCapabilities)
	{	if (soap_out_PointerTott__RealTimeStreamingCapabilities(soap, "tt:StreamingCapabilities", -1, &a->StreamingCapabilities, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:StreamingCapabilities"))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	if (soap_out_PointerTott__MediaCapabilitiesExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__MediaCapabilities * SOAP_FMAC4 soap_in_tt__MediaCapabilities(struct soap *soap, const char *tag, struct tt__MediaCapabilities *a, const char *type)
{
	size_t soap_flag_XAddr = 1;
	size_t soap_flag_StreamingCapabilities = 1;
	struct soap_blist *soap_blist___any = NULL;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__MediaCapabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__MediaCapabilities, sizeof(struct tt__MediaCapabilities), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__MediaCapabilities(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_XAddr && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "tt:XAddr", &a->XAddr, "xsd:string"))
				{	soap_flag_XAddr--;
					continue;
				}
			if (soap_flag_StreamingCapabilities && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__RealTimeStreamingCapabilities(soap, "tt:StreamingCapabilities", &a->StreamingCapabilities, "tt:RealTimeStreamingCapabilities"))
				{	soap_flag_StreamingCapabilities--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__MediaCapabilitiesExtension(soap, "tt:Extension", &a->Extension, "tt:MediaCapabilitiesExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__MediaCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__MediaCapabilities, 0, sizeof(struct tt__MediaCapabilities), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_XAddr > 0 || soap_flag_StreamingCapabilities > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__MediaCapabilities(struct soap *soap, const struct tt__MediaCapabilities *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__MediaCapabilities);
	if (soap_out_tt__MediaCapabilities(soap, tag?tag:"tt:MediaCapabilities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__MediaCapabilities * SOAP_FMAC4 soap_get_tt__MediaCapabilities(struct soap *soap, struct tt__MediaCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__MediaCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__ImagingCapabilities(struct soap *soap, struct tt__ImagingCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->XAddr);
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__ImagingCapabilities(struct soap *soap, const struct tt__ImagingCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->XAddr);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ImagingCapabilities(struct soap *soap, const char *tag, int id, const struct tt__ImagingCapabilities *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ImagingCapabilities), type))
		return soap->error;
	if (a->XAddr)
	{	if (soap_out_string(soap, "tt:XAddr", -1, &a->XAddr, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:XAddr"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__ImagingCapabilities * SOAP_FMAC4 soap_in_tt__ImagingCapabilities(struct soap *soap, const char *tag, struct tt__ImagingCapabilities *a, const char *type)
{
	size_t soap_flag_XAddr = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__ImagingCapabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ImagingCapabilities, sizeof(struct tt__ImagingCapabilities), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__ImagingCapabilities(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_XAddr && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "tt:XAddr", &a->XAddr, "xsd:string"))
				{	soap_flag_XAddr--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__ImagingCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ImagingCapabilities, 0, sizeof(struct tt__ImagingCapabilities), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_XAddr > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ImagingCapabilities(struct soap *soap, const struct tt__ImagingCapabilities *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__ImagingCapabilities);
	if (soap_out_tt__ImagingCapabilities(soap, tag?tag:"tt:ImagingCapabilities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ImagingCapabilities * SOAP_FMAC4 soap_get_tt__ImagingCapabilities(struct soap *soap, struct tt__ImagingCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ImagingCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__EventCapabilities(struct soap *soap, struct tt__EventCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->XAddr);
	soap_default_xsd__boolean_(soap, &a->WSSubscriptionPolicySupport);
	soap_default_xsd__boolean_(soap, &a->WSPullPointSupport);
	soap_default_xsd__boolean_(soap, &a->WSPausableSubscriptionManagerInterfaceSupport);
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__EventCapabilities(struct soap *soap, const struct tt__EventCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->XAddr);
	soap_embedded(soap, &a->WSSubscriptionPolicySupport, SOAP_TYPE_xsd__boolean_);
	soap_embedded(soap, &a->WSPullPointSupport, SOAP_TYPE_xsd__boolean_);
	soap_embedded(soap, &a->WSPausableSubscriptionManagerInterfaceSupport, SOAP_TYPE_xsd__boolean_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__EventCapabilities(struct soap *soap, const char *tag, int id, const struct tt__EventCapabilities *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__EventCapabilities), type))
		return soap->error;
	if (a->XAddr)
	{	if (soap_out_string(soap, "tt:XAddr", -1, &a->XAddr, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:XAddr"))
		return soap->error;
	if (soap_out_xsd__boolean_(soap, "tt:WSSubscriptionPolicySupport", -1, &a->WSSubscriptionPolicySupport, ""))
		return soap->error;
	if (soap_out_xsd__boolean_(soap, "tt:WSPullPointSupport", -1, &a->WSPullPointSupport, ""))
		return soap->error;
	if (soap_out_xsd__boolean_(soap, "tt:WSPausableSubscriptionManagerInterfaceSupport", -1, &a->WSPausableSubscriptionManagerInterfaceSupport, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__EventCapabilities * SOAP_FMAC4 soap_in_tt__EventCapabilities(struct soap *soap, const char *tag, struct tt__EventCapabilities *a, const char *type)
{
	size_t soap_flag_XAddr = 1;
	size_t soap_flag_WSSubscriptionPolicySupport = 1;
	size_t soap_flag_WSPullPointSupport = 1;
	size_t soap_flag_WSPausableSubscriptionManagerInterfaceSupport = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__EventCapabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__EventCapabilities, sizeof(struct tt__EventCapabilities), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__EventCapabilities(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_XAddr && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "tt:XAddr", &a->XAddr, "xsd:string"))
				{	soap_flag_XAddr--;
					continue;
				}
			if (soap_flag_WSSubscriptionPolicySupport && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean_(soap, "tt:WSSubscriptionPolicySupport", &a->WSSubscriptionPolicySupport, "xsd:boolean"))
				{	soap_flag_WSSubscriptionPolicySupport--;
					continue;
				}
			if (soap_flag_WSPullPointSupport && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean_(soap, "tt:WSPullPointSupport", &a->WSPullPointSupport, "xsd:boolean"))
				{	soap_flag_WSPullPointSupport--;
					continue;
				}
			if (soap_flag_WSPausableSubscriptionManagerInterfaceSupport && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean_(soap, "tt:WSPausableSubscriptionManagerInterfaceSupport", &a->WSPausableSubscriptionManagerInterfaceSupport, "xsd:boolean"))
				{	soap_flag_WSPausableSubscriptionManagerInterfaceSupport--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__EventCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__EventCapabilities, 0, sizeof(struct tt__EventCapabilities), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_XAddr > 0 || soap_flag_WSSubscriptionPolicySupport > 0 || soap_flag_WSPullPointSupport > 0 || soap_flag_WSPausableSubscriptionManagerInterfaceSupport > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__EventCapabilities(struct soap *soap, const struct tt__EventCapabilities *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__EventCapabilities);
	if (soap_out_tt__EventCapabilities(soap, tag?tag:"tt:EventCapabilities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__EventCapabilities * SOAP_FMAC4 soap_get_tt__EventCapabilities(struct soap *soap, struct tt__EventCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__EventCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__DeviceCapabilities(struct soap *soap, struct tt__DeviceCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->XAddr);
	a->Network = NULL;
	a->System = NULL;
	a->IO = NULL;
	a->Security = NULL;
	a->Extension = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__DeviceCapabilities(struct soap *soap, const struct tt__DeviceCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->XAddr);
	soap_serialize_PointerTott__NetworkCapabilities(soap, &a->Network);
	soap_serialize_PointerTott__SystemCapabilities(soap, &a->System);
	soap_serialize_PointerTott__IOCapabilities(soap, &a->IO);
	soap_serialize_PointerTott__SecurityCapabilities(soap, &a->Security);
	soap_serialize_PointerTott__DeviceCapabilitiesExtension(soap, &a->Extension);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__DeviceCapabilities(struct soap *soap, const char *tag, int id, const struct tt__DeviceCapabilities *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__DeviceCapabilities), type))
		return soap->error;
	if (a->XAddr)
	{	if (soap_out_string(soap, "tt:XAddr", -1, &a->XAddr, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:XAddr"))
		return soap->error;
	if (soap_out_PointerTott__NetworkCapabilities(soap, "tt:Network", -1, &a->Network, ""))
		return soap->error;
	if (soap_out_PointerTott__SystemCapabilities(soap, "tt:System", -1, &a->System, ""))
		return soap->error;
	if (soap_out_PointerTott__IOCapabilities(soap, "tt:IO", -1, &a->IO, ""))
		return soap->error;
	if (soap_out_PointerTott__SecurityCapabilities(soap, "tt:Security", -1, &a->Security, ""))
		return soap->error;
	if (soap_out_PointerTott__DeviceCapabilitiesExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__DeviceCapabilities * SOAP_FMAC4 soap_in_tt__DeviceCapabilities(struct soap *soap, const char *tag, struct tt__DeviceCapabilities *a, const char *type)
{
	size_t soap_flag_XAddr = 1;
	size_t soap_flag_Network = 1;
	size_t soap_flag_System = 1;
	size_t soap_flag_IO = 1;
	size_t soap_flag_Security = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__DeviceCapabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__DeviceCapabilities, sizeof(struct tt__DeviceCapabilities), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__DeviceCapabilities(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_XAddr && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "tt:XAddr", &a->XAddr, "xsd:string"))
				{	soap_flag_XAddr--;
					continue;
				}
			if (soap_flag_Network && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__NetworkCapabilities(soap, "tt:Network", &a->Network, "tt:NetworkCapabilities"))
				{	soap_flag_Network--;
					continue;
				}
			if (soap_flag_System && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__SystemCapabilities(soap, "tt:System", &a->System, "tt:SystemCapabilities"))
				{	soap_flag_System--;
					continue;
				}
			if (soap_flag_IO && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IOCapabilities(soap, "tt:IO", &a->IO, "tt:IOCapabilities"))
				{	soap_flag_IO--;
					continue;
				}
			if (soap_flag_Security && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__SecurityCapabilities(soap, "tt:Security", &a->Security, "tt:SecurityCapabilities"))
				{	soap_flag_Security--;
					continue;
				}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__DeviceCapabilitiesExtension(soap, "tt:Extension", &a->Extension, "tt:DeviceCapabilitiesExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__DeviceCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__DeviceCapabilities, 0, sizeof(struct tt__DeviceCapabilities), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_XAddr > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__DeviceCapabilities(struct soap *soap, const struct tt__DeviceCapabilities *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__DeviceCapabilities);
	if (soap_out_tt__DeviceCapabilities(soap, tag?tag:"tt:DeviceCapabilities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__DeviceCapabilities * SOAP_FMAC4 soap_get_tt__DeviceCapabilities(struct soap *soap, struct tt__DeviceCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__DeviceCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__AnalyticsCapabilities(struct soap *soap, struct tt__AnalyticsCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->XAddr);
	soap_default_xsd__boolean_(soap, &a->RuleSupport);
	soap_default_xsd__boolean_(soap, &a->AnalyticsModuleSupport);
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__AnalyticsCapabilities(struct soap *soap, const struct tt__AnalyticsCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->XAddr);
	soap_embedded(soap, &a->RuleSupport, SOAP_TYPE_xsd__boolean_);
	soap_embedded(soap, &a->AnalyticsModuleSupport, SOAP_TYPE_xsd__boolean_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AnalyticsCapabilities(struct soap *soap, const char *tag, int id, const struct tt__AnalyticsCapabilities *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AnalyticsCapabilities), type))
		return soap->error;
	if (a->XAddr)
	{	if (soap_out_string(soap, "tt:XAddr", -1, &a->XAddr, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:XAddr"))
		return soap->error;
	if (soap_out_xsd__boolean_(soap, "tt:RuleSupport", -1, &a->RuleSupport, ""))
		return soap->error;
	if (soap_out_xsd__boolean_(soap, "tt:AnalyticsModuleSupport", -1, &a->AnalyticsModuleSupport, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__AnalyticsCapabilities * SOAP_FMAC4 soap_in_tt__AnalyticsCapabilities(struct soap *soap, const char *tag, struct tt__AnalyticsCapabilities *a, const char *type)
{
	size_t soap_flag_XAddr = 1;
	size_t soap_flag_RuleSupport = 1;
	size_t soap_flag_AnalyticsModuleSupport = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__AnalyticsCapabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AnalyticsCapabilities, sizeof(struct tt__AnalyticsCapabilities), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__AnalyticsCapabilities(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_XAddr && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "tt:XAddr", &a->XAddr, "xsd:string"))
				{	soap_flag_XAddr--;
					continue;
				}
			if (soap_flag_RuleSupport && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean_(soap, "tt:RuleSupport", &a->RuleSupport, "xsd:boolean"))
				{	soap_flag_RuleSupport--;
					continue;
				}
			if (soap_flag_AnalyticsModuleSupport && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean_(soap, "tt:AnalyticsModuleSupport", &a->AnalyticsModuleSupport, "xsd:boolean"))
				{	soap_flag_AnalyticsModuleSupport--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__AnalyticsCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AnalyticsCapabilities, 0, sizeof(struct tt__AnalyticsCapabilities), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_XAddr > 0 || soap_flag_RuleSupport > 0 || soap_flag_AnalyticsModuleSupport > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__AnalyticsCapabilities(struct soap *soap, const struct tt__AnalyticsCapabilities *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__AnalyticsCapabilities);
	if (soap_out_tt__AnalyticsCapabilities(soap, tag?tag:"tt:AnalyticsCapabilities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AnalyticsCapabilities * SOAP_FMAC4 soap_get_tt__AnalyticsCapabilities(struct soap *soap, struct tt__AnalyticsCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AnalyticsCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__Dot11AvailableNetworksExtension(struct soap *soap, struct tt__Dot11AvailableNetworksExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__Dot11AvailableNetworksExtension(struct soap *soap, const struct tt__Dot11AvailableNetworksExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Dot11AvailableNetworksExtension(struct soap *soap, const char *tag, int id, const struct tt__Dot11AvailableNetworksExtension *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Dot11AvailableNetworksExtension), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__Dot11AvailableNetworksExtension * SOAP_FMAC4 soap_in_tt__Dot11AvailableNetworksExtension(struct soap *soap, const char *tag, struct tt__Dot11AvailableNetworksExtension *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__Dot11AvailableNetworksExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Dot11AvailableNetworksExtension, sizeof(struct tt__Dot11AvailableNetworksExtension), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__Dot11AvailableNetworksExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__Dot11AvailableNetworksExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Dot11AvailableNetworksExtension, 0, sizeof(struct tt__Dot11AvailableNetworksExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Dot11AvailableNetworksExtension(struct soap *soap, const struct tt__Dot11AvailableNetworksExtension *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__Dot11AvailableNetworksExtension);
	if (soap_out_tt__Dot11AvailableNetworksExtension(soap, tag?tag:"tt:Dot11AvailableNetworksExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Dot11AvailableNetworksExtension * SOAP_FMAC4 soap_get_tt__Dot11AvailableNetworksExtension(struct soap *soap, struct tt__Dot11AvailableNetworksExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Dot11AvailableNetworksExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__Dot11PSKSetExtension(struct soap *soap, struct tt__Dot11PSKSetExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__Dot11PSKSetExtension(struct soap *soap, const struct tt__Dot11PSKSetExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Dot11PSKSetExtension(struct soap *soap, const char *tag, int id, const struct tt__Dot11PSKSetExtension *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Dot11PSKSetExtension), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__Dot11PSKSetExtension * SOAP_FMAC4 soap_in_tt__Dot11PSKSetExtension(struct soap *soap, const char *tag, struct tt__Dot11PSKSetExtension *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__Dot11PSKSetExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Dot11PSKSetExtension, sizeof(struct tt__Dot11PSKSetExtension), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__Dot11PSKSetExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__Dot11PSKSetExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Dot11PSKSetExtension, 0, sizeof(struct tt__Dot11PSKSetExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Dot11PSKSetExtension(struct soap *soap, const struct tt__Dot11PSKSetExtension *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__Dot11PSKSetExtension);
	if (soap_out_tt__Dot11PSKSetExtension(soap, tag?tag:"tt:Dot11PSKSetExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Dot11PSKSetExtension * SOAP_FMAC4 soap_get_tt__Dot11PSKSetExtension(struct soap *soap, struct tt__Dot11PSKSetExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Dot11PSKSetExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__Dot11SecurityConfigurationExtension(struct soap *soap, struct tt__Dot11SecurityConfigurationExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__Dot11SecurityConfigurationExtension(struct soap *soap, const struct tt__Dot11SecurityConfigurationExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Dot11SecurityConfigurationExtension(struct soap *soap, const char *tag, int id, const struct tt__Dot11SecurityConfigurationExtension *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Dot11SecurityConfigurationExtension), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__Dot11SecurityConfigurationExtension * SOAP_FMAC4 soap_in_tt__Dot11SecurityConfigurationExtension(struct soap *soap, const char *tag, struct tt__Dot11SecurityConfigurationExtension *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__Dot11SecurityConfigurationExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Dot11SecurityConfigurationExtension, sizeof(struct tt__Dot11SecurityConfigurationExtension), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__Dot11SecurityConfigurationExtension(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__Dot11SecurityConfigurationExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Dot11SecurityConfigurationExtension, 0, sizeof(struct tt__Dot11SecurityConfigurationExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Dot11SecurityConfigurationExtension(struct soap *soap, const struct tt__Dot11SecurityConfigurationExtension *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__Dot11SecurityConfigurationExtension);
	if (soap_out_tt__Dot11SecurityConfigurationExtension(soap, tag?tag:"tt:Dot11SecurityConfigurationExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Dot11SecurityConfigurationExtension * SOAP_FMAC4 soap_get_tt__Dot11SecurityConfigurationExtension(struct soap *soap, struct tt__Dot11SecurityConfigurationExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Dot11SecurityConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__Dot11PSKSet(struct soap *soap, struct tt__Dot11PSKSet *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Key = NULL;
	soap_default_tt__Dot11PSKPassphrase(soap, &a->Passphrase);
	a->Extension = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__Dot11PSKSet(struct soap *soap, const struct tt__Dot11PSKSet *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTott__Dot11PSK(soap, &a->Key);
	soap_serialize_tt__Dot11PSKPassphrase(soap, &a->Passphrase);
	soap_serialize_PointerTott__Dot11PSKSetExtension(soap, &a->Extension);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Dot11PSKSet(struct soap *soap, const char *tag, int id, const struct tt__Dot11PSKSet *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Dot11PSKSet), type))
		return soap->error;
	if (soap_out_PointerTott__Dot11PSK(soap, "tt:Key", -1, &a->Key, ""))
		return soap->error;
	if (soap_out_tt__Dot11PSKPassphrase(soap, "tt:Passphrase", -1, &a->Passphrase, ""))
		return soap->error;
	if (soap_out_PointerTott__Dot11PSKSetExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__Dot11PSKSet * SOAP_FMAC4 soap_in_tt__Dot11PSKSet(struct soap *soap, const char *tag, struct tt__Dot11PSKSet *a, const char *type)
{
	size_t soap_flag_Key = 1;
	size_t soap_flag_Passphrase = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__Dot11PSKSet *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Dot11PSKSet, sizeof(struct tt__Dot11PSKSet), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__Dot11PSKSet(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Key && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__Dot11PSK(soap, "tt:Key", &a->Key, "tt:Dot11PSK"))
				{	soap_flag_Key--;
					continue;
				}
			if (soap_flag_Passphrase && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__Dot11PSKPassphrase(soap, "tt:Passphrase", &a->Passphrase, "tt:Dot11PSKPassphrase"))
				{	soap_flag_Passphrase--;
					continue;
				}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__Dot11PSKSetExtension(soap, "tt:Extension", &a->Extension, "tt:Dot11PSKSetExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__Dot11PSKSet *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Dot11PSKSet, 0, sizeof(struct tt__Dot11PSKSet), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Dot11PSKSet(struct soap *soap, const struct tt__Dot11PSKSet *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__Dot11PSKSet);
	if (soap_out_tt__Dot11PSKSet(soap, tag?tag:"tt:Dot11PSKSet", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Dot11PSKSet * SOAP_FMAC4 soap_get_tt__Dot11PSKSet(struct soap *soap, struct tt__Dot11PSKSet *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Dot11PSKSet(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__Dot11SecurityConfiguration(struct soap *soap, struct tt__Dot11SecurityConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__Dot11SecurityMode(soap, &a->Mode);
	a->Algorithm = NULL;
	a->PSK = NULL;
	soap_default_tt__ReferenceToken(soap, &a->Dot1X);
	a->Extension = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__Dot11SecurityConfiguration(struct soap *soap, const struct tt__Dot11SecurityConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTott__Dot11Cipher(soap, &a->Algorithm);
	soap_serialize_PointerTott__Dot11PSKSet(soap, &a->PSK);
	soap_serialize_tt__ReferenceToken(soap, &a->Dot1X);
	soap_serialize_PointerTott__Dot11SecurityConfigurationExtension(soap, &a->Extension);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Dot11SecurityConfiguration(struct soap *soap, const char *tag, int id, const struct tt__Dot11SecurityConfiguration *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Dot11SecurityConfiguration), type))
		return soap->error;
	if (soap_out_tt__Dot11SecurityMode(soap, "tt:Mode", -1, &a->Mode, ""))
		return soap->error;
	if (soap_out_PointerTott__Dot11Cipher(soap, "tt:Algorithm", -1, &a->Algorithm, ""))
		return soap->error;
	if (soap_out_PointerTott__Dot11PSKSet(soap, "tt:PSK", -1, &a->PSK, ""))
		return soap->error;
	if (soap_out_tt__ReferenceToken(soap, "tt:Dot1X", -1, &a->Dot1X, ""))
		return soap->error;
	if (soap_out_PointerTott__Dot11SecurityConfigurationExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__Dot11SecurityConfiguration * SOAP_FMAC4 soap_in_tt__Dot11SecurityConfiguration(struct soap *soap, const char *tag, struct tt__Dot11SecurityConfiguration *a, const char *type)
{
	size_t soap_flag_Mode = 1;
	size_t soap_flag_Algorithm = 1;
	size_t soap_flag_PSK = 1;
	size_t soap_flag_Dot1X = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__Dot11SecurityConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Dot11SecurityConfiguration, sizeof(struct tt__Dot11SecurityConfiguration), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__Dot11SecurityConfiguration(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Mode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_tt__Dot11SecurityMode(soap, "tt:Mode", &a->Mode, "tt:Dot11SecurityMode"))
				{	soap_flag_Mode--;
					continue;
				}
			if (soap_flag_Algorithm && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__Dot11Cipher(soap, "tt:Algorithm", &a->Algorithm, "tt:Dot11Cipher"))
				{	soap_flag_Algorithm--;
					continue;
				}
			if (soap_flag_PSK && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__Dot11PSKSet(soap, "tt:PSK", &a->PSK, "tt:Dot11PSKSet"))
				{	soap_flag_PSK--;
					continue;
				}
			if (soap_flag_Dot1X && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "tt:Dot1X", &a->Dot1X, "tt:ReferenceToken"))
				{	soap_flag_Dot1X--;
					continue;
				}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__Dot11SecurityConfigurationExtension(soap, "tt:Extension", &a->Extension, "tt:Dot11SecurityConfigurationExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__Dot11SecurityConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Dot11SecurityConfiguration, 0, sizeof(struct tt__Dot11SecurityConfiguration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Mode > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Dot11SecurityConfiguration(struct soap *soap, const struct tt__Dot11SecurityConfiguration *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__Dot11SecurityConfiguration);
	if (soap_out_tt__Dot11SecurityConfiguration(soap, tag?tag:"tt:Dot11SecurityConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Dot11SecurityConfiguration * SOAP_FMAC4 soap_get_tt__Dot11SecurityConfiguration(struct soap *soap, struct tt__Dot11SecurityConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Dot11SecurityConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__IPAddressFilterExtension(struct soap *soap, struct tt__IPAddressFilterExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__IPAddressFilterExtension(struct soap *soap, const struct tt__IPAddressFilterExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IPAddressFilterExtension(struct soap *soap, const char *tag, int id, const struct tt__IPAddressFilterExtension *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__IPAddressFilterExtension), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__IPAddressFilterExtension * SOAP_FMAC4 soap_in_tt__IPAddressFilterExtension(struct soap *soap, const char *tag, struct tt__IPAddressFilterExtension *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__IPAddressFilterExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IPAddressFilterExtension, sizeof(struct tt__IPAddressFilterExtension), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__IPAddressFilterExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__IPAddressFilterExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__IPAddressFilterExtension, 0, sizeof(struct tt__IPAddressFilterExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__IPAddressFilterExtension(struct soap *soap, const struct tt__IPAddressFilterExtension *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__IPAddressFilterExtension);
	if (soap_out_tt__IPAddressFilterExtension(soap, tag?tag:"tt:IPAddressFilterExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__IPAddressFilterExtension * SOAP_FMAC4 soap_get_tt__IPAddressFilterExtension(struct soap *soap, struct tt__IPAddressFilterExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__IPAddressFilterExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__NetworkZeroConfigurationExtension2(struct soap *soap, struct tt__NetworkZeroConfigurationExtension2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__NetworkZeroConfigurationExtension2(struct soap *soap, const struct tt__NetworkZeroConfigurationExtension2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__NetworkZeroConfigurationExtension2(struct soap *soap, const char *tag, int id, const struct tt__NetworkZeroConfigurationExtension2 *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__NetworkZeroConfigurationExtension2), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__NetworkZeroConfigurationExtension2 * SOAP_FMAC4 soap_in_tt__NetworkZeroConfigurationExtension2(struct soap *soap, const char *tag, struct tt__NetworkZeroConfigurationExtension2 *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__NetworkZeroConfigurationExtension2 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__NetworkZeroConfigurationExtension2, sizeof(struct tt__NetworkZeroConfigurationExtension2), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__NetworkZeroConfigurationExtension2(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__NetworkZeroConfigurationExtension2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__NetworkZeroConfigurationExtension2, 0, sizeof(struct tt__NetworkZeroConfigurationExtension2), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__NetworkZeroConfigurationExtension2(struct soap *soap, const struct tt__NetworkZeroConfigurationExtension2 *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__NetworkZeroConfigurationExtension2);
	if (soap_out_tt__NetworkZeroConfigurationExtension2(soap, tag?tag:"tt:NetworkZeroConfigurationExtension2", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__NetworkZeroConfigurationExtension2 * SOAP_FMAC4 soap_get_tt__NetworkZeroConfigurationExtension2(struct soap *soap, struct tt__NetworkZeroConfigurationExtension2 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__NetworkZeroConfigurationExtension2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__NetworkZeroConfigurationExtension(struct soap *soap, struct tt__NetworkZeroConfigurationExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
	a->__sizeAdditional = 0;
	a->Additional = NULL;
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__NetworkZeroConfigurationExtension(struct soap *soap, const struct tt__NetworkZeroConfigurationExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->Additional)
	{	int i;
		for (i = 0; i < a->__sizeAdditional; i++)
		{
			soap_embedded(soap, a->Additional + i, SOAP_TYPE_tt__NetworkZeroConfiguration);
			soap_serialize_tt__NetworkZeroConfiguration(soap, a->Additional + i);
		}
	}
	soap_serialize_PointerTott__NetworkZeroConfigurationExtension2(soap, &a->Extension);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__NetworkZeroConfigurationExtension(struct soap *soap, const char *tag, int id, const struct tt__NetworkZeroConfigurationExtension *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__NetworkZeroConfigurationExtension), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	if (a->Additional)
	{	int i;
		for (i = 0; i < a->__sizeAdditional; i++)
			if (soap_out_tt__NetworkZeroConfiguration(soap, "tt:Additional", -1, a->Additional + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTott__NetworkZeroConfigurationExtension2(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__NetworkZeroConfigurationExtension * SOAP_FMAC4 soap_in_tt__NetworkZeroConfigurationExtension(struct soap *soap, const char *tag, struct tt__NetworkZeroConfigurationExtension *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	struct soap_blist *soap_blist_Additional = NULL;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__NetworkZeroConfigurationExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__NetworkZeroConfigurationExtension, sizeof(struct tt__NetworkZeroConfigurationExtension), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__NetworkZeroConfigurationExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Additional", 1, NULL))
			{	if (a->Additional == NULL)
				{	if (soap_blist_Additional == NULL)
						soap_blist_Additional = soap_new_block(soap);
					a->Additional = (struct tt__NetworkZeroConfiguration *)soap_push_block(soap, soap_blist_Additional, sizeof(struct tt__NetworkZeroConfiguration));
					if (a->Additional == NULL)
						return NULL;
					soap_default_tt__NetworkZeroConfiguration(soap, a->Additional);
				}
				soap_revert(soap);
				if (soap_in_tt__NetworkZeroConfiguration(soap, "tt:Additional", a->Additional, "tt:NetworkZeroConfiguration"))
				{	a->__sizeAdditional++;
					a->Additional = NULL;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__NetworkZeroConfigurationExtension2(soap, "tt:Extension", &a->Extension, "tt:NetworkZeroConfigurationExtension2"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (a->Additional)
			soap_pop_block(soap, soap_blist_Additional);
		if (a->__sizeAdditional)
			a->Additional = (struct tt__NetworkZeroConfiguration *)soap_save_block(soap, soap_blist_Additional, NULL, 1);
		else
		{	a->Additional = NULL;
			if (soap_blist_Additional)
				soap_end_block(soap, soap_blist_Additional);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__NetworkZeroConfigurationExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__NetworkZeroConfigurationExtension, 0, sizeof(struct tt__NetworkZeroConfigurationExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__NetworkZeroConfigurationExtension(struct soap *soap, const struct tt__NetworkZeroConfigurationExtension *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__NetworkZeroConfigurationExtension);
	if (soap_out_tt__NetworkZeroConfigurationExtension(soap, tag?tag:"tt:NetworkZeroConfigurationExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__NetworkZeroConfigurationExtension * SOAP_FMAC4 soap_get_tt__NetworkZeroConfigurationExtension(struct soap *soap, struct tt__NetworkZeroConfigurationExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__NetworkZeroConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__NetworkInterfaceSetConfigurationExtension2(struct soap *soap, struct tt__NetworkInterfaceSetConfigurationExtension2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__NetworkInterfaceSetConfigurationExtension2(struct soap *soap, const struct tt__NetworkInterfaceSetConfigurationExtension2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__NetworkInterfaceSetConfigurationExtension2(struct soap *soap, const char *tag, int id, const struct tt__NetworkInterfaceSetConfigurationExtension2 *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__NetworkInterfaceSetConfigurationExtension2), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__NetworkInterfaceSetConfigurationExtension2 * SOAP_FMAC4 soap_in_tt__NetworkInterfaceSetConfigurationExtension2(struct soap *soap, const char *tag, struct tt__NetworkInterfaceSetConfigurationExtension2 *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__NetworkInterfaceSetConfigurationExtension2 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__NetworkInterfaceSetConfigurationExtension2, sizeof(struct tt__NetworkInterfaceSetConfigurationExtension2), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__NetworkInterfaceSetConfigurationExtension2(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__NetworkInterfaceSetConfigurationExtension2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__NetworkInterfaceSetConfigurationExtension2, 0, sizeof(struct tt__NetworkInterfaceSetConfigurationExtension2), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__NetworkInterfaceSetConfigurationExtension2(struct soap *soap, const struct tt__NetworkInterfaceSetConfigurationExtension2 *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__NetworkInterfaceSetConfigurationExtension2);
	if (soap_out_tt__NetworkInterfaceSetConfigurationExtension2(soap, tag?tag:"tt:NetworkInterfaceSetConfigurationExtension2", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__NetworkInterfaceSetConfigurationExtension2 * SOAP_FMAC4 soap_get_tt__NetworkInterfaceSetConfigurationExtension2(struct soap *soap, struct tt__NetworkInterfaceSetConfigurationExtension2 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__NetworkInterfaceSetConfigurationExtension2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__NetworkInterfaceSetConfigurationExtension(struct soap *soap, struct tt__NetworkInterfaceSetConfigurationExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
	a->__sizeDot3 = 0;
	a->Dot3 = NULL;
	a->__sizeDot11 = 0;
	a->Dot11 = NULL;
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__NetworkInterfaceSetConfigurationExtension(struct soap *soap, const struct tt__NetworkInterfaceSetConfigurationExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->Dot3)
	{	int i;
		for (i = 0; i < a->__sizeDot3; i++)
		{
			soap_embedded(soap, a->Dot3 + i, SOAP_TYPE_tt__Dot3Configuration);
			soap_serialize_tt__Dot3Configuration(soap, a->Dot3 + i);
		}
	}
	if (a->Dot11)
	{	int i;
		for (i = 0; i < a->__sizeDot11; i++)
		{
			soap_embedded(soap, a->Dot11 + i, SOAP_TYPE_tt__Dot11Configuration);
			soap_serialize_tt__Dot11Configuration(soap, a->Dot11 + i);
		}
	}
	soap_serialize_PointerTott__NetworkInterfaceSetConfigurationExtension2(soap, &a->Extension);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__NetworkInterfaceSetConfigurationExtension(struct soap *soap, const char *tag, int id, const struct tt__NetworkInterfaceSetConfigurationExtension *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__NetworkInterfaceSetConfigurationExtension), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	if (a->Dot3)
	{	int i;
		for (i = 0; i < a->__sizeDot3; i++)
			if (soap_out_tt__Dot3Configuration(soap, "tt:Dot3", -1, a->Dot3 + i, ""))
				return soap->error;
	}
	if (a->Dot11)
	{	int i;
		for (i = 0; i < a->__sizeDot11; i++)
			if (soap_out_tt__Dot11Configuration(soap, "tt:Dot11", -1, a->Dot11 + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTott__NetworkInterfaceSetConfigurationExtension2(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__NetworkInterfaceSetConfigurationExtension * SOAP_FMAC4 soap_in_tt__NetworkInterfaceSetConfigurationExtension(struct soap *soap, const char *tag, struct tt__NetworkInterfaceSetConfigurationExtension *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	struct soap_blist *soap_blist_Dot3 = NULL;
	struct soap_blist *soap_blist_Dot11 = NULL;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__NetworkInterfaceSetConfigurationExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__NetworkInterfaceSetConfigurationExtension, sizeof(struct tt__NetworkInterfaceSetConfigurationExtension), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__NetworkInterfaceSetConfigurationExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Dot3", 1, NULL))
			{	if (a->Dot3 == NULL)
				{	if (soap_blist_Dot3 == NULL)
						soap_blist_Dot3 = soap_new_block(soap);
					a->Dot3 = (struct tt__Dot3Configuration *)soap_push_block(soap, soap_blist_Dot3, sizeof(struct tt__Dot3Configuration));
					if (a->Dot3 == NULL)
						return NULL;
					soap_default_tt__Dot3Configuration(soap, a->Dot3);
				}
				soap_revert(soap);
				if (soap_in_tt__Dot3Configuration(soap, "tt:Dot3", a->Dot3, "tt:Dot3Configuration"))
				{	a->__sizeDot3++;
					a->Dot3 = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Dot11", 1, NULL))
			{	if (a->Dot11 == NULL)
				{	if (soap_blist_Dot11 == NULL)
						soap_blist_Dot11 = soap_new_block(soap);
					a->Dot11 = (struct tt__Dot11Configuration *)soap_push_block(soap, soap_blist_Dot11, sizeof(struct tt__Dot11Configuration));
					if (a->Dot11 == NULL)
						return NULL;
					soap_default_tt__Dot11Configuration(soap, a->Dot11);
				}
				soap_revert(soap);
				if (soap_in_tt__Dot11Configuration(soap, "tt:Dot11", a->Dot11, "tt:Dot11Configuration"))
				{	a->__sizeDot11++;
					a->Dot11 = NULL;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__NetworkInterfaceSetConfigurationExtension2(soap, "tt:Extension", &a->Extension, "tt:NetworkInterfaceSetConfigurationExtension2"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (a->Dot3)
			soap_pop_block(soap, soap_blist_Dot3);
		if (a->__sizeDot3)
			a->Dot3 = (struct tt__Dot3Configuration *)soap_save_block(soap, soap_blist_Dot3, NULL, 1);
		else
		{	a->Dot3 = NULL;
			if (soap_blist_Dot3)
				soap_end_block(soap, soap_blist_Dot3);
		}
		if (a->Dot11)
			soap_pop_block(soap, soap_blist_Dot11);
		if (a->__sizeDot11)
			a->Dot11 = (struct tt__Dot11Configuration *)soap_save_block(soap, soap_blist_Dot11, NULL, 1);
		else
		{	a->Dot11 = NULL;
			if (soap_blist_Dot11)
				soap_end_block(soap, soap_blist_Dot11);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__NetworkInterfaceSetConfigurationExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__NetworkInterfaceSetConfigurationExtension, 0, sizeof(struct tt__NetworkInterfaceSetConfigurationExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__NetworkInterfaceSetConfigurationExtension(struct soap *soap, const struct tt__NetworkInterfaceSetConfigurationExtension *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__NetworkInterfaceSetConfigurationExtension);
	if (soap_out_tt__NetworkInterfaceSetConfigurationExtension(soap, tag?tag:"tt:NetworkInterfaceSetConfigurationExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__NetworkInterfaceSetConfigurationExtension * SOAP_FMAC4 soap_get_tt__NetworkInterfaceSetConfigurationExtension(struct soap *soap, struct tt__NetworkInterfaceSetConfigurationExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__NetworkInterfaceSetConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__IPv6NetworkInterfaceSetConfiguration(struct soap *soap, struct tt__IPv6NetworkInterfaceSetConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Enabled = NULL;
	a->AcceptRouterAdvert = NULL;
	a->__sizeManual = 0;
	a->Manual = NULL;
	a->DHCP = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__IPv6NetworkInterfaceSetConfiguration(struct soap *soap, const struct tt__IPv6NetworkInterfaceSetConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__boolean_(soap, &a->Enabled);
	soap_serialize_PointerToxsd__boolean_(soap, &a->AcceptRouterAdvert);
	if (a->Manual)
	{	int i;
		for (i = 0; i < a->__sizeManual; i++)
		{
			soap_embedded(soap, a->Manual + i, SOAP_TYPE_tt__PrefixedIPv6Address);
			soap_serialize_tt__PrefixedIPv6Address(soap, a->Manual + i);
		}
	}
	soap_serialize_PointerTott__IPv6DHCPConfiguration(soap, &a->DHCP);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IPv6NetworkInterfaceSetConfiguration(struct soap *soap, const char *tag, int id, const struct tt__IPv6NetworkInterfaceSetConfiguration *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__IPv6NetworkInterfaceSetConfiguration), type))
		return soap->error;
	if (soap_out_PointerToxsd__boolean_(soap, "tt:Enabled", -1, &a->Enabled, ""))
		return soap->error;
	if (soap_out_PointerToxsd__boolean_(soap, "tt:AcceptRouterAdvert", -1, &a->AcceptRouterAdvert, ""))
		return soap->error;
	if (a->Manual)
	{	int i;
		for (i = 0; i < a->__sizeManual; i++)
			if (soap_out_tt__PrefixedIPv6Address(soap, "tt:Manual", -1, a->Manual + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTott__IPv6DHCPConfiguration(soap, "tt:DHCP", -1, &a->DHCP, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__IPv6NetworkInterfaceSetConfiguration * SOAP_FMAC4 soap_in_tt__IPv6NetworkInterfaceSetConfiguration(struct soap *soap, const char *tag, struct tt__IPv6NetworkInterfaceSetConfiguration *a, const char *type)
{
	size_t soap_flag_Enabled = 1;
	size_t soap_flag_AcceptRouterAdvert = 1;
	struct soap_blist *soap_blist_Manual = NULL;
	size_t soap_flag_DHCP = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__IPv6NetworkInterfaceSetConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IPv6NetworkInterfaceSetConfiguration, sizeof(struct tt__IPv6NetworkInterfaceSetConfiguration), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__IPv6NetworkInterfaceSetConfiguration(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Enabled && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__boolean_(soap, "tt:Enabled", &a->Enabled, "xsd:boolean"))
				{	soap_flag_Enabled--;
					continue;
				}
			if (soap_flag_AcceptRouterAdvert && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__boolean_(soap, "tt:AcceptRouterAdvert", &a->AcceptRouterAdvert, "xsd:boolean"))
				{	soap_flag_AcceptRouterAdvert--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Manual", 1, NULL))
			{	if (a->Manual == NULL)
				{	if (soap_blist_Manual == NULL)
						soap_blist_Manual = soap_new_block(soap);
					a->Manual = (struct tt__PrefixedIPv6Address *)soap_push_block(soap, soap_blist_Manual, sizeof(struct tt__PrefixedIPv6Address));
					if (a->Manual == NULL)
						return NULL;
					soap_default_tt__PrefixedIPv6Address(soap, a->Manual);
				}
				soap_revert(soap);
				if (soap_in_tt__PrefixedIPv6Address(soap, "tt:Manual", a->Manual, "tt:PrefixedIPv6Address"))
				{	a->__sizeManual++;
					a->Manual = NULL;
					continue;
				}
			}
			if (soap_flag_DHCP && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IPv6DHCPConfiguration(soap, "tt:DHCP", &a->DHCP, "tt:IPv6DHCPConfiguration"))
				{	soap_flag_DHCP--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Manual)
			soap_pop_block(soap, soap_blist_Manual);
		if (a->__sizeManual)
			a->Manual = (struct tt__PrefixedIPv6Address *)soap_save_block(soap, soap_blist_Manual, NULL, 1);
		else
		{	a->Manual = NULL;
			if (soap_blist_Manual)
				soap_end_block(soap, soap_blist_Manual);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__IPv6NetworkInterfaceSetConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__IPv6NetworkInterfaceSetConfiguration, 0, sizeof(struct tt__IPv6NetworkInterfaceSetConfiguration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__IPv6NetworkInterfaceSetConfiguration(struct soap *soap, const struct tt__IPv6NetworkInterfaceSetConfiguration *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__IPv6NetworkInterfaceSetConfiguration);
	if (soap_out_tt__IPv6NetworkInterfaceSetConfiguration(soap, tag?tag:"tt:IPv6NetworkInterfaceSetConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__IPv6NetworkInterfaceSetConfiguration * SOAP_FMAC4 soap_get_tt__IPv6NetworkInterfaceSetConfiguration(struct soap *soap, struct tt__IPv6NetworkInterfaceSetConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__IPv6NetworkInterfaceSetConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__IPv4NetworkInterfaceSetConfiguration(struct soap *soap, struct tt__IPv4NetworkInterfaceSetConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Enabled = NULL;
	a->__sizeManual = 0;
	a->Manual = NULL;
	a->DHCP = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__IPv4NetworkInterfaceSetConfiguration(struct soap *soap, const struct tt__IPv4NetworkInterfaceSetConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__boolean_(soap, &a->Enabled);
	if (a->Manual)
	{	int i;
		for (i = 0; i < a->__sizeManual; i++)
		{
			soap_embedded(soap, a->Manual + i, SOAP_TYPE_tt__PrefixedIPv4Address);
			soap_serialize_tt__PrefixedIPv4Address(soap, a->Manual + i);
		}
	}
	soap_serialize_PointerToxsd__boolean_(soap, &a->DHCP);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IPv4NetworkInterfaceSetConfiguration(struct soap *soap, const char *tag, int id, const struct tt__IPv4NetworkInterfaceSetConfiguration *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__IPv4NetworkInterfaceSetConfiguration), type))
		return soap->error;
	if (soap_out_PointerToxsd__boolean_(soap, "tt:Enabled", -1, &a->Enabled, ""))
		return soap->error;
	if (a->Manual)
	{	int i;
		for (i = 0; i < a->__sizeManual; i++)
			if (soap_out_tt__PrefixedIPv4Address(soap, "tt:Manual", -1, a->Manual + i, ""))
				return soap->error;
	}
	if (soap_out_PointerToxsd__boolean_(soap, "tt:DHCP", -1, &a->DHCP, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__IPv4NetworkInterfaceSetConfiguration * SOAP_FMAC4 soap_in_tt__IPv4NetworkInterfaceSetConfiguration(struct soap *soap, const char *tag, struct tt__IPv4NetworkInterfaceSetConfiguration *a, const char *type)
{
	size_t soap_flag_Enabled = 1;
	struct soap_blist *soap_blist_Manual = NULL;
	size_t soap_flag_DHCP = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__IPv4NetworkInterfaceSetConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IPv4NetworkInterfaceSetConfiguration, sizeof(struct tt__IPv4NetworkInterfaceSetConfiguration), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__IPv4NetworkInterfaceSetConfiguration(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Enabled && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__boolean_(soap, "tt:Enabled", &a->Enabled, "xsd:boolean"))
				{	soap_flag_Enabled--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Manual", 1, NULL))
			{	if (a->Manual == NULL)
				{	if (soap_blist_Manual == NULL)
						soap_blist_Manual = soap_new_block(soap);
					a->Manual = (struct tt__PrefixedIPv4Address *)soap_push_block(soap, soap_blist_Manual, sizeof(struct tt__PrefixedIPv4Address));
					if (a->Manual == NULL)
						return NULL;
					soap_default_tt__PrefixedIPv4Address(soap, a->Manual);
				}
				soap_revert(soap);
				if (soap_in_tt__PrefixedIPv4Address(soap, "tt:Manual", a->Manual, "tt:PrefixedIPv4Address"))
				{	a->__sizeManual++;
					a->Manual = NULL;
					continue;
				}
			}
			if (soap_flag_DHCP && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__boolean_(soap, "tt:DHCP", &a->DHCP, "xsd:boolean"))
				{	soap_flag_DHCP--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Manual)
			soap_pop_block(soap, soap_blist_Manual);
		if (a->__sizeManual)
			a->Manual = (struct tt__PrefixedIPv4Address *)soap_save_block(soap, soap_blist_Manual, NULL, 1);
		else
		{	a->Manual = NULL;
			if (soap_blist_Manual)
				soap_end_block(soap, soap_blist_Manual);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__IPv4NetworkInterfaceSetConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__IPv4NetworkInterfaceSetConfiguration, 0, sizeof(struct tt__IPv4NetworkInterfaceSetConfiguration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__IPv4NetworkInterfaceSetConfiguration(struct soap *soap, const struct tt__IPv4NetworkInterfaceSetConfiguration *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__IPv4NetworkInterfaceSetConfiguration);
	if (soap_out_tt__IPv4NetworkInterfaceSetConfiguration(soap, tag?tag:"tt:IPv4NetworkInterfaceSetConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__IPv4NetworkInterfaceSetConfiguration * SOAP_FMAC4 soap_get_tt__IPv4NetworkInterfaceSetConfiguration(struct soap *soap, struct tt__IPv4NetworkInterfaceSetConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__IPv4NetworkInterfaceSetConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__DynamicDNSInformationExtension(struct soap *soap, struct tt__DynamicDNSInformationExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__DynamicDNSInformationExtension(struct soap *soap, const struct tt__DynamicDNSInformationExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__DynamicDNSInformationExtension(struct soap *soap, const char *tag, int id, const struct tt__DynamicDNSInformationExtension *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__DynamicDNSInformationExtension), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__DynamicDNSInformationExtension * SOAP_FMAC4 soap_in_tt__DynamicDNSInformationExtension(struct soap *soap, const char *tag, struct tt__DynamicDNSInformationExtension *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__DynamicDNSInformationExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__DynamicDNSInformationExtension, sizeof(struct tt__DynamicDNSInformationExtension), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__DynamicDNSInformationExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__DynamicDNSInformationExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__DynamicDNSInformationExtension, 0, sizeof(struct tt__DynamicDNSInformationExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__DynamicDNSInformationExtension(struct soap *soap, const struct tt__DynamicDNSInformationExtension *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__DynamicDNSInformationExtension);
	if (soap_out_tt__DynamicDNSInformationExtension(soap, tag?tag:"tt:DynamicDNSInformationExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__DynamicDNSInformationExtension * SOAP_FMAC4 soap_get_tt__DynamicDNSInformationExtension(struct soap *soap, struct tt__DynamicDNSInformationExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__DynamicDNSInformationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__NTPInformationExtension(struct soap *soap, struct tt__NTPInformationExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__NTPInformationExtension(struct soap *soap, const struct tt__NTPInformationExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__NTPInformationExtension(struct soap *soap, const char *tag, int id, const struct tt__NTPInformationExtension *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__NTPInformationExtension), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__NTPInformationExtension * SOAP_FMAC4 soap_in_tt__NTPInformationExtension(struct soap *soap, const char *tag, struct tt__NTPInformationExtension *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__NTPInformationExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__NTPInformationExtension, sizeof(struct tt__NTPInformationExtension), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__NTPInformationExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__NTPInformationExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__NTPInformationExtension, 0, sizeof(struct tt__NTPInformationExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__NTPInformationExtension(struct soap *soap, const struct tt__NTPInformationExtension *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__NTPInformationExtension);
	if (soap_out_tt__NTPInformationExtension(soap, tag?tag:"tt:NTPInformationExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__NTPInformationExtension * SOAP_FMAC4 soap_get_tt__NTPInformationExtension(struct soap *soap, struct tt__NTPInformationExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__NTPInformationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__DNSInformationExtension(struct soap *soap, struct tt__DNSInformationExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__DNSInformationExtension(struct soap *soap, const struct tt__DNSInformationExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__DNSInformationExtension(struct soap *soap, const char *tag, int id, const struct tt__DNSInformationExtension *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__DNSInformationExtension), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__DNSInformationExtension * SOAP_FMAC4 soap_in_tt__DNSInformationExtension(struct soap *soap, const char *tag, struct tt__DNSInformationExtension *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__DNSInformationExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__DNSInformationExtension, sizeof(struct tt__DNSInformationExtension), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__DNSInformationExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__DNSInformationExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__DNSInformationExtension, 0, sizeof(struct tt__DNSInformationExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__DNSInformationExtension(struct soap *soap, const struct tt__DNSInformationExtension *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__DNSInformationExtension);
	if (soap_out_tt__DNSInformationExtension(soap, tag?tag:"tt:DNSInformationExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__DNSInformationExtension * SOAP_FMAC4 soap_get_tt__DNSInformationExtension(struct soap *soap, struct tt__DNSInformationExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__DNSInformationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__HostnameInformationExtension(struct soap *soap, struct tt__HostnameInformationExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__HostnameInformationExtension(struct soap *soap, const struct tt__HostnameInformationExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__HostnameInformationExtension(struct soap *soap, const char *tag, int id, const struct tt__HostnameInformationExtension *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__HostnameInformationExtension), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__HostnameInformationExtension * SOAP_FMAC4 soap_in_tt__HostnameInformationExtension(struct soap *soap, const char *tag, struct tt__HostnameInformationExtension *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__HostnameInformationExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__HostnameInformationExtension, sizeof(struct tt__HostnameInformationExtension), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__HostnameInformationExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__HostnameInformationExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__HostnameInformationExtension, 0, sizeof(struct tt__HostnameInformationExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__HostnameInformationExtension(struct soap *soap, const struct tt__HostnameInformationExtension *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__HostnameInformationExtension);
	if (soap_out_tt__HostnameInformationExtension(soap, tag?tag:"tt:HostnameInformationExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__HostnameInformationExtension * SOAP_FMAC4 soap_get_tt__HostnameInformationExtension(struct soap *soap, struct tt__HostnameInformationExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__HostnameInformationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__NetworkHostExtension(struct soap *soap, struct tt__NetworkHostExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__NetworkHostExtension(struct soap *soap, const struct tt__NetworkHostExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__NetworkHostExtension(struct soap *soap, const char *tag, int id, const struct tt__NetworkHostExtension *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__NetworkHostExtension), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__NetworkHostExtension * SOAP_FMAC4 soap_in_tt__NetworkHostExtension(struct soap *soap, const char *tag, struct tt__NetworkHostExtension *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__NetworkHostExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__NetworkHostExtension, sizeof(struct tt__NetworkHostExtension), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__NetworkHostExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__NetworkHostExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__NetworkHostExtension, 0, sizeof(struct tt__NetworkHostExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__NetworkHostExtension(struct soap *soap, const struct tt__NetworkHostExtension *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__NetworkHostExtension);
	if (soap_out_tt__NetworkHostExtension(soap, tag?tag:"tt:NetworkHostExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__NetworkHostExtension * SOAP_FMAC4 soap_get_tt__NetworkHostExtension(struct soap *soap, struct tt__NetworkHostExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__NetworkHostExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__NetworkProtocolExtension(struct soap *soap, struct tt__NetworkProtocolExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__NetworkProtocolExtension(struct soap *soap, const struct tt__NetworkProtocolExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__NetworkProtocolExtension(struct soap *soap, const char *tag, int id, const struct tt__NetworkProtocolExtension *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__NetworkProtocolExtension), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__NetworkProtocolExtension * SOAP_FMAC4 soap_in_tt__NetworkProtocolExtension(struct soap *soap, const char *tag, struct tt__NetworkProtocolExtension *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__NetworkProtocolExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__NetworkProtocolExtension, sizeof(struct tt__NetworkProtocolExtension), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__NetworkProtocolExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__NetworkProtocolExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__NetworkProtocolExtension, 0, sizeof(struct tt__NetworkProtocolExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__NetworkProtocolExtension(struct soap *soap, const struct tt__NetworkProtocolExtension *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__NetworkProtocolExtension);
	if (soap_out_tt__NetworkProtocolExtension(soap, tag?tag:"tt:NetworkProtocolExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__NetworkProtocolExtension * SOAP_FMAC4 soap_get_tt__NetworkProtocolExtension(struct soap *soap, struct tt__NetworkProtocolExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__NetworkProtocolExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__IPv6ConfigurationExtension(struct soap *soap, struct tt__IPv6ConfigurationExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__IPv6ConfigurationExtension(struct soap *soap, const struct tt__IPv6ConfigurationExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IPv6ConfigurationExtension(struct soap *soap, const char *tag, int id, const struct tt__IPv6ConfigurationExtension *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__IPv6ConfigurationExtension), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__IPv6ConfigurationExtension * SOAP_FMAC4 soap_in_tt__IPv6ConfigurationExtension(struct soap *soap, const char *tag, struct tt__IPv6ConfigurationExtension *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__IPv6ConfigurationExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IPv6ConfigurationExtension, sizeof(struct tt__IPv6ConfigurationExtension), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__IPv6ConfigurationExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__IPv6ConfigurationExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__IPv6ConfigurationExtension, 0, sizeof(struct tt__IPv6ConfigurationExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__IPv6ConfigurationExtension(struct soap *soap, const struct tt__IPv6ConfigurationExtension *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__IPv6ConfigurationExtension);
	if (soap_out_tt__IPv6ConfigurationExtension(soap, tag?tag:"tt:IPv6ConfigurationExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__IPv6ConfigurationExtension * SOAP_FMAC4 soap_get_tt__IPv6ConfigurationExtension(struct soap *soap, struct tt__IPv6ConfigurationExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__IPv6ConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__PrefixedIPv6Address(struct soap *soap, struct tt__PrefixedIPv6Address *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__IPv6Address(soap, &a->Address);
	soap_default_int(soap, &a->PrefixLength);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__PrefixedIPv6Address(struct soap *soap, const struct tt__PrefixedIPv6Address *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_tt__IPv6Address(soap, &a->Address);
	soap_embedded(soap, &a->PrefixLength, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PrefixedIPv6Address(struct soap *soap, const char *tag, int id, const struct tt__PrefixedIPv6Address *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PrefixedIPv6Address), type))
		return soap->error;
	if (a->Address)
	{	if (soap_out_tt__IPv6Address(soap, "tt:Address", -1, &a->Address, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:Address"))
		return soap->error;
	if (soap_out_int(soap, "tt:PrefixLength", -1, &a->PrefixLength, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__PrefixedIPv6Address * SOAP_FMAC4 soap_in_tt__PrefixedIPv6Address(struct soap *soap, const char *tag, struct tt__PrefixedIPv6Address *a, const char *type)
{
	size_t soap_flag_Address = 1;
	size_t soap_flag_PrefixLength = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__PrefixedIPv6Address *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PrefixedIPv6Address, sizeof(struct tt__PrefixedIPv6Address), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__PrefixedIPv6Address(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Address && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__IPv6Address(soap, "tt:Address", &a->Address, "tt:IPv6Address"))
				{	soap_flag_Address--;
					continue;
				}
			if (soap_flag_PrefixLength && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "tt:PrefixLength", &a->PrefixLength, "xsd:int"))
				{	soap_flag_PrefixLength--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__PrefixedIPv6Address *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PrefixedIPv6Address, 0, sizeof(struct tt__PrefixedIPv6Address), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Address > 0 || soap_flag_PrefixLength > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__PrefixedIPv6Address(struct soap *soap, const struct tt__PrefixedIPv6Address *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__PrefixedIPv6Address);
	if (soap_out_tt__PrefixedIPv6Address(soap, tag?tag:"tt:PrefixedIPv6Address", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PrefixedIPv6Address * SOAP_FMAC4 soap_get_tt__PrefixedIPv6Address(struct soap *soap, struct tt__PrefixedIPv6Address *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PrefixedIPv6Address(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__PrefixedIPv4Address(struct soap *soap, struct tt__PrefixedIPv4Address *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__IPv4Address(soap, &a->Address);
	soap_default_int(soap, &a->PrefixLength);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__PrefixedIPv4Address(struct soap *soap, const struct tt__PrefixedIPv4Address *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_tt__IPv4Address(soap, &a->Address);
	soap_embedded(soap, &a->PrefixLength, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PrefixedIPv4Address(struct soap *soap, const char *tag, int id, const struct tt__PrefixedIPv4Address *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PrefixedIPv4Address), type))
		return soap->error;
	if (a->Address)
	{	if (soap_out_tt__IPv4Address(soap, "tt:Address", -1, &a->Address, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:Address"))
		return soap->error;
	if (soap_out_int(soap, "tt:PrefixLength", -1, &a->PrefixLength, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__PrefixedIPv4Address * SOAP_FMAC4 soap_in_tt__PrefixedIPv4Address(struct soap *soap, const char *tag, struct tt__PrefixedIPv4Address *a, const char *type)
{
	size_t soap_flag_Address = 1;
	size_t soap_flag_PrefixLength = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__PrefixedIPv4Address *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PrefixedIPv4Address, sizeof(struct tt__PrefixedIPv4Address), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__PrefixedIPv4Address(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Address && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__IPv4Address(soap, "tt:Address", &a->Address, "tt:IPv4Address"))
				{	soap_flag_Address--;
					continue;
				}
			if (soap_flag_PrefixLength && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "tt:PrefixLength", &a->PrefixLength, "xsd:int"))
				{	soap_flag_PrefixLength--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__PrefixedIPv4Address *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PrefixedIPv4Address, 0, sizeof(struct tt__PrefixedIPv4Address), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Address > 0 || soap_flag_PrefixLength > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__PrefixedIPv4Address(struct soap *soap, const struct tt__PrefixedIPv4Address *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__PrefixedIPv4Address);
	if (soap_out_tt__PrefixedIPv4Address(soap, tag?tag:"tt:PrefixedIPv4Address", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PrefixedIPv4Address * SOAP_FMAC4 soap_get_tt__PrefixedIPv4Address(struct soap *soap, struct tt__PrefixedIPv4Address *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PrefixedIPv4Address(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__IPv4Configuration(struct soap *soap, struct tt__IPv4Configuration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeManual = 0;
	a->Manual = NULL;
	a->LinkLocal = NULL;
	a->FromDHCP = NULL;
	soap_default_xsd__boolean_(soap, &a->DHCP);
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__IPv4Configuration(struct soap *soap, const struct tt__IPv4Configuration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->Manual)
	{	int i;
		for (i = 0; i < a->__sizeManual; i++)
		{
			soap_embedded(soap, a->Manual + i, SOAP_TYPE_tt__PrefixedIPv4Address);
			soap_serialize_tt__PrefixedIPv4Address(soap, a->Manual + i);
		}
	}
	soap_serialize_PointerTott__PrefixedIPv4Address(soap, &a->LinkLocal);
	soap_serialize_PointerTott__PrefixedIPv4Address(soap, &a->FromDHCP);
	soap_embedded(soap, &a->DHCP, SOAP_TYPE_xsd__boolean_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IPv4Configuration(struct soap *soap, const char *tag, int id, const struct tt__IPv4Configuration *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__IPv4Configuration), type))
		return soap->error;
	if (a->Manual)
	{	int i;
		for (i = 0; i < a->__sizeManual; i++)
			if (soap_out_tt__PrefixedIPv4Address(soap, "tt:Manual", -1, a->Manual + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTott__PrefixedIPv4Address(soap, "tt:LinkLocal", -1, &a->LinkLocal, ""))
		return soap->error;
	if (soap_out_PointerTott__PrefixedIPv4Address(soap, "tt:FromDHCP", -1, &a->FromDHCP, ""))
		return soap->error;
	if (soap_out_xsd__boolean_(soap, "tt:DHCP", -1, &a->DHCP, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__IPv4Configuration * SOAP_FMAC4 soap_in_tt__IPv4Configuration(struct soap *soap, const char *tag, struct tt__IPv4Configuration *a, const char *type)
{
	struct soap_blist *soap_blist_Manual = NULL;
	size_t soap_flag_LinkLocal = 1;
	size_t soap_flag_FromDHCP = 1;
	size_t soap_flag_DHCP = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__IPv4Configuration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IPv4Configuration, sizeof(struct tt__IPv4Configuration), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__IPv4Configuration(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Manual", 1, NULL))
			{	if (a->Manual == NULL)
				{	if (soap_blist_Manual == NULL)
						soap_blist_Manual = soap_new_block(soap);
					a->Manual = (struct tt__PrefixedIPv4Address *)soap_push_block(soap, soap_blist_Manual, sizeof(struct tt__PrefixedIPv4Address));
					if (a->Manual == NULL)
						return NULL;
					soap_default_tt__PrefixedIPv4Address(soap, a->Manual);
				}
				soap_revert(soap);
				if (soap_in_tt__PrefixedIPv4Address(soap, "tt:Manual", a->Manual, "tt:PrefixedIPv4Address"))
				{	a->__sizeManual++;
					a->Manual = NULL;
					continue;
				}
			}
			if (soap_flag_LinkLocal && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__PrefixedIPv4Address(soap, "tt:LinkLocal", &a->LinkLocal, "tt:PrefixedIPv4Address"))
				{	soap_flag_LinkLocal--;
					continue;
				}
			if (soap_flag_FromDHCP && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__PrefixedIPv4Address(soap, "tt:FromDHCP", &a->FromDHCP, "tt:PrefixedIPv4Address"))
				{	soap_flag_FromDHCP--;
					continue;
				}
			if (soap_flag_DHCP && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean_(soap, "tt:DHCP", &a->DHCP, "xsd:boolean"))
				{	soap_flag_DHCP--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Manual)
			soap_pop_block(soap, soap_blist_Manual);
		if (a->__sizeManual)
			a->Manual = (struct tt__PrefixedIPv4Address *)soap_save_block(soap, soap_blist_Manual, NULL, 1);
		else
		{	a->Manual = NULL;
			if (soap_blist_Manual)
				soap_end_block(soap, soap_blist_Manual);
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__IPv4Configuration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__IPv4Configuration, 0, sizeof(struct tt__IPv4Configuration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_DHCP > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__IPv4Configuration(struct soap *soap, const struct tt__IPv4Configuration *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__IPv4Configuration);
	if (soap_out_tt__IPv4Configuration(soap, tag?tag:"tt:IPv4Configuration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__IPv4Configuration * SOAP_FMAC4 soap_get_tt__IPv4Configuration(struct soap *soap, struct tt__IPv4Configuration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__IPv4Configuration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__IPv4NetworkInterface(struct soap *soap, struct tt__IPv4NetworkInterface *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__boolean_(soap, &a->Enabled);
	a->Config = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__IPv4NetworkInterface(struct soap *soap, const struct tt__IPv4NetworkInterface *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->Enabled, SOAP_TYPE_xsd__boolean_);
	soap_serialize_PointerTott__IPv4Configuration(soap, &a->Config);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IPv4NetworkInterface(struct soap *soap, const char *tag, int id, const struct tt__IPv4NetworkInterface *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__IPv4NetworkInterface), type))
		return soap->error;
	if (soap_out_xsd__boolean_(soap, "tt:Enabled", -1, &a->Enabled, ""))
		return soap->error;
	if (a->Config)
	{	if (soap_out_PointerTott__IPv4Configuration(soap, "tt:Config", -1, &a->Config, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:Config"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__IPv4NetworkInterface * SOAP_FMAC4 soap_in_tt__IPv4NetworkInterface(struct soap *soap, const char *tag, struct tt__IPv4NetworkInterface *a, const char *type)
{
	size_t soap_flag_Enabled = 1;
	size_t soap_flag_Config = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__IPv4NetworkInterface *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IPv4NetworkInterface, sizeof(struct tt__IPv4NetworkInterface), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__IPv4NetworkInterface(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Enabled && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean_(soap, "tt:Enabled", &a->Enabled, "xsd:boolean"))
				{	soap_flag_Enabled--;
					continue;
				}
			if (soap_flag_Config && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IPv4Configuration(soap, "tt:Config", &a->Config, "tt:IPv4Configuration"))
				{	soap_flag_Config--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__IPv4NetworkInterface *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__IPv4NetworkInterface, 0, sizeof(struct tt__IPv4NetworkInterface), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Enabled > 0 || soap_flag_Config > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__IPv4NetworkInterface(struct soap *soap, const struct tt__IPv4NetworkInterface *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__IPv4NetworkInterface);
	if (soap_out_tt__IPv4NetworkInterface(soap, tag?tag:"tt:IPv4NetworkInterface", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__IPv4NetworkInterface * SOAP_FMAC4 soap_get_tt__IPv4NetworkInterface(struct soap *soap, struct tt__IPv4NetworkInterface *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__IPv4NetworkInterface(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__IPv6Configuration(struct soap *soap, struct tt__IPv6Configuration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->AcceptRouterAdvert = NULL;
	soap_default_tt__IPv6DHCPConfiguration(soap, &a->DHCP);
	a->__sizeManual = 0;
	a->Manual = NULL;
	a->__sizeLinkLocal = 0;
	a->LinkLocal = NULL;
	a->__sizeFromDHCP = 0;
	a->FromDHCP = NULL;
	a->__sizeFromRA = 0;
	a->FromRA = NULL;
	a->Extension = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__IPv6Configuration(struct soap *soap, const struct tt__IPv6Configuration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__boolean_(soap, &a->AcceptRouterAdvert);
	soap_embedded(soap, &a->DHCP, SOAP_TYPE_tt__IPv6DHCPConfiguration);
	if (a->Manual)
	{	int i;
		for (i = 0; i < a->__sizeManual; i++)
		{
			soap_embedded(soap, a->Manual + i, SOAP_TYPE_tt__PrefixedIPv6Address);
			soap_serialize_tt__PrefixedIPv6Address(soap, a->Manual + i);
		}
	}
	if (a->LinkLocal)
	{	int i;
		for (i = 0; i < a->__sizeLinkLocal; i++)
		{
			soap_embedded(soap, a->LinkLocal + i, SOAP_TYPE_tt__PrefixedIPv6Address);
			soap_serialize_tt__PrefixedIPv6Address(soap, a->LinkLocal + i);
		}
	}
	if (a->FromDHCP)
	{	int i;
		for (i = 0; i < a->__sizeFromDHCP; i++)
		{
			soap_embedded(soap, a->FromDHCP + i, SOAP_TYPE_tt__PrefixedIPv6Address);
			soap_serialize_tt__PrefixedIPv6Address(soap, a->FromDHCP + i);
		}
	}
	if (a->FromRA)
	{	int i;
		for (i = 0; i < a->__sizeFromRA; i++)
		{
			soap_embedded(soap, a->FromRA + i, SOAP_TYPE_tt__PrefixedIPv6Address);
			soap_serialize_tt__PrefixedIPv6Address(soap, a->FromRA + i);
		}
	}
	soap_serialize_PointerTott__IPv6ConfigurationExtension(soap, &a->Extension);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IPv6Configuration(struct soap *soap, const char *tag, int id, const struct tt__IPv6Configuration *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__IPv6Configuration), type))
		return soap->error;
	if (soap_out_PointerToxsd__boolean_(soap, "tt:AcceptRouterAdvert", -1, &a->AcceptRouterAdvert, ""))
		return soap->error;
	if (soap_out_tt__IPv6DHCPConfiguration(soap, "tt:DHCP", -1, &a->DHCP, ""))
		return soap->error;
	if (a->Manual)
	{	int i;
		for (i = 0; i < a->__sizeManual; i++)
			if (soap_out_tt__PrefixedIPv6Address(soap, "tt:Manual", -1, a->Manual + i, ""))
				return soap->error;
	}
	if (a->LinkLocal)
	{	int i;
		for (i = 0; i < a->__sizeLinkLocal; i++)
			if (soap_out_tt__PrefixedIPv6Address(soap, "tt:LinkLocal", -1, a->LinkLocal + i, ""))
				return soap->error;
	}
	if (a->FromDHCP)
	{	int i;
		for (i = 0; i < a->__sizeFromDHCP; i++)
			if (soap_out_tt__PrefixedIPv6Address(soap, "tt:FromDHCP", -1, a->FromDHCP + i, ""))
				return soap->error;
	}
	if (a->FromRA)
	{	int i;
		for (i = 0; i < a->__sizeFromRA; i++)
			if (soap_out_tt__PrefixedIPv6Address(soap, "tt:FromRA", -1, a->FromRA + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTott__IPv6ConfigurationExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__IPv6Configuration * SOAP_FMAC4 soap_in_tt__IPv6Configuration(struct soap *soap, const char *tag, struct tt__IPv6Configuration *a, const char *type)
{
	size_t soap_flag_AcceptRouterAdvert = 1;
	size_t soap_flag_DHCP = 1;
	struct soap_blist *soap_blist_Manual = NULL;
	struct soap_blist *soap_blist_LinkLocal = NULL;
	struct soap_blist *soap_blist_FromDHCP = NULL;
	struct soap_blist *soap_blist_FromRA = NULL;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__IPv6Configuration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IPv6Configuration, sizeof(struct tt__IPv6Configuration), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__IPv6Configuration(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_AcceptRouterAdvert && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__boolean_(soap, "tt:AcceptRouterAdvert", &a->AcceptRouterAdvert, "xsd:boolean"))
				{	soap_flag_AcceptRouterAdvert--;
					continue;
				}
			if (soap_flag_DHCP && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_tt__IPv6DHCPConfiguration(soap, "tt:DHCP", &a->DHCP, "tt:IPv6DHCPConfiguration"))
				{	soap_flag_DHCP--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Manual", 1, NULL))
			{	if (a->Manual == NULL)
				{	if (soap_blist_Manual == NULL)
						soap_blist_Manual = soap_new_block(soap);
					a->Manual = (struct tt__PrefixedIPv6Address *)soap_push_block(soap, soap_blist_Manual, sizeof(struct tt__PrefixedIPv6Address));
					if (a->Manual == NULL)
						return NULL;
					soap_default_tt__PrefixedIPv6Address(soap, a->Manual);
				}
				soap_revert(soap);
				if (soap_in_tt__PrefixedIPv6Address(soap, "tt:Manual", a->Manual, "tt:PrefixedIPv6Address"))
				{	a->__sizeManual++;
					a->Manual = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:LinkLocal", 1, NULL))
			{	if (a->LinkLocal == NULL)
				{	if (soap_blist_LinkLocal == NULL)
						soap_blist_LinkLocal = soap_new_block(soap);
					a->LinkLocal = (struct tt__PrefixedIPv6Address *)soap_push_block(soap, soap_blist_LinkLocal, sizeof(struct tt__PrefixedIPv6Address));
					if (a->LinkLocal == NULL)
						return NULL;
					soap_default_tt__PrefixedIPv6Address(soap, a->LinkLocal);
				}
				soap_revert(soap);
				if (soap_in_tt__PrefixedIPv6Address(soap, "tt:LinkLocal", a->LinkLocal, "tt:PrefixedIPv6Address"))
				{	a->__sizeLinkLocal++;
					a->LinkLocal = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:FromDHCP", 1, NULL))
			{	if (a->FromDHCP == NULL)
				{	if (soap_blist_FromDHCP == NULL)
						soap_blist_FromDHCP = soap_new_block(soap);
					a->FromDHCP = (struct tt__PrefixedIPv6Address *)soap_push_block(soap, soap_blist_FromDHCP, sizeof(struct tt__PrefixedIPv6Address));
					if (a->FromDHCP == NULL)
						return NULL;
					soap_default_tt__PrefixedIPv6Address(soap, a->FromDHCP);
				}
				soap_revert(soap);
				if (soap_in_tt__PrefixedIPv6Address(soap, "tt:FromDHCP", a->FromDHCP, "tt:PrefixedIPv6Address"))
				{	a->__sizeFromDHCP++;
					a->FromDHCP = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:FromRA", 1, NULL))
			{	if (a->FromRA == NULL)
				{	if (soap_blist_FromRA == NULL)
						soap_blist_FromRA = soap_new_block(soap);
					a->FromRA = (struct tt__PrefixedIPv6Address *)soap_push_block(soap, soap_blist_FromRA, sizeof(struct tt__PrefixedIPv6Address));
					if (a->FromRA == NULL)
						return NULL;
					soap_default_tt__PrefixedIPv6Address(soap, a->FromRA);
				}
				soap_revert(soap);
				if (soap_in_tt__PrefixedIPv6Address(soap, "tt:FromRA", a->FromRA, "tt:PrefixedIPv6Address"))
				{	a->__sizeFromRA++;
					a->FromRA = NULL;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IPv6ConfigurationExtension(soap, "tt:Extension", &a->Extension, "tt:IPv6ConfigurationExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Manual)
			soap_pop_block(soap, soap_blist_Manual);
		if (a->__sizeManual)
			a->Manual = (struct tt__PrefixedIPv6Address *)soap_save_block(soap, soap_blist_Manual, NULL, 1);
		else
		{	a->Manual = NULL;
			if (soap_blist_Manual)
				soap_end_block(soap, soap_blist_Manual);
		}
		if (a->LinkLocal)
			soap_pop_block(soap, soap_blist_LinkLocal);
		if (a->__sizeLinkLocal)
			a->LinkLocal = (struct tt__PrefixedIPv6Address *)soap_save_block(soap, soap_blist_LinkLocal, NULL, 1);
		else
		{	a->LinkLocal = NULL;
			if (soap_blist_LinkLocal)
				soap_end_block(soap, soap_blist_LinkLocal);
		}
		if (a->FromDHCP)
			soap_pop_block(soap, soap_blist_FromDHCP);
		if (a->__sizeFromDHCP)
			a->FromDHCP = (struct tt__PrefixedIPv6Address *)soap_save_block(soap, soap_blist_FromDHCP, NULL, 1);
		else
		{	a->FromDHCP = NULL;
			if (soap_blist_FromDHCP)
				soap_end_block(soap, soap_blist_FromDHCP);
		}
		if (a->FromRA)
			soap_pop_block(soap, soap_blist_FromRA);
		if (a->__sizeFromRA)
			a->FromRA = (struct tt__PrefixedIPv6Address *)soap_save_block(soap, soap_blist_FromRA, NULL, 1);
		else
		{	a->FromRA = NULL;
			if (soap_blist_FromRA)
				soap_end_block(soap, soap_blist_FromRA);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__IPv6Configuration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__IPv6Configuration, 0, sizeof(struct tt__IPv6Configuration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_DHCP > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__IPv6Configuration(struct soap *soap, const struct tt__IPv6Configuration *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__IPv6Configuration);
	if (soap_out_tt__IPv6Configuration(soap, tag?tag:"tt:IPv6Configuration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__IPv6Configuration * SOAP_FMAC4 soap_get_tt__IPv6Configuration(struct soap *soap, struct tt__IPv6Configuration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__IPv6Configuration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__IPv6NetworkInterface(struct soap *soap, struct tt__IPv6NetworkInterface *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__boolean_(soap, &a->Enabled);
	a->Config = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__IPv6NetworkInterface(struct soap *soap, const struct tt__IPv6NetworkInterface *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->Enabled, SOAP_TYPE_xsd__boolean_);
	soap_serialize_PointerTott__IPv6Configuration(soap, &a->Config);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IPv6NetworkInterface(struct soap *soap, const char *tag, int id, const struct tt__IPv6NetworkInterface *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__IPv6NetworkInterface), type))
		return soap->error;
	if (soap_out_xsd__boolean_(soap, "tt:Enabled", -1, &a->Enabled, ""))
		return soap->error;
	if (soap_out_PointerTott__IPv6Configuration(soap, "tt:Config", -1, &a->Config, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__IPv6NetworkInterface * SOAP_FMAC4 soap_in_tt__IPv6NetworkInterface(struct soap *soap, const char *tag, struct tt__IPv6NetworkInterface *a, const char *type)
{
	size_t soap_flag_Enabled = 1;
	size_t soap_flag_Config = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__IPv6NetworkInterface *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IPv6NetworkInterface, sizeof(struct tt__IPv6NetworkInterface), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__IPv6NetworkInterface(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Enabled && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean_(soap, "tt:Enabled", &a->Enabled, "xsd:boolean"))
				{	soap_flag_Enabled--;
					continue;
				}
			if (soap_flag_Config && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IPv6Configuration(soap, "tt:Config", &a->Config, "tt:IPv6Configuration"))
				{	soap_flag_Config--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__IPv6NetworkInterface *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__IPv6NetworkInterface, 0, sizeof(struct tt__IPv6NetworkInterface), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Enabled > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__IPv6NetworkInterface(struct soap *soap, const struct tt__IPv6NetworkInterface *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__IPv6NetworkInterface);
	if (soap_out_tt__IPv6NetworkInterface(soap, tag?tag:"tt:IPv6NetworkInterface", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__IPv6NetworkInterface * SOAP_FMAC4 soap_get_tt__IPv6NetworkInterface(struct soap *soap, struct tt__IPv6NetworkInterface *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__IPv6NetworkInterface(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__NetworkInterfaceInfo(struct soap *soap, struct tt__NetworkInterfaceInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Name);
	soap_default_tt__HwAddress(soap, &a->HwAddress);
	a->MTU = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__NetworkInterfaceInfo(struct soap *soap, const struct tt__NetworkInterfaceInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Name);
	soap_serialize_tt__HwAddress(soap, &a->HwAddress);
	soap_serialize_PointerToint(soap, &a->MTU);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__NetworkInterfaceInfo(struct soap *soap, const char *tag, int id, const struct tt__NetworkInterfaceInfo *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__NetworkInterfaceInfo), type))
		return soap->error;
	if (soap_out_string(soap, "tt:Name", -1, &a->Name, ""))
		return soap->error;
	if (a->HwAddress)
	{	if (soap_out_tt__HwAddress(soap, "tt:HwAddress", -1, &a->HwAddress, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:HwAddress"))
		return soap->error;
	if (soap_out_PointerToint(soap, "tt:MTU", -1, &a->MTU, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__NetworkInterfaceInfo * SOAP_FMAC4 soap_in_tt__NetworkInterfaceInfo(struct soap *soap, const char *tag, struct tt__NetworkInterfaceInfo *a, const char *type)
{
	size_t soap_flag_Name = 1;
	size_t soap_flag_HwAddress = 1;
	size_t soap_flag_MTU = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__NetworkInterfaceInfo *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__NetworkInterfaceInfo, sizeof(struct tt__NetworkInterfaceInfo), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__NetworkInterfaceInfo(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "tt:Name", &a->Name, "xsd:string"))
				{	soap_flag_Name--;
					continue;
				}
			if (soap_flag_HwAddress && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__HwAddress(soap, "tt:HwAddress", &a->HwAddress, "tt:HwAddress"))
				{	soap_flag_HwAddress--;
					continue;
				}
			if (soap_flag_MTU && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "tt:MTU", &a->MTU, "xsd:int"))
				{	soap_flag_MTU--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__NetworkInterfaceInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__NetworkInterfaceInfo, 0, sizeof(struct tt__NetworkInterfaceInfo), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_HwAddress > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__NetworkInterfaceInfo(struct soap *soap, const struct tt__NetworkInterfaceInfo *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__NetworkInterfaceInfo);
	if (soap_out_tt__NetworkInterfaceInfo(soap, tag?tag:"tt:NetworkInterfaceInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__NetworkInterfaceInfo * SOAP_FMAC4 soap_get_tt__NetworkInterfaceInfo(struct soap *soap, struct tt__NetworkInterfaceInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__NetworkInterfaceInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__NetworkInterfaceConnectionSetting(struct soap *soap, struct tt__NetworkInterfaceConnectionSetting *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__boolean_(soap, &a->AutoNegotiation);
	soap_default_int(soap, &a->Speed);
	soap_default_tt__Duplex(soap, &a->Duplex);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__NetworkInterfaceConnectionSetting(struct soap *soap, const struct tt__NetworkInterfaceConnectionSetting *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->AutoNegotiation, SOAP_TYPE_xsd__boolean_);
	soap_embedded(soap, &a->Speed, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__NetworkInterfaceConnectionSetting(struct soap *soap, const char *tag, int id, const struct tt__NetworkInterfaceConnectionSetting *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__NetworkInterfaceConnectionSetting), type))
		return soap->error;
	if (soap_out_xsd__boolean_(soap, "tt:AutoNegotiation", -1, &a->AutoNegotiation, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:Speed", -1, &a->Speed, ""))
		return soap->error;
	if (soap_out_tt__Duplex(soap, "tt:Duplex", -1, &a->Duplex, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__NetworkInterfaceConnectionSetting * SOAP_FMAC4 soap_in_tt__NetworkInterfaceConnectionSetting(struct soap *soap, const char *tag, struct tt__NetworkInterfaceConnectionSetting *a, const char *type)
{
	size_t soap_flag_AutoNegotiation = 1;
	size_t soap_flag_Speed = 1;
	size_t soap_flag_Duplex = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__NetworkInterfaceConnectionSetting *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__NetworkInterfaceConnectionSetting, sizeof(struct tt__NetworkInterfaceConnectionSetting), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__NetworkInterfaceConnectionSetting(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_AutoNegotiation && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean_(soap, "tt:AutoNegotiation", &a->AutoNegotiation, "xsd:boolean"))
				{	soap_flag_AutoNegotiation--;
					continue;
				}
			if (soap_flag_Speed && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "tt:Speed", &a->Speed, "xsd:int"))
				{	soap_flag_Speed--;
					continue;
				}
			if (soap_flag_Duplex && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_tt__Duplex(soap, "tt:Duplex", &a->Duplex, "tt:Duplex"))
				{	soap_flag_Duplex--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__NetworkInterfaceConnectionSetting *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__NetworkInterfaceConnectionSetting, 0, sizeof(struct tt__NetworkInterfaceConnectionSetting), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_AutoNegotiation > 0 || soap_flag_Speed > 0 || soap_flag_Duplex > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__NetworkInterfaceConnectionSetting(struct soap *soap, const struct tt__NetworkInterfaceConnectionSetting *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__NetworkInterfaceConnectionSetting);
	if (soap_out_tt__NetworkInterfaceConnectionSetting(soap, tag?tag:"tt:NetworkInterfaceConnectionSetting", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__NetworkInterfaceConnectionSetting * SOAP_FMAC4 soap_get_tt__NetworkInterfaceConnectionSetting(struct soap *soap, struct tt__NetworkInterfaceConnectionSetting *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__NetworkInterfaceConnectionSetting(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__NetworkInterfaceLink(struct soap *soap, struct tt__NetworkInterfaceLink *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->AdminSettings = NULL;
	a->OperSettings = NULL;
	soap_default_tt__IANA_IfTypes(soap, &a->InterfaceType);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__NetworkInterfaceLink(struct soap *soap, const struct tt__NetworkInterfaceLink *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTott__NetworkInterfaceConnectionSetting(soap, &a->AdminSettings);
	soap_serialize_PointerTott__NetworkInterfaceConnectionSetting(soap, &a->OperSettings);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__NetworkInterfaceLink(struct soap *soap, const char *tag, int id, const struct tt__NetworkInterfaceLink *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__NetworkInterfaceLink), type))
		return soap->error;
	if (a->AdminSettings)
	{	if (soap_out_PointerTott__NetworkInterfaceConnectionSetting(soap, "tt:AdminSettings", -1, &a->AdminSettings, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:AdminSettings"))
		return soap->error;
	if (a->OperSettings)
	{	if (soap_out_PointerTott__NetworkInterfaceConnectionSetting(soap, "tt:OperSettings", -1, &a->OperSettings, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:OperSettings"))
		return soap->error;
	if (soap_out_tt__IANA_IfTypes(soap, "tt:InterfaceType", -1, &a->InterfaceType, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__NetworkInterfaceLink * SOAP_FMAC4 soap_in_tt__NetworkInterfaceLink(struct soap *soap, const char *tag, struct tt__NetworkInterfaceLink *a, const char *type)
{
	size_t soap_flag_AdminSettings = 1;
	size_t soap_flag_OperSettings = 1;
	size_t soap_flag_InterfaceType = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__NetworkInterfaceLink *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__NetworkInterfaceLink, sizeof(struct tt__NetworkInterfaceLink), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__NetworkInterfaceLink(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_AdminSettings && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__NetworkInterfaceConnectionSetting(soap, "tt:AdminSettings", &a->AdminSettings, "tt:NetworkInterfaceConnectionSetting"))
				{	soap_flag_AdminSettings--;
					continue;
				}
			if (soap_flag_OperSettings && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__NetworkInterfaceConnectionSetting(soap, "tt:OperSettings", &a->OperSettings, "tt:NetworkInterfaceConnectionSetting"))
				{	soap_flag_OperSettings--;
					continue;
				}
			if (soap_flag_InterfaceType && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_tt__IANA_IfTypes(soap, "tt:InterfaceType", &a->InterfaceType, "tt:IANA-IfTypes"))
				{	soap_flag_InterfaceType--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__NetworkInterfaceLink *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__NetworkInterfaceLink, 0, sizeof(struct tt__NetworkInterfaceLink), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_AdminSettings > 0 || soap_flag_OperSettings > 0 || soap_flag_InterfaceType > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__NetworkInterfaceLink(struct soap *soap, const struct tt__NetworkInterfaceLink *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__NetworkInterfaceLink);
	if (soap_out_tt__NetworkInterfaceLink(soap, tag?tag:"tt:NetworkInterfaceLink", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__NetworkInterfaceLink * SOAP_FMAC4 soap_get_tt__NetworkInterfaceLink(struct soap *soap, struct tt__NetworkInterfaceLink *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__NetworkInterfaceLink(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__NetworkInterfaceExtension2(struct soap *soap, struct tt__NetworkInterfaceExtension2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__NetworkInterfaceExtension2(struct soap *soap, const struct tt__NetworkInterfaceExtension2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__NetworkInterfaceExtension2(struct soap *soap, const char *tag, int id, const struct tt__NetworkInterfaceExtension2 *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__NetworkInterfaceExtension2), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__NetworkInterfaceExtension2 * SOAP_FMAC4 soap_in_tt__NetworkInterfaceExtension2(struct soap *soap, const char *tag, struct tt__NetworkInterfaceExtension2 *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__NetworkInterfaceExtension2 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__NetworkInterfaceExtension2, sizeof(struct tt__NetworkInterfaceExtension2), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__NetworkInterfaceExtension2(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__NetworkInterfaceExtension2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__NetworkInterfaceExtension2, 0, sizeof(struct tt__NetworkInterfaceExtension2), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__NetworkInterfaceExtension2(struct soap *soap, const struct tt__NetworkInterfaceExtension2 *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__NetworkInterfaceExtension2);
	if (soap_out_tt__NetworkInterfaceExtension2(soap, tag?tag:"tt:NetworkInterfaceExtension2", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__NetworkInterfaceExtension2 * SOAP_FMAC4 soap_get_tt__NetworkInterfaceExtension2(struct soap *soap, struct tt__NetworkInterfaceExtension2 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__NetworkInterfaceExtension2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__Dot11Configuration(struct soap *soap, struct tt__Dot11Configuration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__Dot11SSIDType(soap, &a->SSID);
	soap_default_tt__Dot11StationMode(soap, &a->Mode);
	soap_default_tt__Name(soap, &a->Alias);
	soap_default_tt__NetworkInterfaceConfigPriority(soap, &a->Priority);
	a->Security = NULL;
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__Dot11Configuration(struct soap *soap, const struct tt__Dot11Configuration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_tt__Dot11SSIDType(soap, &a->SSID);
	soap_serialize_tt__Name(soap, &a->Alias);
	soap_serialize_PointerTott__Dot11SecurityConfiguration(soap, &a->Security);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Dot11Configuration(struct soap *soap, const char *tag, int id, const struct tt__Dot11Configuration *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Dot11Configuration), type))
		return soap->error;
	if (soap_out_tt__Dot11SSIDType(soap, "tt:SSID", -1, &a->SSID, ""))
		return soap->error;
	if (soap_out_tt__Dot11StationMode(soap, "tt:Mode", -1, &a->Mode, ""))
		return soap->error;
	if (a->Alias)
	{	if (soap_out_tt__Name(soap, "tt:Alias", -1, &a->Alias, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:Alias"))
		return soap->error;
	if (soap_out_tt__NetworkInterfaceConfigPriority(soap, "tt:Priority", -1, &a->Priority, ""))
		return soap->error;
	if (a->Security)
	{	if (soap_out_PointerTott__Dot11SecurityConfiguration(soap, "tt:Security", -1, &a->Security, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:Security"))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__Dot11Configuration * SOAP_FMAC4 soap_in_tt__Dot11Configuration(struct soap *soap, const char *tag, struct tt__Dot11Configuration *a, const char *type)
{
	size_t soap_flag_SSID = 1;
	size_t soap_flag_Mode = 1;
	size_t soap_flag_Alias = 1;
	size_t soap_flag_Priority = 1;
	size_t soap_flag_Security = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__Dot11Configuration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Dot11Configuration, sizeof(struct tt__Dot11Configuration), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__Dot11Configuration(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SSID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_tt__Dot11SSIDType(soap, "tt:SSID", &a->SSID, "tt:Dot11SSIDType"))
				{	soap_flag_SSID--;
					continue;
				}
			if (soap_flag_Mode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_tt__Dot11StationMode(soap, "tt:Mode", &a->Mode, "tt:Dot11StationMode"))
				{	soap_flag_Mode--;
					continue;
				}
			if (soap_flag_Alias && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__Name(soap, "tt:Alias", &a->Alias, "tt:Name"))
				{	soap_flag_Alias--;
					continue;
				}
			if (soap_flag_Priority && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_tt__NetworkInterfaceConfigPriority(soap, "tt:Priority", &a->Priority, "tt:NetworkInterfaceConfigPriority"))
				{	soap_flag_Priority--;
					continue;
				}
			if (soap_flag_Security && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__Dot11SecurityConfiguration(soap, "tt:Security", &a->Security, "tt:Dot11SecurityConfiguration"))
				{	soap_flag_Security--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__Dot11Configuration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Dot11Configuration, 0, sizeof(struct tt__Dot11Configuration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_SSID > 0 || soap_flag_Mode > 0 || soap_flag_Alias > 0 || soap_flag_Priority > 0 || soap_flag_Security > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Dot11Configuration(struct soap *soap, const struct tt__Dot11Configuration *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__Dot11Configuration);
	if (soap_out_tt__Dot11Configuration(soap, tag?tag:"tt:Dot11Configuration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Dot11Configuration * SOAP_FMAC4 soap_get_tt__Dot11Configuration(struct soap *soap, struct tt__Dot11Configuration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Dot11Configuration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__Dot3Configuration(struct soap *soap, struct tt__Dot3Configuration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__Dot3Configuration(struct soap *soap, const struct tt__Dot3Configuration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Dot3Configuration(struct soap *soap, const char *tag, int id, const struct tt__Dot3Configuration *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Dot3Configuration), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__Dot3Configuration * SOAP_FMAC4 soap_in_tt__Dot3Configuration(struct soap *soap, const char *tag, struct tt__Dot3Configuration *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__Dot3Configuration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Dot3Configuration, sizeof(struct tt__Dot3Configuration), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__Dot3Configuration(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__Dot3Configuration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Dot3Configuration, 0, sizeof(struct tt__Dot3Configuration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Dot3Configuration(struct soap *soap, const struct tt__Dot3Configuration *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__Dot3Configuration);
	if (soap_out_tt__Dot3Configuration(soap, tag?tag:"tt:Dot3Configuration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Dot3Configuration * SOAP_FMAC4 soap_get_tt__Dot3Configuration(struct soap *soap, struct tt__Dot3Configuration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Dot3Configuration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__NetworkInterfaceExtension(struct soap *soap, struct tt__NetworkInterfaceExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
	soap_default_tt__IANA_IfTypes(soap, &a->InterfaceType);
	a->__sizeDot3 = 0;
	a->Dot3 = NULL;
	a->__sizeDot11 = 0;
	a->Dot11 = NULL;
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__NetworkInterfaceExtension(struct soap *soap, const struct tt__NetworkInterfaceExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->Dot3)
	{	int i;
		for (i = 0; i < a->__sizeDot3; i++)
		{
			soap_embedded(soap, a->Dot3 + i, SOAP_TYPE_tt__Dot3Configuration);
			soap_serialize_tt__Dot3Configuration(soap, a->Dot3 + i);
		}
	}
	if (a->Dot11)
	{	int i;
		for (i = 0; i < a->__sizeDot11; i++)
		{
			soap_embedded(soap, a->Dot11 + i, SOAP_TYPE_tt__Dot11Configuration);
			soap_serialize_tt__Dot11Configuration(soap, a->Dot11 + i);
		}
	}
	soap_serialize_PointerTott__NetworkInterfaceExtension2(soap, &a->Extension);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__NetworkInterfaceExtension(struct soap *soap, const char *tag, int id, const struct tt__NetworkInterfaceExtension *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__NetworkInterfaceExtension), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	if (soap_out_tt__IANA_IfTypes(soap, "tt:InterfaceType", -1, &a->InterfaceType, ""))
		return soap->error;
	if (a->Dot3)
	{	int i;
		for (i = 0; i < a->__sizeDot3; i++)
			if (soap_out_tt__Dot3Configuration(soap, "tt:Dot3", -1, a->Dot3 + i, ""))
				return soap->error;
	}
	if (a->Dot11)
	{	int i;
		for (i = 0; i < a->__sizeDot11; i++)
			if (soap_out_tt__Dot11Configuration(soap, "tt:Dot11", -1, a->Dot11 + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTott__NetworkInterfaceExtension2(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__NetworkInterfaceExtension * SOAP_FMAC4 soap_in_tt__NetworkInterfaceExtension(struct soap *soap, const char *tag, struct tt__NetworkInterfaceExtension *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	size_t soap_flag_InterfaceType = 1;
	struct soap_blist *soap_blist_Dot3 = NULL;
	struct soap_blist *soap_blist_Dot11 = NULL;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__NetworkInterfaceExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__NetworkInterfaceExtension, sizeof(struct tt__NetworkInterfaceExtension), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__NetworkInterfaceExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap_flag_InterfaceType && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_tt__IANA_IfTypes(soap, "tt:InterfaceType", &a->InterfaceType, "tt:IANA-IfTypes"))
				{	soap_flag_InterfaceType--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Dot3", 1, NULL))
			{	if (a->Dot3 == NULL)
				{	if (soap_blist_Dot3 == NULL)
						soap_blist_Dot3 = soap_new_block(soap);
					a->Dot3 = (struct tt__Dot3Configuration *)soap_push_block(soap, soap_blist_Dot3, sizeof(struct tt__Dot3Configuration));
					if (a->Dot3 == NULL)
						return NULL;
					soap_default_tt__Dot3Configuration(soap, a->Dot3);
				}
				soap_revert(soap);
				if (soap_in_tt__Dot3Configuration(soap, "tt:Dot3", a->Dot3, "tt:Dot3Configuration"))
				{	a->__sizeDot3++;
					a->Dot3 = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Dot11", 1, NULL))
			{	if (a->Dot11 == NULL)
				{	if (soap_blist_Dot11 == NULL)
						soap_blist_Dot11 = soap_new_block(soap);
					a->Dot11 = (struct tt__Dot11Configuration *)soap_push_block(soap, soap_blist_Dot11, sizeof(struct tt__Dot11Configuration));
					if (a->Dot11 == NULL)
						return NULL;
					soap_default_tt__Dot11Configuration(soap, a->Dot11);
				}
				soap_revert(soap);
				if (soap_in_tt__Dot11Configuration(soap, "tt:Dot11", a->Dot11, "tt:Dot11Configuration"))
				{	a->__sizeDot11++;
					a->Dot11 = NULL;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__NetworkInterfaceExtension2(soap, "tt:Extension", &a->Extension, "tt:NetworkInterfaceExtension2"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (a->Dot3)
			soap_pop_block(soap, soap_blist_Dot3);
		if (a->__sizeDot3)
			a->Dot3 = (struct tt__Dot3Configuration *)soap_save_block(soap, soap_blist_Dot3, NULL, 1);
		else
		{	a->Dot3 = NULL;
			if (soap_blist_Dot3)
				soap_end_block(soap, soap_blist_Dot3);
		}
		if (a->Dot11)
			soap_pop_block(soap, soap_blist_Dot11);
		if (a->__sizeDot11)
			a->Dot11 = (struct tt__Dot11Configuration *)soap_save_block(soap, soap_blist_Dot11, NULL, 1);
		else
		{	a->Dot11 = NULL;
			if (soap_blist_Dot11)
				soap_end_block(soap, soap_blist_Dot11);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__NetworkInterfaceExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__NetworkInterfaceExtension, 0, sizeof(struct tt__NetworkInterfaceExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_InterfaceType > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__NetworkInterfaceExtension(struct soap *soap, const struct tt__NetworkInterfaceExtension *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__NetworkInterfaceExtension);
	if (soap_out_tt__NetworkInterfaceExtension(soap, tag?tag:"tt:NetworkInterfaceExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__NetworkInterfaceExtension * SOAP_FMAC4 soap_get_tt__NetworkInterfaceExtension(struct soap *soap, struct tt__NetworkInterfaceExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__NetworkInterfaceExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__MediaUri(struct soap *soap, struct tt__MediaUri *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Uri);
	soap_default_xsd__boolean_(soap, &a->InvalidAfterConnect);
	soap_default_xsd__boolean_(soap, &a->InvalidAfterReboot);
	soap_default_string(soap, &a->Timeout);
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__MediaUri(struct soap *soap, const struct tt__MediaUri *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Uri);
	soap_embedded(soap, &a->InvalidAfterConnect, SOAP_TYPE_xsd__boolean_);
	soap_embedded(soap, &a->InvalidAfterReboot, SOAP_TYPE_xsd__boolean_);
	soap_serialize_string(soap, &a->Timeout);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__MediaUri(struct soap *soap, const char *tag, int id, const struct tt__MediaUri *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__MediaUri), type))
		return soap->error;
	if (a->Uri)
	{	if (soap_out_string(soap, "tt:Uri", -1, &a->Uri, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:Uri"))
		return soap->error;
	if (soap_out_xsd__boolean_(soap, "tt:InvalidAfterConnect", -1, &a->InvalidAfterConnect, ""))
		return soap->error;
	if (soap_out_xsd__boolean_(soap, "tt:InvalidAfterReboot", -1, &a->InvalidAfterReboot, ""))
		return soap->error;
	if (a->Timeout)
	{	if (soap_out_string(soap, "tt:Timeout", -1, &a->Timeout, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:Timeout"))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__MediaUri * SOAP_FMAC4 soap_in_tt__MediaUri(struct soap *soap, const char *tag, struct tt__MediaUri *a, const char *type)
{
	size_t soap_flag_Uri = 1;
	size_t soap_flag_InvalidAfterConnect = 1;
	size_t soap_flag_InvalidAfterReboot = 1;
	size_t soap_flag_Timeout = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__MediaUri *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__MediaUri, sizeof(struct tt__MediaUri), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__MediaUri(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Uri && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "tt:Uri", &a->Uri, "xsd:string"))
				{	soap_flag_Uri--;
					continue;
				}
			if (soap_flag_InvalidAfterConnect && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean_(soap, "tt:InvalidAfterConnect", &a->InvalidAfterConnect, "xsd:boolean"))
				{	soap_flag_InvalidAfterConnect--;
					continue;
				}
			if (soap_flag_InvalidAfterReboot && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean_(soap, "tt:InvalidAfterReboot", &a->InvalidAfterReboot, "xsd:boolean"))
				{	soap_flag_InvalidAfterReboot--;
					continue;
				}
			if (soap_flag_Timeout && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "tt:Timeout", &a->Timeout, "xsd:string"))
				{	soap_flag_Timeout--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__MediaUri *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__MediaUri, 0, sizeof(struct tt__MediaUri), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Uri > 0 || soap_flag_InvalidAfterConnect > 0 || soap_flag_InvalidAfterReboot > 0 || soap_flag_Timeout > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__MediaUri(struct soap *soap, const struct tt__MediaUri *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__MediaUri);
	if (soap_out_tt__MediaUri(soap, tag?tag:"tt:MediaUri", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__MediaUri * SOAP_FMAC4 soap_get_tt__MediaUri(struct soap *soap, struct tt__MediaUri *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__MediaUri(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__Transport(struct soap *soap, struct tt__Transport *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__TransportProtocol(soap, &a->Protocol);
	a->Tunnel = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__Transport(struct soap *soap, const struct tt__Transport *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTott__Transport(soap, &a->Tunnel);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Transport(struct soap *soap, const char *tag, int id, const struct tt__Transport *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Transport), type))
		return soap->error;
	if (soap_out_tt__TransportProtocol(soap, "tt:Protocol", -1, &a->Protocol, ""))
		return soap->error;
	if (soap_out_PointerTott__Transport(soap, "tt:Tunnel", -1, &a->Tunnel, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__Transport * SOAP_FMAC4 soap_in_tt__Transport(struct soap *soap, const char *tag, struct tt__Transport *a, const char *type)
{
	size_t soap_flag_Protocol = 1;
	size_t soap_flag_Tunnel = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__Transport *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Transport, sizeof(struct tt__Transport), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__Transport(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Protocol && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_tt__TransportProtocol(soap, "tt:Protocol", &a->Protocol, "tt:TransportProtocol"))
				{	soap_flag_Protocol--;
					continue;
				}
			if (soap_flag_Tunnel && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__Transport(soap, "tt:Tunnel", &a->Tunnel, "tt:Transport"))
				{	soap_flag_Tunnel--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__Transport *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Transport, 0, sizeof(struct tt__Transport), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Protocol > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Transport(struct soap *soap, const struct tt__Transport *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__Transport);
	if (soap_out_tt__Transport(soap, tag?tag:"tt:Transport", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Transport * SOAP_FMAC4 soap_get_tt__Transport(struct soap *soap, struct tt__Transport *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Transport(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__StreamSetup(struct soap *soap, struct tt__StreamSetup *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__StreamType(soap, &a->Stream);
	a->Transport = NULL;
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__StreamSetup(struct soap *soap, const struct tt__StreamSetup *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTott__Transport(soap, &a->Transport);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__StreamSetup(struct soap *soap, const char *tag, int id, const struct tt__StreamSetup *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__StreamSetup), type))
		return soap->error;
	if (soap_out_tt__StreamType(soap, "tt:Stream", -1, &a->Stream, ""))
		return soap->error;
	if (a->Transport)
	{	if (soap_out_PointerTott__Transport(soap, "tt:Transport", -1, &a->Transport, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:Transport"))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__StreamSetup * SOAP_FMAC4 soap_in_tt__StreamSetup(struct soap *soap, const char *tag, struct tt__StreamSetup *a, const char *type)
{
	size_t soap_flag_Stream = 1;
	size_t soap_flag_Transport = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__StreamSetup *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__StreamSetup, sizeof(struct tt__StreamSetup), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__StreamSetup(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Stream && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_tt__StreamType(soap, "tt:Stream", &a->Stream, "tt:StreamType"))
				{	soap_flag_Stream--;
					continue;
				}
			if (soap_flag_Transport && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__Transport(soap, "tt:Transport", &a->Transport, "tt:Transport"))
				{	soap_flag_Transport--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__StreamSetup *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__StreamSetup, 0, sizeof(struct tt__StreamSetup), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Stream > 0 || soap_flag_Transport > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__StreamSetup(struct soap *soap, const struct tt__StreamSetup *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__StreamSetup);
	if (soap_out_tt__StreamSetup(soap, tag?tag:"tt:StreamSetup", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__StreamSetup * SOAP_FMAC4 soap_get_tt__StreamSetup(struct soap *soap, struct tt__StreamSetup *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__StreamSetup(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__MulticastConfiguration(struct soap *soap, struct tt__MulticastConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Address = NULL;
	soap_default_int(soap, &a->Port);
	soap_default_int(soap, &a->TTL);
	soap_default_xsd__boolean_(soap, &a->AutoStart);
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__MulticastConfiguration(struct soap *soap, const struct tt__MulticastConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTott__IPAddress(soap, &a->Address);
	soap_embedded(soap, &a->Port, SOAP_TYPE_int);
	soap_embedded(soap, &a->TTL, SOAP_TYPE_int);
	soap_embedded(soap, &a->AutoStart, SOAP_TYPE_xsd__boolean_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__MulticastConfiguration(struct soap *soap, const char *tag, int id, const struct tt__MulticastConfiguration *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__MulticastConfiguration), type))
		return soap->error;
	if (a->Address)
	{	if (soap_out_PointerTott__IPAddress(soap, "tt:Address", -1, &a->Address, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:Address"))
		return soap->error;
	if (soap_out_int(soap, "tt:Port", -1, &a->Port, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:TTL", -1, &a->TTL, ""))
		return soap->error;
	if (soap_out_xsd__boolean_(soap, "tt:AutoStart", -1, &a->AutoStart, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__MulticastConfiguration * SOAP_FMAC4 soap_in_tt__MulticastConfiguration(struct soap *soap, const char *tag, struct tt__MulticastConfiguration *a, const char *type)
{
	size_t soap_flag_Address = 1;
	size_t soap_flag_Port = 1;
	size_t soap_flag_TTL = 1;
	size_t soap_flag_AutoStart = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__MulticastConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__MulticastConfiguration, sizeof(struct tt__MulticastConfiguration), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__MulticastConfiguration(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Address && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IPAddress(soap, "tt:Address", &a->Address, "tt:IPAddress"))
				{	soap_flag_Address--;
					continue;
				}
			if (soap_flag_Port && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "tt:Port", &a->Port, "xsd:int"))
				{	soap_flag_Port--;
					continue;
				}
			if (soap_flag_TTL && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "tt:TTL", &a->TTL, "xsd:int"))
				{	soap_flag_TTL--;
					continue;
				}
			if (soap_flag_AutoStart && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean_(soap, "tt:AutoStart", &a->AutoStart, "xsd:boolean"))
				{	soap_flag_AutoStart--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__MulticastConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__MulticastConfiguration, 0, sizeof(struct tt__MulticastConfiguration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Address > 0 || soap_flag_Port > 0 || soap_flag_TTL > 0 || soap_flag_AutoStart > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__MulticastConfiguration(struct soap *soap, const struct tt__MulticastConfiguration *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__MulticastConfiguration);
	if (soap_out_tt__MulticastConfiguration(soap, tag?tag:"tt:MulticastConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__MulticastConfiguration * SOAP_FMAC4 soap_get_tt__MulticastConfiguration(struct soap *soap, struct tt__MulticastConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__MulticastConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__AudioDecoderConfigurationOptionsExtension(struct soap *soap, struct tt__AudioDecoderConfigurationOptionsExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__AudioDecoderConfigurationOptionsExtension(struct soap *soap, const struct tt__AudioDecoderConfigurationOptionsExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AudioDecoderConfigurationOptionsExtension(struct soap *soap, const char *tag, int id, const struct tt__AudioDecoderConfigurationOptionsExtension *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AudioDecoderConfigurationOptionsExtension), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__AudioDecoderConfigurationOptionsExtension * SOAP_FMAC4 soap_in_tt__AudioDecoderConfigurationOptionsExtension(struct soap *soap, const char *tag, struct tt__AudioDecoderConfigurationOptionsExtension *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__AudioDecoderConfigurationOptionsExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AudioDecoderConfigurationOptionsExtension, sizeof(struct tt__AudioDecoderConfigurationOptionsExtension), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__AudioDecoderConfigurationOptionsExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__AudioDecoderConfigurationOptionsExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AudioDecoderConfigurationOptionsExtension, 0, sizeof(struct tt__AudioDecoderConfigurationOptionsExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__AudioDecoderConfigurationOptionsExtension(struct soap *soap, const struct tt__AudioDecoderConfigurationOptionsExtension *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__AudioDecoderConfigurationOptionsExtension);
	if (soap_out_tt__AudioDecoderConfigurationOptionsExtension(soap, tag?tag:"tt:AudioDecoderConfigurationOptionsExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AudioDecoderConfigurationOptionsExtension * SOAP_FMAC4 soap_get_tt__AudioDecoderConfigurationOptionsExtension(struct soap *soap, struct tt__AudioDecoderConfigurationOptionsExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AudioDecoderConfigurationOptionsExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__G726DecOptions(struct soap *soap, struct tt__G726DecOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Bitrate = NULL;
	a->SampleRateRange = NULL;
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__G726DecOptions(struct soap *soap, const struct tt__G726DecOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTott__IntList(soap, &a->Bitrate);
	soap_serialize_PointerTott__IntList(soap, &a->SampleRateRange);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__G726DecOptions(struct soap *soap, const char *tag, int id, const struct tt__G726DecOptions *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__G726DecOptions), type))
		return soap->error;
	if (a->Bitrate)
	{	if (soap_out_PointerTott__IntList(soap, "tt:Bitrate", -1, &a->Bitrate, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:Bitrate"))
		return soap->error;
	if (a->SampleRateRange)
	{	if (soap_out_PointerTott__IntList(soap, "tt:SampleRateRange", -1, &a->SampleRateRange, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:SampleRateRange"))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__G726DecOptions * SOAP_FMAC4 soap_in_tt__G726DecOptions(struct soap *soap, const char *tag, struct tt__G726DecOptions *a, const char *type)
{
	size_t soap_flag_Bitrate = 1;
	size_t soap_flag_SampleRateRange = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__G726DecOptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__G726DecOptions, sizeof(struct tt__G726DecOptions), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__G726DecOptions(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Bitrate && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IntList(soap, "tt:Bitrate", &a->Bitrate, "tt:IntList"))
				{	soap_flag_Bitrate--;
					continue;
				}
			if (soap_flag_SampleRateRange && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IntList(soap, "tt:SampleRateRange", &a->SampleRateRange, "tt:IntList"))
				{	soap_flag_SampleRateRange--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__G726DecOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__G726DecOptions, 0, sizeof(struct tt__G726DecOptions), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Bitrate > 0 || soap_flag_SampleRateRange > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__G726DecOptions(struct soap *soap, const struct tt__G726DecOptions *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__G726DecOptions);
	if (soap_out_tt__G726DecOptions(soap, tag?tag:"tt:G726DecOptions", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__G726DecOptions * SOAP_FMAC4 soap_get_tt__G726DecOptions(struct soap *soap, struct tt__G726DecOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__G726DecOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__G711DecOptions(struct soap *soap, struct tt__G711DecOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Bitrate = NULL;
	a->SampleRateRange = NULL;
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__G711DecOptions(struct soap *soap, const struct tt__G711DecOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTott__IntList(soap, &a->Bitrate);
	soap_serialize_PointerTott__IntList(soap, &a->SampleRateRange);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__G711DecOptions(struct soap *soap, const char *tag, int id, const struct tt__G711DecOptions *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__G711DecOptions), type))
		return soap->error;
	if (a->Bitrate)
	{	if (soap_out_PointerTott__IntList(soap, "tt:Bitrate", -1, &a->Bitrate, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:Bitrate"))
		return soap->error;
	if (a->SampleRateRange)
	{	if (soap_out_PointerTott__IntList(soap, "tt:SampleRateRange", -1, &a->SampleRateRange, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:SampleRateRange"))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__G711DecOptions * SOAP_FMAC4 soap_in_tt__G711DecOptions(struct soap *soap, const char *tag, struct tt__G711DecOptions *a, const char *type)
{
	size_t soap_flag_Bitrate = 1;
	size_t soap_flag_SampleRateRange = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__G711DecOptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__G711DecOptions, sizeof(struct tt__G711DecOptions), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__G711DecOptions(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Bitrate && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IntList(soap, "tt:Bitrate", &a->Bitrate, "tt:IntList"))
				{	soap_flag_Bitrate--;
					continue;
				}
			if (soap_flag_SampleRateRange && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IntList(soap, "tt:SampleRateRange", &a->SampleRateRange, "tt:IntList"))
				{	soap_flag_SampleRateRange--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__G711DecOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__G711DecOptions, 0, sizeof(struct tt__G711DecOptions), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Bitrate > 0 || soap_flag_SampleRateRange > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__G711DecOptions(struct soap *soap, const struct tt__G711DecOptions *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__G711DecOptions);
	if (soap_out_tt__G711DecOptions(soap, tag?tag:"tt:G711DecOptions", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__G711DecOptions * SOAP_FMAC4 soap_get_tt__G711DecOptions(struct soap *soap, struct tt__G711DecOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__G711DecOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__AACDecOptions(struct soap *soap, struct tt__AACDecOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Bitrate = NULL;
	a->SampleRateRange = NULL;
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__AACDecOptions(struct soap *soap, const struct tt__AACDecOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTott__IntList(soap, &a->Bitrate);
	soap_serialize_PointerTott__IntList(soap, &a->SampleRateRange);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AACDecOptions(struct soap *soap, const char *tag, int id, const struct tt__AACDecOptions *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AACDecOptions), type))
		return soap->error;
	if (a->Bitrate)
	{	if (soap_out_PointerTott__IntList(soap, "tt:Bitrate", -1, &a->Bitrate, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:Bitrate"))
		return soap->error;
	if (a->SampleRateRange)
	{	if (soap_out_PointerTott__IntList(soap, "tt:SampleRateRange", -1, &a->SampleRateRange, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:SampleRateRange"))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__AACDecOptions * SOAP_FMAC4 soap_in_tt__AACDecOptions(struct soap *soap, const char *tag, struct tt__AACDecOptions *a, const char *type)
{
	size_t soap_flag_Bitrate = 1;
	size_t soap_flag_SampleRateRange = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__AACDecOptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AACDecOptions, sizeof(struct tt__AACDecOptions), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__AACDecOptions(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Bitrate && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IntList(soap, "tt:Bitrate", &a->Bitrate, "tt:IntList"))
				{	soap_flag_Bitrate--;
					continue;
				}
			if (soap_flag_SampleRateRange && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IntList(soap, "tt:SampleRateRange", &a->SampleRateRange, "tt:IntList"))
				{	soap_flag_SampleRateRange--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__AACDecOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AACDecOptions, 0, sizeof(struct tt__AACDecOptions), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Bitrate > 0 || soap_flag_SampleRateRange > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__AACDecOptions(struct soap *soap, const struct tt__AACDecOptions *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__AACDecOptions);
	if (soap_out_tt__AACDecOptions(soap, tag?tag:"tt:AACDecOptions", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AACDecOptions * SOAP_FMAC4 soap_get_tt__AACDecOptions(struct soap *soap, struct tt__AACDecOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AACDecOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__AudioDecoderConfigurationOptions(struct soap *soap, struct tt__AudioDecoderConfigurationOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->AACDecOptions = NULL;
	a->G711DecOptions = NULL;
	a->G726DecOptions = NULL;
	a->Extension = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__AudioDecoderConfigurationOptions(struct soap *soap, const struct tt__AudioDecoderConfigurationOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTott__AACDecOptions(soap, &a->AACDecOptions);
	soap_serialize_PointerTott__G711DecOptions(soap, &a->G711DecOptions);
	soap_serialize_PointerTott__G726DecOptions(soap, &a->G726DecOptions);
	soap_serialize_PointerTott__AudioDecoderConfigurationOptionsExtension(soap, &a->Extension);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AudioDecoderConfigurationOptions(struct soap *soap, const char *tag, int id, const struct tt__AudioDecoderConfigurationOptions *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AudioDecoderConfigurationOptions), type))
		return soap->error;
	if (soap_out_PointerTott__AACDecOptions(soap, "tt:AACDecOptions", -1, &a->AACDecOptions, ""))
		return soap->error;
	if (soap_out_PointerTott__G711DecOptions(soap, "tt:G711DecOptions", -1, &a->G711DecOptions, ""))
		return soap->error;
	if (soap_out_PointerTott__G726DecOptions(soap, "tt:G726DecOptions", -1, &a->G726DecOptions, ""))
		return soap->error;
	if (soap_out_PointerTott__AudioDecoderConfigurationOptionsExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__AudioDecoderConfigurationOptions * SOAP_FMAC4 soap_in_tt__AudioDecoderConfigurationOptions(struct soap *soap, const char *tag, struct tt__AudioDecoderConfigurationOptions *a, const char *type)
{
	size_t soap_flag_AACDecOptions = 1;
	size_t soap_flag_G711DecOptions = 1;
	size_t soap_flag_G726DecOptions = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__AudioDecoderConfigurationOptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AudioDecoderConfigurationOptions, sizeof(struct tt__AudioDecoderConfigurationOptions), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__AudioDecoderConfigurationOptions(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_AACDecOptions && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__AACDecOptions(soap, "tt:AACDecOptions", &a->AACDecOptions, "tt:AACDecOptions"))
				{	soap_flag_AACDecOptions--;
					continue;
				}
			if (soap_flag_G711DecOptions && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__G711DecOptions(soap, "tt:G711DecOptions", &a->G711DecOptions, "tt:G711DecOptions"))
				{	soap_flag_G711DecOptions--;
					continue;
				}
			if (soap_flag_G726DecOptions && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__G726DecOptions(soap, "tt:G726DecOptions", &a->G726DecOptions, "tt:G726DecOptions"))
				{	soap_flag_G726DecOptions--;
					continue;
				}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__AudioDecoderConfigurationOptionsExtension(soap, "tt:Extension", &a->Extension, "tt:AudioDecoderConfigurationOptionsExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__AudioDecoderConfigurationOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AudioDecoderConfigurationOptions, 0, sizeof(struct tt__AudioDecoderConfigurationOptions), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__AudioDecoderConfigurationOptions(struct soap *soap, const struct tt__AudioDecoderConfigurationOptions *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__AudioDecoderConfigurationOptions);
	if (soap_out_tt__AudioDecoderConfigurationOptions(soap, tag?tag:"tt:AudioDecoderConfigurationOptions", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AudioDecoderConfigurationOptions * SOAP_FMAC4 soap_get_tt__AudioDecoderConfigurationOptions(struct soap *soap, struct tt__AudioDecoderConfigurationOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AudioDecoderConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__AudioOutputConfigurationOptions(struct soap *soap, struct tt__AudioOutputConfigurationOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeOutputTokensAvailable = 0;
	a->OutputTokensAvailable = NULL;
	a->__sizeSendPrimacyOptions = 0;
	a->SendPrimacyOptions = NULL;
	a->OutputLevelRange = NULL;
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__AudioOutputConfigurationOptions(struct soap *soap, const struct tt__AudioOutputConfigurationOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->OutputTokensAvailable)
	{	int i;
		for (i = 0; i < a->__sizeOutputTokensAvailable; i++)
		{
			soap_serialize_tt__ReferenceToken(soap, a->OutputTokensAvailable + i);
		}
	}
	if (a->SendPrimacyOptions)
	{	int i;
		for (i = 0; i < a->__sizeSendPrimacyOptions; i++)
		{
			soap_serialize_string(soap, a->SendPrimacyOptions + i);
		}
	}
	soap_serialize_PointerTott__IntRange(soap, &a->OutputLevelRange);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AudioOutputConfigurationOptions(struct soap *soap, const char *tag, int id, const struct tt__AudioOutputConfigurationOptions *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AudioOutputConfigurationOptions), type))
		return soap->error;
	if (a->OutputTokensAvailable)
	{	int i;
		for (i = 0; i < a->__sizeOutputTokensAvailable; i++)
			if (soap_out_tt__ReferenceToken(soap, "tt:OutputTokensAvailable", -1, a->OutputTokensAvailable + i, ""))
				return soap->error;
	}
	if (a->SendPrimacyOptions)
	{	int i;
		for (i = 0; i < a->__sizeSendPrimacyOptions; i++)
			if (soap_out_string(soap, "tt:SendPrimacyOptions", -1, a->SendPrimacyOptions + i, ""))
				return soap->error;
	}
	if (a->OutputLevelRange)
	{	if (soap_out_PointerTott__IntRange(soap, "tt:OutputLevelRange", -1, &a->OutputLevelRange, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:OutputLevelRange"))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__AudioOutputConfigurationOptions * SOAP_FMAC4 soap_in_tt__AudioOutputConfigurationOptions(struct soap *soap, const char *tag, struct tt__AudioOutputConfigurationOptions *a, const char *type)
{
	struct soap_blist *soap_blist_OutputTokensAvailable = NULL;
	struct soap_blist *soap_blist_SendPrimacyOptions = NULL;
	size_t soap_flag_OutputLevelRange = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__AudioOutputConfigurationOptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AudioOutputConfigurationOptions, sizeof(struct tt__AudioOutputConfigurationOptions), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__AudioOutputConfigurationOptions(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:OutputTokensAvailable", 1, NULL))
			{	if (a->OutputTokensAvailable == NULL)
				{	if (soap_blist_OutputTokensAvailable == NULL)
						soap_blist_OutputTokensAvailable = soap_new_block(soap);
					a->OutputTokensAvailable = (char **)soap_push_block(soap, soap_blist_OutputTokensAvailable, sizeof(char *));
					if (a->OutputTokensAvailable == NULL)
						return NULL;
					*a->OutputTokensAvailable = NULL;
				}
				soap_revert(soap);
				if (soap_in_tt__ReferenceToken(soap, "tt:OutputTokensAvailable", a->OutputTokensAvailable, "tt:ReferenceToken"))
				{	a->__sizeOutputTokensAvailable++;
					a->OutputTokensAvailable = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:SendPrimacyOptions", 1, NULL))
			{	if (a->SendPrimacyOptions == NULL)
				{	if (soap_blist_SendPrimacyOptions == NULL)
						soap_blist_SendPrimacyOptions = soap_new_block(soap);
					a->SendPrimacyOptions = (char **)soap_push_block(soap, soap_blist_SendPrimacyOptions, sizeof(char *));
					if (a->SendPrimacyOptions == NULL)
						return NULL;
					*a->SendPrimacyOptions = NULL;
				}
				soap_revert(soap);
				if (soap_in_string(soap, "tt:SendPrimacyOptions", a->SendPrimacyOptions, "xsd:string"))
				{	a->__sizeSendPrimacyOptions++;
					a->SendPrimacyOptions = NULL;
					continue;
				}
			}
			if (soap_flag_OutputLevelRange && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IntRange(soap, "tt:OutputLevelRange", &a->OutputLevelRange, "tt:IntRange"))
				{	soap_flag_OutputLevelRange--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->OutputTokensAvailable)
			soap_pop_block(soap, soap_blist_OutputTokensAvailable);
		if (a->__sizeOutputTokensAvailable)
			a->OutputTokensAvailable = (char **)soap_save_block(soap, soap_blist_OutputTokensAvailable, NULL, 1);
		else
		{	a->OutputTokensAvailable = NULL;
			if (soap_blist_OutputTokensAvailable)
				soap_end_block(soap, soap_blist_OutputTokensAvailable);
		}
		if (a->SendPrimacyOptions)
			soap_pop_block(soap, soap_blist_SendPrimacyOptions);
		if (a->__sizeSendPrimacyOptions)
			a->SendPrimacyOptions = (char **)soap_save_block(soap, soap_blist_SendPrimacyOptions, NULL, 1);
		else
		{	a->SendPrimacyOptions = NULL;
			if (soap_blist_SendPrimacyOptions)
				soap_end_block(soap, soap_blist_SendPrimacyOptions);
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__AudioOutputConfigurationOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AudioOutputConfigurationOptions, 0, sizeof(struct tt__AudioOutputConfigurationOptions), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeOutputTokensAvailable < 1 || soap_flag_OutputLevelRange > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__AudioOutputConfigurationOptions(struct soap *soap, const struct tt__AudioOutputConfigurationOptions *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__AudioOutputConfigurationOptions);
	if (soap_out_tt__AudioOutputConfigurationOptions(soap, tag?tag:"tt:AudioOutputConfigurationOptions", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AudioOutputConfigurationOptions * SOAP_FMAC4 soap_get_tt__AudioOutputConfigurationOptions(struct soap *soap, struct tt__AudioOutputConfigurationOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AudioOutputConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__VideoDecoderConfigurationOptionsExtension(struct soap *soap, struct tt__VideoDecoderConfigurationOptionsExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__VideoDecoderConfigurationOptionsExtension(struct soap *soap, const struct tt__VideoDecoderConfigurationOptionsExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__VideoDecoderConfigurationOptionsExtension(struct soap *soap, const char *tag, int id, const struct tt__VideoDecoderConfigurationOptionsExtension *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__VideoDecoderConfigurationOptionsExtension), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__VideoDecoderConfigurationOptionsExtension * SOAP_FMAC4 soap_in_tt__VideoDecoderConfigurationOptionsExtension(struct soap *soap, const char *tag, struct tt__VideoDecoderConfigurationOptionsExtension *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__VideoDecoderConfigurationOptionsExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__VideoDecoderConfigurationOptionsExtension, sizeof(struct tt__VideoDecoderConfigurationOptionsExtension), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__VideoDecoderConfigurationOptionsExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__VideoDecoderConfigurationOptionsExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__VideoDecoderConfigurationOptionsExtension, 0, sizeof(struct tt__VideoDecoderConfigurationOptionsExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__VideoDecoderConfigurationOptionsExtension(struct soap *soap, const struct tt__VideoDecoderConfigurationOptionsExtension *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__VideoDecoderConfigurationOptionsExtension);
	if (soap_out_tt__VideoDecoderConfigurationOptionsExtension(soap, tag?tag:"tt:VideoDecoderConfigurationOptionsExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__VideoDecoderConfigurationOptionsExtension * SOAP_FMAC4 soap_get_tt__VideoDecoderConfigurationOptionsExtension(struct soap *soap, struct tt__VideoDecoderConfigurationOptionsExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__VideoDecoderConfigurationOptionsExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__Mpeg4DecOptions(struct soap *soap, struct tt__Mpeg4DecOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeResolutionsAvailable = 0;
	a->ResolutionsAvailable = NULL;
	a->__sizeSupportedMpeg4Profiles = 0;
	a->SupportedMpeg4Profiles = NULL;
	a->SupportedInputBitrate = NULL;
	a->SupportedFrameRate = NULL;
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__Mpeg4DecOptions(struct soap *soap, const struct tt__Mpeg4DecOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->ResolutionsAvailable)
	{	int i;
		for (i = 0; i < a->__sizeResolutionsAvailable; i++)
		{
			soap_embedded(soap, a->ResolutionsAvailable + i, SOAP_TYPE_tt__VideoResolution);
			soap_serialize_tt__VideoResolution(soap, a->ResolutionsAvailable + i);
		}
	}
	if (a->SupportedMpeg4Profiles)
	{	int i;
		for (i = 0; i < a->__sizeSupportedMpeg4Profiles; i++)
		{
			soap_embedded(soap, a->SupportedMpeg4Profiles + i, SOAP_TYPE_tt__Mpeg4Profile);
		}
	}
	soap_serialize_PointerTott__IntRange(soap, &a->SupportedInputBitrate);
	soap_serialize_PointerTott__IntRange(soap, &a->SupportedFrameRate);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Mpeg4DecOptions(struct soap *soap, const char *tag, int id, const struct tt__Mpeg4DecOptions *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Mpeg4DecOptions), type))
		return soap->error;
	if (a->ResolutionsAvailable)
	{	int i;
		for (i = 0; i < a->__sizeResolutionsAvailable; i++)
			if (soap_out_tt__VideoResolution(soap, "tt:ResolutionsAvailable", -1, a->ResolutionsAvailable + i, ""))
				return soap->error;
	}
	if (a->SupportedMpeg4Profiles)
	{	int i;
		for (i = 0; i < a->__sizeSupportedMpeg4Profiles; i++)
			if (soap_out_tt__Mpeg4Profile(soap, "tt:SupportedMpeg4Profiles", -1, a->SupportedMpeg4Profiles + i, ""))
				return soap->error;
	}
	if (a->SupportedInputBitrate)
	{	if (soap_out_PointerTott__IntRange(soap, "tt:SupportedInputBitrate", -1, &a->SupportedInputBitrate, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:SupportedInputBitrate"))
		return soap->error;
	if (a->SupportedFrameRate)
	{	if (soap_out_PointerTott__IntRange(soap, "tt:SupportedFrameRate", -1, &a->SupportedFrameRate, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:SupportedFrameRate"))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__Mpeg4DecOptions * SOAP_FMAC4 soap_in_tt__Mpeg4DecOptions(struct soap *soap, const char *tag, struct tt__Mpeg4DecOptions *a, const char *type)
{
	struct soap_blist *soap_blist_ResolutionsAvailable = NULL;
	struct soap_blist *soap_blist_SupportedMpeg4Profiles = NULL;
	size_t soap_flag_SupportedInputBitrate = 1;
	size_t soap_flag_SupportedFrameRate = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__Mpeg4DecOptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Mpeg4DecOptions, sizeof(struct tt__Mpeg4DecOptions), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__Mpeg4DecOptions(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:ResolutionsAvailable", 1, NULL))
			{	if (a->ResolutionsAvailable == NULL)
				{	if (soap_blist_ResolutionsAvailable == NULL)
						soap_blist_ResolutionsAvailable = soap_new_block(soap);
					a->ResolutionsAvailable = (struct tt__VideoResolution *)soap_push_block(soap, soap_blist_ResolutionsAvailable, sizeof(struct tt__VideoResolution));
					if (a->ResolutionsAvailable == NULL)
						return NULL;
					soap_default_tt__VideoResolution(soap, a->ResolutionsAvailable);
				}
				soap_revert(soap);
				if (soap_in_tt__VideoResolution(soap, "tt:ResolutionsAvailable", a->ResolutionsAvailable, "tt:VideoResolution"))
				{	a->__sizeResolutionsAvailable++;
					a->ResolutionsAvailable = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:SupportedMpeg4Profiles", 1, NULL))
			{	if (a->SupportedMpeg4Profiles == NULL)
				{	if (soap_blist_SupportedMpeg4Profiles == NULL)
						soap_blist_SupportedMpeg4Profiles = soap_new_block(soap);
					a->SupportedMpeg4Profiles = (enum tt__Mpeg4Profile *)soap_push_block(soap, soap_blist_SupportedMpeg4Profiles, sizeof(enum tt__Mpeg4Profile));
					if (a->SupportedMpeg4Profiles == NULL)
						return NULL;
					soap_default_tt__Mpeg4Profile(soap, a->SupportedMpeg4Profiles);
				}
				soap_revert(soap);
				if (soap_in_tt__Mpeg4Profile(soap, "tt:SupportedMpeg4Profiles", a->SupportedMpeg4Profiles, "tt:Mpeg4Profile"))
				{	a->__sizeSupportedMpeg4Profiles++;
					a->SupportedMpeg4Profiles = NULL;
					continue;
				}
			}
			if (soap_flag_SupportedInputBitrate && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IntRange(soap, "tt:SupportedInputBitrate", &a->SupportedInputBitrate, "tt:IntRange"))
				{	soap_flag_SupportedInputBitrate--;
					continue;
				}
			if (soap_flag_SupportedFrameRate && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IntRange(soap, "tt:SupportedFrameRate", &a->SupportedFrameRate, "tt:IntRange"))
				{	soap_flag_SupportedFrameRate--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ResolutionsAvailable)
			soap_pop_block(soap, soap_blist_ResolutionsAvailable);
		if (a->__sizeResolutionsAvailable)
			a->ResolutionsAvailable = (struct tt__VideoResolution *)soap_save_block(soap, soap_blist_ResolutionsAvailable, NULL, 1);
		else
		{	a->ResolutionsAvailable = NULL;
			if (soap_blist_ResolutionsAvailable)
				soap_end_block(soap, soap_blist_ResolutionsAvailable);
		}
		if (a->SupportedMpeg4Profiles)
			soap_pop_block(soap, soap_blist_SupportedMpeg4Profiles);
		if (a->__sizeSupportedMpeg4Profiles)
			a->SupportedMpeg4Profiles = (enum tt__Mpeg4Profile *)soap_save_block(soap, soap_blist_SupportedMpeg4Profiles, NULL, 1);
		else
		{	a->SupportedMpeg4Profiles = NULL;
			if (soap_blist_SupportedMpeg4Profiles)
				soap_end_block(soap, soap_blist_SupportedMpeg4Profiles);
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__Mpeg4DecOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Mpeg4DecOptions, 0, sizeof(struct tt__Mpeg4DecOptions), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeResolutionsAvailable < 1 || a->__sizeSupportedMpeg4Profiles < 1 || soap_flag_SupportedInputBitrate > 0 || soap_flag_SupportedFrameRate > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Mpeg4DecOptions(struct soap *soap, const struct tt__Mpeg4DecOptions *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__Mpeg4DecOptions);
	if (soap_out_tt__Mpeg4DecOptions(soap, tag?tag:"tt:Mpeg4DecOptions", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Mpeg4DecOptions * SOAP_FMAC4 soap_get_tt__Mpeg4DecOptions(struct soap *soap, struct tt__Mpeg4DecOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Mpeg4DecOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__H264DecOptions(struct soap *soap, struct tt__H264DecOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeResolutionsAvailable = 0;
	a->ResolutionsAvailable = NULL;
	a->__sizeSupportedH264Profiles = 0;
	a->SupportedH264Profiles = NULL;
	a->SupportedInputBitrate = NULL;
	a->SupportedFrameRate = NULL;
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__H264DecOptions(struct soap *soap, const struct tt__H264DecOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->ResolutionsAvailable)
	{	int i;
		for (i = 0; i < a->__sizeResolutionsAvailable; i++)
		{
			soap_embedded(soap, a->ResolutionsAvailable + i, SOAP_TYPE_tt__VideoResolution);
			soap_serialize_tt__VideoResolution(soap, a->ResolutionsAvailable + i);
		}
	}
	if (a->SupportedH264Profiles)
	{	int i;
		for (i = 0; i < a->__sizeSupportedH264Profiles; i++)
		{
			soap_embedded(soap, a->SupportedH264Profiles + i, SOAP_TYPE_tt__H264Profile);
		}
	}
	soap_serialize_PointerTott__IntRange(soap, &a->SupportedInputBitrate);
	soap_serialize_PointerTott__IntRange(soap, &a->SupportedFrameRate);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__H264DecOptions(struct soap *soap, const char *tag, int id, const struct tt__H264DecOptions *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__H264DecOptions), type))
		return soap->error;
	if (a->ResolutionsAvailable)
	{	int i;
		for (i = 0; i < a->__sizeResolutionsAvailable; i++)
			if (soap_out_tt__VideoResolution(soap, "tt:ResolutionsAvailable", -1, a->ResolutionsAvailable + i, ""))
				return soap->error;
	}
	if (a->SupportedH264Profiles)
	{	int i;
		for (i = 0; i < a->__sizeSupportedH264Profiles; i++)
			if (soap_out_tt__H264Profile(soap, "tt:SupportedH264Profiles", -1, a->SupportedH264Profiles + i, ""))
				return soap->error;
	}
	if (a->SupportedInputBitrate)
	{	if (soap_out_PointerTott__IntRange(soap, "tt:SupportedInputBitrate", -1, &a->SupportedInputBitrate, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:SupportedInputBitrate"))
		return soap->error;
	if (a->SupportedFrameRate)
	{	if (soap_out_PointerTott__IntRange(soap, "tt:SupportedFrameRate", -1, &a->SupportedFrameRate, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:SupportedFrameRate"))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__H264DecOptions * SOAP_FMAC4 soap_in_tt__H264DecOptions(struct soap *soap, const char *tag, struct tt__H264DecOptions *a, const char *type)
{
	struct soap_blist *soap_blist_ResolutionsAvailable = NULL;
	struct soap_blist *soap_blist_SupportedH264Profiles = NULL;
	size_t soap_flag_SupportedInputBitrate = 1;
	size_t soap_flag_SupportedFrameRate = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__H264DecOptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__H264DecOptions, sizeof(struct tt__H264DecOptions), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__H264DecOptions(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:ResolutionsAvailable", 1, NULL))
			{	if (a->ResolutionsAvailable == NULL)
				{	if (soap_blist_ResolutionsAvailable == NULL)
						soap_blist_ResolutionsAvailable = soap_new_block(soap);
					a->ResolutionsAvailable = (struct tt__VideoResolution *)soap_push_block(soap, soap_blist_ResolutionsAvailable, sizeof(struct tt__VideoResolution));
					if (a->ResolutionsAvailable == NULL)
						return NULL;
					soap_default_tt__VideoResolution(soap, a->ResolutionsAvailable);
				}
				soap_revert(soap);
				if (soap_in_tt__VideoResolution(soap, "tt:ResolutionsAvailable", a->ResolutionsAvailable, "tt:VideoResolution"))
				{	a->__sizeResolutionsAvailable++;
					a->ResolutionsAvailable = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:SupportedH264Profiles", 1, NULL))
			{	if (a->SupportedH264Profiles == NULL)
				{	if (soap_blist_SupportedH264Profiles == NULL)
						soap_blist_SupportedH264Profiles = soap_new_block(soap);
					a->SupportedH264Profiles = (enum tt__H264Profile *)soap_push_block(soap, soap_blist_SupportedH264Profiles, sizeof(enum tt__H264Profile));
					if (a->SupportedH264Profiles == NULL)
						return NULL;
					soap_default_tt__H264Profile(soap, a->SupportedH264Profiles);
				}
				soap_revert(soap);
				if (soap_in_tt__H264Profile(soap, "tt:SupportedH264Profiles", a->SupportedH264Profiles, "tt:H264Profile"))
				{	a->__sizeSupportedH264Profiles++;
					a->SupportedH264Profiles = NULL;
					continue;
				}
			}
			if (soap_flag_SupportedInputBitrate && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IntRange(soap, "tt:SupportedInputBitrate", &a->SupportedInputBitrate, "tt:IntRange"))
				{	soap_flag_SupportedInputBitrate--;
					continue;
				}
			if (soap_flag_SupportedFrameRate && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IntRange(soap, "tt:SupportedFrameRate", &a->SupportedFrameRate, "tt:IntRange"))
				{	soap_flag_SupportedFrameRate--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ResolutionsAvailable)
			soap_pop_block(soap, soap_blist_ResolutionsAvailable);
		if (a->__sizeResolutionsAvailable)
			a->ResolutionsAvailable = (struct tt__VideoResolution *)soap_save_block(soap, soap_blist_ResolutionsAvailable, NULL, 1);
		else
		{	a->ResolutionsAvailable = NULL;
			if (soap_blist_ResolutionsAvailable)
				soap_end_block(soap, soap_blist_ResolutionsAvailable);
		}
		if (a->SupportedH264Profiles)
			soap_pop_block(soap, soap_blist_SupportedH264Profiles);
		if (a->__sizeSupportedH264Profiles)
			a->SupportedH264Profiles = (enum tt__H264Profile *)soap_save_block(soap, soap_blist_SupportedH264Profiles, NULL, 1);
		else
		{	a->SupportedH264Profiles = NULL;
			if (soap_blist_SupportedH264Profiles)
				soap_end_block(soap, soap_blist_SupportedH264Profiles);
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__H264DecOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__H264DecOptions, 0, sizeof(struct tt__H264DecOptions), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeResolutionsAvailable < 1 || a->__sizeSupportedH264Profiles < 1 || soap_flag_SupportedInputBitrate > 0 || soap_flag_SupportedFrameRate > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__H264DecOptions(struct soap *soap, const struct tt__H264DecOptions *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__H264DecOptions);
	if (soap_out_tt__H264DecOptions(soap, tag?tag:"tt:H264DecOptions", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__H264DecOptions * SOAP_FMAC4 soap_get_tt__H264DecOptions(struct soap *soap, struct tt__H264DecOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__H264DecOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__JpegDecOptions(struct soap *soap, struct tt__JpegDecOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeResolutionsAvailable = 0;
	a->ResolutionsAvailable = NULL;
	a->SupportedInputBitrate = NULL;
	a->SupportedFrameRate = NULL;
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__JpegDecOptions(struct soap *soap, const struct tt__JpegDecOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->ResolutionsAvailable)
	{	int i;
		for (i = 0; i < a->__sizeResolutionsAvailable; i++)
		{
			soap_embedded(soap, a->ResolutionsAvailable + i, SOAP_TYPE_tt__VideoResolution);
			soap_serialize_tt__VideoResolution(soap, a->ResolutionsAvailable + i);
		}
	}
	soap_serialize_PointerTott__IntRange(soap, &a->SupportedInputBitrate);
	soap_serialize_PointerTott__IntRange(soap, &a->SupportedFrameRate);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__JpegDecOptions(struct soap *soap, const char *tag, int id, const struct tt__JpegDecOptions *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__JpegDecOptions), type))
		return soap->error;
	if (a->ResolutionsAvailable)
	{	int i;
		for (i = 0; i < a->__sizeResolutionsAvailable; i++)
			if (soap_out_tt__VideoResolution(soap, "tt:ResolutionsAvailable", -1, a->ResolutionsAvailable + i, ""))
				return soap->error;
	}
	if (a->SupportedInputBitrate)
	{	if (soap_out_PointerTott__IntRange(soap, "tt:SupportedInputBitrate", -1, &a->SupportedInputBitrate, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:SupportedInputBitrate"))
		return soap->error;
	if (a->SupportedFrameRate)
	{	if (soap_out_PointerTott__IntRange(soap, "tt:SupportedFrameRate", -1, &a->SupportedFrameRate, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:SupportedFrameRate"))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__JpegDecOptions * SOAP_FMAC4 soap_in_tt__JpegDecOptions(struct soap *soap, const char *tag, struct tt__JpegDecOptions *a, const char *type)
{
	struct soap_blist *soap_blist_ResolutionsAvailable = NULL;
	size_t soap_flag_SupportedInputBitrate = 1;
	size_t soap_flag_SupportedFrameRate = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__JpegDecOptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__JpegDecOptions, sizeof(struct tt__JpegDecOptions), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__JpegDecOptions(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:ResolutionsAvailable", 1, NULL))
			{	if (a->ResolutionsAvailable == NULL)
				{	if (soap_blist_ResolutionsAvailable == NULL)
						soap_blist_ResolutionsAvailable = soap_new_block(soap);
					a->ResolutionsAvailable = (struct tt__VideoResolution *)soap_push_block(soap, soap_blist_ResolutionsAvailable, sizeof(struct tt__VideoResolution));
					if (a->ResolutionsAvailable == NULL)
						return NULL;
					soap_default_tt__VideoResolution(soap, a->ResolutionsAvailable);
				}
				soap_revert(soap);
				if (soap_in_tt__VideoResolution(soap, "tt:ResolutionsAvailable", a->ResolutionsAvailable, "tt:VideoResolution"))
				{	a->__sizeResolutionsAvailable++;
					a->ResolutionsAvailable = NULL;
					continue;
				}
			}
			if (soap_flag_SupportedInputBitrate && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IntRange(soap, "tt:SupportedInputBitrate", &a->SupportedInputBitrate, "tt:IntRange"))
				{	soap_flag_SupportedInputBitrate--;
					continue;
				}
			if (soap_flag_SupportedFrameRate && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IntRange(soap, "tt:SupportedFrameRate", &a->SupportedFrameRate, "tt:IntRange"))
				{	soap_flag_SupportedFrameRate--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ResolutionsAvailable)
			soap_pop_block(soap, soap_blist_ResolutionsAvailable);
		if (a->__sizeResolutionsAvailable)
			a->ResolutionsAvailable = (struct tt__VideoResolution *)soap_save_block(soap, soap_blist_ResolutionsAvailable, NULL, 1);
		else
		{	a->ResolutionsAvailable = NULL;
			if (soap_blist_ResolutionsAvailable)
				soap_end_block(soap, soap_blist_ResolutionsAvailable);
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__JpegDecOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__JpegDecOptions, 0, sizeof(struct tt__JpegDecOptions), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeResolutionsAvailable < 1 || soap_flag_SupportedInputBitrate > 0 || soap_flag_SupportedFrameRate > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__JpegDecOptions(struct soap *soap, const struct tt__JpegDecOptions *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__JpegDecOptions);
	if (soap_out_tt__JpegDecOptions(soap, tag?tag:"tt:JpegDecOptions", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__JpegDecOptions * SOAP_FMAC4 soap_get_tt__JpegDecOptions(struct soap *soap, struct tt__JpegDecOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__JpegDecOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__VideoDecoderConfigurationOptions(struct soap *soap, struct tt__VideoDecoderConfigurationOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->JpegDecOptions = NULL;
	a->H264DecOptions = NULL;
	a->Mpeg4DecOptions = NULL;
	a->Extension = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__VideoDecoderConfigurationOptions(struct soap *soap, const struct tt__VideoDecoderConfigurationOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTott__JpegDecOptions(soap, &a->JpegDecOptions);
	soap_serialize_PointerTott__H264DecOptions(soap, &a->H264DecOptions);
	soap_serialize_PointerTott__Mpeg4DecOptions(soap, &a->Mpeg4DecOptions);
	soap_serialize_PointerTott__VideoDecoderConfigurationOptionsExtension(soap, &a->Extension);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__VideoDecoderConfigurationOptions(struct soap *soap, const char *tag, int id, const struct tt__VideoDecoderConfigurationOptions *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__VideoDecoderConfigurationOptions), type))
		return soap->error;
	if (soap_out_PointerTott__JpegDecOptions(soap, "tt:JpegDecOptions", -1, &a->JpegDecOptions, ""))
		return soap->error;
	if (soap_out_PointerTott__H264DecOptions(soap, "tt:H264DecOptions", -1, &a->H264DecOptions, ""))
		return soap->error;
	if (soap_out_PointerTott__Mpeg4DecOptions(soap, "tt:Mpeg4DecOptions", -1, &a->Mpeg4DecOptions, ""))
		return soap->error;
	if (soap_out_PointerTott__VideoDecoderConfigurationOptionsExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__VideoDecoderConfigurationOptions * SOAP_FMAC4 soap_in_tt__VideoDecoderConfigurationOptions(struct soap *soap, const char *tag, struct tt__VideoDecoderConfigurationOptions *a, const char *type)
{
	size_t soap_flag_JpegDecOptions = 1;
	size_t soap_flag_H264DecOptions = 1;
	size_t soap_flag_Mpeg4DecOptions = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__VideoDecoderConfigurationOptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__VideoDecoderConfigurationOptions, sizeof(struct tt__VideoDecoderConfigurationOptions), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__VideoDecoderConfigurationOptions(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_JpegDecOptions && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__JpegDecOptions(soap, "tt:JpegDecOptions", &a->JpegDecOptions, "tt:JpegDecOptions"))
				{	soap_flag_JpegDecOptions--;
					continue;
				}
			if (soap_flag_H264DecOptions && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__H264DecOptions(soap, "tt:H264DecOptions", &a->H264DecOptions, "tt:H264DecOptions"))
				{	soap_flag_H264DecOptions--;
					continue;
				}
			if (soap_flag_Mpeg4DecOptions && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__Mpeg4DecOptions(soap, "tt:Mpeg4DecOptions", &a->Mpeg4DecOptions, "tt:Mpeg4DecOptions"))
				{	soap_flag_Mpeg4DecOptions--;
					continue;
				}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__VideoDecoderConfigurationOptionsExtension(soap, "tt:Extension", &a->Extension, "tt:VideoDecoderConfigurationOptionsExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__VideoDecoderConfigurationOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__VideoDecoderConfigurationOptions, 0, sizeof(struct tt__VideoDecoderConfigurationOptions), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__VideoDecoderConfigurationOptions(struct soap *soap, const struct tt__VideoDecoderConfigurationOptions *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__VideoDecoderConfigurationOptions);
	if (soap_out_tt__VideoDecoderConfigurationOptions(soap, tag?tag:"tt:VideoDecoderConfigurationOptions", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__VideoDecoderConfigurationOptions * SOAP_FMAC4 soap_get_tt__VideoDecoderConfigurationOptions(struct soap *soap, struct tt__VideoDecoderConfigurationOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__VideoDecoderConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__VideoOutputConfigurationOptions(struct soap *soap, struct tt__VideoOutputConfigurationOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__VideoOutputConfigurationOptions(struct soap *soap, const struct tt__VideoOutputConfigurationOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__VideoOutputConfigurationOptions(struct soap *soap, const char *tag, int id, const struct tt__VideoOutputConfigurationOptions *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__VideoOutputConfigurationOptions), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__VideoOutputConfigurationOptions * SOAP_FMAC4 soap_in_tt__VideoOutputConfigurationOptions(struct soap *soap, const char *tag, struct tt__VideoOutputConfigurationOptions *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__VideoOutputConfigurationOptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__VideoOutputConfigurationOptions, sizeof(struct tt__VideoOutputConfigurationOptions), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__VideoOutputConfigurationOptions(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__VideoOutputConfigurationOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__VideoOutputConfigurationOptions, 0, sizeof(struct tt__VideoOutputConfigurationOptions), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__VideoOutputConfigurationOptions(struct soap *soap, const struct tt__VideoOutputConfigurationOptions *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__VideoOutputConfigurationOptions);
	if (soap_out_tt__VideoOutputConfigurationOptions(soap, tag?tag:"tt:VideoOutputConfigurationOptions", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__VideoOutputConfigurationOptions * SOAP_FMAC4 soap_get_tt__VideoOutputConfigurationOptions(struct soap *soap, struct tt__VideoOutputConfigurationOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__VideoOutputConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__VideoOutputExtension(struct soap *soap, struct tt__VideoOutputExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__VideoOutputExtension(struct soap *soap, const struct tt__VideoOutputExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__VideoOutputExtension(struct soap *soap, const char *tag, int id, const struct tt__VideoOutputExtension *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__VideoOutputExtension), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__VideoOutputExtension * SOAP_FMAC4 soap_in_tt__VideoOutputExtension(struct soap *soap, const char *tag, struct tt__VideoOutputExtension *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__VideoOutputExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__VideoOutputExtension, sizeof(struct tt__VideoOutputExtension), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__VideoOutputExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__VideoOutputExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__VideoOutputExtension, 0, sizeof(struct tt__VideoOutputExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__VideoOutputExtension(struct soap *soap, const struct tt__VideoOutputExtension *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__VideoOutputExtension);
	if (soap_out_tt__VideoOutputExtension(soap, tag?tag:"tt:VideoOutputExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__VideoOutputExtension * SOAP_FMAC4 soap_get_tt__VideoOutputExtension(struct soap *soap, struct tt__VideoOutputExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__VideoOutputExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__PTZStatusFilterOptionsExtension(struct soap *soap, struct tt__PTZStatusFilterOptionsExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__PTZStatusFilterOptionsExtension(struct soap *soap, const struct tt__PTZStatusFilterOptionsExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZStatusFilterOptionsExtension(struct soap *soap, const char *tag, int id, const struct tt__PTZStatusFilterOptionsExtension *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTZStatusFilterOptionsExtension), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__PTZStatusFilterOptionsExtension * SOAP_FMAC4 soap_in_tt__PTZStatusFilterOptionsExtension(struct soap *soap, const char *tag, struct tt__PTZStatusFilterOptionsExtension *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__PTZStatusFilterOptionsExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZStatusFilterOptionsExtension, sizeof(struct tt__PTZStatusFilterOptionsExtension), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__PTZStatusFilterOptionsExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__PTZStatusFilterOptionsExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZStatusFilterOptionsExtension, 0, sizeof(struct tt__PTZStatusFilterOptionsExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__PTZStatusFilterOptionsExtension(struct soap *soap, const struct tt__PTZStatusFilterOptionsExtension *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__PTZStatusFilterOptionsExtension);
	if (soap_out_tt__PTZStatusFilterOptionsExtension(soap, tag?tag:"tt:PTZStatusFilterOptionsExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PTZStatusFilterOptionsExtension * SOAP_FMAC4 soap_get_tt__PTZStatusFilterOptionsExtension(struct soap *soap, struct tt__PTZStatusFilterOptionsExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTZStatusFilterOptionsExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__PTZStatusFilterOptions(struct soap *soap, struct tt__PTZStatusFilterOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__boolean_(soap, &a->PanTiltStatusSupported);
	soap_default_xsd__boolean_(soap, &a->ZoomStatusSupported);
	a->__size = 0;
	a->__any = NULL;
	a->PanTiltPositionSupported = NULL;
	a->ZoomPositionSupported = NULL;
	a->Extension = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__PTZStatusFilterOptions(struct soap *soap, const struct tt__PTZStatusFilterOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->PanTiltStatusSupported, SOAP_TYPE_xsd__boolean_);
	soap_embedded(soap, &a->ZoomStatusSupported, SOAP_TYPE_xsd__boolean_);
	soap_serialize_PointerToxsd__boolean_(soap, &a->PanTiltPositionSupported);
	soap_serialize_PointerToxsd__boolean_(soap, &a->ZoomPositionSupported);
	soap_serialize_PointerTott__PTZStatusFilterOptionsExtension(soap, &a->Extension);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZStatusFilterOptions(struct soap *soap, const char *tag, int id, const struct tt__PTZStatusFilterOptions *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTZStatusFilterOptions), type))
		return soap->error;
	if (soap_out_xsd__boolean_(soap, "tt:PanTiltStatusSupported", -1, &a->PanTiltStatusSupported, ""))
		return soap->error;
	if (soap_out_xsd__boolean_(soap, "tt:ZoomStatusSupported", -1, &a->ZoomStatusSupported, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	if (soap_out_PointerToxsd__boolean_(soap, "tt:PanTiltPositionSupported", -1, &a->PanTiltPositionSupported, ""))
		return soap->error;
	if (soap_out_PointerToxsd__boolean_(soap, "tt:ZoomPositionSupported", -1, &a->ZoomPositionSupported, ""))
		return soap->error;
	if (soap_out_PointerTott__PTZStatusFilterOptionsExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__PTZStatusFilterOptions * SOAP_FMAC4 soap_in_tt__PTZStatusFilterOptions(struct soap *soap, const char *tag, struct tt__PTZStatusFilterOptions *a, const char *type)
{
	size_t soap_flag_PanTiltStatusSupported = 1;
	size_t soap_flag_ZoomStatusSupported = 1;
	struct soap_blist *soap_blist___any = NULL;
	size_t soap_flag_PanTiltPositionSupported = 1;
	size_t soap_flag_ZoomPositionSupported = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__PTZStatusFilterOptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZStatusFilterOptions, sizeof(struct tt__PTZStatusFilterOptions), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__PTZStatusFilterOptions(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_PanTiltStatusSupported && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean_(soap, "tt:PanTiltStatusSupported", &a->PanTiltStatusSupported, "xsd:boolean"))
				{	soap_flag_PanTiltStatusSupported--;
					continue;
				}
			if (soap_flag_ZoomStatusSupported && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean_(soap, "tt:ZoomStatusSupported", &a->ZoomStatusSupported, "xsd:boolean"))
				{	soap_flag_ZoomStatusSupported--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap_flag_PanTiltPositionSupported && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__boolean_(soap, "tt:PanTiltPositionSupported", &a->PanTiltPositionSupported, "xsd:boolean"))
				{	soap_flag_PanTiltPositionSupported--;
					continue;
				}
			if (soap_flag_ZoomPositionSupported && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__boolean_(soap, "tt:ZoomPositionSupported", &a->ZoomPositionSupported, "xsd:boolean"))
				{	soap_flag_ZoomPositionSupported--;
					continue;
				}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__PTZStatusFilterOptionsExtension(soap, "tt:Extension", &a->Extension, "tt:PTZStatusFilterOptionsExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__PTZStatusFilterOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZStatusFilterOptions, 0, sizeof(struct tt__PTZStatusFilterOptions), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_PanTiltStatusSupported > 0 || soap_flag_ZoomStatusSupported > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__PTZStatusFilterOptions(struct soap *soap, const struct tt__PTZStatusFilterOptions *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__PTZStatusFilterOptions);
	if (soap_out_tt__PTZStatusFilterOptions(soap, tag?tag:"tt:PTZStatusFilterOptions", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PTZStatusFilterOptions * SOAP_FMAC4 soap_get_tt__PTZStatusFilterOptions(struct soap *soap, struct tt__PTZStatusFilterOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTZStatusFilterOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__MetadataConfigurationOptions(struct soap *soap, struct tt__MetadataConfigurationOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->PTZStatusFilterOptions = NULL;
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__MetadataConfigurationOptions(struct soap *soap, const struct tt__MetadataConfigurationOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTott__PTZStatusFilterOptions(soap, &a->PTZStatusFilterOptions);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__MetadataConfigurationOptions(struct soap *soap, const char *tag, int id, const struct tt__MetadataConfigurationOptions *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__MetadataConfigurationOptions), type))
		return soap->error;
	if (a->PTZStatusFilterOptions)
	{	if (soap_out_PointerTott__PTZStatusFilterOptions(soap, "tt:PTZStatusFilterOptions", -1, &a->PTZStatusFilterOptions, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:PTZStatusFilterOptions"))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__MetadataConfigurationOptions * SOAP_FMAC4 soap_in_tt__MetadataConfigurationOptions(struct soap *soap, const char *tag, struct tt__MetadataConfigurationOptions *a, const char *type)
{
	size_t soap_flag_PTZStatusFilterOptions = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__MetadataConfigurationOptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__MetadataConfigurationOptions, sizeof(struct tt__MetadataConfigurationOptions), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__MetadataConfigurationOptions(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_PTZStatusFilterOptions && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__PTZStatusFilterOptions(soap, "tt:PTZStatusFilterOptions", &a->PTZStatusFilterOptions, "tt:PTZStatusFilterOptions"))
				{	soap_flag_PTZStatusFilterOptions--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__MetadataConfigurationOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__MetadataConfigurationOptions, 0, sizeof(struct tt__MetadataConfigurationOptions), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_PTZStatusFilterOptions > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__MetadataConfigurationOptions(struct soap *soap, const struct tt__MetadataConfigurationOptions *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__MetadataConfigurationOptions);
	if (soap_out_tt__MetadataConfigurationOptions(soap, tag?tag:"tt:MetadataConfigurationOptions", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__MetadataConfigurationOptions * SOAP_FMAC4 soap_get_tt__MetadataConfigurationOptions(struct soap *soap, struct tt__MetadataConfigurationOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__MetadataConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tt__EventSubscription_SubscriptionPolicy(struct soap *soap, struct _tt__EventSubscription_SubscriptionPolicy *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tt__EventSubscription_SubscriptionPolicy(struct soap *soap, const struct _tt__EventSubscription_SubscriptionPolicy *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tt__EventSubscription_SubscriptionPolicy(struct soap *soap, const char *tag, int id, const struct _tt__EventSubscription_SubscriptionPolicy *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tt__EventSubscription_SubscriptionPolicy), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tt__EventSubscription_SubscriptionPolicy * SOAP_FMAC4 soap_in__tt__EventSubscription_SubscriptionPolicy(struct soap *soap, const char *tag, struct _tt__EventSubscription_SubscriptionPolicy *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tt__EventSubscription_SubscriptionPolicy *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tt__EventSubscription_SubscriptionPolicy, sizeof(struct _tt__EventSubscription_SubscriptionPolicy), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tt__EventSubscription_SubscriptionPolicy(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tt__EventSubscription_SubscriptionPolicy *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tt__EventSubscription_SubscriptionPolicy, 0, sizeof(struct _tt__EventSubscription_SubscriptionPolicy), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tt__EventSubscription_SubscriptionPolicy(struct soap *soap, const struct _tt__EventSubscription_SubscriptionPolicy *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tt__EventSubscription_SubscriptionPolicy);
	if (soap_out__tt__EventSubscription_SubscriptionPolicy(soap, tag?tag:"tt:EventSubscription-SubscriptionPolicy", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tt__EventSubscription_SubscriptionPolicy * SOAP_FMAC4 soap_get__tt__EventSubscription_SubscriptionPolicy(struct soap *soap, struct _tt__EventSubscription_SubscriptionPolicy *p, const char *tag, const char *type)
{
	if ((p = soap_in__tt__EventSubscription_SubscriptionPolicy(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsnt__FilterType(struct soap *soap, struct wsnt__FilterType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsnt__FilterType(struct soap *soap, const struct wsnt__FilterType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__FilterType(struct soap *soap, const char *tag, int id, const struct wsnt__FilterType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsnt__FilterType), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsnt__FilterType * SOAP_FMAC4 soap_in_wsnt__FilterType(struct soap *soap, const char *tag, struct wsnt__FilterType *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wsnt__FilterType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsnt__FilterType, sizeof(struct wsnt__FilterType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsnt__FilterType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wsnt__FilterType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnt__FilterType, 0, sizeof(struct wsnt__FilterType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsnt__FilterType(struct soap *soap, const struct wsnt__FilterType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wsnt__FilterType);
	if (soap_out_wsnt__FilterType(soap, tag?tag:"wsnt:FilterType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsnt__FilterType * SOAP_FMAC4 soap_get_wsnt__FilterType(struct soap *soap, struct wsnt__FilterType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnt__FilterType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__EventSubscription(struct soap *soap, struct tt__EventSubscription *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Filter = NULL;
	a->SubscriptionPolicy = NULL;
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__EventSubscription(struct soap *soap, const struct tt__EventSubscription *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTowsnt__FilterType(soap, &a->Filter);
	soap_serialize_PointerTo_tt__EventSubscription_SubscriptionPolicy(soap, &a->SubscriptionPolicy);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__EventSubscription(struct soap *soap, const char *tag, int id, const struct tt__EventSubscription *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__EventSubscription), type))
		return soap->error;
	if (soap_out_PointerTowsnt__FilterType(soap, "tt:Filter", -1, &a->Filter, ""))
		return soap->error;
	if (soap_out_PointerTo_tt__EventSubscription_SubscriptionPolicy(soap, "tt:SubscriptionPolicy", -1, &a->SubscriptionPolicy, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__EventSubscription * SOAP_FMAC4 soap_in_tt__EventSubscription(struct soap *soap, const char *tag, struct tt__EventSubscription *a, const char *type)
{
	size_t soap_flag_Filter = 1;
	size_t soap_flag_SubscriptionPolicy = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__EventSubscription *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__EventSubscription, sizeof(struct tt__EventSubscription), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__EventSubscription(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Filter && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsnt__FilterType(soap, "tt:Filter", &a->Filter, "wsnt:FilterType"))
				{	soap_flag_Filter--;
					continue;
				}
			if (soap_flag_SubscriptionPolicy && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_tt__EventSubscription_SubscriptionPolicy(soap, "tt:SubscriptionPolicy", &a->SubscriptionPolicy, ""))
				{	soap_flag_SubscriptionPolicy--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__EventSubscription *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__EventSubscription, 0, sizeof(struct tt__EventSubscription), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__EventSubscription(struct soap *soap, const struct tt__EventSubscription *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__EventSubscription);
	if (soap_out_tt__EventSubscription(soap, tag?tag:"tt:EventSubscription", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__EventSubscription * SOAP_FMAC4 soap_get_tt__EventSubscription(struct soap *soap, struct tt__EventSubscription *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__EventSubscription(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__PTZFilter(struct soap *soap, struct tt__PTZFilter *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__boolean_(soap, &a->Status);
	soap_default_xsd__boolean_(soap, &a->Position);
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__PTZFilter(struct soap *soap, const struct tt__PTZFilter *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->Status, SOAP_TYPE_xsd__boolean_);
	soap_embedded(soap, &a->Position, SOAP_TYPE_xsd__boolean_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZFilter(struct soap *soap, const char *tag, int id, const struct tt__PTZFilter *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTZFilter), type))
		return soap->error;
	if (soap_out_xsd__boolean_(soap, "tt:Status", -1, &a->Status, ""))
		return soap->error;
	if (soap_out_xsd__boolean_(soap, "tt:Position", -1, &a->Position, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__PTZFilter * SOAP_FMAC4 soap_in_tt__PTZFilter(struct soap *soap, const char *tag, struct tt__PTZFilter *a, const char *type)
{
	size_t soap_flag_Status = 1;
	size_t soap_flag_Position = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__PTZFilter *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZFilter, sizeof(struct tt__PTZFilter), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__PTZFilter(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Status && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean_(soap, "tt:Status", &a->Status, "xsd:boolean"))
				{	soap_flag_Status--;
					continue;
				}
			if (soap_flag_Position && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean_(soap, "tt:Position", &a->Position, "xsd:boolean"))
				{	soap_flag_Position--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__PTZFilter *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZFilter, 0, sizeof(struct tt__PTZFilter), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Status > 0 || soap_flag_Position > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__PTZFilter(struct soap *soap, const struct tt__PTZFilter *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__PTZFilter);
	if (soap_out_tt__PTZFilter(soap, tag?tag:"tt:PTZFilter", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PTZFilter * SOAP_FMAC4 soap_get_tt__PTZFilter(struct soap *soap, struct tt__PTZFilter *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTZFilter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__MetadataConfigurationExtension(struct soap *soap, struct tt__MetadataConfigurationExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__MetadataConfigurationExtension(struct soap *soap, const struct tt__MetadataConfigurationExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__MetadataConfigurationExtension(struct soap *soap, const char *tag, int id, const struct tt__MetadataConfigurationExtension *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__MetadataConfigurationExtension), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__MetadataConfigurationExtension * SOAP_FMAC4 soap_in_tt__MetadataConfigurationExtension(struct soap *soap, const char *tag, struct tt__MetadataConfigurationExtension *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__MetadataConfigurationExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__MetadataConfigurationExtension, sizeof(struct tt__MetadataConfigurationExtension), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__MetadataConfigurationExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__MetadataConfigurationExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__MetadataConfigurationExtension, 0, sizeof(struct tt__MetadataConfigurationExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__MetadataConfigurationExtension(struct soap *soap, const struct tt__MetadataConfigurationExtension *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__MetadataConfigurationExtension);
	if (soap_out_tt__MetadataConfigurationExtension(soap, tag?tag:"tt:MetadataConfigurationExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__MetadataConfigurationExtension * SOAP_FMAC4 soap_get_tt__MetadataConfigurationExtension(struct soap *soap, struct tt__MetadataConfigurationExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__MetadataConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__AudioEncoderConfigurationOption(struct soap *soap, struct tt__AudioEncoderConfigurationOption *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__AudioEncoding(soap, &a->Encoding);
	a->BitrateList = NULL;
	a->SampleRateList = NULL;
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__AudioEncoderConfigurationOption(struct soap *soap, const struct tt__AudioEncoderConfigurationOption *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTott__IntList(soap, &a->BitrateList);
	soap_serialize_PointerTott__IntList(soap, &a->SampleRateList);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AudioEncoderConfigurationOption(struct soap *soap, const char *tag, int id, const struct tt__AudioEncoderConfigurationOption *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AudioEncoderConfigurationOption), type))
		return soap->error;
	if (soap_out_tt__AudioEncoding(soap, "tt:Encoding", -1, &a->Encoding, ""))
		return soap->error;
	if (a->BitrateList)
	{	if (soap_out_PointerTott__IntList(soap, "tt:BitrateList", -1, &a->BitrateList, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:BitrateList"))
		return soap->error;
	if (a->SampleRateList)
	{	if (soap_out_PointerTott__IntList(soap, "tt:SampleRateList", -1, &a->SampleRateList, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:SampleRateList"))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__AudioEncoderConfigurationOption * SOAP_FMAC4 soap_in_tt__AudioEncoderConfigurationOption(struct soap *soap, const char *tag, struct tt__AudioEncoderConfigurationOption *a, const char *type)
{
	size_t soap_flag_Encoding = 1;
	size_t soap_flag_BitrateList = 1;
	size_t soap_flag_SampleRateList = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__AudioEncoderConfigurationOption *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AudioEncoderConfigurationOption, sizeof(struct tt__AudioEncoderConfigurationOption), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__AudioEncoderConfigurationOption(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Encoding && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_tt__AudioEncoding(soap, "tt:Encoding", &a->Encoding, "tt:AudioEncoding"))
				{	soap_flag_Encoding--;
					continue;
				}
			if (soap_flag_BitrateList && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IntList(soap, "tt:BitrateList", &a->BitrateList, "tt:IntList"))
				{	soap_flag_BitrateList--;
					continue;
				}
			if (soap_flag_SampleRateList && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IntList(soap, "tt:SampleRateList", &a->SampleRateList, "tt:IntList"))
				{	soap_flag_SampleRateList--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__AudioEncoderConfigurationOption *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AudioEncoderConfigurationOption, 0, sizeof(struct tt__AudioEncoderConfigurationOption), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Encoding > 0 || soap_flag_BitrateList > 0 || soap_flag_SampleRateList > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__AudioEncoderConfigurationOption(struct soap *soap, const struct tt__AudioEncoderConfigurationOption *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__AudioEncoderConfigurationOption);
	if (soap_out_tt__AudioEncoderConfigurationOption(soap, tag?tag:"tt:AudioEncoderConfigurationOption", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AudioEncoderConfigurationOption * SOAP_FMAC4 soap_get_tt__AudioEncoderConfigurationOption(struct soap *soap, struct tt__AudioEncoderConfigurationOption *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AudioEncoderConfigurationOption(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__AudioEncoderConfigurationOptions(struct soap *soap, struct tt__AudioEncoderConfigurationOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeOptions = 0;
	a->Options = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__AudioEncoderConfigurationOptions(struct soap *soap, const struct tt__AudioEncoderConfigurationOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->Options)
	{	int i;
		for (i = 0; i < a->__sizeOptions; i++)
		{
			soap_embedded(soap, a->Options + i, SOAP_TYPE_tt__AudioEncoderConfigurationOption);
			soap_serialize_tt__AudioEncoderConfigurationOption(soap, a->Options + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AudioEncoderConfigurationOptions(struct soap *soap, const char *tag, int id, const struct tt__AudioEncoderConfigurationOptions *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AudioEncoderConfigurationOptions), type))
		return soap->error;
	if (a->Options)
	{	int i;
		for (i = 0; i < a->__sizeOptions; i++)
			if (soap_out_tt__AudioEncoderConfigurationOption(soap, "tt:Options", -1, a->Options + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__AudioEncoderConfigurationOptions * SOAP_FMAC4 soap_in_tt__AudioEncoderConfigurationOptions(struct soap *soap, const char *tag, struct tt__AudioEncoderConfigurationOptions *a, const char *type)
{
	struct soap_blist *soap_blist_Options = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__AudioEncoderConfigurationOptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AudioEncoderConfigurationOptions, sizeof(struct tt__AudioEncoderConfigurationOptions), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__AudioEncoderConfigurationOptions(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Options", 1, NULL))
			{	if (a->Options == NULL)
				{	if (soap_blist_Options == NULL)
						soap_blist_Options = soap_new_block(soap);
					a->Options = (struct tt__AudioEncoderConfigurationOption *)soap_push_block(soap, soap_blist_Options, sizeof(struct tt__AudioEncoderConfigurationOption));
					if (a->Options == NULL)
						return NULL;
					soap_default_tt__AudioEncoderConfigurationOption(soap, a->Options);
				}
				soap_revert(soap);
				if (soap_in_tt__AudioEncoderConfigurationOption(soap, "tt:Options", a->Options, "tt:AudioEncoderConfigurationOption"))
				{	a->__sizeOptions++;
					a->Options = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Options)
			soap_pop_block(soap, soap_blist_Options);
		if (a->__sizeOptions)
			a->Options = (struct tt__AudioEncoderConfigurationOption *)soap_save_block(soap, soap_blist_Options, NULL, 1);
		else
		{	a->Options = NULL;
			if (soap_blist_Options)
				soap_end_block(soap, soap_blist_Options);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__AudioEncoderConfigurationOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AudioEncoderConfigurationOptions, 0, sizeof(struct tt__AudioEncoderConfigurationOptions), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__AudioEncoderConfigurationOptions(struct soap *soap, const struct tt__AudioEncoderConfigurationOptions *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__AudioEncoderConfigurationOptions);
	if (soap_out_tt__AudioEncoderConfigurationOptions(soap, tag?tag:"tt:AudioEncoderConfigurationOptions", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AudioEncoderConfigurationOptions * SOAP_FMAC4 soap_get_tt__AudioEncoderConfigurationOptions(struct soap *soap, struct tt__AudioEncoderConfigurationOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AudioEncoderConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__AudioSourceOptionsExtension(struct soap *soap, struct tt__AudioSourceOptionsExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__AudioSourceOptionsExtension(struct soap *soap, const struct tt__AudioSourceOptionsExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AudioSourceOptionsExtension(struct soap *soap, const char *tag, int id, const struct tt__AudioSourceOptionsExtension *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AudioSourceOptionsExtension), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__AudioSourceOptionsExtension * SOAP_FMAC4 soap_in_tt__AudioSourceOptionsExtension(struct soap *soap, const char *tag, struct tt__AudioSourceOptionsExtension *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__AudioSourceOptionsExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AudioSourceOptionsExtension, sizeof(struct tt__AudioSourceOptionsExtension), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__AudioSourceOptionsExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__AudioSourceOptionsExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AudioSourceOptionsExtension, 0, sizeof(struct tt__AudioSourceOptionsExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__AudioSourceOptionsExtension(struct soap *soap, const struct tt__AudioSourceOptionsExtension *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__AudioSourceOptionsExtension);
	if (soap_out_tt__AudioSourceOptionsExtension(soap, tag?tag:"tt:AudioSourceOptionsExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AudioSourceOptionsExtension * SOAP_FMAC4 soap_get_tt__AudioSourceOptionsExtension(struct soap *soap, struct tt__AudioSourceOptionsExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AudioSourceOptionsExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__AudioSourceConfigurationOptions(struct soap *soap, struct tt__AudioSourceConfigurationOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeInputTokensAvailable = 0;
	a->InputTokensAvailable = NULL;
	a->Extension = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__AudioSourceConfigurationOptions(struct soap *soap, const struct tt__AudioSourceConfigurationOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->InputTokensAvailable)
	{	int i;
		for (i = 0; i < a->__sizeInputTokensAvailable; i++)
		{
			soap_serialize_tt__ReferenceToken(soap, a->InputTokensAvailable + i);
		}
	}
	soap_serialize_PointerTott__AudioSourceOptionsExtension(soap, &a->Extension);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AudioSourceConfigurationOptions(struct soap *soap, const char *tag, int id, const struct tt__AudioSourceConfigurationOptions *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AudioSourceConfigurationOptions), type))
		return soap->error;
	if (a->InputTokensAvailable)
	{	int i;
		for (i = 0; i < a->__sizeInputTokensAvailable; i++)
			if (soap_out_tt__ReferenceToken(soap, "tt:InputTokensAvailable", -1, a->InputTokensAvailable + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTott__AudioSourceOptionsExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__AudioSourceConfigurationOptions * SOAP_FMAC4 soap_in_tt__AudioSourceConfigurationOptions(struct soap *soap, const char *tag, struct tt__AudioSourceConfigurationOptions *a, const char *type)
{
	struct soap_blist *soap_blist_InputTokensAvailable = NULL;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__AudioSourceConfigurationOptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AudioSourceConfigurationOptions, sizeof(struct tt__AudioSourceConfigurationOptions), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__AudioSourceConfigurationOptions(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:InputTokensAvailable", 1, NULL))
			{	if (a->InputTokensAvailable == NULL)
				{	if (soap_blist_InputTokensAvailable == NULL)
						soap_blist_InputTokensAvailable = soap_new_block(soap);
					a->InputTokensAvailable = (char **)soap_push_block(soap, soap_blist_InputTokensAvailable, sizeof(char *));
					if (a->InputTokensAvailable == NULL)
						return NULL;
					*a->InputTokensAvailable = NULL;
				}
				soap_revert(soap);
				if (soap_in_tt__ReferenceToken(soap, "tt:InputTokensAvailable", a->InputTokensAvailable, "tt:ReferenceToken"))
				{	a->__sizeInputTokensAvailable++;
					a->InputTokensAvailable = NULL;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__AudioSourceOptionsExtension(soap, "tt:Extension", &a->Extension, "tt:AudioSourceOptionsExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->InputTokensAvailable)
			soap_pop_block(soap, soap_blist_InputTokensAvailable);
		if (a->__sizeInputTokensAvailable)
			a->InputTokensAvailable = (char **)soap_save_block(soap, soap_blist_InputTokensAvailable, NULL, 1);
		else
		{	a->InputTokensAvailable = NULL;
			if (soap_blist_InputTokensAvailable)
				soap_end_block(soap, soap_blist_InputTokensAvailable);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__AudioSourceConfigurationOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AudioSourceConfigurationOptions, 0, sizeof(struct tt__AudioSourceConfigurationOptions), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeInputTokensAvailable < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__AudioSourceConfigurationOptions(struct soap *soap, const struct tt__AudioSourceConfigurationOptions *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__AudioSourceConfigurationOptions);
	if (soap_out_tt__AudioSourceConfigurationOptions(soap, tag?tag:"tt:AudioSourceConfigurationOptions", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AudioSourceConfigurationOptions * SOAP_FMAC4 soap_get_tt__AudioSourceConfigurationOptions(struct soap *soap, struct tt__AudioSourceConfigurationOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AudioSourceConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__VideoEncoderOptionsExtension2(struct soap *soap, struct tt__VideoEncoderOptionsExtension2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__VideoEncoderOptionsExtension2(struct soap *soap, const struct tt__VideoEncoderOptionsExtension2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__VideoEncoderOptionsExtension2(struct soap *soap, const char *tag, int id, const struct tt__VideoEncoderOptionsExtension2 *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__VideoEncoderOptionsExtension2), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__VideoEncoderOptionsExtension2 * SOAP_FMAC4 soap_in_tt__VideoEncoderOptionsExtension2(struct soap *soap, const char *tag, struct tt__VideoEncoderOptionsExtension2 *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__VideoEncoderOptionsExtension2 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__VideoEncoderOptionsExtension2, sizeof(struct tt__VideoEncoderOptionsExtension2), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__VideoEncoderOptionsExtension2(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__VideoEncoderOptionsExtension2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__VideoEncoderOptionsExtension2, 0, sizeof(struct tt__VideoEncoderOptionsExtension2), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__VideoEncoderOptionsExtension2(struct soap *soap, const struct tt__VideoEncoderOptionsExtension2 *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__VideoEncoderOptionsExtension2);
	if (soap_out_tt__VideoEncoderOptionsExtension2(soap, tag?tag:"tt:VideoEncoderOptionsExtension2", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__VideoEncoderOptionsExtension2 * SOAP_FMAC4 soap_get_tt__VideoEncoderOptionsExtension2(struct soap *soap, struct tt__VideoEncoderOptionsExtension2 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__VideoEncoderOptionsExtension2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__H264Options2(struct soap *soap, struct tt__H264Options2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeResolutionsAvailable = 0;
	a->ResolutionsAvailable = NULL;
	a->GovLengthRange = NULL;
	a->FrameRateRange = NULL;
	a->EncodingIntervalRange = NULL;
	a->__sizeH264ProfilesSupported = 0;
	a->H264ProfilesSupported = NULL;
	a->BitrateRange = NULL;
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__H264Options2(struct soap *soap, const struct tt__H264Options2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->ResolutionsAvailable)
	{	int i;
		for (i = 0; i < a->__sizeResolutionsAvailable; i++)
		{
			soap_embedded(soap, a->ResolutionsAvailable + i, SOAP_TYPE_tt__VideoResolution);
			soap_serialize_tt__VideoResolution(soap, a->ResolutionsAvailable + i);
		}
	}
	soap_serialize_PointerTott__IntRange(soap, &a->GovLengthRange);
	soap_serialize_PointerTott__IntRange(soap, &a->FrameRateRange);
	soap_serialize_PointerTott__IntRange(soap, &a->EncodingIntervalRange);
	if (a->H264ProfilesSupported)
	{	int i;
		for (i = 0; i < a->__sizeH264ProfilesSupported; i++)
		{
			soap_embedded(soap, a->H264ProfilesSupported + i, SOAP_TYPE_tt__H264Profile);
		}
	}
	soap_serialize_PointerTott__IntRange(soap, &a->BitrateRange);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__H264Options2(struct soap *soap, const char *tag, int id, const struct tt__H264Options2 *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__H264Options2), type))
		return soap->error;
	if (a->ResolutionsAvailable)
	{	int i;
		for (i = 0; i < a->__sizeResolutionsAvailable; i++)
			if (soap_out_tt__VideoResolution(soap, "tt:ResolutionsAvailable", -1, a->ResolutionsAvailable + i, ""))
				return soap->error;
	}
	if (a->GovLengthRange)
	{	if (soap_out_PointerTott__IntRange(soap, "tt:GovLengthRange", -1, &a->GovLengthRange, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:GovLengthRange"))
		return soap->error;
	if (a->FrameRateRange)
	{	if (soap_out_PointerTott__IntRange(soap, "tt:FrameRateRange", -1, &a->FrameRateRange, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:FrameRateRange"))
		return soap->error;
	if (a->EncodingIntervalRange)
	{	if (soap_out_PointerTott__IntRange(soap, "tt:EncodingIntervalRange", -1, &a->EncodingIntervalRange, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:EncodingIntervalRange"))
		return soap->error;
	if (a->H264ProfilesSupported)
	{	int i;
		for (i = 0; i < a->__sizeH264ProfilesSupported; i++)
			if (soap_out_tt__H264Profile(soap, "tt:H264ProfilesSupported", -1, a->H264ProfilesSupported + i, ""))
				return soap->error;
	}
	if (a->BitrateRange)
	{	if (soap_out_PointerTott__IntRange(soap, "tt:BitrateRange", -1, &a->BitrateRange, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:BitrateRange"))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of soapC.c */
