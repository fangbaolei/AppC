/* soapC.c
   Generated by gSOAP 2.8.0 from onvif.h
   Copyright(C) 2000-2010, Robert van Engelen, Genivia Inc. All Rights Reserved.
   The generated code is released under one of the following licenses:
   GPL, the gSOAP public license, or Genivia's license for commercial use.
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "soapH.h"

SOAP_FMAC3 struct tt__H264Options2 * SOAP_FMAC4 soap_in_tt__H264Options2(struct soap *soap, const char *tag, struct tt__H264Options2 *a, const char *type)
{
	struct soap_blist *soap_blist_ResolutionsAvailable = NULL;
	size_t soap_flag_GovLengthRange = 1;
	size_t soap_flag_FrameRateRange = 1;
	size_t soap_flag_EncodingIntervalRange = 1;
	struct soap_blist *soap_blist_H264ProfilesSupported = NULL;
	size_t soap_flag_BitrateRange = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__H264Options2 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__H264Options2, sizeof(struct tt__H264Options2), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__H264Options2(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:ResolutionsAvailable", 1, NULL))
			{	if (a->ResolutionsAvailable == NULL)
				{	if (soap_blist_ResolutionsAvailable == NULL)
						soap_blist_ResolutionsAvailable = soap_new_block(soap);
					a->ResolutionsAvailable = (struct tt__VideoResolution *)soap_push_block(soap, soap_blist_ResolutionsAvailable, sizeof(struct tt__VideoResolution));
					if (a->ResolutionsAvailable == NULL)
						return NULL;
					soap_default_tt__VideoResolution(soap, a->ResolutionsAvailable);
				}
				soap_revert(soap);
				if (soap_in_tt__VideoResolution(soap, "tt:ResolutionsAvailable", a->ResolutionsAvailable, "tt:VideoResolution"))
				{	a->__sizeResolutionsAvailable++;
					a->ResolutionsAvailable = NULL;
					continue;
				}
			}
			if (soap_flag_GovLengthRange && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IntRange(soap, "tt:GovLengthRange", &a->GovLengthRange, "tt:IntRange"))
				{	soap_flag_GovLengthRange--;
					continue;
				}
			if (soap_flag_FrameRateRange && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IntRange(soap, "tt:FrameRateRange", &a->FrameRateRange, "tt:IntRange"))
				{	soap_flag_FrameRateRange--;
					continue;
				}
			if (soap_flag_EncodingIntervalRange && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IntRange(soap, "tt:EncodingIntervalRange", &a->EncodingIntervalRange, "tt:IntRange"))
				{	soap_flag_EncodingIntervalRange--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:H264ProfilesSupported", 1, NULL))
			{	if (a->H264ProfilesSupported == NULL)
				{	if (soap_blist_H264ProfilesSupported == NULL)
						soap_blist_H264ProfilesSupported = soap_new_block(soap);
					a->H264ProfilesSupported = (enum tt__H264Profile *)soap_push_block(soap, soap_blist_H264ProfilesSupported, sizeof(enum tt__H264Profile));
					if (a->H264ProfilesSupported == NULL)
						return NULL;
					soap_default_tt__H264Profile(soap, a->H264ProfilesSupported);
				}
				soap_revert(soap);
				if (soap_in_tt__H264Profile(soap, "tt:H264ProfilesSupported", a->H264ProfilesSupported, "tt:H264Profile"))
				{	a->__sizeH264ProfilesSupported++;
					a->H264ProfilesSupported = NULL;
					continue;
				}
			}
			if (soap_flag_BitrateRange && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IntRange(soap, "tt:BitrateRange", &a->BitrateRange, "tt:IntRange"))
				{	soap_flag_BitrateRange--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ResolutionsAvailable)
			soap_pop_block(soap, soap_blist_ResolutionsAvailable);
		if (a->__sizeResolutionsAvailable)
			a->ResolutionsAvailable = (struct tt__VideoResolution *)soap_save_block(soap, soap_blist_ResolutionsAvailable, NULL, 1);
		else
		{	a->ResolutionsAvailable = NULL;
			if (soap_blist_ResolutionsAvailable)
				soap_end_block(soap, soap_blist_ResolutionsAvailable);
		}
		if (a->H264ProfilesSupported)
			soap_pop_block(soap, soap_blist_H264ProfilesSupported);
		if (a->__sizeH264ProfilesSupported)
			a->H264ProfilesSupported = (enum tt__H264Profile *)soap_save_block(soap, soap_blist_H264ProfilesSupported, NULL, 1);
		else
		{	a->H264ProfilesSupported = NULL;
			if (soap_blist_H264ProfilesSupported)
				soap_end_block(soap, soap_blist_H264ProfilesSupported);
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__H264Options2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__H264Options2, 0, sizeof(struct tt__H264Options2), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeResolutionsAvailable < 1 || soap_flag_GovLengthRange > 0 || soap_flag_FrameRateRange > 0 || soap_flag_EncodingIntervalRange > 0 || a->__sizeH264ProfilesSupported < 1 || soap_flag_BitrateRange > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__H264Options2(struct soap *soap, const struct tt__H264Options2 *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__H264Options2);
	if (soap_out_tt__H264Options2(soap, tag?tag:"tt:H264Options2", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__H264Options2 * SOAP_FMAC4 soap_get_tt__H264Options2(struct soap *soap, struct tt__H264Options2 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__H264Options2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__Mpeg4Options2(struct soap *soap, struct tt__Mpeg4Options2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeResolutionsAvailable = 0;
	a->ResolutionsAvailable = NULL;
	a->GovLengthRange = NULL;
	a->FrameRateRange = NULL;
	a->EncodingIntervalRange = NULL;
	a->__sizeMpeg4ProfilesSupported = 0;
	a->Mpeg4ProfilesSupported = NULL;
	a->BitrateRange = NULL;
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__Mpeg4Options2(struct soap *soap, const struct tt__Mpeg4Options2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->ResolutionsAvailable)
	{	int i;
		for (i = 0; i < a->__sizeResolutionsAvailable; i++)
		{
			soap_embedded(soap, a->ResolutionsAvailable + i, SOAP_TYPE_tt__VideoResolution);
			soap_serialize_tt__VideoResolution(soap, a->ResolutionsAvailable + i);
		}
	}
	soap_serialize_PointerTott__IntRange(soap, &a->GovLengthRange);
	soap_serialize_PointerTott__IntRange(soap, &a->FrameRateRange);
	soap_serialize_PointerTott__IntRange(soap, &a->EncodingIntervalRange);
	if (a->Mpeg4ProfilesSupported)
	{	int i;
		for (i = 0; i < a->__sizeMpeg4ProfilesSupported; i++)
		{
			soap_embedded(soap, a->Mpeg4ProfilesSupported + i, SOAP_TYPE_tt__Mpeg4Profile);
		}
	}
	soap_serialize_PointerTott__IntRange(soap, &a->BitrateRange);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Mpeg4Options2(struct soap *soap, const char *tag, int id, const struct tt__Mpeg4Options2 *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Mpeg4Options2), type))
		return soap->error;
	if (a->ResolutionsAvailable)
	{	int i;
		for (i = 0; i < a->__sizeResolutionsAvailable; i++)
			if (soap_out_tt__VideoResolution(soap, "tt:ResolutionsAvailable", -1, a->ResolutionsAvailable + i, ""))
				return soap->error;
	}
	if (a->GovLengthRange)
	{	if (soap_out_PointerTott__IntRange(soap, "tt:GovLengthRange", -1, &a->GovLengthRange, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:GovLengthRange"))
		return soap->error;
	if (a->FrameRateRange)
	{	if (soap_out_PointerTott__IntRange(soap, "tt:FrameRateRange", -1, &a->FrameRateRange, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:FrameRateRange"))
		return soap->error;
	if (a->EncodingIntervalRange)
	{	if (soap_out_PointerTott__IntRange(soap, "tt:EncodingIntervalRange", -1, &a->EncodingIntervalRange, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:EncodingIntervalRange"))
		return soap->error;
	if (a->Mpeg4ProfilesSupported)
	{	int i;
		for (i = 0; i < a->__sizeMpeg4ProfilesSupported; i++)
			if (soap_out_tt__Mpeg4Profile(soap, "tt:Mpeg4ProfilesSupported", -1, a->Mpeg4ProfilesSupported + i, ""))
				return soap->error;
	}
	if (a->BitrateRange)
	{	if (soap_out_PointerTott__IntRange(soap, "tt:BitrateRange", -1, &a->BitrateRange, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:BitrateRange"))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__Mpeg4Options2 * SOAP_FMAC4 soap_in_tt__Mpeg4Options2(struct soap *soap, const char *tag, struct tt__Mpeg4Options2 *a, const char *type)
{
	struct soap_blist *soap_blist_ResolutionsAvailable = NULL;
	size_t soap_flag_GovLengthRange = 1;
	size_t soap_flag_FrameRateRange = 1;
	size_t soap_flag_EncodingIntervalRange = 1;
	struct soap_blist *soap_blist_Mpeg4ProfilesSupported = NULL;
	size_t soap_flag_BitrateRange = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__Mpeg4Options2 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Mpeg4Options2, sizeof(struct tt__Mpeg4Options2), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__Mpeg4Options2(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:ResolutionsAvailable", 1, NULL))
			{	if (a->ResolutionsAvailable == NULL)
				{	if (soap_blist_ResolutionsAvailable == NULL)
						soap_blist_ResolutionsAvailable = soap_new_block(soap);
					a->ResolutionsAvailable = (struct tt__VideoResolution *)soap_push_block(soap, soap_blist_ResolutionsAvailable, sizeof(struct tt__VideoResolution));
					if (a->ResolutionsAvailable == NULL)
						return NULL;
					soap_default_tt__VideoResolution(soap, a->ResolutionsAvailable);
				}
				soap_revert(soap);
				if (soap_in_tt__VideoResolution(soap, "tt:ResolutionsAvailable", a->ResolutionsAvailable, "tt:VideoResolution"))
				{	a->__sizeResolutionsAvailable++;
					a->ResolutionsAvailable = NULL;
					continue;
				}
			}
			if (soap_flag_GovLengthRange && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IntRange(soap, "tt:GovLengthRange", &a->GovLengthRange, "tt:IntRange"))
				{	soap_flag_GovLengthRange--;
					continue;
				}
			if (soap_flag_FrameRateRange && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IntRange(soap, "tt:FrameRateRange", &a->FrameRateRange, "tt:IntRange"))
				{	soap_flag_FrameRateRange--;
					continue;
				}
			if (soap_flag_EncodingIntervalRange && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IntRange(soap, "tt:EncodingIntervalRange", &a->EncodingIntervalRange, "tt:IntRange"))
				{	soap_flag_EncodingIntervalRange--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Mpeg4ProfilesSupported", 1, NULL))
			{	if (a->Mpeg4ProfilesSupported == NULL)
				{	if (soap_blist_Mpeg4ProfilesSupported == NULL)
						soap_blist_Mpeg4ProfilesSupported = soap_new_block(soap);
					a->Mpeg4ProfilesSupported = (enum tt__Mpeg4Profile *)soap_push_block(soap, soap_blist_Mpeg4ProfilesSupported, sizeof(enum tt__Mpeg4Profile));
					if (a->Mpeg4ProfilesSupported == NULL)
						return NULL;
					soap_default_tt__Mpeg4Profile(soap, a->Mpeg4ProfilesSupported);
				}
				soap_revert(soap);
				if (soap_in_tt__Mpeg4Profile(soap, "tt:Mpeg4ProfilesSupported", a->Mpeg4ProfilesSupported, "tt:Mpeg4Profile"))
				{	a->__sizeMpeg4ProfilesSupported++;
					a->Mpeg4ProfilesSupported = NULL;
					continue;
				}
			}
			if (soap_flag_BitrateRange && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IntRange(soap, "tt:BitrateRange", &a->BitrateRange, "tt:IntRange"))
				{	soap_flag_BitrateRange--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ResolutionsAvailable)
			soap_pop_block(soap, soap_blist_ResolutionsAvailable);
		if (a->__sizeResolutionsAvailable)
			a->ResolutionsAvailable = (struct tt__VideoResolution *)soap_save_block(soap, soap_blist_ResolutionsAvailable, NULL, 1);
		else
		{	a->ResolutionsAvailable = NULL;
			if (soap_blist_ResolutionsAvailable)
				soap_end_block(soap, soap_blist_ResolutionsAvailable);
		}
		if (a->Mpeg4ProfilesSupported)
			soap_pop_block(soap, soap_blist_Mpeg4ProfilesSupported);
		if (a->__sizeMpeg4ProfilesSupported)
			a->Mpeg4ProfilesSupported = (enum tt__Mpeg4Profile *)soap_save_block(soap, soap_blist_Mpeg4ProfilesSupported, NULL, 1);
		else
		{	a->Mpeg4ProfilesSupported = NULL;
			if (soap_blist_Mpeg4ProfilesSupported)
				soap_end_block(soap, soap_blist_Mpeg4ProfilesSupported);
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__Mpeg4Options2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Mpeg4Options2, 0, sizeof(struct tt__Mpeg4Options2), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeResolutionsAvailable < 1 || soap_flag_GovLengthRange > 0 || soap_flag_FrameRateRange > 0 || soap_flag_EncodingIntervalRange > 0 || a->__sizeMpeg4ProfilesSupported < 1 || soap_flag_BitrateRange > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Mpeg4Options2(struct soap *soap, const struct tt__Mpeg4Options2 *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__Mpeg4Options2);
	if (soap_out_tt__Mpeg4Options2(soap, tag?tag:"tt:Mpeg4Options2", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Mpeg4Options2 * SOAP_FMAC4 soap_get_tt__Mpeg4Options2(struct soap *soap, struct tt__Mpeg4Options2 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Mpeg4Options2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__JpegOptions2(struct soap *soap, struct tt__JpegOptions2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeResolutionsAvailable = 0;
	a->ResolutionsAvailable = NULL;
	a->FrameRateRange = NULL;
	a->EncodingIntervalRange = NULL;
	a->BitrateRange = NULL;
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__JpegOptions2(struct soap *soap, const struct tt__JpegOptions2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->ResolutionsAvailable)
	{	int i;
		for (i = 0; i < a->__sizeResolutionsAvailable; i++)
		{
			soap_embedded(soap, a->ResolutionsAvailable + i, SOAP_TYPE_tt__VideoResolution);
			soap_serialize_tt__VideoResolution(soap, a->ResolutionsAvailable + i);
		}
	}
	soap_serialize_PointerTott__IntRange(soap, &a->FrameRateRange);
	soap_serialize_PointerTott__IntRange(soap, &a->EncodingIntervalRange);
	soap_serialize_PointerTott__IntRange(soap, &a->BitrateRange);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__JpegOptions2(struct soap *soap, const char *tag, int id, const struct tt__JpegOptions2 *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__JpegOptions2), type))
		return soap->error;
	if (a->ResolutionsAvailable)
	{	int i;
		for (i = 0; i < a->__sizeResolutionsAvailable; i++)
			if (soap_out_tt__VideoResolution(soap, "tt:ResolutionsAvailable", -1, a->ResolutionsAvailable + i, ""))
				return soap->error;
	}
	if (a->FrameRateRange)
	{	if (soap_out_PointerTott__IntRange(soap, "tt:FrameRateRange", -1, &a->FrameRateRange, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:FrameRateRange"))
		return soap->error;
	if (a->EncodingIntervalRange)
	{	if (soap_out_PointerTott__IntRange(soap, "tt:EncodingIntervalRange", -1, &a->EncodingIntervalRange, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:EncodingIntervalRange"))
		return soap->error;
	if (a->BitrateRange)
	{	if (soap_out_PointerTott__IntRange(soap, "tt:BitrateRange", -1, &a->BitrateRange, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:BitrateRange"))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__JpegOptions2 * SOAP_FMAC4 soap_in_tt__JpegOptions2(struct soap *soap, const char *tag, struct tt__JpegOptions2 *a, const char *type)
{
	struct soap_blist *soap_blist_ResolutionsAvailable = NULL;
	size_t soap_flag_FrameRateRange = 1;
	size_t soap_flag_EncodingIntervalRange = 1;
	size_t soap_flag_BitrateRange = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__JpegOptions2 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__JpegOptions2, sizeof(struct tt__JpegOptions2), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__JpegOptions2(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:ResolutionsAvailable", 1, NULL))
			{	if (a->ResolutionsAvailable == NULL)
				{	if (soap_blist_ResolutionsAvailable == NULL)
						soap_blist_ResolutionsAvailable = soap_new_block(soap);
					a->ResolutionsAvailable = (struct tt__VideoResolution *)soap_push_block(soap, soap_blist_ResolutionsAvailable, sizeof(struct tt__VideoResolution));
					if (a->ResolutionsAvailable == NULL)
						return NULL;
					soap_default_tt__VideoResolution(soap, a->ResolutionsAvailable);
				}
				soap_revert(soap);
				if (soap_in_tt__VideoResolution(soap, "tt:ResolutionsAvailable", a->ResolutionsAvailable, "tt:VideoResolution"))
				{	a->__sizeResolutionsAvailable++;
					a->ResolutionsAvailable = NULL;
					continue;
				}
			}
			if (soap_flag_FrameRateRange && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IntRange(soap, "tt:FrameRateRange", &a->FrameRateRange, "tt:IntRange"))
				{	soap_flag_FrameRateRange--;
					continue;
				}
			if (soap_flag_EncodingIntervalRange && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IntRange(soap, "tt:EncodingIntervalRange", &a->EncodingIntervalRange, "tt:IntRange"))
				{	soap_flag_EncodingIntervalRange--;
					continue;
				}
			if (soap_flag_BitrateRange && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IntRange(soap, "tt:BitrateRange", &a->BitrateRange, "tt:IntRange"))
				{	soap_flag_BitrateRange--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ResolutionsAvailable)
			soap_pop_block(soap, soap_blist_ResolutionsAvailable);
		if (a->__sizeResolutionsAvailable)
			a->ResolutionsAvailable = (struct tt__VideoResolution *)soap_save_block(soap, soap_blist_ResolutionsAvailable, NULL, 1);
		else
		{	a->ResolutionsAvailable = NULL;
			if (soap_blist_ResolutionsAvailable)
				soap_end_block(soap, soap_blist_ResolutionsAvailable);
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__JpegOptions2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__JpegOptions2, 0, sizeof(struct tt__JpegOptions2), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeResolutionsAvailable < 1 || soap_flag_FrameRateRange > 0 || soap_flag_EncodingIntervalRange > 0 || soap_flag_BitrateRange > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__JpegOptions2(struct soap *soap, const struct tt__JpegOptions2 *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__JpegOptions2);
	if (soap_out_tt__JpegOptions2(soap, tag?tag:"tt:JpegOptions2", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__JpegOptions2 * SOAP_FMAC4 soap_get_tt__JpegOptions2(struct soap *soap, struct tt__JpegOptions2 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__JpegOptions2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__VideoEncoderOptionsExtension(struct soap *soap, struct tt__VideoEncoderOptionsExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
	a->JPEG = NULL;
	a->MPEG4 = NULL;
	a->H264 = NULL;
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__VideoEncoderOptionsExtension(struct soap *soap, const struct tt__VideoEncoderOptionsExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTott__JpegOptions2(soap, &a->JPEG);
	soap_serialize_PointerTott__Mpeg4Options2(soap, &a->MPEG4);
	soap_serialize_PointerTott__H264Options2(soap, &a->H264);
	soap_serialize_PointerTott__VideoEncoderOptionsExtension2(soap, &a->Extension);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__VideoEncoderOptionsExtension(struct soap *soap, const char *tag, int id, const struct tt__VideoEncoderOptionsExtension *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__VideoEncoderOptionsExtension), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	if (soap_out_PointerTott__JpegOptions2(soap, "tt:JPEG", -1, &a->JPEG, ""))
		return soap->error;
	if (soap_out_PointerTott__Mpeg4Options2(soap, "tt:MPEG4", -1, &a->MPEG4, ""))
		return soap->error;
	if (soap_out_PointerTott__H264Options2(soap, "tt:H264", -1, &a->H264, ""))
		return soap->error;
	if (soap_out_PointerTott__VideoEncoderOptionsExtension2(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__VideoEncoderOptionsExtension * SOAP_FMAC4 soap_in_tt__VideoEncoderOptionsExtension(struct soap *soap, const char *tag, struct tt__VideoEncoderOptionsExtension *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	size_t soap_flag_JPEG = 1;
	size_t soap_flag_MPEG4 = 1;
	size_t soap_flag_H264 = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__VideoEncoderOptionsExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__VideoEncoderOptionsExtension, sizeof(struct tt__VideoEncoderOptionsExtension), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__VideoEncoderOptionsExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap_flag_JPEG && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__JpegOptions2(soap, "tt:JPEG", &a->JPEG, "tt:JpegOptions2"))
				{	soap_flag_JPEG--;
					continue;
				}
			if (soap_flag_MPEG4 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__Mpeg4Options2(soap, "tt:MPEG4", &a->MPEG4, "tt:Mpeg4Options2"))
				{	soap_flag_MPEG4--;
					continue;
				}
			if (soap_flag_H264 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__H264Options2(soap, "tt:H264", &a->H264, "tt:H264Options2"))
				{	soap_flag_H264--;
					continue;
				}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__VideoEncoderOptionsExtension2(soap, "tt:Extension", &a->Extension, "tt:VideoEncoderOptionsExtension2"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__VideoEncoderOptionsExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__VideoEncoderOptionsExtension, 0, sizeof(struct tt__VideoEncoderOptionsExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__VideoEncoderOptionsExtension(struct soap *soap, const struct tt__VideoEncoderOptionsExtension *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__VideoEncoderOptionsExtension);
	if (soap_out_tt__VideoEncoderOptionsExtension(soap, tag?tag:"tt:VideoEncoderOptionsExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__VideoEncoderOptionsExtension * SOAP_FMAC4 soap_get_tt__VideoEncoderOptionsExtension(struct soap *soap, struct tt__VideoEncoderOptionsExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__VideoEncoderOptionsExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__H264Options(struct soap *soap, struct tt__H264Options *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeResolutionsAvailable = 0;
	a->ResolutionsAvailable = NULL;
	a->GovLengthRange = NULL;
	a->FrameRateRange = NULL;
	a->EncodingIntervalRange = NULL;
	a->__sizeH264ProfilesSupported = 0;
	a->H264ProfilesSupported = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__H264Options(struct soap *soap, const struct tt__H264Options *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->ResolutionsAvailable)
	{	int i;
		for (i = 0; i < a->__sizeResolutionsAvailable; i++)
		{
			soap_embedded(soap, a->ResolutionsAvailable + i, SOAP_TYPE_tt__VideoResolution);
			soap_serialize_tt__VideoResolution(soap, a->ResolutionsAvailable + i);
		}
	}
	soap_serialize_PointerTott__IntRange(soap, &a->GovLengthRange);
	soap_serialize_PointerTott__IntRange(soap, &a->FrameRateRange);
	soap_serialize_PointerTott__IntRange(soap, &a->EncodingIntervalRange);
	if (a->H264ProfilesSupported)
	{	int i;
		for (i = 0; i < a->__sizeH264ProfilesSupported; i++)
		{
			soap_embedded(soap, a->H264ProfilesSupported + i, SOAP_TYPE_tt__H264Profile);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__H264Options(struct soap *soap, const char *tag, int id, const struct tt__H264Options *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__H264Options), type))
		return soap->error;
	if (a->ResolutionsAvailable)
	{	int i;
		for (i = 0; i < a->__sizeResolutionsAvailable; i++)
			if (soap_out_tt__VideoResolution(soap, "tt:ResolutionsAvailable", -1, a->ResolutionsAvailable + i, ""))
				return soap->error;
	}
	if (a->GovLengthRange)
	{	if (soap_out_PointerTott__IntRange(soap, "tt:GovLengthRange", -1, &a->GovLengthRange, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:GovLengthRange"))
		return soap->error;
	if (a->FrameRateRange)
	{	if (soap_out_PointerTott__IntRange(soap, "tt:FrameRateRange", -1, &a->FrameRateRange, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:FrameRateRange"))
		return soap->error;
	if (a->EncodingIntervalRange)
	{	if (soap_out_PointerTott__IntRange(soap, "tt:EncodingIntervalRange", -1, &a->EncodingIntervalRange, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:EncodingIntervalRange"))
		return soap->error;
	if (a->H264ProfilesSupported)
	{	int i;
		for (i = 0; i < a->__sizeH264ProfilesSupported; i++)
			if (soap_out_tt__H264Profile(soap, "tt:H264ProfilesSupported", -1, a->H264ProfilesSupported + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__H264Options * SOAP_FMAC4 soap_in_tt__H264Options(struct soap *soap, const char *tag, struct tt__H264Options *a, const char *type)
{
	struct soap_blist *soap_blist_ResolutionsAvailable = NULL;
	size_t soap_flag_GovLengthRange = 1;
	size_t soap_flag_FrameRateRange = 1;
	size_t soap_flag_EncodingIntervalRange = 1;
	struct soap_blist *soap_blist_H264ProfilesSupported = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__H264Options *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__H264Options, sizeof(struct tt__H264Options), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__H264Options(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:ResolutionsAvailable", 1, NULL))
			{	if (a->ResolutionsAvailable == NULL)
				{	if (soap_blist_ResolutionsAvailable == NULL)
						soap_blist_ResolutionsAvailable = soap_new_block(soap);
					a->ResolutionsAvailable = (struct tt__VideoResolution *)soap_push_block(soap, soap_blist_ResolutionsAvailable, sizeof(struct tt__VideoResolution));
					if (a->ResolutionsAvailable == NULL)
						return NULL;
					soap_default_tt__VideoResolution(soap, a->ResolutionsAvailable);
				}
				soap_revert(soap);
				if (soap_in_tt__VideoResolution(soap, "tt:ResolutionsAvailable", a->ResolutionsAvailable, "tt:VideoResolution"))
				{	a->__sizeResolutionsAvailable++;
					a->ResolutionsAvailable = NULL;
					continue;
				}
			}
			if (soap_flag_GovLengthRange && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IntRange(soap, "tt:GovLengthRange", &a->GovLengthRange, "tt:IntRange"))
				{	soap_flag_GovLengthRange--;
					continue;
				}
			if (soap_flag_FrameRateRange && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IntRange(soap, "tt:FrameRateRange", &a->FrameRateRange, "tt:IntRange"))
				{	soap_flag_FrameRateRange--;
					continue;
				}
			if (soap_flag_EncodingIntervalRange && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IntRange(soap, "tt:EncodingIntervalRange", &a->EncodingIntervalRange, "tt:IntRange"))
				{	soap_flag_EncodingIntervalRange--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:H264ProfilesSupported", 1, NULL))
			{	if (a->H264ProfilesSupported == NULL)
				{	if (soap_blist_H264ProfilesSupported == NULL)
						soap_blist_H264ProfilesSupported = soap_new_block(soap);
					a->H264ProfilesSupported = (enum tt__H264Profile *)soap_push_block(soap, soap_blist_H264ProfilesSupported, sizeof(enum tt__H264Profile));
					if (a->H264ProfilesSupported == NULL)
						return NULL;
					soap_default_tt__H264Profile(soap, a->H264ProfilesSupported);
				}
				soap_revert(soap);
				if (soap_in_tt__H264Profile(soap, "tt:H264ProfilesSupported", a->H264ProfilesSupported, "tt:H264Profile"))
				{	a->__sizeH264ProfilesSupported++;
					a->H264ProfilesSupported = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ResolutionsAvailable)
			soap_pop_block(soap, soap_blist_ResolutionsAvailable);
		if (a->__sizeResolutionsAvailable)
			a->ResolutionsAvailable = (struct tt__VideoResolution *)soap_save_block(soap, soap_blist_ResolutionsAvailable, NULL, 1);
		else
		{	a->ResolutionsAvailable = NULL;
			if (soap_blist_ResolutionsAvailable)
				soap_end_block(soap, soap_blist_ResolutionsAvailable);
		}
		if (a->H264ProfilesSupported)
			soap_pop_block(soap, soap_blist_H264ProfilesSupported);
		if (a->__sizeH264ProfilesSupported)
			a->H264ProfilesSupported = (enum tt__H264Profile *)soap_save_block(soap, soap_blist_H264ProfilesSupported, NULL, 1);
		else
		{	a->H264ProfilesSupported = NULL;
			if (soap_blist_H264ProfilesSupported)
				soap_end_block(soap, soap_blist_H264ProfilesSupported);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__H264Options *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__H264Options, 0, sizeof(struct tt__H264Options), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeResolutionsAvailable < 1 || soap_flag_GovLengthRange > 0 || soap_flag_FrameRateRange > 0 || soap_flag_EncodingIntervalRange > 0 || a->__sizeH264ProfilesSupported < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__H264Options(struct soap *soap, const struct tt__H264Options *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__H264Options);
	if (soap_out_tt__H264Options(soap, tag?tag:"tt:H264Options", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__H264Options * SOAP_FMAC4 soap_get_tt__H264Options(struct soap *soap, struct tt__H264Options *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__H264Options(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__Mpeg4Options(struct soap *soap, struct tt__Mpeg4Options *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeResolutionsAvailable = 0;
	a->ResolutionsAvailable = NULL;
	a->GovLengthRange = NULL;
	a->FrameRateRange = NULL;
	a->EncodingIntervalRange = NULL;
	a->__sizeMpeg4ProfilesSupported = 0;
	a->Mpeg4ProfilesSupported = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__Mpeg4Options(struct soap *soap, const struct tt__Mpeg4Options *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->ResolutionsAvailable)
	{	int i;
		for (i = 0; i < a->__sizeResolutionsAvailable; i++)
		{
			soap_embedded(soap, a->ResolutionsAvailable + i, SOAP_TYPE_tt__VideoResolution);
			soap_serialize_tt__VideoResolution(soap, a->ResolutionsAvailable + i);
		}
	}
	soap_serialize_PointerTott__IntRange(soap, &a->GovLengthRange);
	soap_serialize_PointerTott__IntRange(soap, &a->FrameRateRange);
	soap_serialize_PointerTott__IntRange(soap, &a->EncodingIntervalRange);
	if (a->Mpeg4ProfilesSupported)
	{	int i;
		for (i = 0; i < a->__sizeMpeg4ProfilesSupported; i++)
		{
			soap_embedded(soap, a->Mpeg4ProfilesSupported + i, SOAP_TYPE_tt__Mpeg4Profile);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Mpeg4Options(struct soap *soap, const char *tag, int id, const struct tt__Mpeg4Options *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Mpeg4Options), type))
		return soap->error;
	if (a->ResolutionsAvailable)
	{	int i;
		for (i = 0; i < a->__sizeResolutionsAvailable; i++)
			if (soap_out_tt__VideoResolution(soap, "tt:ResolutionsAvailable", -1, a->ResolutionsAvailable + i, ""))
				return soap->error;
	}
	if (a->GovLengthRange)
	{	if (soap_out_PointerTott__IntRange(soap, "tt:GovLengthRange", -1, &a->GovLengthRange, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:GovLengthRange"))
		return soap->error;
	if (a->FrameRateRange)
	{	if (soap_out_PointerTott__IntRange(soap, "tt:FrameRateRange", -1, &a->FrameRateRange, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:FrameRateRange"))
		return soap->error;
	if (a->EncodingIntervalRange)
	{	if (soap_out_PointerTott__IntRange(soap, "tt:EncodingIntervalRange", -1, &a->EncodingIntervalRange, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:EncodingIntervalRange"))
		return soap->error;
	if (a->Mpeg4ProfilesSupported)
	{	int i;
		for (i = 0; i < a->__sizeMpeg4ProfilesSupported; i++)
			if (soap_out_tt__Mpeg4Profile(soap, "tt:Mpeg4ProfilesSupported", -1, a->Mpeg4ProfilesSupported + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__Mpeg4Options * SOAP_FMAC4 soap_in_tt__Mpeg4Options(struct soap *soap, const char *tag, struct tt__Mpeg4Options *a, const char *type)
{
	struct soap_blist *soap_blist_ResolutionsAvailable = NULL;
	size_t soap_flag_GovLengthRange = 1;
	size_t soap_flag_FrameRateRange = 1;
	size_t soap_flag_EncodingIntervalRange = 1;
	struct soap_blist *soap_blist_Mpeg4ProfilesSupported = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__Mpeg4Options *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Mpeg4Options, sizeof(struct tt__Mpeg4Options), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__Mpeg4Options(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:ResolutionsAvailable", 1, NULL))
			{	if (a->ResolutionsAvailable == NULL)
				{	if (soap_blist_ResolutionsAvailable == NULL)
						soap_blist_ResolutionsAvailable = soap_new_block(soap);
					a->ResolutionsAvailable = (struct tt__VideoResolution *)soap_push_block(soap, soap_blist_ResolutionsAvailable, sizeof(struct tt__VideoResolution));
					if (a->ResolutionsAvailable == NULL)
						return NULL;
					soap_default_tt__VideoResolution(soap, a->ResolutionsAvailable);
				}
				soap_revert(soap);
				if (soap_in_tt__VideoResolution(soap, "tt:ResolutionsAvailable", a->ResolutionsAvailable, "tt:VideoResolution"))
				{	a->__sizeResolutionsAvailable++;
					a->ResolutionsAvailable = NULL;
					continue;
				}
			}
			if (soap_flag_GovLengthRange && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IntRange(soap, "tt:GovLengthRange", &a->GovLengthRange, "tt:IntRange"))
				{	soap_flag_GovLengthRange--;
					continue;
				}
			if (soap_flag_FrameRateRange && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IntRange(soap, "tt:FrameRateRange", &a->FrameRateRange, "tt:IntRange"))
				{	soap_flag_FrameRateRange--;
					continue;
				}
			if (soap_flag_EncodingIntervalRange && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IntRange(soap, "tt:EncodingIntervalRange", &a->EncodingIntervalRange, "tt:IntRange"))
				{	soap_flag_EncodingIntervalRange--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Mpeg4ProfilesSupported", 1, NULL))
			{	if (a->Mpeg4ProfilesSupported == NULL)
				{	if (soap_blist_Mpeg4ProfilesSupported == NULL)
						soap_blist_Mpeg4ProfilesSupported = soap_new_block(soap);
					a->Mpeg4ProfilesSupported = (enum tt__Mpeg4Profile *)soap_push_block(soap, soap_blist_Mpeg4ProfilesSupported, sizeof(enum tt__Mpeg4Profile));
					if (a->Mpeg4ProfilesSupported == NULL)
						return NULL;
					soap_default_tt__Mpeg4Profile(soap, a->Mpeg4ProfilesSupported);
				}
				soap_revert(soap);
				if (soap_in_tt__Mpeg4Profile(soap, "tt:Mpeg4ProfilesSupported", a->Mpeg4ProfilesSupported, "tt:Mpeg4Profile"))
				{	a->__sizeMpeg4ProfilesSupported++;
					a->Mpeg4ProfilesSupported = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ResolutionsAvailable)
			soap_pop_block(soap, soap_blist_ResolutionsAvailable);
		if (a->__sizeResolutionsAvailable)
			a->ResolutionsAvailable = (struct tt__VideoResolution *)soap_save_block(soap, soap_blist_ResolutionsAvailable, NULL, 1);
		else
		{	a->ResolutionsAvailable = NULL;
			if (soap_blist_ResolutionsAvailable)
				soap_end_block(soap, soap_blist_ResolutionsAvailable);
		}
		if (a->Mpeg4ProfilesSupported)
			soap_pop_block(soap, soap_blist_Mpeg4ProfilesSupported);
		if (a->__sizeMpeg4ProfilesSupported)
			a->Mpeg4ProfilesSupported = (enum tt__Mpeg4Profile *)soap_save_block(soap, soap_blist_Mpeg4ProfilesSupported, NULL, 1);
		else
		{	a->Mpeg4ProfilesSupported = NULL;
			if (soap_blist_Mpeg4ProfilesSupported)
				soap_end_block(soap, soap_blist_Mpeg4ProfilesSupported);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__Mpeg4Options *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Mpeg4Options, 0, sizeof(struct tt__Mpeg4Options), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeResolutionsAvailable < 1 || soap_flag_GovLengthRange > 0 || soap_flag_FrameRateRange > 0 || soap_flag_EncodingIntervalRange > 0 || a->__sizeMpeg4ProfilesSupported < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Mpeg4Options(struct soap *soap, const struct tt__Mpeg4Options *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__Mpeg4Options);
	if (soap_out_tt__Mpeg4Options(soap, tag?tag:"tt:Mpeg4Options", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Mpeg4Options * SOAP_FMAC4 soap_get_tt__Mpeg4Options(struct soap *soap, struct tt__Mpeg4Options *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Mpeg4Options(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__JpegOptions(struct soap *soap, struct tt__JpegOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeResolutionsAvailable = 0;
	a->ResolutionsAvailable = NULL;
	a->FrameRateRange = NULL;
	a->EncodingIntervalRange = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__JpegOptions(struct soap *soap, const struct tt__JpegOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->ResolutionsAvailable)
	{	int i;
		for (i = 0; i < a->__sizeResolutionsAvailable; i++)
		{
			soap_embedded(soap, a->ResolutionsAvailable + i, SOAP_TYPE_tt__VideoResolution);
			soap_serialize_tt__VideoResolution(soap, a->ResolutionsAvailable + i);
		}
	}
	soap_serialize_PointerTott__IntRange(soap, &a->FrameRateRange);
	soap_serialize_PointerTott__IntRange(soap, &a->EncodingIntervalRange);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__JpegOptions(struct soap *soap, const char *tag, int id, const struct tt__JpegOptions *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__JpegOptions), type))
		return soap->error;
	if (a->ResolutionsAvailable)
	{	int i;
		for (i = 0; i < a->__sizeResolutionsAvailable; i++)
			if (soap_out_tt__VideoResolution(soap, "tt:ResolutionsAvailable", -1, a->ResolutionsAvailable + i, ""))
				return soap->error;
	}
	if (a->FrameRateRange)
	{	if (soap_out_PointerTott__IntRange(soap, "tt:FrameRateRange", -1, &a->FrameRateRange, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:FrameRateRange"))
		return soap->error;
	if (a->EncodingIntervalRange)
	{	if (soap_out_PointerTott__IntRange(soap, "tt:EncodingIntervalRange", -1, &a->EncodingIntervalRange, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:EncodingIntervalRange"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__JpegOptions * SOAP_FMAC4 soap_in_tt__JpegOptions(struct soap *soap, const char *tag, struct tt__JpegOptions *a, const char *type)
{
	struct soap_blist *soap_blist_ResolutionsAvailable = NULL;
	size_t soap_flag_FrameRateRange = 1;
	size_t soap_flag_EncodingIntervalRange = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__JpegOptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__JpegOptions, sizeof(struct tt__JpegOptions), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__JpegOptions(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:ResolutionsAvailable", 1, NULL))
			{	if (a->ResolutionsAvailable == NULL)
				{	if (soap_blist_ResolutionsAvailable == NULL)
						soap_blist_ResolutionsAvailable = soap_new_block(soap);
					a->ResolutionsAvailable = (struct tt__VideoResolution *)soap_push_block(soap, soap_blist_ResolutionsAvailable, sizeof(struct tt__VideoResolution));
					if (a->ResolutionsAvailable == NULL)
						return NULL;
					soap_default_tt__VideoResolution(soap, a->ResolutionsAvailable);
				}
				soap_revert(soap);
				if (soap_in_tt__VideoResolution(soap, "tt:ResolutionsAvailable", a->ResolutionsAvailable, "tt:VideoResolution"))
				{	a->__sizeResolutionsAvailable++;
					a->ResolutionsAvailable = NULL;
					continue;
				}
			}
			if (soap_flag_FrameRateRange && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IntRange(soap, "tt:FrameRateRange", &a->FrameRateRange, "tt:IntRange"))
				{	soap_flag_FrameRateRange--;
					continue;
				}
			if (soap_flag_EncodingIntervalRange && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IntRange(soap, "tt:EncodingIntervalRange", &a->EncodingIntervalRange, "tt:IntRange"))
				{	soap_flag_EncodingIntervalRange--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ResolutionsAvailable)
			soap_pop_block(soap, soap_blist_ResolutionsAvailable);
		if (a->__sizeResolutionsAvailable)
			a->ResolutionsAvailable = (struct tt__VideoResolution *)soap_save_block(soap, soap_blist_ResolutionsAvailable, NULL, 1);
		else
		{	a->ResolutionsAvailable = NULL;
			if (soap_blist_ResolutionsAvailable)
				soap_end_block(soap, soap_blist_ResolutionsAvailable);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__JpegOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__JpegOptions, 0, sizeof(struct tt__JpegOptions), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeResolutionsAvailable < 1 || soap_flag_FrameRateRange > 0 || soap_flag_EncodingIntervalRange > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__JpegOptions(struct soap *soap, const struct tt__JpegOptions *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__JpegOptions);
	if (soap_out_tt__JpegOptions(soap, tag?tag:"tt:JpegOptions", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__JpegOptions * SOAP_FMAC4 soap_get_tt__JpegOptions(struct soap *soap, struct tt__JpegOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__JpegOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__VideoEncoderConfigurationOptions(struct soap *soap, struct tt__VideoEncoderConfigurationOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->QualityRange = NULL;
	a->JPEG = NULL;
	a->MPEG4 = NULL;
	a->H264 = NULL;
	a->Extension = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__VideoEncoderConfigurationOptions(struct soap *soap, const struct tt__VideoEncoderConfigurationOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTott__IntRange(soap, &a->QualityRange);
	soap_serialize_PointerTott__JpegOptions(soap, &a->JPEG);
	soap_serialize_PointerTott__Mpeg4Options(soap, &a->MPEG4);
	soap_serialize_PointerTott__H264Options(soap, &a->H264);
	soap_serialize_PointerTott__VideoEncoderOptionsExtension(soap, &a->Extension);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__VideoEncoderConfigurationOptions(struct soap *soap, const char *tag, int id, const struct tt__VideoEncoderConfigurationOptions *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__VideoEncoderConfigurationOptions), type))
		return soap->error;
	if (a->QualityRange)
	{	if (soap_out_PointerTott__IntRange(soap, "tt:QualityRange", -1, &a->QualityRange, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:QualityRange"))
		return soap->error;
	if (soap_out_PointerTott__JpegOptions(soap, "tt:JPEG", -1, &a->JPEG, ""))
		return soap->error;
	if (soap_out_PointerTott__Mpeg4Options(soap, "tt:MPEG4", -1, &a->MPEG4, ""))
		return soap->error;
	if (soap_out_PointerTott__H264Options(soap, "tt:H264", -1, &a->H264, ""))
		return soap->error;
	if (soap_out_PointerTott__VideoEncoderOptionsExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__VideoEncoderConfigurationOptions * SOAP_FMAC4 soap_in_tt__VideoEncoderConfigurationOptions(struct soap *soap, const char *tag, struct tt__VideoEncoderConfigurationOptions *a, const char *type)
{
	size_t soap_flag_QualityRange = 1;
	size_t soap_flag_JPEG = 1;
	size_t soap_flag_MPEG4 = 1;
	size_t soap_flag_H264 = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__VideoEncoderConfigurationOptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__VideoEncoderConfigurationOptions, sizeof(struct tt__VideoEncoderConfigurationOptions), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__VideoEncoderConfigurationOptions(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_QualityRange && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IntRange(soap, "tt:QualityRange", &a->QualityRange, "tt:IntRange"))
				{	soap_flag_QualityRange--;
					continue;
				}
			if (soap_flag_JPEG && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__JpegOptions(soap, "tt:JPEG", &a->JPEG, "tt:JpegOptions"))
				{	soap_flag_JPEG--;
					continue;
				}
			if (soap_flag_MPEG4 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__Mpeg4Options(soap, "tt:MPEG4", &a->MPEG4, "tt:Mpeg4Options"))
				{	soap_flag_MPEG4--;
					continue;
				}
			if (soap_flag_H264 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__H264Options(soap, "tt:H264", &a->H264, "tt:H264Options"))
				{	soap_flag_H264--;
					continue;
				}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__VideoEncoderOptionsExtension(soap, "tt:Extension", &a->Extension, "tt:VideoEncoderOptionsExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__VideoEncoderConfigurationOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__VideoEncoderConfigurationOptions, 0, sizeof(struct tt__VideoEncoderConfigurationOptions), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_QualityRange > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__VideoEncoderConfigurationOptions(struct soap *soap, const struct tt__VideoEncoderConfigurationOptions *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__VideoEncoderConfigurationOptions);
	if (soap_out_tt__VideoEncoderConfigurationOptions(soap, tag?tag:"tt:VideoEncoderConfigurationOptions", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__VideoEncoderConfigurationOptions * SOAP_FMAC4 soap_get_tt__VideoEncoderConfigurationOptions(struct soap *soap, struct tt__VideoEncoderConfigurationOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__VideoEncoderConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__H264Configuration(struct soap *soap, struct tt__H264Configuration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->GovLength);
	soap_default_tt__H264Profile(soap, &a->H264Profile);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__H264Configuration(struct soap *soap, const struct tt__H264Configuration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->GovLength, SOAP_TYPE_int);
	soap_embedded(soap, &a->H264Profile, SOAP_TYPE_tt__H264Profile);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__H264Configuration(struct soap *soap, const char *tag, int id, const struct tt__H264Configuration *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__H264Configuration), type))
		return soap->error;
	if (soap_out_int(soap, "tt:GovLength", -1, &a->GovLength, ""))
		return soap->error;
	if (soap_out_tt__H264Profile(soap, "tt:H264Profile", -1, &a->H264Profile, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__H264Configuration * SOAP_FMAC4 soap_in_tt__H264Configuration(struct soap *soap, const char *tag, struct tt__H264Configuration *a, const char *type)
{
	size_t soap_flag_GovLength = 1;
	size_t soap_flag_H264Profile = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__H264Configuration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__H264Configuration, sizeof(struct tt__H264Configuration), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__H264Configuration(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GovLength && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "tt:GovLength", &a->GovLength, "xsd:int"))
				{	soap_flag_GovLength--;
					continue;
				}
			if (soap_flag_H264Profile && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_tt__H264Profile(soap, "tt:H264Profile", &a->H264Profile, "tt:H264Profile"))
				{	soap_flag_H264Profile--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__H264Configuration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__H264Configuration, 0, sizeof(struct tt__H264Configuration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_GovLength > 0 || soap_flag_H264Profile > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__H264Configuration(struct soap *soap, const struct tt__H264Configuration *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__H264Configuration);
	if (soap_out_tt__H264Configuration(soap, tag?tag:"tt:H264Configuration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__H264Configuration * SOAP_FMAC4 soap_get_tt__H264Configuration(struct soap *soap, struct tt__H264Configuration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__H264Configuration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__Mpeg4Configuration(struct soap *soap, struct tt__Mpeg4Configuration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->GovLength);
	soap_default_tt__Mpeg4Profile(soap, &a->Mpeg4Profile);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__Mpeg4Configuration(struct soap *soap, const struct tt__Mpeg4Configuration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->GovLength, SOAP_TYPE_int);
	soap_embedded(soap, &a->Mpeg4Profile, SOAP_TYPE_tt__Mpeg4Profile);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Mpeg4Configuration(struct soap *soap, const char *tag, int id, const struct tt__Mpeg4Configuration *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Mpeg4Configuration), type))
		return soap->error;
	if (soap_out_int(soap, "tt:GovLength", -1, &a->GovLength, ""))
		return soap->error;
	if (soap_out_tt__Mpeg4Profile(soap, "tt:Mpeg4Profile", -1, &a->Mpeg4Profile, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__Mpeg4Configuration * SOAP_FMAC4 soap_in_tt__Mpeg4Configuration(struct soap *soap, const char *tag, struct tt__Mpeg4Configuration *a, const char *type)
{
	size_t soap_flag_GovLength = 1;
	size_t soap_flag_Mpeg4Profile = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__Mpeg4Configuration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Mpeg4Configuration, sizeof(struct tt__Mpeg4Configuration), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__Mpeg4Configuration(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GovLength && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "tt:GovLength", &a->GovLength, "xsd:int"))
				{	soap_flag_GovLength--;
					continue;
				}
			if (soap_flag_Mpeg4Profile && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_tt__Mpeg4Profile(soap, "tt:Mpeg4Profile", &a->Mpeg4Profile, "tt:Mpeg4Profile"))
				{	soap_flag_Mpeg4Profile--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__Mpeg4Configuration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Mpeg4Configuration, 0, sizeof(struct tt__Mpeg4Configuration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_GovLength > 0 || soap_flag_Mpeg4Profile > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Mpeg4Configuration(struct soap *soap, const struct tt__Mpeg4Configuration *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__Mpeg4Configuration);
	if (soap_out_tt__Mpeg4Configuration(soap, tag?tag:"tt:Mpeg4Configuration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Mpeg4Configuration * SOAP_FMAC4 soap_get_tt__Mpeg4Configuration(struct soap *soap, struct tt__Mpeg4Configuration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Mpeg4Configuration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__VideoRateControl(struct soap *soap, struct tt__VideoRateControl *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->FrameRateLimit);
	soap_default_int(soap, &a->EncodingInterval);
	soap_default_int(soap, &a->BitrateLimit);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__VideoRateControl(struct soap *soap, const struct tt__VideoRateControl *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->FrameRateLimit, SOAP_TYPE_int);
	soap_embedded(soap, &a->EncodingInterval, SOAP_TYPE_int);
	soap_embedded(soap, &a->BitrateLimit, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__VideoRateControl(struct soap *soap, const char *tag, int id, const struct tt__VideoRateControl *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__VideoRateControl), type))
		return soap->error;
	if (soap_out_int(soap, "tt:FrameRateLimit", -1, &a->FrameRateLimit, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:EncodingInterval", -1, &a->EncodingInterval, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:BitrateLimit", -1, &a->BitrateLimit, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__VideoRateControl * SOAP_FMAC4 soap_in_tt__VideoRateControl(struct soap *soap, const char *tag, struct tt__VideoRateControl *a, const char *type)
{
	size_t soap_flag_FrameRateLimit = 1;
	size_t soap_flag_EncodingInterval = 1;
	size_t soap_flag_BitrateLimit = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__VideoRateControl *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__VideoRateControl, sizeof(struct tt__VideoRateControl), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__VideoRateControl(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_FrameRateLimit && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "tt:FrameRateLimit", &a->FrameRateLimit, "xsd:int"))
				{	soap_flag_FrameRateLimit--;
					continue;
				}
			if (soap_flag_EncodingInterval && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "tt:EncodingInterval", &a->EncodingInterval, "xsd:int"))
				{	soap_flag_EncodingInterval--;
					continue;
				}
			if (soap_flag_BitrateLimit && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "tt:BitrateLimit", &a->BitrateLimit, "xsd:int"))
				{	soap_flag_BitrateLimit--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__VideoRateControl *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__VideoRateControl, 0, sizeof(struct tt__VideoRateControl), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_FrameRateLimit > 0 || soap_flag_EncodingInterval > 0 || soap_flag_BitrateLimit > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__VideoRateControl(struct soap *soap, const struct tt__VideoRateControl *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__VideoRateControl);
	if (soap_out_tt__VideoRateControl(soap, tag?tag:"tt:VideoRateControl", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__VideoRateControl * SOAP_FMAC4 soap_get_tt__VideoRateControl(struct soap *soap, struct tt__VideoRateControl *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__VideoRateControl(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__VideoResolution(struct soap *soap, struct tt__VideoResolution *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->Width);
	soap_default_int(soap, &a->Height);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__VideoResolution(struct soap *soap, const struct tt__VideoResolution *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->Width, SOAP_TYPE_int);
	soap_embedded(soap, &a->Height, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__VideoResolution(struct soap *soap, const char *tag, int id, const struct tt__VideoResolution *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__VideoResolution), type))
		return soap->error;
	if (soap_out_int(soap, "tt:Width", -1, &a->Width, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:Height", -1, &a->Height, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__VideoResolution * SOAP_FMAC4 soap_in_tt__VideoResolution(struct soap *soap, const char *tag, struct tt__VideoResolution *a, const char *type)
{
	size_t soap_flag_Width = 1;
	size_t soap_flag_Height = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__VideoResolution *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__VideoResolution, sizeof(struct tt__VideoResolution), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__VideoResolution(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Width && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "tt:Width", &a->Width, "xsd:int"))
				{	soap_flag_Width--;
					continue;
				}
			if (soap_flag_Height && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "tt:Height", &a->Height, "xsd:int"))
				{	soap_flag_Height--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__VideoResolution *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__VideoResolution, 0, sizeof(struct tt__VideoResolution), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Width > 0 || soap_flag_Height > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__VideoResolution(struct soap *soap, const struct tt__VideoResolution *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__VideoResolution);
	if (soap_out_tt__VideoResolution(soap, tag?tag:"tt:VideoResolution", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__VideoResolution * SOAP_FMAC4 soap_get_tt__VideoResolution(struct soap *soap, struct tt__VideoResolution *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__VideoResolution(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__VideoSourceConfigurationOptionsExtension(struct soap *soap, struct tt__VideoSourceConfigurationOptionsExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__VideoSourceConfigurationOptionsExtension(struct soap *soap, const struct tt__VideoSourceConfigurationOptionsExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__VideoSourceConfigurationOptionsExtension(struct soap *soap, const char *tag, int id, const struct tt__VideoSourceConfigurationOptionsExtension *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__VideoSourceConfigurationOptionsExtension), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__VideoSourceConfigurationOptionsExtension * SOAP_FMAC4 soap_in_tt__VideoSourceConfigurationOptionsExtension(struct soap *soap, const char *tag, struct tt__VideoSourceConfigurationOptionsExtension *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__VideoSourceConfigurationOptionsExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__VideoSourceConfigurationOptionsExtension, sizeof(struct tt__VideoSourceConfigurationOptionsExtension), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__VideoSourceConfigurationOptionsExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__VideoSourceConfigurationOptionsExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__VideoSourceConfigurationOptionsExtension, 0, sizeof(struct tt__VideoSourceConfigurationOptionsExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__VideoSourceConfigurationOptionsExtension(struct soap *soap, const struct tt__VideoSourceConfigurationOptionsExtension *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__VideoSourceConfigurationOptionsExtension);
	if (soap_out_tt__VideoSourceConfigurationOptionsExtension(soap, tag?tag:"tt:VideoSourceConfigurationOptionsExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__VideoSourceConfigurationOptionsExtension * SOAP_FMAC4 soap_get_tt__VideoSourceConfigurationOptionsExtension(struct soap *soap, struct tt__VideoSourceConfigurationOptionsExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__VideoSourceConfigurationOptionsExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__VideoSourceConfigurationOptions(struct soap *soap, struct tt__VideoSourceConfigurationOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->BoundsRange = NULL;
	a->__sizeVideoSourceTokensAvailable = 0;
	a->VideoSourceTokensAvailable = NULL;
	a->Extension = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__VideoSourceConfigurationOptions(struct soap *soap, const struct tt__VideoSourceConfigurationOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTott__IntRectangleRange(soap, &a->BoundsRange);
	if (a->VideoSourceTokensAvailable)
	{	int i;
		for (i = 0; i < a->__sizeVideoSourceTokensAvailable; i++)
		{
			soap_serialize_tt__ReferenceToken(soap, a->VideoSourceTokensAvailable + i);
		}
	}
	soap_serialize_PointerTott__VideoSourceConfigurationOptionsExtension(soap, &a->Extension);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__VideoSourceConfigurationOptions(struct soap *soap, const char *tag, int id, const struct tt__VideoSourceConfigurationOptions *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__VideoSourceConfigurationOptions), type))
		return soap->error;
	if (a->BoundsRange)
	{	if (soap_out_PointerTott__IntRectangleRange(soap, "tt:BoundsRange", -1, &a->BoundsRange, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:BoundsRange"))
		return soap->error;
	if (a->VideoSourceTokensAvailable)
	{	int i;
		for (i = 0; i < a->__sizeVideoSourceTokensAvailable; i++)
			if (soap_out_tt__ReferenceToken(soap, "tt:VideoSourceTokensAvailable", -1, a->VideoSourceTokensAvailable + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTott__VideoSourceConfigurationOptionsExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__VideoSourceConfigurationOptions * SOAP_FMAC4 soap_in_tt__VideoSourceConfigurationOptions(struct soap *soap, const char *tag, struct tt__VideoSourceConfigurationOptions *a, const char *type)
{
	size_t soap_flag_BoundsRange = 1;
	struct soap_blist *soap_blist_VideoSourceTokensAvailable = NULL;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__VideoSourceConfigurationOptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__VideoSourceConfigurationOptions, sizeof(struct tt__VideoSourceConfigurationOptions), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__VideoSourceConfigurationOptions(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_BoundsRange && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IntRectangleRange(soap, "tt:BoundsRange", &a->BoundsRange, "tt:IntRectangleRange"))
				{	soap_flag_BoundsRange--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:VideoSourceTokensAvailable", 1, NULL))
			{	if (a->VideoSourceTokensAvailable == NULL)
				{	if (soap_blist_VideoSourceTokensAvailable == NULL)
						soap_blist_VideoSourceTokensAvailable = soap_new_block(soap);
					a->VideoSourceTokensAvailable = (char **)soap_push_block(soap, soap_blist_VideoSourceTokensAvailable, sizeof(char *));
					if (a->VideoSourceTokensAvailable == NULL)
						return NULL;
					*a->VideoSourceTokensAvailable = NULL;
				}
				soap_revert(soap);
				if (soap_in_tt__ReferenceToken(soap, "tt:VideoSourceTokensAvailable", a->VideoSourceTokensAvailable, "tt:ReferenceToken"))
				{	a->__sizeVideoSourceTokensAvailable++;
					a->VideoSourceTokensAvailable = NULL;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__VideoSourceConfigurationOptionsExtension(soap, "tt:Extension", &a->Extension, "tt:VideoSourceConfigurationOptionsExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->VideoSourceTokensAvailable)
			soap_pop_block(soap, soap_blist_VideoSourceTokensAvailable);
		if (a->__sizeVideoSourceTokensAvailable)
			a->VideoSourceTokensAvailable = (char **)soap_save_block(soap, soap_blist_VideoSourceTokensAvailable, NULL, 1);
		else
		{	a->VideoSourceTokensAvailable = NULL;
			if (soap_blist_VideoSourceTokensAvailable)
				soap_end_block(soap, soap_blist_VideoSourceTokensAvailable);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__VideoSourceConfigurationOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__VideoSourceConfigurationOptions, 0, sizeof(struct tt__VideoSourceConfigurationOptions), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_BoundsRange > 0 || a->__sizeVideoSourceTokensAvailable < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__VideoSourceConfigurationOptions(struct soap *soap, const struct tt__VideoSourceConfigurationOptions *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__VideoSourceConfigurationOptions);
	if (soap_out_tt__VideoSourceConfigurationOptions(soap, tag?tag:"tt:VideoSourceConfigurationOptions", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__VideoSourceConfigurationOptions * SOAP_FMAC4 soap_get_tt__VideoSourceConfigurationOptions(struct soap *soap, struct tt__VideoSourceConfigurationOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__VideoSourceConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__ConfigurationEntity(struct soap *soap, struct tt__ConfigurationEntity *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__Name(soap, &a->Name);
	soap_default_int(soap, &a->UseCount);
	soap_default_tt__ReferenceToken(soap, &a->token);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__ConfigurationEntity(struct soap *soap, const struct tt__ConfigurationEntity *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_tt__Name(soap, &a->Name);
	soap_embedded(soap, &a->UseCount, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ConfigurationEntity(struct soap *soap, const char *tag, int id, const struct tt__ConfigurationEntity *a, const char *type)
{
	if (a->token)
		soap_set_attr(soap, "token", a->token, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ConfigurationEntity), type))
		return soap->error;
	if (a->Name)
	{	if (soap_out_tt__Name(soap, "tt:Name", -1, &a->Name, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:Name"))
		return soap->error;
	if (soap_out_int(soap, "tt:UseCount", -1, &a->UseCount, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__ConfigurationEntity * SOAP_FMAC4 soap_in_tt__ConfigurationEntity(struct soap *soap, const char *tag, struct tt__ConfigurationEntity *a, const char *type)
{
	size_t soap_flag_Name = 1;
	size_t soap_flag_UseCount = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__ConfigurationEntity *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ConfigurationEntity, sizeof(struct tt__ConfigurationEntity), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__ConfigurationEntity(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "token", 1), &a->token, -1, 64))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__Name(soap, "tt:Name", &a->Name, "tt:Name"))
				{	soap_flag_Name--;
					continue;
				}
			if (soap_flag_UseCount && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "tt:UseCount", &a->UseCount, "xsd:int"))
				{	soap_flag_UseCount--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__ConfigurationEntity *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ConfigurationEntity, 0, sizeof(struct tt__ConfigurationEntity), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Name > 0 || soap_flag_UseCount > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ConfigurationEntity(struct soap *soap, const struct tt__ConfigurationEntity *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__ConfigurationEntity);
	if (soap_out_tt__ConfigurationEntity(soap, tag?tag:"tt:ConfigurationEntity", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ConfigurationEntity * SOAP_FMAC4 soap_get_tt__ConfigurationEntity(struct soap *soap, struct tt__ConfigurationEntity *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ConfigurationEntity(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__ProfileExtension2(struct soap *soap, struct tt__ProfileExtension2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__ProfileExtension2(struct soap *soap, const struct tt__ProfileExtension2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ProfileExtension2(struct soap *soap, const char *tag, int id, const struct tt__ProfileExtension2 *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ProfileExtension2), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__ProfileExtension2 * SOAP_FMAC4 soap_in_tt__ProfileExtension2(struct soap *soap, const char *tag, struct tt__ProfileExtension2 *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__ProfileExtension2 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ProfileExtension2, sizeof(struct tt__ProfileExtension2), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__ProfileExtension2(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__ProfileExtension2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ProfileExtension2, 0, sizeof(struct tt__ProfileExtension2), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ProfileExtension2(struct soap *soap, const struct tt__ProfileExtension2 *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__ProfileExtension2);
	if (soap_out_tt__ProfileExtension2(soap, tag?tag:"tt:ProfileExtension2", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ProfileExtension2 * SOAP_FMAC4 soap_get_tt__ProfileExtension2(struct soap *soap, struct tt__ProfileExtension2 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ProfileExtension2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__AudioDecoderConfiguration(struct soap *soap, struct tt__AudioDecoderConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__Name(soap, &a->Name);
	soap_default_int(soap, &a->UseCount);
	soap_default_tt__ReferenceToken(soap, &a->token);
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__AudioDecoderConfiguration(struct soap *soap, const struct tt__AudioDecoderConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_tt__Name(soap, &a->Name);
	soap_embedded(soap, &a->UseCount, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AudioDecoderConfiguration(struct soap *soap, const char *tag, int id, const struct tt__AudioDecoderConfiguration *a, const char *type)
{
	if (a->token)
		soap_set_attr(soap, "token", a->token, 1);
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AudioDecoderConfiguration), type))
		return soap->error;
	if (a->Name)
	{	if (soap_out_tt__Name(soap, "tt:Name", -1, &a->Name, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:Name"))
		return soap->error;
	if (soap_out_int(soap, "tt:UseCount", -1, &a->UseCount, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__AudioDecoderConfiguration * SOAP_FMAC4 soap_in_tt__AudioDecoderConfiguration(struct soap *soap, const char *tag, struct tt__AudioDecoderConfiguration *a, const char *type)
{
	size_t soap_flag_Name = 1;
	size_t soap_flag_UseCount = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__AudioDecoderConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AudioDecoderConfiguration, sizeof(struct tt__AudioDecoderConfiguration), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__AudioDecoderConfiguration(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "token", 1), &a->token, -1, 64))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__Name(soap, "tt:Name", &a->Name, "tt:Name"))
				{	soap_flag_Name--;
					continue;
				}
			if (soap_flag_UseCount && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "tt:UseCount", &a->UseCount, "xsd:int"))
				{	soap_flag_UseCount--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__AudioDecoderConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AudioDecoderConfiguration, 0, sizeof(struct tt__AudioDecoderConfiguration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Name > 0 || soap_flag_UseCount > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__AudioDecoderConfiguration(struct soap *soap, const struct tt__AudioDecoderConfiguration *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__AudioDecoderConfiguration);
	if (soap_out_tt__AudioDecoderConfiguration(soap, tag?tag:"tt:AudioDecoderConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AudioDecoderConfiguration * SOAP_FMAC4 soap_get_tt__AudioDecoderConfiguration(struct soap *soap, struct tt__AudioDecoderConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AudioDecoderConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__AudioOutputConfiguration(struct soap *soap, struct tt__AudioOutputConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__Name(soap, &a->Name);
	soap_default_int(soap, &a->UseCount);
	soap_default_tt__ReferenceToken(soap, &a->token);
	soap_default_tt__ReferenceToken(soap, &a->OutputToken);
	soap_default_string(soap, &a->SendPrimacy);
	soap_default_int(soap, &a->OutputLevel);
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__AudioOutputConfiguration(struct soap *soap, const struct tt__AudioOutputConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_tt__Name(soap, &a->Name);
	soap_embedded(soap, &a->UseCount, SOAP_TYPE_int);
	soap_serialize_tt__ReferenceToken(soap, &a->OutputToken);
	soap_serialize_string(soap, &a->SendPrimacy);
	soap_embedded(soap, &a->OutputLevel, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AudioOutputConfiguration(struct soap *soap, const char *tag, int id, const struct tt__AudioOutputConfiguration *a, const char *type)
{
	if (a->token)
		soap_set_attr(soap, "token", a->token, 1);
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AudioOutputConfiguration), type))
		return soap->error;
	if (a->Name)
	{	if (soap_out_tt__Name(soap, "tt:Name", -1, &a->Name, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:Name"))
		return soap->error;
	if (soap_out_int(soap, "tt:UseCount", -1, &a->UseCount, ""))
		return soap->error;
	if (a->OutputToken)
	{	if (soap_out_tt__ReferenceToken(soap, "tt:OutputToken", -1, &a->OutputToken, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:OutputToken"))
		return soap->error;
	if (soap_out_string(soap, "tt:SendPrimacy", -1, &a->SendPrimacy, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:OutputLevel", -1, &a->OutputLevel, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__AudioOutputConfiguration * SOAP_FMAC4 soap_in_tt__AudioOutputConfiguration(struct soap *soap, const char *tag, struct tt__AudioOutputConfiguration *a, const char *type)
{
	size_t soap_flag_Name = 1;
	size_t soap_flag_UseCount = 1;
	size_t soap_flag_OutputToken = 1;
	size_t soap_flag_SendPrimacy = 1;
	size_t soap_flag_OutputLevel = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__AudioOutputConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AudioOutputConfiguration, sizeof(struct tt__AudioOutputConfiguration), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__AudioOutputConfiguration(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "token", 1), &a->token, -1, 64))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__Name(soap, "tt:Name", &a->Name, "tt:Name"))
				{	soap_flag_Name--;
					continue;
				}
			if (soap_flag_UseCount && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "tt:UseCount", &a->UseCount, "xsd:int"))
				{	soap_flag_UseCount--;
					continue;
				}
			if (soap_flag_OutputToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "tt:OutputToken", &a->OutputToken, "tt:ReferenceToken"))
				{	soap_flag_OutputToken--;
					continue;
				}
			if (soap_flag_SendPrimacy && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "tt:SendPrimacy", &a->SendPrimacy, "xsd:string"))
				{	soap_flag_SendPrimacy--;
					continue;
				}
			if (soap_flag_OutputLevel && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "tt:OutputLevel", &a->OutputLevel, "xsd:int"))
				{	soap_flag_OutputLevel--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__AudioOutputConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AudioOutputConfiguration, 0, sizeof(struct tt__AudioOutputConfiguration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Name > 0 || soap_flag_UseCount > 0 || soap_flag_OutputToken > 0 || soap_flag_OutputLevel > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__AudioOutputConfiguration(struct soap *soap, const struct tt__AudioOutputConfiguration *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__AudioOutputConfiguration);
	if (soap_out_tt__AudioOutputConfiguration(soap, tag?tag:"tt:AudioOutputConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AudioOutputConfiguration * SOAP_FMAC4 soap_get_tt__AudioOutputConfiguration(struct soap *soap, struct tt__AudioOutputConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AudioOutputConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__ProfileExtension(struct soap *soap, struct tt__ProfileExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
	a->AudioOutputConfiguration = NULL;
	a->AudioDecoderConfiguration = NULL;
	a->Extension = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__ProfileExtension(struct soap *soap, const struct tt__ProfileExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTott__AudioOutputConfiguration(soap, &a->AudioOutputConfiguration);
	soap_serialize_PointerTott__AudioDecoderConfiguration(soap, &a->AudioDecoderConfiguration);
	soap_serialize_PointerTott__ProfileExtension2(soap, &a->Extension);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ProfileExtension(struct soap *soap, const char *tag, int id, const struct tt__ProfileExtension *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ProfileExtension), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	if (soap_out_PointerTott__AudioOutputConfiguration(soap, "tt:AudioOutputConfiguration", -1, &a->AudioOutputConfiguration, ""))
		return soap->error;
	if (soap_out_PointerTott__AudioDecoderConfiguration(soap, "tt:AudioDecoderConfiguration", -1, &a->AudioDecoderConfiguration, ""))
		return soap->error;
	if (soap_out_PointerTott__ProfileExtension2(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__ProfileExtension * SOAP_FMAC4 soap_in_tt__ProfileExtension(struct soap *soap, const char *tag, struct tt__ProfileExtension *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	size_t soap_flag_AudioOutputConfiguration = 1;
	size_t soap_flag_AudioDecoderConfiguration = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__ProfileExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ProfileExtension, sizeof(struct tt__ProfileExtension), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__ProfileExtension(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap_flag_AudioOutputConfiguration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__AudioOutputConfiguration(soap, "tt:AudioOutputConfiguration", &a->AudioOutputConfiguration, "tt:AudioOutputConfiguration"))
				{	soap_flag_AudioOutputConfiguration--;
					continue;
				}
			if (soap_flag_AudioDecoderConfiguration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__AudioDecoderConfiguration(soap, "tt:AudioDecoderConfiguration", &a->AudioDecoderConfiguration, "tt:AudioDecoderConfiguration"))
				{	soap_flag_AudioDecoderConfiguration--;
					continue;
				}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__ProfileExtension2(soap, "tt:Extension", &a->Extension, "tt:ProfileExtension2"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__ProfileExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ProfileExtension, 0, sizeof(struct tt__ProfileExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ProfileExtension(struct soap *soap, const struct tt__ProfileExtension *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__ProfileExtension);
	if (soap_out_tt__ProfileExtension(soap, tag?tag:"tt:ProfileExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ProfileExtension * SOAP_FMAC4 soap_get_tt__ProfileExtension(struct soap *soap, struct tt__ProfileExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ProfileExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__MetadataConfiguration(struct soap *soap, struct tt__MetadataConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__Name(soap, &a->Name);
	soap_default_int(soap, &a->UseCount);
	soap_default_tt__ReferenceToken(soap, &a->token);
	a->PTZStatus = NULL;
	a->Events = NULL;
	a->Analytics = NULL;
	a->Multicast = NULL;
	soap_default_string(soap, &a->SessionTimeout);
	a->__size = 0;
	a->__any = NULL;
	a->AnalyticsEngineConfiguration = NULL;
	a->Extension = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__MetadataConfiguration(struct soap *soap, const struct tt__MetadataConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_tt__Name(soap, &a->Name);
	soap_embedded(soap, &a->UseCount, SOAP_TYPE_int);
	soap_serialize_PointerTott__PTZFilter(soap, &a->PTZStatus);
	soap_serialize_PointerTott__EventSubscription(soap, &a->Events);
	soap_serialize_PointerToxsd__boolean_(soap, &a->Analytics);
	soap_serialize_PointerTott__MulticastConfiguration(soap, &a->Multicast);
	soap_serialize_string(soap, &a->SessionTimeout);
	soap_serialize_PointerTott__AnalyticsEngineConfiguration(soap, &a->AnalyticsEngineConfiguration);
	soap_serialize_PointerTott__MetadataConfigurationExtension(soap, &a->Extension);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__MetadataConfiguration(struct soap *soap, const char *tag, int id, const struct tt__MetadataConfiguration *a, const char *type)
{
	if (a->token)
		soap_set_attr(soap, "token", a->token, 1);
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__MetadataConfiguration), type))
		return soap->error;
	if (a->Name)
	{	if (soap_out_tt__Name(soap, "tt:Name", -1, &a->Name, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:Name"))
		return soap->error;
	if (soap_out_int(soap, "tt:UseCount", -1, &a->UseCount, ""))
		return soap->error;
	if (soap_out_PointerTott__PTZFilter(soap, "tt:PTZStatus", -1, &a->PTZStatus, ""))
		return soap->error;
	if (soap_out_PointerTott__EventSubscription(soap, "tt:Events", -1, &a->Events, ""))
		return soap->error;
	if (soap_out_PointerToxsd__boolean_(soap, "tt:Analytics", -1, &a->Analytics, ""))
		return soap->error;
	if (a->Multicast)
	{	if (soap_out_PointerTott__MulticastConfiguration(soap, "tt:Multicast", -1, &a->Multicast, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:Multicast"))
		return soap->error;
	if (a->SessionTimeout)
	{	if (soap_out_string(soap, "tt:SessionTimeout", -1, &a->SessionTimeout, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:SessionTimeout"))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	if (soap_out_PointerTott__AnalyticsEngineConfiguration(soap, "tt:AnalyticsEngineConfiguration", -1, &a->AnalyticsEngineConfiguration, ""))
		return soap->error;
	if (soap_out_PointerTott__MetadataConfigurationExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__MetadataConfiguration * SOAP_FMAC4 soap_in_tt__MetadataConfiguration(struct soap *soap, const char *tag, struct tt__MetadataConfiguration *a, const char *type)
{
	size_t soap_flag_Name = 1;
	size_t soap_flag_UseCount = 1;
	size_t soap_flag_PTZStatus = 1;
	size_t soap_flag_Events = 1;
	size_t soap_flag_Analytics = 1;
	size_t soap_flag_Multicast = 1;
	size_t soap_flag_SessionTimeout = 1;
	struct soap_blist *soap_blist___any = NULL;
	size_t soap_flag_AnalyticsEngineConfiguration = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__MetadataConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__MetadataConfiguration, sizeof(struct tt__MetadataConfiguration), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__MetadataConfiguration(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "token", 1), &a->token, -1, 64))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__Name(soap, "tt:Name", &a->Name, "tt:Name"))
				{	soap_flag_Name--;
					continue;
				}
			if (soap_flag_UseCount && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "tt:UseCount", &a->UseCount, "xsd:int"))
				{	soap_flag_UseCount--;
					continue;
				}
			if (soap_flag_PTZStatus && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__PTZFilter(soap, "tt:PTZStatus", &a->PTZStatus, "tt:PTZFilter"))
				{	soap_flag_PTZStatus--;
					continue;
				}
			if (soap_flag_Events && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__EventSubscription(soap, "tt:Events", &a->Events, "tt:EventSubscription"))
				{	soap_flag_Events--;
					continue;
				}
			if (soap_flag_Analytics && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__boolean_(soap, "tt:Analytics", &a->Analytics, "xsd:boolean"))
				{	soap_flag_Analytics--;
					continue;
				}
			if (soap_flag_Multicast && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__MulticastConfiguration(soap, "tt:Multicast", &a->Multicast, "tt:MulticastConfiguration"))
				{	soap_flag_Multicast--;
					continue;
				}
			if (soap_flag_SessionTimeout && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "tt:SessionTimeout", &a->SessionTimeout, "xsd:string"))
				{	soap_flag_SessionTimeout--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap_flag_AnalyticsEngineConfiguration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__AnalyticsEngineConfiguration(soap, "tt:AnalyticsEngineConfiguration", &a->AnalyticsEngineConfiguration, "tt:AnalyticsEngineConfiguration"))
				{	soap_flag_AnalyticsEngineConfiguration--;
					continue;
				}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__MetadataConfigurationExtension(soap, "tt:Extension", &a->Extension, "tt:MetadataConfigurationExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__MetadataConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__MetadataConfiguration, 0, sizeof(struct tt__MetadataConfiguration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Name > 0 || soap_flag_UseCount > 0 || soap_flag_Multicast > 0 || soap_flag_SessionTimeout > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__MetadataConfiguration(struct soap *soap, const struct tt__MetadataConfiguration *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__MetadataConfiguration);
	if (soap_out_tt__MetadataConfiguration(soap, tag?tag:"tt:MetadataConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__MetadataConfiguration * SOAP_FMAC4 soap_get_tt__MetadataConfiguration(struct soap *soap, struct tt__MetadataConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__MetadataConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__PTZConfiguration(struct soap *soap, struct tt__PTZConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__Name(soap, &a->Name);
	soap_default_int(soap, &a->UseCount);
	soap_default_tt__ReferenceToken(soap, &a->token);
	soap_default_tt__ReferenceToken(soap, &a->NodeToken);
	soap_default_string(soap, &a->DefaultAbsolutePantTiltPositionSpace);
	soap_default_string(soap, &a->DefaultAbsoluteZoomPositionSpace);
	soap_default_string(soap, &a->DefaultRelativePanTiltTranslationSpace);
	soap_default_string(soap, &a->DefaultRelativeZoomTranslationSpace);
	soap_default_string(soap, &a->DefaultContinuousPanTiltVelocitySpace);
	soap_default_string(soap, &a->DefaultContinuousZoomVelocitySpace);
	a->DefaultPTZSpeed = NULL;
	soap_default_string(soap, &a->DefaultPTZTimeout);
	a->PanTiltLimits = NULL;
	a->ZoomLimits = NULL;
	a->Extension = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__PTZConfiguration(struct soap *soap, const struct tt__PTZConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_tt__Name(soap, &a->Name);
	soap_embedded(soap, &a->UseCount, SOAP_TYPE_int);
	soap_serialize_tt__ReferenceToken(soap, &a->NodeToken);
	soap_serialize_string(soap, &a->DefaultAbsolutePantTiltPositionSpace);
	soap_serialize_string(soap, &a->DefaultAbsoluteZoomPositionSpace);
	soap_serialize_string(soap, &a->DefaultRelativePanTiltTranslationSpace);
	soap_serialize_string(soap, &a->DefaultRelativeZoomTranslationSpace);
	soap_serialize_string(soap, &a->DefaultContinuousPanTiltVelocitySpace);
	soap_serialize_string(soap, &a->DefaultContinuousZoomVelocitySpace);
	soap_serialize_PointerTott__PTZSpeed(soap, &a->DefaultPTZSpeed);
	soap_serialize_string(soap, &a->DefaultPTZTimeout);
	soap_serialize_PointerTott__PanTiltLimits(soap, &a->PanTiltLimits);
	soap_serialize_PointerTott__ZoomLimits(soap, &a->ZoomLimits);
	soap_serialize_PointerTott__PTZConfigurationExtension(soap, &a->Extension);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZConfiguration(struct soap *soap, const char *tag, int id, const struct tt__PTZConfiguration *a, const char *type)
{
	if (a->token)
		soap_set_attr(soap, "token", a->token, 1);
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTZConfiguration), type))
		return soap->error;
	if (a->Name)
	{	if (soap_out_tt__Name(soap, "tt:Name", -1, &a->Name, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:Name"))
		return soap->error;
	if (soap_out_int(soap, "tt:UseCount", -1, &a->UseCount, ""))
		return soap->error;
	if (a->NodeToken)
	{	if (soap_out_tt__ReferenceToken(soap, "tt:NodeToken", -1, &a->NodeToken, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:NodeToken"))
		return soap->error;
	if (soap_out_string(soap, "tt:DefaultAbsolutePantTiltPositionSpace", -1, &a->DefaultAbsolutePantTiltPositionSpace, ""))
		return soap->error;
	if (soap_out_string(soap, "tt:DefaultAbsoluteZoomPositionSpace", -1, &a->DefaultAbsoluteZoomPositionSpace, ""))
		return soap->error;
	if (soap_out_string(soap, "tt:DefaultRelativePanTiltTranslationSpace", -1, &a->DefaultRelativePanTiltTranslationSpace, ""))
		return soap->error;
	if (soap_out_string(soap, "tt:DefaultRelativeZoomTranslationSpace", -1, &a->DefaultRelativeZoomTranslationSpace, ""))
		return soap->error;
	if (soap_out_string(soap, "tt:DefaultContinuousPanTiltVelocitySpace", -1, &a->DefaultContinuousPanTiltVelocitySpace, ""))
		return soap->error;
	if (soap_out_string(soap, "tt:DefaultContinuousZoomVelocitySpace", -1, &a->DefaultContinuousZoomVelocitySpace, ""))
		return soap->error;
	if (soap_out_PointerTott__PTZSpeed(soap, "tt:DefaultPTZSpeed", -1, &a->DefaultPTZSpeed, ""))
		return soap->error;
	if (soap_out_string(soap, "tt:DefaultPTZTimeout", -1, &a->DefaultPTZTimeout, ""))
		return soap->error;
	if (soap_out_PointerTott__PanTiltLimits(soap, "tt:PanTiltLimits", -1, &a->PanTiltLimits, ""))
		return soap->error;
	if (soap_out_PointerTott__ZoomLimits(soap, "tt:ZoomLimits", -1, &a->ZoomLimits, ""))
		return soap->error;
	if (soap_out_PointerTott__PTZConfigurationExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__PTZConfiguration * SOAP_FMAC4 soap_in_tt__PTZConfiguration(struct soap *soap, const char *tag, struct tt__PTZConfiguration *a, const char *type)
{
	size_t soap_flag_Name = 1;
	size_t soap_flag_UseCount = 1;
	size_t soap_flag_NodeToken = 1;
	size_t soap_flag_DefaultAbsolutePantTiltPositionSpace = 1;
	size_t soap_flag_DefaultAbsoluteZoomPositionSpace = 1;
	size_t soap_flag_DefaultRelativePanTiltTranslationSpace = 1;
	size_t soap_flag_DefaultRelativeZoomTranslationSpace = 1;
	size_t soap_flag_DefaultContinuousPanTiltVelocitySpace = 1;
	size_t soap_flag_DefaultContinuousZoomVelocitySpace = 1;
	size_t soap_flag_DefaultPTZSpeed = 1;
	size_t soap_flag_DefaultPTZTimeout = 1;
	size_t soap_flag_PanTiltLimits = 1;
	size_t soap_flag_ZoomLimits = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__PTZConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZConfiguration, sizeof(struct tt__PTZConfiguration), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__PTZConfiguration(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "token", 1), &a->token, -1, 64))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__Name(soap, "tt:Name", &a->Name, "tt:Name"))
				{	soap_flag_Name--;
					continue;
				}
			if (soap_flag_UseCount && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "tt:UseCount", &a->UseCount, "xsd:int"))
				{	soap_flag_UseCount--;
					continue;
				}
			if (soap_flag_NodeToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "tt:NodeToken", &a->NodeToken, "tt:ReferenceToken"))
				{	soap_flag_NodeToken--;
					continue;
				}
			if (soap_flag_DefaultAbsolutePantTiltPositionSpace && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "tt:DefaultAbsolutePantTiltPositionSpace", &a->DefaultAbsolutePantTiltPositionSpace, "xsd:string"))
				{	soap_flag_DefaultAbsolutePantTiltPositionSpace--;
					continue;
				}
			if (soap_flag_DefaultAbsoluteZoomPositionSpace && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "tt:DefaultAbsoluteZoomPositionSpace", &a->DefaultAbsoluteZoomPositionSpace, "xsd:string"))
				{	soap_flag_DefaultAbsoluteZoomPositionSpace--;
					continue;
				}
			if (soap_flag_DefaultRelativePanTiltTranslationSpace && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "tt:DefaultRelativePanTiltTranslationSpace", &a->DefaultRelativePanTiltTranslationSpace, "xsd:string"))
				{	soap_flag_DefaultRelativePanTiltTranslationSpace--;
					continue;
				}
			if (soap_flag_DefaultRelativeZoomTranslationSpace && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "tt:DefaultRelativeZoomTranslationSpace", &a->DefaultRelativeZoomTranslationSpace, "xsd:string"))
				{	soap_flag_DefaultRelativeZoomTranslationSpace--;
					continue;
				}
			if (soap_flag_DefaultContinuousPanTiltVelocitySpace && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "tt:DefaultContinuousPanTiltVelocitySpace", &a->DefaultContinuousPanTiltVelocitySpace, "xsd:string"))
				{	soap_flag_DefaultContinuousPanTiltVelocitySpace--;
					continue;
				}
			if (soap_flag_DefaultContinuousZoomVelocitySpace && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "tt:DefaultContinuousZoomVelocitySpace", &a->DefaultContinuousZoomVelocitySpace, "xsd:string"))
				{	soap_flag_DefaultContinuousZoomVelocitySpace--;
					continue;
				}
			if (soap_flag_DefaultPTZSpeed && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__PTZSpeed(soap, "tt:DefaultPTZSpeed", &a->DefaultPTZSpeed, "tt:PTZSpeed"))
				{	soap_flag_DefaultPTZSpeed--;
					continue;
				}
			if (soap_flag_DefaultPTZTimeout && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "tt:DefaultPTZTimeout", &a->DefaultPTZTimeout, "xsd:string"))
				{	soap_flag_DefaultPTZTimeout--;
					continue;
				}
			if (soap_flag_PanTiltLimits && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__PanTiltLimits(soap, "tt:PanTiltLimits", &a->PanTiltLimits, "tt:PanTiltLimits"))
				{	soap_flag_PanTiltLimits--;
					continue;
				}
			if (soap_flag_ZoomLimits && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__ZoomLimits(soap, "tt:ZoomLimits", &a->ZoomLimits, "tt:ZoomLimits"))
				{	soap_flag_ZoomLimits--;
					continue;
				}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__PTZConfigurationExtension(soap, "tt:Extension", &a->Extension, "tt:PTZConfigurationExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__PTZConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZConfiguration, 0, sizeof(struct tt__PTZConfiguration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Name > 0 || soap_flag_UseCount > 0 || soap_flag_NodeToken > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__PTZConfiguration(struct soap *soap, const struct tt__PTZConfiguration *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__PTZConfiguration);
	if (soap_out_tt__PTZConfiguration(soap, tag?tag:"tt:PTZConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PTZConfiguration * SOAP_FMAC4 soap_get_tt__PTZConfiguration(struct soap *soap, struct tt__PTZConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTZConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__VideoAnalyticsConfiguration(struct soap *soap, struct tt__VideoAnalyticsConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__Name(soap, &a->Name);
	soap_default_int(soap, &a->UseCount);
	soap_default_tt__ReferenceToken(soap, &a->token);
	a->AnalyticsEngineConfiguration = NULL;
	a->RuleEngineConfiguration = NULL;
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__VideoAnalyticsConfiguration(struct soap *soap, const struct tt__VideoAnalyticsConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_tt__Name(soap, &a->Name);
	soap_embedded(soap, &a->UseCount, SOAP_TYPE_int);
	soap_serialize_PointerTott__AnalyticsEngineConfiguration(soap, &a->AnalyticsEngineConfiguration);
	soap_serialize_PointerTott__RuleEngineConfiguration(soap, &a->RuleEngineConfiguration);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__VideoAnalyticsConfiguration(struct soap *soap, const char *tag, int id, const struct tt__VideoAnalyticsConfiguration *a, const char *type)
{
	if (a->token)
		soap_set_attr(soap, "token", a->token, 1);
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__VideoAnalyticsConfiguration), type))
		return soap->error;
	if (a->Name)
	{	if (soap_out_tt__Name(soap, "tt:Name", -1, &a->Name, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:Name"))
		return soap->error;
	if (soap_out_int(soap, "tt:UseCount", -1, &a->UseCount, ""))
		return soap->error;
	if (a->AnalyticsEngineConfiguration)
	{	if (soap_out_PointerTott__AnalyticsEngineConfiguration(soap, "tt:AnalyticsEngineConfiguration", -1, &a->AnalyticsEngineConfiguration, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:AnalyticsEngineConfiguration"))
		return soap->error;
	if (a->RuleEngineConfiguration)
	{	if (soap_out_PointerTott__RuleEngineConfiguration(soap, "tt:RuleEngineConfiguration", -1, &a->RuleEngineConfiguration, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:RuleEngineConfiguration"))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__VideoAnalyticsConfiguration * SOAP_FMAC4 soap_in_tt__VideoAnalyticsConfiguration(struct soap *soap, const char *tag, struct tt__VideoAnalyticsConfiguration *a, const char *type)
{
	size_t soap_flag_Name = 1;
	size_t soap_flag_UseCount = 1;
	size_t soap_flag_AnalyticsEngineConfiguration = 1;
	size_t soap_flag_RuleEngineConfiguration = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__VideoAnalyticsConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__VideoAnalyticsConfiguration, sizeof(struct tt__VideoAnalyticsConfiguration), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__VideoAnalyticsConfiguration(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "token", 1), &a->token, -1, 64))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__Name(soap, "tt:Name", &a->Name, "tt:Name"))
				{	soap_flag_Name--;
					continue;
				}
			if (soap_flag_UseCount && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "tt:UseCount", &a->UseCount, "xsd:int"))
				{	soap_flag_UseCount--;
					continue;
				}
			if (soap_flag_AnalyticsEngineConfiguration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__AnalyticsEngineConfiguration(soap, "tt:AnalyticsEngineConfiguration", &a->AnalyticsEngineConfiguration, "tt:AnalyticsEngineConfiguration"))
				{	soap_flag_AnalyticsEngineConfiguration--;
					continue;
				}
			if (soap_flag_RuleEngineConfiguration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__RuleEngineConfiguration(soap, "tt:RuleEngineConfiguration", &a->RuleEngineConfiguration, "tt:RuleEngineConfiguration"))
				{	soap_flag_RuleEngineConfiguration--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__VideoAnalyticsConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__VideoAnalyticsConfiguration, 0, sizeof(struct tt__VideoAnalyticsConfiguration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Name > 0 || soap_flag_UseCount > 0 || soap_flag_AnalyticsEngineConfiguration > 0 || soap_flag_RuleEngineConfiguration > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__VideoAnalyticsConfiguration(struct soap *soap, const struct tt__VideoAnalyticsConfiguration *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__VideoAnalyticsConfiguration);
	if (soap_out_tt__VideoAnalyticsConfiguration(soap, tag?tag:"tt:VideoAnalyticsConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__VideoAnalyticsConfiguration * SOAP_FMAC4 soap_get_tt__VideoAnalyticsConfiguration(struct soap *soap, struct tt__VideoAnalyticsConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__VideoAnalyticsConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__AudioEncoderConfiguration(struct soap *soap, struct tt__AudioEncoderConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__Name(soap, &a->Name);
	soap_default_int(soap, &a->UseCount);
	soap_default_tt__ReferenceToken(soap, &a->token);
	soap_default_tt__AudioEncoding(soap, &a->Encoding);
	soap_default_int(soap, &a->Bitrate);
	soap_default_int(soap, &a->SampleRate);
	a->Multicast = NULL;
	soap_default_string(soap, &a->SessionTimeout);
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__AudioEncoderConfiguration(struct soap *soap, const struct tt__AudioEncoderConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_tt__Name(soap, &a->Name);
	soap_embedded(soap, &a->UseCount, SOAP_TYPE_int);
	soap_embedded(soap, &a->Bitrate, SOAP_TYPE_int);
	soap_embedded(soap, &a->SampleRate, SOAP_TYPE_int);
	soap_serialize_PointerTott__MulticastConfiguration(soap, &a->Multicast);
	soap_serialize_string(soap, &a->SessionTimeout);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AudioEncoderConfiguration(struct soap *soap, const char *tag, int id, const struct tt__AudioEncoderConfiguration *a, const char *type)
{
	if (a->token)
		soap_set_attr(soap, "token", a->token, 1);
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AudioEncoderConfiguration), type))
		return soap->error;
	if (a->Name)
	{	if (soap_out_tt__Name(soap, "tt:Name", -1, &a->Name, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:Name"))
		return soap->error;
	if (soap_out_int(soap, "tt:UseCount", -1, &a->UseCount, ""))
		return soap->error;
	if (soap_out_tt__AudioEncoding(soap, "tt:Encoding", -1, &a->Encoding, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:Bitrate", -1, &a->Bitrate, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:SampleRate", -1, &a->SampleRate, ""))
		return soap->error;
	if (a->Multicast)
	{	if (soap_out_PointerTott__MulticastConfiguration(soap, "tt:Multicast", -1, &a->Multicast, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:Multicast"))
		return soap->error;
	if (a->SessionTimeout)
	{	if (soap_out_string(soap, "tt:SessionTimeout", -1, &a->SessionTimeout, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:SessionTimeout"))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__AudioEncoderConfiguration * SOAP_FMAC4 soap_in_tt__AudioEncoderConfiguration(struct soap *soap, const char *tag, struct tt__AudioEncoderConfiguration *a, const char *type)
{
	size_t soap_flag_Name = 1;
	size_t soap_flag_UseCount = 1;
	size_t soap_flag_Encoding = 1;
	size_t soap_flag_Bitrate = 1;
	size_t soap_flag_SampleRate = 1;
	size_t soap_flag_Multicast = 1;
	size_t soap_flag_SessionTimeout = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__AudioEncoderConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AudioEncoderConfiguration, sizeof(struct tt__AudioEncoderConfiguration), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__AudioEncoderConfiguration(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "token", 1), &a->token, -1, 64))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__Name(soap, "tt:Name", &a->Name, "tt:Name"))
				{	soap_flag_Name--;
					continue;
				}
			if (soap_flag_UseCount && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "tt:UseCount", &a->UseCount, "xsd:int"))
				{	soap_flag_UseCount--;
					continue;
				}
			if (soap_flag_Encoding && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_tt__AudioEncoding(soap, "tt:Encoding", &a->Encoding, "tt:AudioEncoding"))
				{	soap_flag_Encoding--;
					continue;
				}
			if (soap_flag_Bitrate && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "tt:Bitrate", &a->Bitrate, "xsd:int"))
				{	soap_flag_Bitrate--;
					continue;
				}
			if (soap_flag_SampleRate && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "tt:SampleRate", &a->SampleRate, "xsd:int"))
				{	soap_flag_SampleRate--;
					continue;
				}
			if (soap_flag_Multicast && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__MulticastConfiguration(soap, "tt:Multicast", &a->Multicast, "tt:MulticastConfiguration"))
				{	soap_flag_Multicast--;
					continue;
				}
			if (soap_flag_SessionTimeout && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "tt:SessionTimeout", &a->SessionTimeout, "xsd:string"))
				{	soap_flag_SessionTimeout--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__AudioEncoderConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AudioEncoderConfiguration, 0, sizeof(struct tt__AudioEncoderConfiguration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Name > 0 || soap_flag_UseCount > 0 || soap_flag_Encoding > 0 || soap_flag_Bitrate > 0 || soap_flag_SampleRate > 0 || soap_flag_Multicast > 0 || soap_flag_SessionTimeout > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__AudioEncoderConfiguration(struct soap *soap, const struct tt__AudioEncoderConfiguration *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__AudioEncoderConfiguration);
	if (soap_out_tt__AudioEncoderConfiguration(soap, tag?tag:"tt:AudioEncoderConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AudioEncoderConfiguration * SOAP_FMAC4 soap_get_tt__AudioEncoderConfiguration(struct soap *soap, struct tt__AudioEncoderConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AudioEncoderConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__VideoEncoderConfiguration(struct soap *soap, struct tt__VideoEncoderConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__Name(soap, &a->Name);
	soap_default_int(soap, &a->UseCount);
	soap_default_tt__ReferenceToken(soap, &a->token);
	soap_default_tt__VideoEncoding(soap, &a->Encoding);
	a->Resolution = NULL;
	soap_default_float(soap, &a->Quality);
	a->RateControl = NULL;
	a->MPEG4 = NULL;
	a->H264 = NULL;
	a->Multicast = NULL;
	soap_default_string(soap, &a->SessionTimeout);
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__VideoEncoderConfiguration(struct soap *soap, const struct tt__VideoEncoderConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_tt__Name(soap, &a->Name);
	soap_embedded(soap, &a->UseCount, SOAP_TYPE_int);
	soap_serialize_PointerTott__VideoResolution(soap, &a->Resolution);
	soap_embedded(soap, &a->Quality, SOAP_TYPE_float);
	soap_serialize_PointerTott__VideoRateControl(soap, &a->RateControl);
	soap_serialize_PointerTott__Mpeg4Configuration(soap, &a->MPEG4);
	soap_serialize_PointerTott__H264Configuration(soap, &a->H264);
	soap_serialize_PointerTott__MulticastConfiguration(soap, &a->Multicast);
	soap_serialize_string(soap, &a->SessionTimeout);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__VideoEncoderConfiguration(struct soap *soap, const char *tag, int id, const struct tt__VideoEncoderConfiguration *a, const char *type)
{
	if (a->token)
		soap_set_attr(soap, "token", a->token, 1);
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__VideoEncoderConfiguration), type))
		return soap->error;
	if (a->Name)
	{	if (soap_out_tt__Name(soap, "tt:Name", -1, &a->Name, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:Name"))
		return soap->error;
	if (soap_out_int(soap, "tt:UseCount", -1, &a->UseCount, ""))
		return soap->error;
	if (soap_out_tt__VideoEncoding(soap, "tt:Encoding", -1, &a->Encoding, ""))
		return soap->error;
	if (a->Resolution)
	{	if (soap_out_PointerTott__VideoResolution(soap, "tt:Resolution", -1, &a->Resolution, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:Resolution"))
		return soap->error;
	if (soap_out_float(soap, "tt:Quality", -1, &a->Quality, ""))
		return soap->error;
	if (soap_out_PointerTott__VideoRateControl(soap, "tt:RateControl", -1, &a->RateControl, ""))
		return soap->error;
	if (soap_out_PointerTott__Mpeg4Configuration(soap, "tt:MPEG4", -1, &a->MPEG4, ""))
		return soap->error;
	if (soap_out_PointerTott__H264Configuration(soap, "tt:H264", -1, &a->H264, ""))
		return soap->error;
	if (a->Multicast)
	{	if (soap_out_PointerTott__MulticastConfiguration(soap, "tt:Multicast", -1, &a->Multicast, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:Multicast"))
		return soap->error;
	if (a->SessionTimeout)
	{	if (soap_out_string(soap, "tt:SessionTimeout", -1, &a->SessionTimeout, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:SessionTimeout"))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__VideoEncoderConfiguration * SOAP_FMAC4 soap_in_tt__VideoEncoderConfiguration(struct soap *soap, const char *tag, struct tt__VideoEncoderConfiguration *a, const char *type)
{
	size_t soap_flag_Name = 1;
	size_t soap_flag_UseCount = 1;
	size_t soap_flag_Encoding = 1;
	size_t soap_flag_Resolution = 1;
	size_t soap_flag_Quality = 1;
	size_t soap_flag_RateControl = 1;
	size_t soap_flag_MPEG4 = 1;
	size_t soap_flag_H264 = 1;
	size_t soap_flag_Multicast = 1;
	size_t soap_flag_SessionTimeout = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__VideoEncoderConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__VideoEncoderConfiguration, sizeof(struct tt__VideoEncoderConfiguration), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__VideoEncoderConfiguration(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "token", 1), &a->token, -1, 64))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__Name(soap, "tt:Name", &a->Name, "tt:Name"))
				{	soap_flag_Name--;
					continue;
				}
			if (soap_flag_UseCount && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "tt:UseCount", &a->UseCount, "xsd:int"))
				{	soap_flag_UseCount--;
					continue;
				}
			if (soap_flag_Encoding && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_tt__VideoEncoding(soap, "tt:Encoding", &a->Encoding, "tt:VideoEncoding"))
				{	soap_flag_Encoding--;
					continue;
				}
			if (soap_flag_Resolution && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__VideoResolution(soap, "tt:Resolution", &a->Resolution, "tt:VideoResolution"))
				{	soap_flag_Resolution--;
					continue;
				}
			if (soap_flag_Quality && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_float(soap, "tt:Quality", &a->Quality, "xsd:float"))
				{	soap_flag_Quality--;
					continue;
				}
			if (soap_flag_RateControl && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__VideoRateControl(soap, "tt:RateControl", &a->RateControl, "tt:VideoRateControl"))
				{	soap_flag_RateControl--;
					continue;
				}
			if (soap_flag_MPEG4 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__Mpeg4Configuration(soap, "tt:MPEG4", &a->MPEG4, "tt:Mpeg4Configuration"))
				{	soap_flag_MPEG4--;
					continue;
				}
			if (soap_flag_H264 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__H264Configuration(soap, "tt:H264", &a->H264, "tt:H264Configuration"))
				{	soap_flag_H264--;
					continue;
				}
			if (soap_flag_Multicast && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__MulticastConfiguration(soap, "tt:Multicast", &a->Multicast, "tt:MulticastConfiguration"))
				{	soap_flag_Multicast--;
					continue;
				}
			if (soap_flag_SessionTimeout && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "tt:SessionTimeout", &a->SessionTimeout, "xsd:string"))
				{	soap_flag_SessionTimeout--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__VideoEncoderConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__VideoEncoderConfiguration, 0, sizeof(struct tt__VideoEncoderConfiguration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Name > 0 || soap_flag_UseCount > 0 || soap_flag_Encoding > 0 || soap_flag_Resolution > 0 || soap_flag_Quality > 0 || soap_flag_Multicast > 0 || soap_flag_SessionTimeout > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__VideoEncoderConfiguration(struct soap *soap, const struct tt__VideoEncoderConfiguration *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__VideoEncoderConfiguration);
	if (soap_out_tt__VideoEncoderConfiguration(soap, tag?tag:"tt:VideoEncoderConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__VideoEncoderConfiguration * SOAP_FMAC4 soap_get_tt__VideoEncoderConfiguration(struct soap *soap, struct tt__VideoEncoderConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__VideoEncoderConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__AudioSourceConfiguration(struct soap *soap, struct tt__AudioSourceConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__Name(soap, &a->Name);
	soap_default_int(soap, &a->UseCount);
	soap_default_tt__ReferenceToken(soap, &a->token);
	soap_default_tt__ReferenceToken(soap, &a->SourceToken);
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__AudioSourceConfiguration(struct soap *soap, const struct tt__AudioSourceConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_tt__Name(soap, &a->Name);
	soap_embedded(soap, &a->UseCount, SOAP_TYPE_int);
	soap_serialize_tt__ReferenceToken(soap, &a->SourceToken);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AudioSourceConfiguration(struct soap *soap, const char *tag, int id, const struct tt__AudioSourceConfiguration *a, const char *type)
{
	if (a->token)
		soap_set_attr(soap, "token", a->token, 1);
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AudioSourceConfiguration), type))
		return soap->error;
	if (a->Name)
	{	if (soap_out_tt__Name(soap, "tt:Name", -1, &a->Name, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:Name"))
		return soap->error;
	if (soap_out_int(soap, "tt:UseCount", -1, &a->UseCount, ""))
		return soap->error;
	if (a->SourceToken)
	{	if (soap_out_tt__ReferenceToken(soap, "tt:SourceToken", -1, &a->SourceToken, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:SourceToken"))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__AudioSourceConfiguration * SOAP_FMAC4 soap_in_tt__AudioSourceConfiguration(struct soap *soap, const char *tag, struct tt__AudioSourceConfiguration *a, const char *type)
{
	size_t soap_flag_Name = 1;
	size_t soap_flag_UseCount = 1;
	size_t soap_flag_SourceToken = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__AudioSourceConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AudioSourceConfiguration, sizeof(struct tt__AudioSourceConfiguration), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__AudioSourceConfiguration(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "token", 1), &a->token, -1, 64))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__Name(soap, "tt:Name", &a->Name, "tt:Name"))
				{	soap_flag_Name--;
					continue;
				}
			if (soap_flag_UseCount && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "tt:UseCount", &a->UseCount, "xsd:int"))
				{	soap_flag_UseCount--;
					continue;
				}
			if (soap_flag_SourceToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "tt:SourceToken", &a->SourceToken, "tt:ReferenceToken"))
				{	soap_flag_SourceToken--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__AudioSourceConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AudioSourceConfiguration, 0, sizeof(struct tt__AudioSourceConfiguration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Name > 0 || soap_flag_UseCount > 0 || soap_flag_SourceToken > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__AudioSourceConfiguration(struct soap *soap, const struct tt__AudioSourceConfiguration *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__AudioSourceConfiguration);
	if (soap_out_tt__AudioSourceConfiguration(soap, tag?tag:"tt:AudioSourceConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AudioSourceConfiguration * SOAP_FMAC4 soap_get_tt__AudioSourceConfiguration(struct soap *soap, struct tt__AudioSourceConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AudioSourceConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__VideoSourceConfiguration(struct soap *soap, struct tt__VideoSourceConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__Name(soap, &a->Name);
	soap_default_int(soap, &a->UseCount);
	soap_default_tt__ReferenceToken(soap, &a->token);
	soap_default_tt__ReferenceToken(soap, &a->SourceToken);
	a->Bounds = NULL;
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__VideoSourceConfiguration(struct soap *soap, const struct tt__VideoSourceConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_tt__Name(soap, &a->Name);
	soap_embedded(soap, &a->UseCount, SOAP_TYPE_int);
	soap_serialize_tt__ReferenceToken(soap, &a->SourceToken);
	soap_serialize_PointerTott__IntRectangle(soap, &a->Bounds);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__VideoSourceConfiguration(struct soap *soap, const char *tag, int id, const struct tt__VideoSourceConfiguration *a, const char *type)
{
	if (a->token)
		soap_set_attr(soap, "token", a->token, 1);
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__VideoSourceConfiguration), type))
		return soap->error;
	if (a->Name)
	{	if (soap_out_tt__Name(soap, "tt:Name", -1, &a->Name, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:Name"))
		return soap->error;
	if (soap_out_int(soap, "tt:UseCount", -1, &a->UseCount, ""))
		return soap->error;
	if (a->SourceToken)
	{	if (soap_out_tt__ReferenceToken(soap, "tt:SourceToken", -1, &a->SourceToken, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:SourceToken"))
		return soap->error;
	if (a->Bounds)
	{	if (soap_out_PointerTott__IntRectangle(soap, "tt:Bounds", -1, &a->Bounds, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:Bounds"))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__VideoSourceConfiguration * SOAP_FMAC4 soap_in_tt__VideoSourceConfiguration(struct soap *soap, const char *tag, struct tt__VideoSourceConfiguration *a, const char *type)
{
	size_t soap_flag_Name = 1;
	size_t soap_flag_UseCount = 1;
	size_t soap_flag_SourceToken = 1;
	size_t soap_flag_Bounds = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__VideoSourceConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__VideoSourceConfiguration, sizeof(struct tt__VideoSourceConfiguration), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__VideoSourceConfiguration(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "token", 1), &a->token, -1, 64))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__Name(soap, "tt:Name", &a->Name, "tt:Name"))
				{	soap_flag_Name--;
					continue;
				}
			if (soap_flag_UseCount && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "tt:UseCount", &a->UseCount, "xsd:int"))
				{	soap_flag_UseCount--;
					continue;
				}
			if (soap_flag_SourceToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "tt:SourceToken", &a->SourceToken, "tt:ReferenceToken"))
				{	soap_flag_SourceToken--;
					continue;
				}
			if (soap_flag_Bounds && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IntRectangle(soap, "tt:Bounds", &a->Bounds, "tt:IntRectangle"))
				{	soap_flag_Bounds--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__VideoSourceConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__VideoSourceConfiguration, 0, sizeof(struct tt__VideoSourceConfiguration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Name > 0 || soap_flag_UseCount > 0 || soap_flag_SourceToken > 0 || soap_flag_Bounds > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__VideoSourceConfiguration(struct soap *soap, const struct tt__VideoSourceConfiguration *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__VideoSourceConfiguration);
	if (soap_out_tt__VideoSourceConfiguration(soap, tag?tag:"tt:VideoSourceConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__VideoSourceConfiguration * SOAP_FMAC4 soap_get_tt__VideoSourceConfiguration(struct soap *soap, struct tt__VideoSourceConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__VideoSourceConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__Profile(struct soap *soap, struct tt__Profile *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__Name(soap, &a->Name);
	a->VideoSourceConfiguration = NULL;
	a->AudioSourceConfiguration = NULL;
	a->VideoEncoderConfiguration = NULL;
	a->AudioEncoderConfiguration = NULL;
	a->VideoAnalyticsConfiguration = NULL;
	a->PTZConfiguration = NULL;
	a->MetadataConfiguration = NULL;
	a->Extension = NULL;
	soap_default_tt__ReferenceToken(soap, &a->token);
	a->fixed = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__Profile(struct soap *soap, const struct tt__Profile *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_tt__Name(soap, &a->Name);
	soap_serialize_PointerTott__VideoSourceConfiguration(soap, &a->VideoSourceConfiguration);
	soap_serialize_PointerTott__AudioSourceConfiguration(soap, &a->AudioSourceConfiguration);
	soap_serialize_PointerTott__VideoEncoderConfiguration(soap, &a->VideoEncoderConfiguration);
	soap_serialize_PointerTott__AudioEncoderConfiguration(soap, &a->AudioEncoderConfiguration);
	soap_serialize_PointerTott__VideoAnalyticsConfiguration(soap, &a->VideoAnalyticsConfiguration);
	soap_serialize_PointerTott__PTZConfiguration(soap, &a->PTZConfiguration);
	soap_serialize_PointerTott__MetadataConfiguration(soap, &a->MetadataConfiguration);
	soap_serialize_PointerTott__ProfileExtension(soap, &a->Extension);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Profile(struct soap *soap, const char *tag, int id, const struct tt__Profile *a, const char *type)
{
	if (a->token)
		soap_set_attr(soap, "token", a->token, 1);
	if (a->fixed)
		soap_set_attr(soap, "fixed", soap_xsd__boolean_2s(soap, *a->fixed), 1);
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Profile), type))
		return soap->error;
	if (a->Name)
	{	if (soap_out_tt__Name(soap, "tt:Name", -1, &a->Name, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:Name"))
		return soap->error;
	if (soap_out_PointerTott__VideoSourceConfiguration(soap, "tt:VideoSourceConfiguration", -1, &a->VideoSourceConfiguration, ""))
		return soap->error;
	if (soap_out_PointerTott__AudioSourceConfiguration(soap, "tt:AudioSourceConfiguration", -1, &a->AudioSourceConfiguration, ""))
		return soap->error;
	if (soap_out_PointerTott__VideoEncoderConfiguration(soap, "tt:VideoEncoderConfiguration", -1, &a->VideoEncoderConfiguration, ""))
		return soap->error;
	if (soap_out_PointerTott__AudioEncoderConfiguration(soap, "tt:AudioEncoderConfiguration", -1, &a->AudioEncoderConfiguration, ""))
		return soap->error;
	if (soap_out_PointerTott__VideoAnalyticsConfiguration(soap, "tt:VideoAnalyticsConfiguration", -1, &a->VideoAnalyticsConfiguration, ""))
		return soap->error;
	if (soap_out_PointerTott__PTZConfiguration(soap, "tt:PTZConfiguration", -1, &a->PTZConfiguration, ""))
		return soap->error;
	if (soap_out_PointerTott__MetadataConfiguration(soap, "tt:MetadataConfiguration", -1, &a->MetadataConfiguration, ""))
		return soap->error;
	if (soap_out_PointerTott__ProfileExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__Profile * SOAP_FMAC4 soap_in_tt__Profile(struct soap *soap, const char *tag, struct tt__Profile *a, const char *type)
{
	size_t soap_flag_Name = 1;
	size_t soap_flag_VideoSourceConfiguration = 1;
	size_t soap_flag_AudioSourceConfiguration = 1;
	size_t soap_flag_VideoEncoderConfiguration = 1;
	size_t soap_flag_AudioEncoderConfiguration = 1;
	size_t soap_flag_VideoAnalyticsConfiguration = 1;
	size_t soap_flag_PTZConfiguration = 1;
	size_t soap_flag_MetadataConfiguration = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__Profile *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Profile, sizeof(struct tt__Profile), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__Profile(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "token", 1), &a->token, -1, 64))
		return NULL;
	{	const char *t = soap_attr_value(soap, "fixed", 0);
		if (t)
		{
			if (!(a->fixed = (enum xsd__boolean_ *)soap_malloc(soap, sizeof(enum xsd__boolean_))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean_(soap, t, a->fixed))
			return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__Name(soap, "tt:Name", &a->Name, "tt:Name"))
				{	soap_flag_Name--;
					continue;
				}
			if (soap_flag_VideoSourceConfiguration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__VideoSourceConfiguration(soap, "tt:VideoSourceConfiguration", &a->VideoSourceConfiguration, "tt:VideoSourceConfiguration"))
				{	soap_flag_VideoSourceConfiguration--;
					continue;
				}
			if (soap_flag_AudioSourceConfiguration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__AudioSourceConfiguration(soap, "tt:AudioSourceConfiguration", &a->AudioSourceConfiguration, "tt:AudioSourceConfiguration"))
				{	soap_flag_AudioSourceConfiguration--;
					continue;
				}
			if (soap_flag_VideoEncoderConfiguration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__VideoEncoderConfiguration(soap, "tt:VideoEncoderConfiguration", &a->VideoEncoderConfiguration, "tt:VideoEncoderConfiguration"))
				{	soap_flag_VideoEncoderConfiguration--;
					continue;
				}
			if (soap_flag_AudioEncoderConfiguration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__AudioEncoderConfiguration(soap, "tt:AudioEncoderConfiguration", &a->AudioEncoderConfiguration, "tt:AudioEncoderConfiguration"))
				{	soap_flag_AudioEncoderConfiguration--;
					continue;
				}
			if (soap_flag_VideoAnalyticsConfiguration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__VideoAnalyticsConfiguration(soap, "tt:VideoAnalyticsConfiguration", &a->VideoAnalyticsConfiguration, "tt:VideoAnalyticsConfiguration"))
				{	soap_flag_VideoAnalyticsConfiguration--;
					continue;
				}
			if (soap_flag_PTZConfiguration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__PTZConfiguration(soap, "tt:PTZConfiguration", &a->PTZConfiguration, "tt:PTZConfiguration"))
				{	soap_flag_PTZConfiguration--;
					continue;
				}
			if (soap_flag_MetadataConfiguration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__MetadataConfiguration(soap, "tt:MetadataConfiguration", &a->MetadataConfiguration, "tt:MetadataConfiguration"))
				{	soap_flag_MetadataConfiguration--;
					continue;
				}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__ProfileExtension(soap, "tt:Extension", &a->Extension, "tt:ProfileExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__Profile *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Profile, 0, sizeof(struct tt__Profile), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Name > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Profile(struct soap *soap, const struct tt__Profile *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__Profile);
	if (soap_out_tt__Profile(soap, tag?tag:"tt:Profile", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Profile * SOAP_FMAC4 soap_get_tt__Profile(struct soap *soap, struct tt__Profile *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Profile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__VideoSourceExtension2(struct soap *soap, struct tt__VideoSourceExtension2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__VideoSourceExtension2(struct soap *soap, const struct tt__VideoSourceExtension2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__VideoSourceExtension2(struct soap *soap, const char *tag, int id, const struct tt__VideoSourceExtension2 *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__VideoSourceExtension2), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__VideoSourceExtension2 * SOAP_FMAC4 soap_in_tt__VideoSourceExtension2(struct soap *soap, const char *tag, struct tt__VideoSourceExtension2 *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__VideoSourceExtension2 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__VideoSourceExtension2, sizeof(struct tt__VideoSourceExtension2), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__VideoSourceExtension2(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__VideoSourceExtension2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__VideoSourceExtension2, 0, sizeof(struct tt__VideoSourceExtension2), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__VideoSourceExtension2(struct soap *soap, const struct tt__VideoSourceExtension2 *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__VideoSourceExtension2);
	if (soap_out_tt__VideoSourceExtension2(soap, tag?tag:"tt:VideoSourceExtension2", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__VideoSourceExtension2 * SOAP_FMAC4 soap_get_tt__VideoSourceExtension2(struct soap *soap, struct tt__VideoSourceExtension2 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__VideoSourceExtension2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__ImagingSettings20(struct soap *soap, struct tt__ImagingSettings20 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->BacklightCompensation = NULL;
	a->Brightness = NULL;
	a->ColorSaturation = NULL;
	a->Contrast = NULL;
	a->Exposure = NULL;
	a->Focus = NULL;
	a->IrCutFilter = NULL;
	a->Sharpness = NULL;
	a->WideDynamicRange = NULL;
	a->WhiteBalance = NULL;
	a->Extension = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__ImagingSettings20(struct soap *soap, const struct tt__ImagingSettings20 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTott__BacklightCompensation20(soap, &a->BacklightCompensation);
	soap_serialize_PointerTofloat(soap, &a->Brightness);
	soap_serialize_PointerTofloat(soap, &a->ColorSaturation);
	soap_serialize_PointerTofloat(soap, &a->Contrast);
	soap_serialize_PointerTott__Exposure20(soap, &a->Exposure);
	soap_serialize_PointerTott__FocusConfiguration20(soap, &a->Focus);
	soap_serialize_PointerTott__IrCutFilterMode(soap, &a->IrCutFilter);
	soap_serialize_PointerTofloat(soap, &a->Sharpness);
	soap_serialize_PointerTott__WideDynamicRange20(soap, &a->WideDynamicRange);
	soap_serialize_PointerTott__WhiteBalance20(soap, &a->WhiteBalance);
	soap_serialize_PointerTott__ImagingSettingsExtension20(soap, &a->Extension);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ImagingSettings20(struct soap *soap, const char *tag, int id, const struct tt__ImagingSettings20 *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ImagingSettings20), type))
		return soap->error;
	if (soap_out_PointerTott__BacklightCompensation20(soap, "tt:BacklightCompensation", -1, &a->BacklightCompensation, ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "tt:Brightness", -1, &a->Brightness, ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "tt:ColorSaturation", -1, &a->ColorSaturation, ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "tt:Contrast", -1, &a->Contrast, ""))
		return soap->error;
	if (soap_out_PointerTott__Exposure20(soap, "tt:Exposure", -1, &a->Exposure, ""))
		return soap->error;
	if (soap_out_PointerTott__FocusConfiguration20(soap, "tt:Focus", -1, &a->Focus, ""))
		return soap->error;
	if (soap_out_PointerTott__IrCutFilterMode(soap, "tt:IrCutFilter", -1, &a->IrCutFilter, ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "tt:Sharpness", -1, &a->Sharpness, ""))
		return soap->error;
	if (soap_out_PointerTott__WideDynamicRange20(soap, "tt:WideDynamicRange", -1, &a->WideDynamicRange, ""))
		return soap->error;
	if (soap_out_PointerTott__WhiteBalance20(soap, "tt:WhiteBalance", -1, &a->WhiteBalance, ""))
		return soap->error;
	if (soap_out_PointerTott__ImagingSettingsExtension20(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__ImagingSettings20 * SOAP_FMAC4 soap_in_tt__ImagingSettings20(struct soap *soap, const char *tag, struct tt__ImagingSettings20 *a, const char *type)
{
	size_t soap_flag_BacklightCompensation = 1;
	size_t soap_flag_Brightness = 1;
	size_t soap_flag_ColorSaturation = 1;
	size_t soap_flag_Contrast = 1;
	size_t soap_flag_Exposure = 1;
	size_t soap_flag_Focus = 1;
	size_t soap_flag_IrCutFilter = 1;
	size_t soap_flag_Sharpness = 1;
	size_t soap_flag_WideDynamicRange = 1;
	size_t soap_flag_WhiteBalance = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__ImagingSettings20 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ImagingSettings20, sizeof(struct tt__ImagingSettings20), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__ImagingSettings20(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_BacklightCompensation && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__BacklightCompensation20(soap, "tt:BacklightCompensation", &a->BacklightCompensation, "tt:BacklightCompensation20"))
				{	soap_flag_BacklightCompensation--;
					continue;
				}
			if (soap_flag_Brightness && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofloat(soap, "tt:Brightness", &a->Brightness, "xsd:float"))
				{	soap_flag_Brightness--;
					continue;
				}
			if (soap_flag_ColorSaturation && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofloat(soap, "tt:ColorSaturation", &a->ColorSaturation, "xsd:float"))
				{	soap_flag_ColorSaturation--;
					continue;
				}
			if (soap_flag_Contrast && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofloat(soap, "tt:Contrast", &a->Contrast, "xsd:float"))
				{	soap_flag_Contrast--;
					continue;
				}
			if (soap_flag_Exposure && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__Exposure20(soap, "tt:Exposure", &a->Exposure, "tt:Exposure20"))
				{	soap_flag_Exposure--;
					continue;
				}
			if (soap_flag_Focus && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__FocusConfiguration20(soap, "tt:Focus", &a->Focus, "tt:FocusConfiguration20"))
				{	soap_flag_Focus--;
					continue;
				}
			if (soap_flag_IrCutFilter && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IrCutFilterMode(soap, "tt:IrCutFilter", &a->IrCutFilter, "tt:IrCutFilterMode"))
				{	soap_flag_IrCutFilter--;
					continue;
				}
			if (soap_flag_Sharpness && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofloat(soap, "tt:Sharpness", &a->Sharpness, "xsd:float"))
				{	soap_flag_Sharpness--;
					continue;
				}
			if (soap_flag_WideDynamicRange && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__WideDynamicRange20(soap, "tt:WideDynamicRange", &a->WideDynamicRange, "tt:WideDynamicRange20"))
				{	soap_flag_WideDynamicRange--;
					continue;
				}
			if (soap_flag_WhiteBalance && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__WhiteBalance20(soap, "tt:WhiteBalance", &a->WhiteBalance, "tt:WhiteBalance20"))
				{	soap_flag_WhiteBalance--;
					continue;
				}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__ImagingSettingsExtension20(soap, "tt:Extension", &a->Extension, "tt:ImagingSettingsExtension20"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__ImagingSettings20 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ImagingSettings20, 0, sizeof(struct tt__ImagingSettings20), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ImagingSettings20(struct soap *soap, const struct tt__ImagingSettings20 *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__ImagingSettings20);
	if (soap_out_tt__ImagingSettings20(soap, tag?tag:"tt:ImagingSettings20", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ImagingSettings20 * SOAP_FMAC4 soap_get_tt__ImagingSettings20(struct soap *soap, struct tt__ImagingSettings20 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ImagingSettings20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__VideoSourceExtension(struct soap *soap, struct tt__VideoSourceExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
	a->Imaging = NULL;
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__VideoSourceExtension(struct soap *soap, const struct tt__VideoSourceExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTott__ImagingSettings20(soap, &a->Imaging);
	soap_serialize_PointerTott__VideoSourceExtension2(soap, &a->Extension);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__VideoSourceExtension(struct soap *soap, const char *tag, int id, const struct tt__VideoSourceExtension *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__VideoSourceExtension), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	if (soap_out_PointerTott__ImagingSettings20(soap, "tt:Imaging", -1, &a->Imaging, ""))
		return soap->error;
	if (soap_out_PointerTott__VideoSourceExtension2(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__VideoSourceExtension * SOAP_FMAC4 soap_in_tt__VideoSourceExtension(struct soap *soap, const char *tag, struct tt__VideoSourceExtension *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	size_t soap_flag_Imaging = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__VideoSourceExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__VideoSourceExtension, sizeof(struct tt__VideoSourceExtension), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__VideoSourceExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap_flag_Imaging && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__ImagingSettings20(soap, "tt:Imaging", &a->Imaging, "tt:ImagingSettings20"))
				{	soap_flag_Imaging--;
					continue;
				}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__VideoSourceExtension2(soap, "tt:Extension", &a->Extension, "tt:VideoSourceExtension2"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__VideoSourceExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__VideoSourceExtension, 0, sizeof(struct tt__VideoSourceExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__VideoSourceExtension(struct soap *soap, const struct tt__VideoSourceExtension *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__VideoSourceExtension);
	if (soap_out_tt__VideoSourceExtension(soap, tag?tag:"tt:VideoSourceExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__VideoSourceExtension * SOAP_FMAC4 soap_get_tt__VideoSourceExtension(struct soap *soap, struct tt__VideoSourceExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__VideoSourceExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__IntList(struct soap *soap, struct tt__IntList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeItems = 0;
	a->Items = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__IntList(struct soap *soap, const struct tt__IntList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->Items)
	{	int i;
		for (i = 0; i < a->__sizeItems; i++)
		{
			soap_embedded(soap, a->Items + i, SOAP_TYPE_int);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IntList(struct soap *soap, const char *tag, int id, const struct tt__IntList *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__IntList), type))
		return soap->error;
	if (a->Items)
	{	int i;
		for (i = 0; i < a->__sizeItems; i++)
			if (soap_out_int(soap, "tt:Items", -1, a->Items + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__IntList * SOAP_FMAC4 soap_in_tt__IntList(struct soap *soap, const char *tag, struct tt__IntList *a, const char *type)
{
	struct soap_blist *soap_blist_Items = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__IntList *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IntList, sizeof(struct tt__IntList), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__IntList(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Items", 1, NULL))
			{	if (a->Items == NULL)
				{	if (soap_blist_Items == NULL)
						soap_blist_Items = soap_new_block(soap);
					a->Items = (int *)soap_push_block(soap, soap_blist_Items, sizeof(int));
					if (a->Items == NULL)
						return NULL;
					soap_default_int(soap, a->Items);
				}
				soap_revert(soap);
				if (soap_in_int(soap, "tt:Items", a->Items, "xsd:int"))
				{	a->__sizeItems++;
					a->Items = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Items)
			soap_pop_block(soap, soap_blist_Items);
		if (a->__sizeItems)
			a->Items = (int *)soap_save_block(soap, soap_blist_Items, NULL, 1);
		else
		{	a->Items = NULL;
			if (soap_blist_Items)
				soap_end_block(soap, soap_blist_Items);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__IntList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__IntList, 0, sizeof(struct tt__IntList), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__IntList(struct soap *soap, const struct tt__IntList *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__IntList);
	if (soap_out_tt__IntList(soap, tag?tag:"tt:IntList", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__IntList * SOAP_FMAC4 soap_get_tt__IntList(struct soap *soap, struct tt__IntList *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__IntList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__DurationRange(struct soap *soap, struct tt__DurationRange *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Min);
	soap_default_string(soap, &a->Max);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__DurationRange(struct soap *soap, const struct tt__DurationRange *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Min);
	soap_serialize_string(soap, &a->Max);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__DurationRange(struct soap *soap, const char *tag, int id, const struct tt__DurationRange *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__DurationRange), type))
		return soap->error;
	if (a->Min)
	{	if (soap_out_string(soap, "tt:Min", -1, &a->Min, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:Min"))
		return soap->error;
	if (a->Max)
	{	if (soap_out_string(soap, "tt:Max", -1, &a->Max, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:Max"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__DurationRange * SOAP_FMAC4 soap_in_tt__DurationRange(struct soap *soap, const char *tag, struct tt__DurationRange *a, const char *type)
{
	size_t soap_flag_Min = 1;
	size_t soap_flag_Max = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__DurationRange *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__DurationRange, sizeof(struct tt__DurationRange), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__DurationRange(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Min && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "tt:Min", &a->Min, "xsd:string"))
				{	soap_flag_Min--;
					continue;
				}
			if (soap_flag_Max && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "tt:Max", &a->Max, "xsd:string"))
				{	soap_flag_Max--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__DurationRange *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__DurationRange, 0, sizeof(struct tt__DurationRange), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Min > 0 || soap_flag_Max > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__DurationRange(struct soap *soap, const struct tt__DurationRange *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__DurationRange);
	if (soap_out_tt__DurationRange(soap, tag?tag:"tt:DurationRange", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__DurationRange * SOAP_FMAC4 soap_get_tt__DurationRange(struct soap *soap, struct tt__DurationRange *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__DurationRange(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__FloatRange(struct soap *soap, struct tt__FloatRange *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_float(soap, &a->Min);
	soap_default_float(soap, &a->Max);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__FloatRange(struct soap *soap, const struct tt__FloatRange *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->Min, SOAP_TYPE_float);
	soap_embedded(soap, &a->Max, SOAP_TYPE_float);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__FloatRange(struct soap *soap, const char *tag, int id, const struct tt__FloatRange *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__FloatRange), type))
		return soap->error;
	if (soap_out_float(soap, "tt:Min", -1, &a->Min, ""))
		return soap->error;
	if (soap_out_float(soap, "tt:Max", -1, &a->Max, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__FloatRange * SOAP_FMAC4 soap_in_tt__FloatRange(struct soap *soap, const char *tag, struct tt__FloatRange *a, const char *type)
{
	size_t soap_flag_Min = 1;
	size_t soap_flag_Max = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__FloatRange *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__FloatRange, sizeof(struct tt__FloatRange), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__FloatRange(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Min && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_float(soap, "tt:Min", &a->Min, "xsd:float"))
				{	soap_flag_Min--;
					continue;
				}
			if (soap_flag_Max && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_float(soap, "tt:Max", &a->Max, "xsd:float"))
				{	soap_flag_Max--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__FloatRange *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__FloatRange, 0, sizeof(struct tt__FloatRange), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Min > 0 || soap_flag_Max > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__FloatRange(struct soap *soap, const struct tt__FloatRange *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__FloatRange);
	if (soap_out_tt__FloatRange(soap, tag?tag:"tt:FloatRange", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__FloatRange * SOAP_FMAC4 soap_get_tt__FloatRange(struct soap *soap, struct tt__FloatRange *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__FloatRange(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__IntRange(struct soap *soap, struct tt__IntRange *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->Min);
	soap_default_int(soap, &a->Max);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__IntRange(struct soap *soap, const struct tt__IntRange *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->Min, SOAP_TYPE_int);
	soap_embedded(soap, &a->Max, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IntRange(struct soap *soap, const char *tag, int id, const struct tt__IntRange *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__IntRange), type))
		return soap->error;
	if (soap_out_int(soap, "tt:Min", -1, &a->Min, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:Max", -1, &a->Max, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__IntRange * SOAP_FMAC4 soap_in_tt__IntRange(struct soap *soap, const char *tag, struct tt__IntRange *a, const char *type)
{
	size_t soap_flag_Min = 1;
	size_t soap_flag_Max = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__IntRange *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IntRange, sizeof(struct tt__IntRange), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__IntRange(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Min && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "tt:Min", &a->Min, "xsd:int"))
				{	soap_flag_Min--;
					continue;
				}
			if (soap_flag_Max && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "tt:Max", &a->Max, "xsd:int"))
				{	soap_flag_Max--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__IntRange *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__IntRange, 0, sizeof(struct tt__IntRange), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Min > 0 || soap_flag_Max > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__IntRange(struct soap *soap, const struct tt__IntRange *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__IntRange);
	if (soap_out_tt__IntRange(soap, tag?tag:"tt:IntRange", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__IntRange * SOAP_FMAC4 soap_get_tt__IntRange(struct soap *soap, struct tt__IntRange *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__IntRange(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__IntRectangleRange(struct soap *soap, struct tt__IntRectangleRange *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->XRange = NULL;
	a->YRange = NULL;
	a->WidthRange = NULL;
	a->HeightRange = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__IntRectangleRange(struct soap *soap, const struct tt__IntRectangleRange *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTott__IntRange(soap, &a->XRange);
	soap_serialize_PointerTott__IntRange(soap, &a->YRange);
	soap_serialize_PointerTott__IntRange(soap, &a->WidthRange);
	soap_serialize_PointerTott__IntRange(soap, &a->HeightRange);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IntRectangleRange(struct soap *soap, const char *tag, int id, const struct tt__IntRectangleRange *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__IntRectangleRange), type))
		return soap->error;
	if (a->XRange)
	{	if (soap_out_PointerTott__IntRange(soap, "tt:XRange", -1, &a->XRange, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:XRange"))
		return soap->error;
	if (a->YRange)
	{	if (soap_out_PointerTott__IntRange(soap, "tt:YRange", -1, &a->YRange, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:YRange"))
		return soap->error;
	if (a->WidthRange)
	{	if (soap_out_PointerTott__IntRange(soap, "tt:WidthRange", -1, &a->WidthRange, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:WidthRange"))
		return soap->error;
	if (a->HeightRange)
	{	if (soap_out_PointerTott__IntRange(soap, "tt:HeightRange", -1, &a->HeightRange, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:HeightRange"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__IntRectangleRange * SOAP_FMAC4 soap_in_tt__IntRectangleRange(struct soap *soap, const char *tag, struct tt__IntRectangleRange *a, const char *type)
{
	size_t soap_flag_XRange = 1;
	size_t soap_flag_YRange = 1;
	size_t soap_flag_WidthRange = 1;
	size_t soap_flag_HeightRange = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__IntRectangleRange *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IntRectangleRange, sizeof(struct tt__IntRectangleRange), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__IntRectangleRange(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_XRange && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IntRange(soap, "tt:XRange", &a->XRange, "tt:IntRange"))
				{	soap_flag_XRange--;
					continue;
				}
			if (soap_flag_YRange && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IntRange(soap, "tt:YRange", &a->YRange, "tt:IntRange"))
				{	soap_flag_YRange--;
					continue;
				}
			if (soap_flag_WidthRange && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IntRange(soap, "tt:WidthRange", &a->WidthRange, "tt:IntRange"))
				{	soap_flag_WidthRange--;
					continue;
				}
			if (soap_flag_HeightRange && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IntRange(soap, "tt:HeightRange", &a->HeightRange, "tt:IntRange"))
				{	soap_flag_HeightRange--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__IntRectangleRange *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__IntRectangleRange, 0, sizeof(struct tt__IntRectangleRange), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_XRange > 0 || soap_flag_YRange > 0 || soap_flag_WidthRange > 0 || soap_flag_HeightRange > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__IntRectangleRange(struct soap *soap, const struct tt__IntRectangleRange *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__IntRectangleRange);
	if (soap_out_tt__IntRectangleRange(soap, tag?tag:"tt:IntRectangleRange", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__IntRectangleRange * SOAP_FMAC4 soap_get_tt__IntRectangleRange(struct soap *soap, struct tt__IntRectangleRange *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__IntRectangleRange(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__IntRectangle(struct soap *soap, struct tt__IntRectangle *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->x);
	soap_default_int(soap, &a->y);
	soap_default_int(soap, &a->width);
	soap_default_int(soap, &a->height);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__IntRectangle(struct soap *soap, const struct tt__IntRectangle *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IntRectangle(struct soap *soap, const char *tag, int id, const struct tt__IntRectangle *a, const char *type)
{
	soap_set_attr(soap, "x", soap_int2s(soap, a->x), 1);
	soap_set_attr(soap, "y", soap_int2s(soap, a->y), 1);
	soap_set_attr(soap, "width", soap_int2s(soap, a->width), 1);
	soap_set_attr(soap, "height", soap_int2s(soap, a->height), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__IntRectangle), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__IntRectangle * SOAP_FMAC4 soap_in_tt__IntRectangle(struct soap *soap, const char *tag, struct tt__IntRectangle *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__IntRectangle *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IntRectangle, sizeof(struct tt__IntRectangle), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__IntRectangle(soap, a);
	if (soap_s2int(soap, soap_attr_value(soap, "x", 1), &a->x))
		return NULL;
	if (soap_s2int(soap, soap_attr_value(soap, "y", 1), &a->y))
		return NULL;
	if (soap_s2int(soap, soap_attr_value(soap, "width", 1), &a->width))
		return NULL;
	if (soap_s2int(soap, soap_attr_value(soap, "height", 1), &a->height))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__IntRectangle *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__IntRectangle, 0, sizeof(struct tt__IntRectangle), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__IntRectangle(struct soap *soap, const struct tt__IntRectangle *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__IntRectangle);
	if (soap_out_tt__IntRectangle(soap, tag?tag:"tt:IntRectangle", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__IntRectangle * SOAP_FMAC4 soap_get_tt__IntRectangle(struct soap *soap, struct tt__IntRectangle *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__IntRectangle(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__DeviceEntity(struct soap *soap, struct tt__DeviceEntity *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->token);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__DeviceEntity(struct soap *soap, const struct tt__DeviceEntity *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__DeviceEntity(struct soap *soap, const char *tag, int id, const struct tt__DeviceEntity *a, const char *type)
{
	if (a->token)
		soap_set_attr(soap, "token", a->token, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__DeviceEntity), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__DeviceEntity * SOAP_FMAC4 soap_in_tt__DeviceEntity(struct soap *soap, const char *tag, struct tt__DeviceEntity *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__DeviceEntity *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__DeviceEntity, sizeof(struct tt__DeviceEntity), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__DeviceEntity(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "token", 1), &a->token, -1, 64))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__DeviceEntity *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__DeviceEntity, 0, sizeof(struct tt__DeviceEntity), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__DeviceEntity(struct soap *soap, const struct tt__DeviceEntity *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__DeviceEntity);
	if (soap_out_tt__DeviceEntity(soap, tag?tag:"tt:DeviceEntity", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__DeviceEntity * SOAP_FMAC4 soap_get_tt__DeviceEntity(struct soap *soap, struct tt__DeviceEntity *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__DeviceEntity(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__StartSystemRestoreResponse(struct soap *soap, struct _tds__StartSystemRestoreResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->UploadUri);
	soap_default_string(soap, &a->ExpectedDownTime);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__StartSystemRestoreResponse(struct soap *soap, const struct _tds__StartSystemRestoreResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->UploadUri);
	soap_serialize_string(soap, &a->ExpectedDownTime);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__StartSystemRestoreResponse(struct soap *soap, const char *tag, int id, const struct _tds__StartSystemRestoreResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__StartSystemRestoreResponse), type))
		return soap->error;
	if (a->UploadUri)
		soap_element_result(soap, "tds:UploadUri");
	if (a->UploadUri)
	{	if (soap_out_string(soap, "tds:UploadUri", -1, &a->UploadUri, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tds:UploadUri"))
		return soap->error;
	if (a->ExpectedDownTime)
	{	if (soap_out_string(soap, "tds:ExpectedDownTime", -1, &a->ExpectedDownTime, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tds:ExpectedDownTime"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__StartSystemRestoreResponse * SOAP_FMAC4 soap_in__tds__StartSystemRestoreResponse(struct soap *soap, const char *tag, struct _tds__StartSystemRestoreResponse *a, const char *type)
{
	size_t soap_flag_UploadUri = 1;
	size_t soap_flag_ExpectedDownTime = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__StartSystemRestoreResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__StartSystemRestoreResponse, sizeof(struct _tds__StartSystemRestoreResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__StartSystemRestoreResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_UploadUri && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "tds:UploadUri", &a->UploadUri, "xsd:string"))
				{	soap_flag_UploadUri--;
					continue;
				}
			if (soap_flag_ExpectedDownTime && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "tds:ExpectedDownTime", &a->ExpectedDownTime, "xsd:string"))
				{	soap_flag_ExpectedDownTime--;
					continue;
				}
			soap_check_result(soap, "tds:UploadUri");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__StartSystemRestoreResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__StartSystemRestoreResponse, 0, sizeof(struct _tds__StartSystemRestoreResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_UploadUri > 0 || soap_flag_ExpectedDownTime > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__StartSystemRestoreResponse(struct soap *soap, const struct _tds__StartSystemRestoreResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__StartSystemRestoreResponse);
	if (soap_out__tds__StartSystemRestoreResponse(soap, tag?tag:"tds:StartSystemRestoreResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__StartSystemRestoreResponse * SOAP_FMAC4 soap_get__tds__StartSystemRestoreResponse(struct soap *soap, struct _tds__StartSystemRestoreResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__StartSystemRestoreResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__StartSystemRestore(struct soap *soap, struct _tds__StartSystemRestore *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__StartSystemRestore(struct soap *soap, const struct _tds__StartSystemRestore *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__StartSystemRestore(struct soap *soap, const char *tag, int id, const struct _tds__StartSystemRestore *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__StartSystemRestore), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__StartSystemRestore * SOAP_FMAC4 soap_in__tds__StartSystemRestore(struct soap *soap, const char *tag, struct _tds__StartSystemRestore *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__StartSystemRestore *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__StartSystemRestore, sizeof(struct _tds__StartSystemRestore), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__StartSystemRestore(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__StartSystemRestore *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__StartSystemRestore, 0, sizeof(struct _tds__StartSystemRestore), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__StartSystemRestore(struct soap *soap, const struct _tds__StartSystemRestore *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__StartSystemRestore);
	if (soap_out__tds__StartSystemRestore(soap, tag?tag:"tds:StartSystemRestore", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__StartSystemRestore * SOAP_FMAC4 soap_get__tds__StartSystemRestore(struct soap *soap, struct _tds__StartSystemRestore *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__StartSystemRestore(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__StartFirmwareUpgradeResponse(struct soap *soap, struct _tds__StartFirmwareUpgradeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->UploadUri);
	soap_default_string(soap, &a->UploadDelay);
	soap_default_string(soap, &a->ExpectedDownTime);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__StartFirmwareUpgradeResponse(struct soap *soap, const struct _tds__StartFirmwareUpgradeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->UploadUri);
	soap_serialize_string(soap, &a->UploadDelay);
	soap_serialize_string(soap, &a->ExpectedDownTime);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__StartFirmwareUpgradeResponse(struct soap *soap, const char *tag, int id, const struct _tds__StartFirmwareUpgradeResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__StartFirmwareUpgradeResponse), type))
		return soap->error;
	if (a->UploadUri)
		soap_element_result(soap, "tds:UploadUri");
	if (a->UploadUri)
	{	if (soap_out_string(soap, "tds:UploadUri", -1, &a->UploadUri, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tds:UploadUri"))
		return soap->error;
	if (a->UploadDelay)
	{	if (soap_out_string(soap, "tds:UploadDelay", -1, &a->UploadDelay, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tds:UploadDelay"))
		return soap->error;
	if (a->ExpectedDownTime)
	{	if (soap_out_string(soap, "tds:ExpectedDownTime", -1, &a->ExpectedDownTime, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tds:ExpectedDownTime"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__StartFirmwareUpgradeResponse * SOAP_FMAC4 soap_in__tds__StartFirmwareUpgradeResponse(struct soap *soap, const char *tag, struct _tds__StartFirmwareUpgradeResponse *a, const char *type)
{
	size_t soap_flag_UploadUri = 1;
	size_t soap_flag_UploadDelay = 1;
	size_t soap_flag_ExpectedDownTime = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__StartFirmwareUpgradeResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__StartFirmwareUpgradeResponse, sizeof(struct _tds__StartFirmwareUpgradeResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__StartFirmwareUpgradeResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_UploadUri && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "tds:UploadUri", &a->UploadUri, "xsd:string"))
				{	soap_flag_UploadUri--;
					continue;
				}
			if (soap_flag_UploadDelay && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "tds:UploadDelay", &a->UploadDelay, "xsd:string"))
				{	soap_flag_UploadDelay--;
					continue;
				}
			if (soap_flag_ExpectedDownTime && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "tds:ExpectedDownTime", &a->ExpectedDownTime, "xsd:string"))
				{	soap_flag_ExpectedDownTime--;
					continue;
				}
			soap_check_result(soap, "tds:UploadUri");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__StartFirmwareUpgradeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__StartFirmwareUpgradeResponse, 0, sizeof(struct _tds__StartFirmwareUpgradeResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_UploadUri > 0 || soap_flag_UploadDelay > 0 || soap_flag_ExpectedDownTime > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__StartFirmwareUpgradeResponse(struct soap *soap, const struct _tds__StartFirmwareUpgradeResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__StartFirmwareUpgradeResponse);
	if (soap_out__tds__StartFirmwareUpgradeResponse(soap, tag?tag:"tds:StartFirmwareUpgradeResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__StartFirmwareUpgradeResponse * SOAP_FMAC4 soap_get__tds__StartFirmwareUpgradeResponse(struct soap *soap, struct _tds__StartFirmwareUpgradeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__StartFirmwareUpgradeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__StartFirmwareUpgrade(struct soap *soap, struct _tds__StartFirmwareUpgrade *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__StartFirmwareUpgrade(struct soap *soap, const struct _tds__StartFirmwareUpgrade *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__StartFirmwareUpgrade(struct soap *soap, const char *tag, int id, const struct _tds__StartFirmwareUpgrade *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__StartFirmwareUpgrade), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__StartFirmwareUpgrade * SOAP_FMAC4 soap_in__tds__StartFirmwareUpgrade(struct soap *soap, const char *tag, struct _tds__StartFirmwareUpgrade *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__StartFirmwareUpgrade *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__StartFirmwareUpgrade, sizeof(struct _tds__StartFirmwareUpgrade), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__StartFirmwareUpgrade(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__StartFirmwareUpgrade *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__StartFirmwareUpgrade, 0, sizeof(struct _tds__StartFirmwareUpgrade), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__StartFirmwareUpgrade(struct soap *soap, const struct _tds__StartFirmwareUpgrade *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__StartFirmwareUpgrade);
	if (soap_out__tds__StartFirmwareUpgrade(soap, tag?tag:"tds:StartFirmwareUpgrade", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__StartFirmwareUpgrade * SOAP_FMAC4 soap_get__tds__StartFirmwareUpgrade(struct soap *soap, struct _tds__StartFirmwareUpgrade *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__StartFirmwareUpgrade(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetSystemUrisResponse_Extension(struct soap *soap, struct _tds__GetSystemUrisResponse_Extension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetSystemUrisResponse_Extension(struct soap *soap, const struct _tds__GetSystemUrisResponse_Extension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetSystemUrisResponse_Extension(struct soap *soap, const char *tag, int id, const struct _tds__GetSystemUrisResponse_Extension *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetSystemUrisResponse_Extension), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetSystemUrisResponse_Extension * SOAP_FMAC4 soap_in__tds__GetSystemUrisResponse_Extension(struct soap *soap, const char *tag, struct _tds__GetSystemUrisResponse_Extension *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__GetSystemUrisResponse_Extension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetSystemUrisResponse_Extension, sizeof(struct _tds__GetSystemUrisResponse_Extension), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetSystemUrisResponse_Extension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__GetSystemUrisResponse_Extension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetSystemUrisResponse_Extension, 0, sizeof(struct _tds__GetSystemUrisResponse_Extension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetSystemUrisResponse_Extension(struct soap *soap, const struct _tds__GetSystemUrisResponse_Extension *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__GetSystemUrisResponse_Extension);
	if (soap_out__tds__GetSystemUrisResponse_Extension(soap, tag?tag:"tds:GetSystemUrisResponse-Extension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetSystemUrisResponse_Extension * SOAP_FMAC4 soap_get__tds__GetSystemUrisResponse_Extension(struct soap *soap, struct _tds__GetSystemUrisResponse_Extension *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetSystemUrisResponse_Extension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__SystemLogUriList(struct soap *soap, struct tt__SystemLogUriList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeSystemLog = 0;
	a->SystemLog = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__SystemLogUriList(struct soap *soap, const struct tt__SystemLogUriList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->SystemLog)
	{	int i;
		for (i = 0; i < a->__sizeSystemLog; i++)
		{
			soap_embedded(soap, a->SystemLog + i, SOAP_TYPE_tt__SystemLogUri);
			soap_serialize_tt__SystemLogUri(soap, a->SystemLog + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__SystemLogUriList(struct soap *soap, const char *tag, int id, const struct tt__SystemLogUriList *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__SystemLogUriList), type))
		return soap->error;
	if (a->SystemLog)
	{	int i;
		for (i = 0; i < a->__sizeSystemLog; i++)
			if (soap_out_tt__SystemLogUri(soap, "tt:SystemLog", -1, a->SystemLog + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__SystemLogUriList * SOAP_FMAC4 soap_in_tt__SystemLogUriList(struct soap *soap, const char *tag, struct tt__SystemLogUriList *a, const char *type)
{
	struct soap_blist *soap_blist_SystemLog = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__SystemLogUriList *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__SystemLogUriList, sizeof(struct tt__SystemLogUriList), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__SystemLogUriList(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:SystemLog", 1, NULL))
			{	if (a->SystemLog == NULL)
				{	if (soap_blist_SystemLog == NULL)
						soap_blist_SystemLog = soap_new_block(soap);
					a->SystemLog = (struct tt__SystemLogUri *)soap_push_block(soap, soap_blist_SystemLog, sizeof(struct tt__SystemLogUri));
					if (a->SystemLog == NULL)
						return NULL;
					soap_default_tt__SystemLogUri(soap, a->SystemLog);
				}
				soap_revert(soap);
				if (soap_in_tt__SystemLogUri(soap, "tt:SystemLog", a->SystemLog, "tt:SystemLogUri"))
				{	a->__sizeSystemLog++;
					a->SystemLog = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->SystemLog)
			soap_pop_block(soap, soap_blist_SystemLog);
		if (a->__sizeSystemLog)
			a->SystemLog = (struct tt__SystemLogUri *)soap_save_block(soap, soap_blist_SystemLog, NULL, 1);
		else
		{	a->SystemLog = NULL;
			if (soap_blist_SystemLog)
				soap_end_block(soap, soap_blist_SystemLog);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__SystemLogUriList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__SystemLogUriList, 0, sizeof(struct tt__SystemLogUriList), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__SystemLogUriList(struct soap *soap, const struct tt__SystemLogUriList *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__SystemLogUriList);
	if (soap_out_tt__SystemLogUriList(soap, tag?tag:"tt:SystemLogUriList", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__SystemLogUriList * SOAP_FMAC4 soap_get_tt__SystemLogUriList(struct soap *soap, struct tt__SystemLogUriList *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__SystemLogUriList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetSystemUrisResponse(struct soap *soap, struct _tds__GetSystemUrisResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->SystemLogUris = NULL;
	soap_default_string(soap, &a->SupportInfoUri);
	soap_default_string(soap, &a->SystemBackupUri);
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetSystemUrisResponse(struct soap *soap, const struct _tds__GetSystemUrisResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTott__SystemLogUriList(soap, &a->SystemLogUris);
	soap_serialize_string(soap, &a->SupportInfoUri);
	soap_serialize_string(soap, &a->SystemBackupUri);
	soap_serialize_PointerTo_tds__GetSystemUrisResponse_Extension(soap, &a->Extension);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetSystemUrisResponse(struct soap *soap, const char *tag, int id, const struct _tds__GetSystemUrisResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetSystemUrisResponse), type))
		return soap->error;
	if (a->SystemLogUris)
		soap_element_result(soap, "tds:SystemLogUris");
	if (soap_out_PointerTott__SystemLogUriList(soap, "tds:SystemLogUris", -1, &a->SystemLogUris, ""))
		return soap->error;
	if (soap_out_string(soap, "tds:SupportInfoUri", -1, &a->SupportInfoUri, ""))
		return soap->error;
	if (soap_out_string(soap, "tds:SystemBackupUri", -1, &a->SystemBackupUri, ""))
		return soap->error;
	if (soap_out_PointerTo_tds__GetSystemUrisResponse_Extension(soap, "tds:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetSystemUrisResponse * SOAP_FMAC4 soap_in__tds__GetSystemUrisResponse(struct soap *soap, const char *tag, struct _tds__GetSystemUrisResponse *a, const char *type)
{
	size_t soap_flag_SystemLogUris = 1;
	size_t soap_flag_SupportInfoUri = 1;
	size_t soap_flag_SystemBackupUri = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__GetSystemUrisResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetSystemUrisResponse, sizeof(struct _tds__GetSystemUrisResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetSystemUrisResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SystemLogUris && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__SystemLogUriList(soap, "tds:SystemLogUris", &a->SystemLogUris, "tt:SystemLogUriList"))
				{	soap_flag_SystemLogUris--;
					continue;
				}
			if (soap_flag_SupportInfoUri && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "tds:SupportInfoUri", &a->SupportInfoUri, "xsd:string"))
				{	soap_flag_SupportInfoUri--;
					continue;
				}
			if (soap_flag_SystemBackupUri && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "tds:SystemBackupUri", &a->SystemBackupUri, "xsd:string"))
				{	soap_flag_SystemBackupUri--;
					continue;
				}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_tds__GetSystemUrisResponse_Extension(soap, "tds:Extension", &a->Extension, ""))
				{	soap_flag_Extension--;
					continue;
				}
			soap_check_result(soap, "tds:SystemLogUris");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__GetSystemUrisResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetSystemUrisResponse, 0, sizeof(struct _tds__GetSystemUrisResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetSystemUrisResponse(struct soap *soap, const struct _tds__GetSystemUrisResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__GetSystemUrisResponse);
	if (soap_out__tds__GetSystemUrisResponse(soap, tag?tag:"tds:GetSystemUrisResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetSystemUrisResponse * SOAP_FMAC4 soap_get__tds__GetSystemUrisResponse(struct soap *soap, struct _tds__GetSystemUrisResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetSystemUrisResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetSystemUris(struct soap *soap, struct _tds__GetSystemUris *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetSystemUris(struct soap *soap, const struct _tds__GetSystemUris *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetSystemUris(struct soap *soap, const char *tag, int id, const struct _tds__GetSystemUris *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetSystemUris), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetSystemUris * SOAP_FMAC4 soap_in__tds__GetSystemUris(struct soap *soap, const char *tag, struct _tds__GetSystemUris *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__GetSystemUris *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetSystemUris, sizeof(struct _tds__GetSystemUris), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetSystemUris(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__GetSystemUris *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetSystemUris, 0, sizeof(struct _tds__GetSystemUris), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetSystemUris(struct soap *soap, const struct _tds__GetSystemUris *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__GetSystemUris);
	if (soap_out__tds__GetSystemUris(soap, tag?tag:"tds:GetSystemUris", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetSystemUris * SOAP_FMAC4 soap_get__tds__GetSystemUris(struct soap *soap, struct _tds__GetSystemUris *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetSystemUris(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__Dot11AvailableNetworks(struct soap *soap, struct tt__Dot11AvailableNetworks *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__Dot11SSIDType(soap, &a->SSID);
	soap_default_string(soap, &a->BSSID);
	a->__sizeAuthAndMangementSuite = 0;
	a->AuthAndMangementSuite = NULL;
	a->__sizePairCipher = 0;
	a->PairCipher = NULL;
	a->__sizeGroupCipher = 0;
	a->GroupCipher = NULL;
	a->SignalStrength = NULL;
	a->Extension = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__Dot11AvailableNetworks(struct soap *soap, const struct tt__Dot11AvailableNetworks *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_tt__Dot11SSIDType(soap, &a->SSID);
	soap_serialize_string(soap, &a->BSSID);
	if (a->AuthAndMangementSuite)
	{	int i;
		for (i = 0; i < a->__sizeAuthAndMangementSuite; i++)
		{
			soap_embedded(soap, a->AuthAndMangementSuite + i, SOAP_TYPE_tt__Dot11AuthAndMangementSuite);
		}
	}
	if (a->PairCipher)
	{	int i;
		for (i = 0; i < a->__sizePairCipher; i++)
		{
			soap_embedded(soap, a->PairCipher + i, SOAP_TYPE_tt__Dot11Cipher);
		}
	}
	if (a->GroupCipher)
	{	int i;
		for (i = 0; i < a->__sizeGroupCipher; i++)
		{
			soap_embedded(soap, a->GroupCipher + i, SOAP_TYPE_tt__Dot11Cipher);
		}
	}
	soap_serialize_PointerTott__Dot11SignalStrength(soap, &a->SignalStrength);
	soap_serialize_PointerTott__Dot11AvailableNetworksExtension(soap, &a->Extension);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Dot11AvailableNetworks(struct soap *soap, const char *tag, int id, const struct tt__Dot11AvailableNetworks *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Dot11AvailableNetworks), type))
		return soap->error;
	if (soap_out_tt__Dot11SSIDType(soap, "tt:SSID", -1, &a->SSID, ""))
		return soap->error;
	if (soap_out_string(soap, "tt:BSSID", -1, &a->BSSID, ""))
		return soap->error;
	if (a->AuthAndMangementSuite)
	{	int i;
		for (i = 0; i < a->__sizeAuthAndMangementSuite; i++)
			if (soap_out_tt__Dot11AuthAndMangementSuite(soap, "tt:AuthAndMangementSuite", -1, a->AuthAndMangementSuite + i, ""))
				return soap->error;
	}
	if (a->PairCipher)
	{	int i;
		for (i = 0; i < a->__sizePairCipher; i++)
			if (soap_out_tt__Dot11Cipher(soap, "tt:PairCipher", -1, a->PairCipher + i, ""))
				return soap->error;
	}
	if (a->GroupCipher)
	{	int i;
		for (i = 0; i < a->__sizeGroupCipher; i++)
			if (soap_out_tt__Dot11Cipher(soap, "tt:GroupCipher", -1, a->GroupCipher + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTott__Dot11SignalStrength(soap, "tt:SignalStrength", -1, &a->SignalStrength, ""))
		return soap->error;
	if (soap_out_PointerTott__Dot11AvailableNetworksExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__Dot11AvailableNetworks * SOAP_FMAC4 soap_in_tt__Dot11AvailableNetworks(struct soap *soap, const char *tag, struct tt__Dot11AvailableNetworks *a, const char *type)
{
	size_t soap_flag_SSID = 1;
	size_t soap_flag_BSSID = 1;
	struct soap_blist *soap_blist_AuthAndMangementSuite = NULL;
	struct soap_blist *soap_blist_PairCipher = NULL;
	struct soap_blist *soap_blist_GroupCipher = NULL;
	size_t soap_flag_SignalStrength = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__Dot11AvailableNetworks *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Dot11AvailableNetworks, sizeof(struct tt__Dot11AvailableNetworks), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__Dot11AvailableNetworks(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SSID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_tt__Dot11SSIDType(soap, "tt:SSID", &a->SSID, "tt:Dot11SSIDType"))
				{	soap_flag_SSID--;
					continue;
				}
			if (soap_flag_BSSID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "tt:BSSID", &a->BSSID, "xsd:string"))
				{	soap_flag_BSSID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:AuthAndMangementSuite", 1, NULL))
			{	if (a->AuthAndMangementSuite == NULL)
				{	if (soap_blist_AuthAndMangementSuite == NULL)
						soap_blist_AuthAndMangementSuite = soap_new_block(soap);
					a->AuthAndMangementSuite = (enum tt__Dot11AuthAndMangementSuite *)soap_push_block(soap, soap_blist_AuthAndMangementSuite, sizeof(enum tt__Dot11AuthAndMangementSuite));
					if (a->AuthAndMangementSuite == NULL)
						return NULL;
					soap_default_tt__Dot11AuthAndMangementSuite(soap, a->AuthAndMangementSuite);
				}
				soap_revert(soap);
				if (soap_in_tt__Dot11AuthAndMangementSuite(soap, "tt:AuthAndMangementSuite", a->AuthAndMangementSuite, "tt:Dot11AuthAndMangementSuite"))
				{	a->__sizeAuthAndMangementSuite++;
					a->AuthAndMangementSuite = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:PairCipher", 1, NULL))
			{	if (a->PairCipher == NULL)
				{	if (soap_blist_PairCipher == NULL)
						soap_blist_PairCipher = soap_new_block(soap);
					a->PairCipher = (enum tt__Dot11Cipher *)soap_push_block(soap, soap_blist_PairCipher, sizeof(enum tt__Dot11Cipher));
					if (a->PairCipher == NULL)
						return NULL;
					soap_default_tt__Dot11Cipher(soap, a->PairCipher);
				}
				soap_revert(soap);
				if (soap_in_tt__Dot11Cipher(soap, "tt:PairCipher", a->PairCipher, "tt:Dot11Cipher"))
				{	a->__sizePairCipher++;
					a->PairCipher = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:GroupCipher", 1, NULL))
			{	if (a->GroupCipher == NULL)
				{	if (soap_blist_GroupCipher == NULL)
						soap_blist_GroupCipher = soap_new_block(soap);
					a->GroupCipher = (enum tt__Dot11Cipher *)soap_push_block(soap, soap_blist_GroupCipher, sizeof(enum tt__Dot11Cipher));
					if (a->GroupCipher == NULL)
						return NULL;
					soap_default_tt__Dot11Cipher(soap, a->GroupCipher);
				}
				soap_revert(soap);
				if (soap_in_tt__Dot11Cipher(soap, "tt:GroupCipher", a->GroupCipher, "tt:Dot11Cipher"))
				{	a->__sizeGroupCipher++;
					a->GroupCipher = NULL;
					continue;
				}
			}
			if (soap_flag_SignalStrength && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__Dot11SignalStrength(soap, "tt:SignalStrength", &a->SignalStrength, "tt:Dot11SignalStrength"))
				{	soap_flag_SignalStrength--;
					continue;
				}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__Dot11AvailableNetworksExtension(soap, "tt:Extension", &a->Extension, "tt:Dot11AvailableNetworksExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->AuthAndMangementSuite)
			soap_pop_block(soap, soap_blist_AuthAndMangementSuite);
		if (a->__sizeAuthAndMangementSuite)
			a->AuthAndMangementSuite = (enum tt__Dot11AuthAndMangementSuite *)soap_save_block(soap, soap_blist_AuthAndMangementSuite, NULL, 1);
		else
		{	a->AuthAndMangementSuite = NULL;
			if (soap_blist_AuthAndMangementSuite)
				soap_end_block(soap, soap_blist_AuthAndMangementSuite);
		}
		if (a->PairCipher)
			soap_pop_block(soap, soap_blist_PairCipher);
		if (a->__sizePairCipher)
			a->PairCipher = (enum tt__Dot11Cipher *)soap_save_block(soap, soap_blist_PairCipher, NULL, 1);
		else
		{	a->PairCipher = NULL;
			if (soap_blist_PairCipher)
				soap_end_block(soap, soap_blist_PairCipher);
		}
		if (a->GroupCipher)
			soap_pop_block(soap, soap_blist_GroupCipher);
		if (a->__sizeGroupCipher)
			a->GroupCipher = (enum tt__Dot11Cipher *)soap_save_block(soap, soap_blist_GroupCipher, NULL, 1);
		else
		{	a->GroupCipher = NULL;
			if (soap_blist_GroupCipher)
				soap_end_block(soap, soap_blist_GroupCipher);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__Dot11AvailableNetworks *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Dot11AvailableNetworks, 0, sizeof(struct tt__Dot11AvailableNetworks), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_SSID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Dot11AvailableNetworks(struct soap *soap, const struct tt__Dot11AvailableNetworks *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__Dot11AvailableNetworks);
	if (soap_out_tt__Dot11AvailableNetworks(soap, tag?tag:"tt:Dot11AvailableNetworks", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Dot11AvailableNetworks * SOAP_FMAC4 soap_get_tt__Dot11AvailableNetworks(struct soap *soap, struct tt__Dot11AvailableNetworks *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Dot11AvailableNetworks(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__ScanAvailableDot11NetworksResponse(struct soap *soap, struct _tds__ScanAvailableDot11NetworksResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeNetworks = 0;
	a->Networks = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__ScanAvailableDot11NetworksResponse(struct soap *soap, const struct _tds__ScanAvailableDot11NetworksResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->Networks)
	{	int i;
		for (i = 0; i < a->__sizeNetworks; i++)
		{
			soap_embedded(soap, a->Networks + i, SOAP_TYPE_tt__Dot11AvailableNetworks);
			soap_serialize_tt__Dot11AvailableNetworks(soap, a->Networks + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__ScanAvailableDot11NetworksResponse(struct soap *soap, const char *tag, int id, const struct _tds__ScanAvailableDot11NetworksResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__ScanAvailableDot11NetworksResponse), type))
		return soap->error;
	soap_element_result(soap, "-sizeNetworks");
	if (a->Networks)
	{	int i;
		for (i = 0; i < a->__sizeNetworks; i++)
			if (soap_out_tt__Dot11AvailableNetworks(soap, "tds:Networks", -1, a->Networks + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__ScanAvailableDot11NetworksResponse * SOAP_FMAC4 soap_in__tds__ScanAvailableDot11NetworksResponse(struct soap *soap, const char *tag, struct _tds__ScanAvailableDot11NetworksResponse *a, const char *type)
{
	struct soap_blist *soap_blist_Networks = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__ScanAvailableDot11NetworksResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__ScanAvailableDot11NetworksResponse, sizeof(struct _tds__ScanAvailableDot11NetworksResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__ScanAvailableDot11NetworksResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tds:Networks", 1, NULL))
			{	if (a->Networks == NULL)
				{	if (soap_blist_Networks == NULL)
						soap_blist_Networks = soap_new_block(soap);
					a->Networks = (struct tt__Dot11AvailableNetworks *)soap_push_block(soap, soap_blist_Networks, sizeof(struct tt__Dot11AvailableNetworks));
					if (a->Networks == NULL)
						return NULL;
					soap_default_tt__Dot11AvailableNetworks(soap, a->Networks);
				}
				soap_revert(soap);
				if (soap_in_tt__Dot11AvailableNetworks(soap, "tds:Networks", a->Networks, "tt:Dot11AvailableNetworks"))
				{	a->__sizeNetworks++;
					a->Networks = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizeNetworks");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Networks)
			soap_pop_block(soap, soap_blist_Networks);
		if (a->__sizeNetworks)
			a->Networks = (struct tt__Dot11AvailableNetworks *)soap_save_block(soap, soap_blist_Networks, NULL, 1);
		else
		{	a->Networks = NULL;
			if (soap_blist_Networks)
				soap_end_block(soap, soap_blist_Networks);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__ScanAvailableDot11NetworksResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__ScanAvailableDot11NetworksResponse, 0, sizeof(struct _tds__ScanAvailableDot11NetworksResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__ScanAvailableDot11NetworksResponse(struct soap *soap, const struct _tds__ScanAvailableDot11NetworksResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__ScanAvailableDot11NetworksResponse);
	if (soap_out__tds__ScanAvailableDot11NetworksResponse(soap, tag?tag:"tds:ScanAvailableDot11NetworksResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__ScanAvailableDot11NetworksResponse * SOAP_FMAC4 soap_get__tds__ScanAvailableDot11NetworksResponse(struct soap *soap, struct _tds__ScanAvailableDot11NetworksResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__ScanAvailableDot11NetworksResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__ScanAvailableDot11Networks(struct soap *soap, struct _tds__ScanAvailableDot11Networks *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->InterfaceToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__ScanAvailableDot11Networks(struct soap *soap, const struct _tds__ScanAvailableDot11Networks *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_tt__ReferenceToken(soap, &a->InterfaceToken);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__ScanAvailableDot11Networks(struct soap *soap, const char *tag, int id, const struct _tds__ScanAvailableDot11Networks *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__ScanAvailableDot11Networks), type))
		return soap->error;
	if (a->InterfaceToken)
	{	if (soap_out_tt__ReferenceToken(soap, "tds:InterfaceToken", -1, &a->InterfaceToken, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tds:InterfaceToken"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__ScanAvailableDot11Networks * SOAP_FMAC4 soap_in__tds__ScanAvailableDot11Networks(struct soap *soap, const char *tag, struct _tds__ScanAvailableDot11Networks *a, const char *type)
{
	size_t soap_flag_InterfaceToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__ScanAvailableDot11Networks *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__ScanAvailableDot11Networks, sizeof(struct _tds__ScanAvailableDot11Networks), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__ScanAvailableDot11Networks(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_InterfaceToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "tds:InterfaceToken", &a->InterfaceToken, "tt:ReferenceToken"))
				{	soap_flag_InterfaceToken--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__ScanAvailableDot11Networks *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__ScanAvailableDot11Networks, 0, sizeof(struct _tds__ScanAvailableDot11Networks), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_InterfaceToken > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__ScanAvailableDot11Networks(struct soap *soap, const struct _tds__ScanAvailableDot11Networks *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__ScanAvailableDot11Networks);
	if (soap_out__tds__ScanAvailableDot11Networks(soap, tag?tag:"tds:ScanAvailableDot11Networks", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__ScanAvailableDot11Networks * SOAP_FMAC4 soap_get__tds__ScanAvailableDot11Networks(struct soap *soap, struct _tds__ScanAvailableDot11Networks *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__ScanAvailableDot11Networks(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__Dot11Status(struct soap *soap, struct tt__Dot11Status *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__Dot11SSIDType(soap, &a->SSID);
	soap_default_string(soap, &a->BSSID);
	a->PairCipher = NULL;
	a->GroupCipher = NULL;
	a->SignalStrength = NULL;
	soap_default_tt__ReferenceToken(soap, &a->ActiveConfigAlias);
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__Dot11Status(struct soap *soap, const struct tt__Dot11Status *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_tt__Dot11SSIDType(soap, &a->SSID);
	soap_serialize_string(soap, &a->BSSID);
	soap_serialize_PointerTott__Dot11Cipher(soap, &a->PairCipher);
	soap_serialize_PointerTott__Dot11Cipher(soap, &a->GroupCipher);
	soap_serialize_PointerTott__Dot11SignalStrength(soap, &a->SignalStrength);
	soap_serialize_tt__ReferenceToken(soap, &a->ActiveConfigAlias);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Dot11Status(struct soap *soap, const char *tag, int id, const struct tt__Dot11Status *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Dot11Status), type))
		return soap->error;
	if (soap_out_tt__Dot11SSIDType(soap, "tt:SSID", -1, &a->SSID, ""))
		return soap->error;
	if (soap_out_string(soap, "tt:BSSID", -1, &a->BSSID, ""))
		return soap->error;
	if (soap_out_PointerTott__Dot11Cipher(soap, "tt:PairCipher", -1, &a->PairCipher, ""))
		return soap->error;
	if (soap_out_PointerTott__Dot11Cipher(soap, "tt:GroupCipher", -1, &a->GroupCipher, ""))
		return soap->error;
	if (soap_out_PointerTott__Dot11SignalStrength(soap, "tt:SignalStrength", -1, &a->SignalStrength, ""))
		return soap->error;
	if (a->ActiveConfigAlias)
	{	if (soap_out_tt__ReferenceToken(soap, "tt:ActiveConfigAlias", -1, &a->ActiveConfigAlias, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:ActiveConfigAlias"))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__Dot11Status * SOAP_FMAC4 soap_in_tt__Dot11Status(struct soap *soap, const char *tag, struct tt__Dot11Status *a, const char *type)
{
	size_t soap_flag_SSID = 1;
	size_t soap_flag_BSSID = 1;
	size_t soap_flag_PairCipher = 1;
	size_t soap_flag_GroupCipher = 1;
	size_t soap_flag_SignalStrength = 1;
	size_t soap_flag_ActiveConfigAlias = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__Dot11Status *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Dot11Status, sizeof(struct tt__Dot11Status), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__Dot11Status(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SSID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_tt__Dot11SSIDType(soap, "tt:SSID", &a->SSID, "tt:Dot11SSIDType"))
				{	soap_flag_SSID--;
					continue;
				}
			if (soap_flag_BSSID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "tt:BSSID", &a->BSSID, "xsd:string"))
				{	soap_flag_BSSID--;
					continue;
				}
			if (soap_flag_PairCipher && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__Dot11Cipher(soap, "tt:PairCipher", &a->PairCipher, "tt:Dot11Cipher"))
				{	soap_flag_PairCipher--;
					continue;
				}
			if (soap_flag_GroupCipher && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__Dot11Cipher(soap, "tt:GroupCipher", &a->GroupCipher, "tt:Dot11Cipher"))
				{	soap_flag_GroupCipher--;
					continue;
				}
			if (soap_flag_SignalStrength && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__Dot11SignalStrength(soap, "tt:SignalStrength", &a->SignalStrength, "tt:Dot11SignalStrength"))
				{	soap_flag_SignalStrength--;
					continue;
				}
			if (soap_flag_ActiveConfigAlias && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "tt:ActiveConfigAlias", &a->ActiveConfigAlias, "tt:ReferenceToken"))
				{	soap_flag_ActiveConfigAlias--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__Dot11Status *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Dot11Status, 0, sizeof(struct tt__Dot11Status), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_SSID > 0 || soap_flag_ActiveConfigAlias > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Dot11Status(struct soap *soap, const struct tt__Dot11Status *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__Dot11Status);
	if (soap_out_tt__Dot11Status(soap, tag?tag:"tt:Dot11Status", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Dot11Status * SOAP_FMAC4 soap_get_tt__Dot11Status(struct soap *soap, struct tt__Dot11Status *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Dot11Status(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetDot11StatusResponse(struct soap *soap, struct _tds__GetDot11StatusResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Status = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetDot11StatusResponse(struct soap *soap, const struct _tds__GetDot11StatusResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTott__Dot11Status(soap, &a->Status);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetDot11StatusResponse(struct soap *soap, const char *tag, int id, const struct _tds__GetDot11StatusResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetDot11StatusResponse), type))
		return soap->error;
	if (a->Status)
		soap_element_result(soap, "tds:Status");
	if (a->Status)
	{	if (soap_out_PointerTott__Dot11Status(soap, "tds:Status", -1, &a->Status, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tds:Status"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetDot11StatusResponse * SOAP_FMAC4 soap_in__tds__GetDot11StatusResponse(struct soap *soap, const char *tag, struct _tds__GetDot11StatusResponse *a, const char *type)
{
	size_t soap_flag_Status = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__GetDot11StatusResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetDot11StatusResponse, sizeof(struct _tds__GetDot11StatusResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetDot11StatusResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Status && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__Dot11Status(soap, "tds:Status", &a->Status, "tt:Dot11Status"))
				{	soap_flag_Status--;
					continue;
				}
			soap_check_result(soap, "tds:Status");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__GetDot11StatusResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetDot11StatusResponse, 0, sizeof(struct _tds__GetDot11StatusResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Status > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetDot11StatusResponse(struct soap *soap, const struct _tds__GetDot11StatusResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__GetDot11StatusResponse);
	if (soap_out__tds__GetDot11StatusResponse(soap, tag?tag:"tds:GetDot11StatusResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetDot11StatusResponse * SOAP_FMAC4 soap_get__tds__GetDot11StatusResponse(struct soap *soap, struct _tds__GetDot11StatusResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetDot11StatusResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetDot11Status(struct soap *soap, struct _tds__GetDot11Status *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->InterfaceToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetDot11Status(struct soap *soap, const struct _tds__GetDot11Status *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_tt__ReferenceToken(soap, &a->InterfaceToken);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetDot11Status(struct soap *soap, const char *tag, int id, const struct _tds__GetDot11Status *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetDot11Status), type))
		return soap->error;
	if (a->InterfaceToken)
	{	if (soap_out_tt__ReferenceToken(soap, "tds:InterfaceToken", -1, &a->InterfaceToken, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tds:InterfaceToken"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetDot11Status * SOAP_FMAC4 soap_in__tds__GetDot11Status(struct soap *soap, const char *tag, struct _tds__GetDot11Status *a, const char *type)
{
	size_t soap_flag_InterfaceToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__GetDot11Status *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetDot11Status, sizeof(struct _tds__GetDot11Status), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetDot11Status(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_InterfaceToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "tds:InterfaceToken", &a->InterfaceToken, "tt:ReferenceToken"))
				{	soap_flag_InterfaceToken--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__GetDot11Status *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetDot11Status, 0, sizeof(struct _tds__GetDot11Status), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_InterfaceToken > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetDot11Status(struct soap *soap, const struct _tds__GetDot11Status *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__GetDot11Status);
	if (soap_out__tds__GetDot11Status(soap, tag?tag:"tds:GetDot11Status", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetDot11Status * SOAP_FMAC4 soap_get__tds__GetDot11Status(struct soap *soap, struct _tds__GetDot11Status *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetDot11Status(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__Dot11Capabilities(struct soap *soap, struct tt__Dot11Capabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__boolean_(soap, &a->TKIP);
	soap_default_xsd__boolean_(soap, &a->ScanAvailableNetworks);
	soap_default_xsd__boolean_(soap, &a->MultipleConfiguration);
	soap_default_xsd__boolean_(soap, &a->AdHocStationMode);
	soap_default_xsd__boolean_(soap, &a->WEP);
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__Dot11Capabilities(struct soap *soap, const struct tt__Dot11Capabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->TKIP, SOAP_TYPE_xsd__boolean_);
	soap_embedded(soap, &a->ScanAvailableNetworks, SOAP_TYPE_xsd__boolean_);
	soap_embedded(soap, &a->MultipleConfiguration, SOAP_TYPE_xsd__boolean_);
	soap_embedded(soap, &a->AdHocStationMode, SOAP_TYPE_xsd__boolean_);
	soap_embedded(soap, &a->WEP, SOAP_TYPE_xsd__boolean_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Dot11Capabilities(struct soap *soap, const char *tag, int id, const struct tt__Dot11Capabilities *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Dot11Capabilities), type))
		return soap->error;
	if (soap_out_xsd__boolean_(soap, "tt:TKIP", -1, &a->TKIP, ""))
		return soap->error;
	if (soap_out_xsd__boolean_(soap, "tt:ScanAvailableNetworks", -1, &a->ScanAvailableNetworks, ""))
		return soap->error;
	if (soap_out_xsd__boolean_(soap, "tt:MultipleConfiguration", -1, &a->MultipleConfiguration, ""))
		return soap->error;
	if (soap_out_xsd__boolean_(soap, "tt:AdHocStationMode", -1, &a->AdHocStationMode, ""))
		return soap->error;
	if (soap_out_xsd__boolean_(soap, "tt:WEP", -1, &a->WEP, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__Dot11Capabilities * SOAP_FMAC4 soap_in_tt__Dot11Capabilities(struct soap *soap, const char *tag, struct tt__Dot11Capabilities *a, const char *type)
{
	size_t soap_flag_TKIP = 1;
	size_t soap_flag_ScanAvailableNetworks = 1;
	size_t soap_flag_MultipleConfiguration = 1;
	size_t soap_flag_AdHocStationMode = 1;
	size_t soap_flag_WEP = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__Dot11Capabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Dot11Capabilities, sizeof(struct tt__Dot11Capabilities), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__Dot11Capabilities(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_TKIP && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean_(soap, "tt:TKIP", &a->TKIP, "xsd:boolean"))
				{	soap_flag_TKIP--;
					continue;
				}
			if (soap_flag_ScanAvailableNetworks && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean_(soap, "tt:ScanAvailableNetworks", &a->ScanAvailableNetworks, "xsd:boolean"))
				{	soap_flag_ScanAvailableNetworks--;
					continue;
				}
			if (soap_flag_MultipleConfiguration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean_(soap, "tt:MultipleConfiguration", &a->MultipleConfiguration, "xsd:boolean"))
				{	soap_flag_MultipleConfiguration--;
					continue;
				}
			if (soap_flag_AdHocStationMode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean_(soap, "tt:AdHocStationMode", &a->AdHocStationMode, "xsd:boolean"))
				{	soap_flag_AdHocStationMode--;
					continue;
				}
			if (soap_flag_WEP && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean_(soap, "tt:WEP", &a->WEP, "xsd:boolean"))
				{	soap_flag_WEP--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__Dot11Capabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Dot11Capabilities, 0, sizeof(struct tt__Dot11Capabilities), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_TKIP > 0 || soap_flag_ScanAvailableNetworks > 0 || soap_flag_MultipleConfiguration > 0 || soap_flag_AdHocStationMode > 0 || soap_flag_WEP > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Dot11Capabilities(struct soap *soap, const struct tt__Dot11Capabilities *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__Dot11Capabilities);
	if (soap_out_tt__Dot11Capabilities(soap, tag?tag:"tt:Dot11Capabilities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Dot11Capabilities * SOAP_FMAC4 soap_get_tt__Dot11Capabilities(struct soap *soap, struct tt__Dot11Capabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Dot11Capabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetDot11CapabilitiesResponse(struct soap *soap, struct _tds__GetDot11CapabilitiesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Capabilities = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetDot11CapabilitiesResponse(struct soap *soap, const struct _tds__GetDot11CapabilitiesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTott__Dot11Capabilities(soap, &a->Capabilities);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetDot11CapabilitiesResponse(struct soap *soap, const char *tag, int id, const struct _tds__GetDot11CapabilitiesResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetDot11CapabilitiesResponse), type))
		return soap->error;
	if (a->Capabilities)
		soap_element_result(soap, "tds:Capabilities");
	if (a->Capabilities)
	{	if (soap_out_PointerTott__Dot11Capabilities(soap, "tds:Capabilities", -1, &a->Capabilities, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tds:Capabilities"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetDot11CapabilitiesResponse * SOAP_FMAC4 soap_in__tds__GetDot11CapabilitiesResponse(struct soap *soap, const char *tag, struct _tds__GetDot11CapabilitiesResponse *a, const char *type)
{
	size_t soap_flag_Capabilities = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__GetDot11CapabilitiesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetDot11CapabilitiesResponse, sizeof(struct _tds__GetDot11CapabilitiesResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetDot11CapabilitiesResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Capabilities && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__Dot11Capabilities(soap, "tds:Capabilities", &a->Capabilities, "tt:Dot11Capabilities"))
				{	soap_flag_Capabilities--;
					continue;
				}
			soap_check_result(soap, "tds:Capabilities");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__GetDot11CapabilitiesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetDot11CapabilitiesResponse, 0, sizeof(struct _tds__GetDot11CapabilitiesResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Capabilities > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetDot11CapabilitiesResponse(struct soap *soap, const struct _tds__GetDot11CapabilitiesResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__GetDot11CapabilitiesResponse);
	if (soap_out__tds__GetDot11CapabilitiesResponse(soap, tag?tag:"tds:GetDot11CapabilitiesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetDot11CapabilitiesResponse * SOAP_FMAC4 soap_get__tds__GetDot11CapabilitiesResponse(struct soap *soap, struct _tds__GetDot11CapabilitiesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetDot11CapabilitiesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetDot11Capabilities(struct soap *soap, struct _tds__GetDot11Capabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetDot11Capabilities(struct soap *soap, const struct _tds__GetDot11Capabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetDot11Capabilities(struct soap *soap, const char *tag, int id, const struct _tds__GetDot11Capabilities *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetDot11Capabilities), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetDot11Capabilities * SOAP_FMAC4 soap_in__tds__GetDot11Capabilities(struct soap *soap, const char *tag, struct _tds__GetDot11Capabilities *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__GetDot11Capabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetDot11Capabilities, sizeof(struct _tds__GetDot11Capabilities), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetDot11Capabilities(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__GetDot11Capabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetDot11Capabilities, 0, sizeof(struct _tds__GetDot11Capabilities), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetDot11Capabilities(struct soap *soap, const struct _tds__GetDot11Capabilities *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__GetDot11Capabilities);
	if (soap_out__tds__GetDot11Capabilities(soap, tag?tag:"tds:GetDot11Capabilities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetDot11Capabilities * SOAP_FMAC4 soap_get__tds__GetDot11Capabilities(struct soap *soap, struct _tds__GetDot11Capabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetDot11Capabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__SendAuxiliaryCommandResponse(struct soap *soap, struct _tds__SendAuxiliaryCommandResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__AuxiliaryData(soap, &a->AuxiliaryCommandResponse);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__SendAuxiliaryCommandResponse(struct soap *soap, const struct _tds__SendAuxiliaryCommandResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_tt__AuxiliaryData(soap, &a->AuxiliaryCommandResponse);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SendAuxiliaryCommandResponse(struct soap *soap, const char *tag, int id, const struct _tds__SendAuxiliaryCommandResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SendAuxiliaryCommandResponse), type))
		return soap->error;
	if (a->AuxiliaryCommandResponse)
		soap_element_result(soap, "tds:AuxiliaryCommandResponse");
	if (soap_out_tt__AuxiliaryData(soap, "tds:AuxiliaryCommandResponse", -1, &a->AuxiliaryCommandResponse, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__SendAuxiliaryCommandResponse * SOAP_FMAC4 soap_in__tds__SendAuxiliaryCommandResponse(struct soap *soap, const char *tag, struct _tds__SendAuxiliaryCommandResponse *a, const char *type)
{
	size_t soap_flag_AuxiliaryCommandResponse = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__SendAuxiliaryCommandResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SendAuxiliaryCommandResponse, sizeof(struct _tds__SendAuxiliaryCommandResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__SendAuxiliaryCommandResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_AuxiliaryCommandResponse && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__AuxiliaryData(soap, "tds:AuxiliaryCommandResponse", &a->AuxiliaryCommandResponse, "tt:AuxiliaryData"))
				{	soap_flag_AuxiliaryCommandResponse--;
					continue;
				}
			soap_check_result(soap, "tds:AuxiliaryCommandResponse");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__SendAuxiliaryCommandResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SendAuxiliaryCommandResponse, 0, sizeof(struct _tds__SendAuxiliaryCommandResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__SendAuxiliaryCommandResponse(struct soap *soap, const struct _tds__SendAuxiliaryCommandResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__SendAuxiliaryCommandResponse);
	if (soap_out__tds__SendAuxiliaryCommandResponse(soap, tag?tag:"tds:SendAuxiliaryCommandResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SendAuxiliaryCommandResponse * SOAP_FMAC4 soap_get__tds__SendAuxiliaryCommandResponse(struct soap *soap, struct _tds__SendAuxiliaryCommandResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SendAuxiliaryCommandResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__SendAuxiliaryCommand(struct soap *soap, struct _tds__SendAuxiliaryCommand *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__AuxiliaryData(soap, &a->AuxiliaryCommand);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__SendAuxiliaryCommand(struct soap *soap, const struct _tds__SendAuxiliaryCommand *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_tt__AuxiliaryData(soap, &a->AuxiliaryCommand);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SendAuxiliaryCommand(struct soap *soap, const char *tag, int id, const struct _tds__SendAuxiliaryCommand *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SendAuxiliaryCommand), type))
		return soap->error;
	if (a->AuxiliaryCommand)
	{	if (soap_out_tt__AuxiliaryData(soap, "tds:AuxiliaryCommand", -1, &a->AuxiliaryCommand, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tds:AuxiliaryCommand"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__SendAuxiliaryCommand * SOAP_FMAC4 soap_in__tds__SendAuxiliaryCommand(struct soap *soap, const char *tag, struct _tds__SendAuxiliaryCommand *a, const char *type)
{
	size_t soap_flag_AuxiliaryCommand = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__SendAuxiliaryCommand *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SendAuxiliaryCommand, sizeof(struct _tds__SendAuxiliaryCommand), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__SendAuxiliaryCommand(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_AuxiliaryCommand && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__AuxiliaryData(soap, "tds:AuxiliaryCommand", &a->AuxiliaryCommand, "tt:AuxiliaryData"))
				{	soap_flag_AuxiliaryCommand--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__SendAuxiliaryCommand *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SendAuxiliaryCommand, 0, sizeof(struct _tds__SendAuxiliaryCommand), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_AuxiliaryCommand > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__SendAuxiliaryCommand(struct soap *soap, const struct _tds__SendAuxiliaryCommand *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__SendAuxiliaryCommand);
	if (soap_out__tds__SendAuxiliaryCommand(soap, tag?tag:"tds:SendAuxiliaryCommand", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SendAuxiliaryCommand * SOAP_FMAC4 soap_get__tds__SendAuxiliaryCommand(struct soap *soap, struct _tds__SendAuxiliaryCommand *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SendAuxiliaryCommand(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__SetRelayOutputStateResponse(struct soap *soap, struct _tds__SetRelayOutputStateResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__SetRelayOutputStateResponse(struct soap *soap, const struct _tds__SetRelayOutputStateResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetRelayOutputStateResponse(struct soap *soap, const char *tag, int id, const struct _tds__SetRelayOutputStateResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetRelayOutputStateResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__SetRelayOutputStateResponse * SOAP_FMAC4 soap_in__tds__SetRelayOutputStateResponse(struct soap *soap, const char *tag, struct _tds__SetRelayOutputStateResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__SetRelayOutputStateResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetRelayOutputStateResponse, sizeof(struct _tds__SetRelayOutputStateResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__SetRelayOutputStateResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__SetRelayOutputStateResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetRelayOutputStateResponse, 0, sizeof(struct _tds__SetRelayOutputStateResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__SetRelayOutputStateResponse(struct soap *soap, const struct _tds__SetRelayOutputStateResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__SetRelayOutputStateResponse);
	if (soap_out__tds__SetRelayOutputStateResponse(soap, tag?tag:"tds:SetRelayOutputStateResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetRelayOutputStateResponse * SOAP_FMAC4 soap_get__tds__SetRelayOutputStateResponse(struct soap *soap, struct _tds__SetRelayOutputStateResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetRelayOutputStateResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__SetRelayOutputState(struct soap *soap, struct _tds__SetRelayOutputState *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->RelayOutputToken);
	soap_default_tt__RelayLogicalState(soap, &a->LogicalState);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__SetRelayOutputState(struct soap *soap, const struct _tds__SetRelayOutputState *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_tt__ReferenceToken(soap, &a->RelayOutputToken);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetRelayOutputState(struct soap *soap, const char *tag, int id, const struct _tds__SetRelayOutputState *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetRelayOutputState), type))
		return soap->error;
	if (a->RelayOutputToken)
	{	if (soap_out_tt__ReferenceToken(soap, "tds:RelayOutputToken", -1, &a->RelayOutputToken, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tds:RelayOutputToken"))
		return soap->error;
	if (soap_out_tt__RelayLogicalState(soap, "tds:LogicalState", -1, &a->LogicalState, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__SetRelayOutputState * SOAP_FMAC4 soap_in__tds__SetRelayOutputState(struct soap *soap, const char *tag, struct _tds__SetRelayOutputState *a, const char *type)
{
	size_t soap_flag_RelayOutputToken = 1;
	size_t soap_flag_LogicalState = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__SetRelayOutputState *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetRelayOutputState, sizeof(struct _tds__SetRelayOutputState), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__SetRelayOutputState(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RelayOutputToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "tds:RelayOutputToken", &a->RelayOutputToken, "tt:ReferenceToken"))
				{	soap_flag_RelayOutputToken--;
					continue;
				}
			if (soap_flag_LogicalState && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_tt__RelayLogicalState(soap, "tds:LogicalState", &a->LogicalState, "tt:RelayLogicalState"))
				{	soap_flag_LogicalState--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__SetRelayOutputState *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetRelayOutputState, 0, sizeof(struct _tds__SetRelayOutputState), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_RelayOutputToken > 0 || soap_flag_LogicalState > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__SetRelayOutputState(struct soap *soap, const struct _tds__SetRelayOutputState *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__SetRelayOutputState);
	if (soap_out__tds__SetRelayOutputState(soap, tag?tag:"tds:SetRelayOutputState", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetRelayOutputState * SOAP_FMAC4 soap_get__tds__SetRelayOutputState(struct soap *soap, struct _tds__SetRelayOutputState *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetRelayOutputState(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__SetRelayOutputSettingsResponse(struct soap *soap, struct _tds__SetRelayOutputSettingsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__SetRelayOutputSettingsResponse(struct soap *soap, const struct _tds__SetRelayOutputSettingsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetRelayOutputSettingsResponse(struct soap *soap, const char *tag, int id, const struct _tds__SetRelayOutputSettingsResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetRelayOutputSettingsResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__SetRelayOutputSettingsResponse * SOAP_FMAC4 soap_in__tds__SetRelayOutputSettingsResponse(struct soap *soap, const char *tag, struct _tds__SetRelayOutputSettingsResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__SetRelayOutputSettingsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetRelayOutputSettingsResponse, sizeof(struct _tds__SetRelayOutputSettingsResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__SetRelayOutputSettingsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__SetRelayOutputSettingsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetRelayOutputSettingsResponse, 0, sizeof(struct _tds__SetRelayOutputSettingsResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__SetRelayOutputSettingsResponse(struct soap *soap, const struct _tds__SetRelayOutputSettingsResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__SetRelayOutputSettingsResponse);
	if (soap_out__tds__SetRelayOutputSettingsResponse(soap, tag?tag:"tds:SetRelayOutputSettingsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetRelayOutputSettingsResponse * SOAP_FMAC4 soap_get__tds__SetRelayOutputSettingsResponse(struct soap *soap, struct _tds__SetRelayOutputSettingsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetRelayOutputSettingsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__RelayOutputSettings(struct soap *soap, struct tt__RelayOutputSettings *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__RelayMode(soap, &a->Mode);
	soap_default_string(soap, &a->DelayTime);
	soap_default_tt__RelayIdleState(soap, &a->IdleState);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__RelayOutputSettings(struct soap *soap, const struct tt__RelayOutputSettings *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->DelayTime);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__RelayOutputSettings(struct soap *soap, const char *tag, int id, const struct tt__RelayOutputSettings *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__RelayOutputSettings), type))
		return soap->error;
	if (soap_out_tt__RelayMode(soap, "tt:Mode", -1, &a->Mode, ""))
		return soap->error;
	if (a->DelayTime)
	{	if (soap_out_string(soap, "tt:DelayTime", -1, &a->DelayTime, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:DelayTime"))
		return soap->error;
	if (soap_out_tt__RelayIdleState(soap, "tt:IdleState", -1, &a->IdleState, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__RelayOutputSettings * SOAP_FMAC4 soap_in_tt__RelayOutputSettings(struct soap *soap, const char *tag, struct tt__RelayOutputSettings *a, const char *type)
{
	size_t soap_flag_Mode = 1;
	size_t soap_flag_DelayTime = 1;
	size_t soap_flag_IdleState = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__RelayOutputSettings *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RelayOutputSettings, sizeof(struct tt__RelayOutputSettings), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__RelayOutputSettings(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Mode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_tt__RelayMode(soap, "tt:Mode", &a->Mode, "tt:RelayMode"))
				{	soap_flag_Mode--;
					continue;
				}
			if (soap_flag_DelayTime && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "tt:DelayTime", &a->DelayTime, "xsd:string"))
				{	soap_flag_DelayTime--;
					continue;
				}
			if (soap_flag_IdleState && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_tt__RelayIdleState(soap, "tt:IdleState", &a->IdleState, "tt:RelayIdleState"))
				{	soap_flag_IdleState--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__RelayOutputSettings *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__RelayOutputSettings, 0, sizeof(struct tt__RelayOutputSettings), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Mode > 0 || soap_flag_DelayTime > 0 || soap_flag_IdleState > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__RelayOutputSettings(struct soap *soap, const struct tt__RelayOutputSettings *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__RelayOutputSettings);
	if (soap_out_tt__RelayOutputSettings(soap, tag?tag:"tt:RelayOutputSettings", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__RelayOutputSettings * SOAP_FMAC4 soap_get_tt__RelayOutputSettings(struct soap *soap, struct tt__RelayOutputSettings *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__RelayOutputSettings(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__SetRelayOutputSettings(struct soap *soap, struct _tds__SetRelayOutputSettings *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->RelayOutputToken);
	a->Properties = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__SetRelayOutputSettings(struct soap *soap, const struct _tds__SetRelayOutputSettings *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_tt__ReferenceToken(soap, &a->RelayOutputToken);
	soap_serialize_PointerTott__RelayOutputSettings(soap, &a->Properties);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetRelayOutputSettings(struct soap *soap, const char *tag, int id, const struct _tds__SetRelayOutputSettings *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetRelayOutputSettings), type))
		return soap->error;
	if (a->RelayOutputToken)
	{	if (soap_out_tt__ReferenceToken(soap, "tds:RelayOutputToken", -1, &a->RelayOutputToken, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tds:RelayOutputToken"))
		return soap->error;
	if (a->Properties)
	{	if (soap_out_PointerTott__RelayOutputSettings(soap, "tds:Properties", -1, &a->Properties, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tds:Properties"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__SetRelayOutputSettings * SOAP_FMAC4 soap_in__tds__SetRelayOutputSettings(struct soap *soap, const char *tag, struct _tds__SetRelayOutputSettings *a, const char *type)
{
	size_t soap_flag_RelayOutputToken = 1;
	size_t soap_flag_Properties = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__SetRelayOutputSettings *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetRelayOutputSettings, sizeof(struct _tds__SetRelayOutputSettings), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__SetRelayOutputSettings(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RelayOutputToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "tds:RelayOutputToken", &a->RelayOutputToken, "tt:ReferenceToken"))
				{	soap_flag_RelayOutputToken--;
					continue;
				}
			if (soap_flag_Properties && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__RelayOutputSettings(soap, "tds:Properties", &a->Properties, "tt:RelayOutputSettings"))
				{	soap_flag_Properties--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__SetRelayOutputSettings *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetRelayOutputSettings, 0, sizeof(struct _tds__SetRelayOutputSettings), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_RelayOutputToken > 0 || soap_flag_Properties > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__SetRelayOutputSettings(struct soap *soap, const struct _tds__SetRelayOutputSettings *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__SetRelayOutputSettings);
	if (soap_out__tds__SetRelayOutputSettings(soap, tag?tag:"tds:SetRelayOutputSettings", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetRelayOutputSettings * SOAP_FMAC4 soap_get__tds__SetRelayOutputSettings(struct soap *soap, struct _tds__SetRelayOutputSettings *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetRelayOutputSettings(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__RelayOutput(struct soap *soap, struct tt__RelayOutput *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->token);
	a->Properties = NULL;
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__RelayOutput(struct soap *soap, const struct tt__RelayOutput *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTott__RelayOutputSettings(soap, &a->Properties);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__RelayOutput(struct soap *soap, const char *tag, int id, const struct tt__RelayOutput *a, const char *type)
{
	if (a->token)
		soap_set_attr(soap, "token", a->token, 1);
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__RelayOutput), type))
		return soap->error;
	if (a->Properties)
	{	if (soap_out_PointerTott__RelayOutputSettings(soap, "tt:Properties", -1, &a->Properties, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:Properties"))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__RelayOutput * SOAP_FMAC4 soap_in_tt__RelayOutput(struct soap *soap, const char *tag, struct tt__RelayOutput *a, const char *type)
{
	size_t soap_flag_Properties = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__RelayOutput *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RelayOutput, sizeof(struct tt__RelayOutput), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__RelayOutput(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "token", 1), &a->token, -1, 64))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Properties && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__RelayOutputSettings(soap, "tt:Properties", &a->Properties, "tt:RelayOutputSettings"))
				{	soap_flag_Properties--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__RelayOutput *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__RelayOutput, 0, sizeof(struct tt__RelayOutput), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Properties > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__RelayOutput(struct soap *soap, const struct tt__RelayOutput *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__RelayOutput);
	if (soap_out_tt__RelayOutput(soap, tag?tag:"tt:RelayOutput", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__RelayOutput * SOAP_FMAC4 soap_get_tt__RelayOutput(struct soap *soap, struct tt__RelayOutput *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__RelayOutput(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetRelayOutputsResponse(struct soap *soap, struct _tds__GetRelayOutputsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeRelayOutputs = 0;
	a->RelayOutputs = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetRelayOutputsResponse(struct soap *soap, const struct _tds__GetRelayOutputsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->RelayOutputs)
	{	int i;
		for (i = 0; i < a->__sizeRelayOutputs; i++)
		{
			soap_embedded(soap, a->RelayOutputs + i, SOAP_TYPE_tt__RelayOutput);
			soap_serialize_tt__RelayOutput(soap, a->RelayOutputs + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetRelayOutputsResponse(struct soap *soap, const char *tag, int id, const struct _tds__GetRelayOutputsResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetRelayOutputsResponse), type))
		return soap->error;
	soap_element_result(soap, "-sizeRelayOutputs");
	if (a->RelayOutputs)
	{	int i;
		for (i = 0; i < a->__sizeRelayOutputs; i++)
			if (soap_out_tt__RelayOutput(soap, "tds:RelayOutputs", -1, a->RelayOutputs + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetRelayOutputsResponse * SOAP_FMAC4 soap_in__tds__GetRelayOutputsResponse(struct soap *soap, const char *tag, struct _tds__GetRelayOutputsResponse *a, const char *type)
{
	struct soap_blist *soap_blist_RelayOutputs = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__GetRelayOutputsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetRelayOutputsResponse, sizeof(struct _tds__GetRelayOutputsResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetRelayOutputsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tds:RelayOutputs", 1, NULL))
			{	if (a->RelayOutputs == NULL)
				{	if (soap_blist_RelayOutputs == NULL)
						soap_blist_RelayOutputs = soap_new_block(soap);
					a->RelayOutputs = (struct tt__RelayOutput *)soap_push_block(soap, soap_blist_RelayOutputs, sizeof(struct tt__RelayOutput));
					if (a->RelayOutputs == NULL)
						return NULL;
					soap_default_tt__RelayOutput(soap, a->RelayOutputs);
				}
				soap_revert(soap);
				if (soap_in_tt__RelayOutput(soap, "tds:RelayOutputs", a->RelayOutputs, "tt:RelayOutput"))
				{	a->__sizeRelayOutputs++;
					a->RelayOutputs = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizeRelayOutputs");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->RelayOutputs)
			soap_pop_block(soap, soap_blist_RelayOutputs);
		if (a->__sizeRelayOutputs)
			a->RelayOutputs = (struct tt__RelayOutput *)soap_save_block(soap, soap_blist_RelayOutputs, NULL, 1);
		else
		{	a->RelayOutputs = NULL;
			if (soap_blist_RelayOutputs)
				soap_end_block(soap, soap_blist_RelayOutputs);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__GetRelayOutputsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetRelayOutputsResponse, 0, sizeof(struct _tds__GetRelayOutputsResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetRelayOutputsResponse(struct soap *soap, const struct _tds__GetRelayOutputsResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__GetRelayOutputsResponse);
	if (soap_out__tds__GetRelayOutputsResponse(soap, tag?tag:"tds:GetRelayOutputsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetRelayOutputsResponse * SOAP_FMAC4 soap_get__tds__GetRelayOutputsResponse(struct soap *soap, struct _tds__GetRelayOutputsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetRelayOutputsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetRelayOutputs(struct soap *soap, struct _tds__GetRelayOutputs *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetRelayOutputs(struct soap *soap, const struct _tds__GetRelayOutputs *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetRelayOutputs(struct soap *soap, const char *tag, int id, const struct _tds__GetRelayOutputs *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetRelayOutputs), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetRelayOutputs * SOAP_FMAC4 soap_in__tds__GetRelayOutputs(struct soap *soap, const char *tag, struct _tds__GetRelayOutputs *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__GetRelayOutputs *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetRelayOutputs, sizeof(struct _tds__GetRelayOutputs), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetRelayOutputs(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__GetRelayOutputs *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetRelayOutputs, 0, sizeof(struct _tds__GetRelayOutputs), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetRelayOutputs(struct soap *soap, const struct _tds__GetRelayOutputs *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__GetRelayOutputs);
	if (soap_out__tds__GetRelayOutputs(soap, tag?tag:"tds:GetRelayOutputs", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetRelayOutputs * SOAP_FMAC4 soap_get__tds__GetRelayOutputs(struct soap *soap, struct _tds__GetRelayOutputs *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetRelayOutputs(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__DeleteDot1XConfigurationResponse(struct soap *soap, struct _tds__DeleteDot1XConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__DeleteDot1XConfigurationResponse(struct soap *soap, const struct _tds__DeleteDot1XConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__DeleteDot1XConfigurationResponse(struct soap *soap, const char *tag, int id, const struct _tds__DeleteDot1XConfigurationResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__DeleteDot1XConfigurationResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__DeleteDot1XConfigurationResponse * SOAP_FMAC4 soap_in__tds__DeleteDot1XConfigurationResponse(struct soap *soap, const char *tag, struct _tds__DeleteDot1XConfigurationResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__DeleteDot1XConfigurationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__DeleteDot1XConfigurationResponse, sizeof(struct _tds__DeleteDot1XConfigurationResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__DeleteDot1XConfigurationResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__DeleteDot1XConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__DeleteDot1XConfigurationResponse, 0, sizeof(struct _tds__DeleteDot1XConfigurationResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__DeleteDot1XConfigurationResponse(struct soap *soap, const struct _tds__DeleteDot1XConfigurationResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__DeleteDot1XConfigurationResponse);
	if (soap_out__tds__DeleteDot1XConfigurationResponse(soap, tag?tag:"tds:DeleteDot1XConfigurationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__DeleteDot1XConfigurationResponse * SOAP_FMAC4 soap_get__tds__DeleteDot1XConfigurationResponse(struct soap *soap, struct _tds__DeleteDot1XConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__DeleteDot1XConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__DeleteDot1XConfiguration(struct soap *soap, struct _tds__DeleteDot1XConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeDot1XConfigurationToken = 0;
	a->Dot1XConfigurationToken = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__DeleteDot1XConfiguration(struct soap *soap, const struct _tds__DeleteDot1XConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->Dot1XConfigurationToken)
	{	int i;
		for (i = 0; i < a->__sizeDot1XConfigurationToken; i++)
		{
			soap_serialize_tt__ReferenceToken(soap, a->Dot1XConfigurationToken + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__DeleteDot1XConfiguration(struct soap *soap, const char *tag, int id, const struct _tds__DeleteDot1XConfiguration *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__DeleteDot1XConfiguration), type))
		return soap->error;
	if (a->Dot1XConfigurationToken)
	{	int i;
		for (i = 0; i < a->__sizeDot1XConfigurationToken; i++)
			if (soap_out_tt__ReferenceToken(soap, "tds:Dot1XConfigurationToken", -1, a->Dot1XConfigurationToken + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__DeleteDot1XConfiguration * SOAP_FMAC4 soap_in__tds__DeleteDot1XConfiguration(struct soap *soap, const char *tag, struct _tds__DeleteDot1XConfiguration *a, const char *type)
{
	struct soap_blist *soap_blist_Dot1XConfigurationToken = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__DeleteDot1XConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__DeleteDot1XConfiguration, sizeof(struct _tds__DeleteDot1XConfiguration), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__DeleteDot1XConfiguration(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tds:Dot1XConfigurationToken", 1, NULL))
			{	if (a->Dot1XConfigurationToken == NULL)
				{	if (soap_blist_Dot1XConfigurationToken == NULL)
						soap_blist_Dot1XConfigurationToken = soap_new_block(soap);
					a->Dot1XConfigurationToken = (char **)soap_push_block(soap, soap_blist_Dot1XConfigurationToken, sizeof(char *));
					if (a->Dot1XConfigurationToken == NULL)
						return NULL;
					*a->Dot1XConfigurationToken = NULL;
				}
				soap_revert(soap);
				if (soap_in_tt__ReferenceToken(soap, "tds:Dot1XConfigurationToken", a->Dot1XConfigurationToken, "tt:ReferenceToken"))
				{	a->__sizeDot1XConfigurationToken++;
					a->Dot1XConfigurationToken = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Dot1XConfigurationToken)
			soap_pop_block(soap, soap_blist_Dot1XConfigurationToken);
		if (a->__sizeDot1XConfigurationToken)
			a->Dot1XConfigurationToken = (char **)soap_save_block(soap, soap_blist_Dot1XConfigurationToken, NULL, 1);
		else
		{	a->Dot1XConfigurationToken = NULL;
			if (soap_blist_Dot1XConfigurationToken)
				soap_end_block(soap, soap_blist_Dot1XConfigurationToken);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__DeleteDot1XConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__DeleteDot1XConfiguration, 0, sizeof(struct _tds__DeleteDot1XConfiguration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__DeleteDot1XConfiguration(struct soap *soap, const struct _tds__DeleteDot1XConfiguration *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__DeleteDot1XConfiguration);
	if (soap_out__tds__DeleteDot1XConfiguration(soap, tag?tag:"tds:DeleteDot1XConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__DeleteDot1XConfiguration * SOAP_FMAC4 soap_get__tds__DeleteDot1XConfiguration(struct soap *soap, struct _tds__DeleteDot1XConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__DeleteDot1XConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetDot1XConfigurationsResponse(struct soap *soap, struct _tds__GetDot1XConfigurationsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeDot1XConfiguration = 0;
	a->Dot1XConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetDot1XConfigurationsResponse(struct soap *soap, const struct _tds__GetDot1XConfigurationsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->Dot1XConfiguration)
	{	int i;
		for (i = 0; i < a->__sizeDot1XConfiguration; i++)
		{
			soap_embedded(soap, a->Dot1XConfiguration + i, SOAP_TYPE_tt__Dot1XConfiguration);
			soap_serialize_tt__Dot1XConfiguration(soap, a->Dot1XConfiguration + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetDot1XConfigurationsResponse(struct soap *soap, const char *tag, int id, const struct _tds__GetDot1XConfigurationsResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetDot1XConfigurationsResponse), type))
		return soap->error;
	soap_element_result(soap, "-sizeDot1XConfiguration");
	if (a->Dot1XConfiguration)
	{	int i;
		for (i = 0; i < a->__sizeDot1XConfiguration; i++)
			if (soap_out_tt__Dot1XConfiguration(soap, "tds:Dot1XConfiguration", -1, a->Dot1XConfiguration + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetDot1XConfigurationsResponse * SOAP_FMAC4 soap_in__tds__GetDot1XConfigurationsResponse(struct soap *soap, const char *tag, struct _tds__GetDot1XConfigurationsResponse *a, const char *type)
{
	struct soap_blist *soap_blist_Dot1XConfiguration = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__GetDot1XConfigurationsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetDot1XConfigurationsResponse, sizeof(struct _tds__GetDot1XConfigurationsResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetDot1XConfigurationsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tds:Dot1XConfiguration", 1, NULL))
			{	if (a->Dot1XConfiguration == NULL)
				{	if (soap_blist_Dot1XConfiguration == NULL)
						soap_blist_Dot1XConfiguration = soap_new_block(soap);
					a->Dot1XConfiguration = (struct tt__Dot1XConfiguration *)soap_push_block(soap, soap_blist_Dot1XConfiguration, sizeof(struct tt__Dot1XConfiguration));
					if (a->Dot1XConfiguration == NULL)
						return NULL;
					soap_default_tt__Dot1XConfiguration(soap, a->Dot1XConfiguration);
				}
				soap_revert(soap);
				if (soap_in_tt__Dot1XConfiguration(soap, "tds:Dot1XConfiguration", a->Dot1XConfiguration, "tt:Dot1XConfiguration"))
				{	a->__sizeDot1XConfiguration++;
					a->Dot1XConfiguration = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizeDot1XConfiguration");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Dot1XConfiguration)
			soap_pop_block(soap, soap_blist_Dot1XConfiguration);
		if (a->__sizeDot1XConfiguration)
			a->Dot1XConfiguration = (struct tt__Dot1XConfiguration *)soap_save_block(soap, soap_blist_Dot1XConfiguration, NULL, 1);
		else
		{	a->Dot1XConfiguration = NULL;
			if (soap_blist_Dot1XConfiguration)
				soap_end_block(soap, soap_blist_Dot1XConfiguration);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__GetDot1XConfigurationsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetDot1XConfigurationsResponse, 0, sizeof(struct _tds__GetDot1XConfigurationsResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetDot1XConfigurationsResponse(struct soap *soap, const struct _tds__GetDot1XConfigurationsResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__GetDot1XConfigurationsResponse);
	if (soap_out__tds__GetDot1XConfigurationsResponse(soap, tag?tag:"tds:GetDot1XConfigurationsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetDot1XConfigurationsResponse * SOAP_FMAC4 soap_get__tds__GetDot1XConfigurationsResponse(struct soap *soap, struct _tds__GetDot1XConfigurationsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetDot1XConfigurationsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetDot1XConfigurations(struct soap *soap, struct _tds__GetDot1XConfigurations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetDot1XConfigurations(struct soap *soap, const struct _tds__GetDot1XConfigurations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetDot1XConfigurations(struct soap *soap, const char *tag, int id, const struct _tds__GetDot1XConfigurations *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetDot1XConfigurations), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetDot1XConfigurations * SOAP_FMAC4 soap_in__tds__GetDot1XConfigurations(struct soap *soap, const char *tag, struct _tds__GetDot1XConfigurations *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__GetDot1XConfigurations *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetDot1XConfigurations, sizeof(struct _tds__GetDot1XConfigurations), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetDot1XConfigurations(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__GetDot1XConfigurations *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetDot1XConfigurations, 0, sizeof(struct _tds__GetDot1XConfigurations), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetDot1XConfigurations(struct soap *soap, const struct _tds__GetDot1XConfigurations *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__GetDot1XConfigurations);
	if (soap_out__tds__GetDot1XConfigurations(soap, tag?tag:"tds:GetDot1XConfigurations", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetDot1XConfigurations * SOAP_FMAC4 soap_get__tds__GetDot1XConfigurations(struct soap *soap, struct _tds__GetDot1XConfigurations *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetDot1XConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetDot1XConfigurationResponse(struct soap *soap, struct _tds__GetDot1XConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Dot1XConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetDot1XConfigurationResponse(struct soap *soap, const struct _tds__GetDot1XConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTott__Dot1XConfiguration(soap, &a->Dot1XConfiguration);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetDot1XConfigurationResponse(struct soap *soap, const char *tag, int id, const struct _tds__GetDot1XConfigurationResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetDot1XConfigurationResponse), type))
		return soap->error;
	if (a->Dot1XConfiguration)
		soap_element_result(soap, "tds:Dot1XConfiguration");
	if (a->Dot1XConfiguration)
	{	if (soap_out_PointerTott__Dot1XConfiguration(soap, "tds:Dot1XConfiguration", -1, &a->Dot1XConfiguration, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tds:Dot1XConfiguration"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetDot1XConfigurationResponse * SOAP_FMAC4 soap_in__tds__GetDot1XConfigurationResponse(struct soap *soap, const char *tag, struct _tds__GetDot1XConfigurationResponse *a, const char *type)
{
	size_t soap_flag_Dot1XConfiguration = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__GetDot1XConfigurationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetDot1XConfigurationResponse, sizeof(struct _tds__GetDot1XConfigurationResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetDot1XConfigurationResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Dot1XConfiguration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__Dot1XConfiguration(soap, "tds:Dot1XConfiguration", &a->Dot1XConfiguration, "tt:Dot1XConfiguration"))
				{	soap_flag_Dot1XConfiguration--;
					continue;
				}
			soap_check_result(soap, "tds:Dot1XConfiguration");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__GetDot1XConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetDot1XConfigurationResponse, 0, sizeof(struct _tds__GetDot1XConfigurationResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Dot1XConfiguration > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetDot1XConfigurationResponse(struct soap *soap, const struct _tds__GetDot1XConfigurationResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__GetDot1XConfigurationResponse);
	if (soap_out__tds__GetDot1XConfigurationResponse(soap, tag?tag:"tds:GetDot1XConfigurationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetDot1XConfigurationResponse * SOAP_FMAC4 soap_get__tds__GetDot1XConfigurationResponse(struct soap *soap, struct _tds__GetDot1XConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetDot1XConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetDot1XConfiguration(struct soap *soap, struct _tds__GetDot1XConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->Dot1XConfigurationToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetDot1XConfiguration(struct soap *soap, const struct _tds__GetDot1XConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_tt__ReferenceToken(soap, &a->Dot1XConfigurationToken);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetDot1XConfiguration(struct soap *soap, const char *tag, int id, const struct _tds__GetDot1XConfiguration *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetDot1XConfiguration), type))
		return soap->error;
	if (a->Dot1XConfigurationToken)
	{	if (soap_out_tt__ReferenceToken(soap, "tds:Dot1XConfigurationToken", -1, &a->Dot1XConfigurationToken, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tds:Dot1XConfigurationToken"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetDot1XConfiguration * SOAP_FMAC4 soap_in__tds__GetDot1XConfiguration(struct soap *soap, const char *tag, struct _tds__GetDot1XConfiguration *a, const char *type)
{
	size_t soap_flag_Dot1XConfigurationToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__GetDot1XConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetDot1XConfiguration, sizeof(struct _tds__GetDot1XConfiguration), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetDot1XConfiguration(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Dot1XConfigurationToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "tds:Dot1XConfigurationToken", &a->Dot1XConfigurationToken, "tt:ReferenceToken"))
				{	soap_flag_Dot1XConfigurationToken--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__GetDot1XConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetDot1XConfiguration, 0, sizeof(struct _tds__GetDot1XConfiguration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Dot1XConfigurationToken > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetDot1XConfiguration(struct soap *soap, const struct _tds__GetDot1XConfiguration *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__GetDot1XConfiguration);
	if (soap_out__tds__GetDot1XConfiguration(soap, tag?tag:"tds:GetDot1XConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetDot1XConfiguration * SOAP_FMAC4 soap_get__tds__GetDot1XConfiguration(struct soap *soap, struct _tds__GetDot1XConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetDot1XConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__SetDot1XConfigurationResponse(struct soap *soap, struct _tds__SetDot1XConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__SetDot1XConfigurationResponse(struct soap *soap, const struct _tds__SetDot1XConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetDot1XConfigurationResponse(struct soap *soap, const char *tag, int id, const struct _tds__SetDot1XConfigurationResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetDot1XConfigurationResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__SetDot1XConfigurationResponse * SOAP_FMAC4 soap_in__tds__SetDot1XConfigurationResponse(struct soap *soap, const char *tag, struct _tds__SetDot1XConfigurationResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__SetDot1XConfigurationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetDot1XConfigurationResponse, sizeof(struct _tds__SetDot1XConfigurationResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__SetDot1XConfigurationResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__SetDot1XConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetDot1XConfigurationResponse, 0, sizeof(struct _tds__SetDot1XConfigurationResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__SetDot1XConfigurationResponse(struct soap *soap, const struct _tds__SetDot1XConfigurationResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__SetDot1XConfigurationResponse);
	if (soap_out__tds__SetDot1XConfigurationResponse(soap, tag?tag:"tds:SetDot1XConfigurationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetDot1XConfigurationResponse * SOAP_FMAC4 soap_get__tds__SetDot1XConfigurationResponse(struct soap *soap, struct _tds__SetDot1XConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetDot1XConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__SetDot1XConfiguration(struct soap *soap, struct _tds__SetDot1XConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Dot1XConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__SetDot1XConfiguration(struct soap *soap, const struct _tds__SetDot1XConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTott__Dot1XConfiguration(soap, &a->Dot1XConfiguration);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetDot1XConfiguration(struct soap *soap, const char *tag, int id, const struct _tds__SetDot1XConfiguration *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetDot1XConfiguration), type))
		return soap->error;
	if (a->Dot1XConfiguration)
	{	if (soap_out_PointerTott__Dot1XConfiguration(soap, "tds:Dot1XConfiguration", -1, &a->Dot1XConfiguration, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tds:Dot1XConfiguration"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__SetDot1XConfiguration * SOAP_FMAC4 soap_in__tds__SetDot1XConfiguration(struct soap *soap, const char *tag, struct _tds__SetDot1XConfiguration *a, const char *type)
{
	size_t soap_flag_Dot1XConfiguration = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__SetDot1XConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetDot1XConfiguration, sizeof(struct _tds__SetDot1XConfiguration), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__SetDot1XConfiguration(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Dot1XConfiguration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__Dot1XConfiguration(soap, "tds:Dot1XConfiguration", &a->Dot1XConfiguration, "tt:Dot1XConfiguration"))
				{	soap_flag_Dot1XConfiguration--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__SetDot1XConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetDot1XConfiguration, 0, sizeof(struct _tds__SetDot1XConfiguration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Dot1XConfiguration > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__SetDot1XConfiguration(struct soap *soap, const struct _tds__SetDot1XConfiguration *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__SetDot1XConfiguration);
	if (soap_out__tds__SetDot1XConfiguration(soap, tag?tag:"tds:SetDot1XConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetDot1XConfiguration * SOAP_FMAC4 soap_get__tds__SetDot1XConfiguration(struct soap *soap, struct _tds__SetDot1XConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetDot1XConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__CreateDot1XConfigurationResponse(struct soap *soap, struct _tds__CreateDot1XConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__CreateDot1XConfigurationResponse(struct soap *soap, const struct _tds__CreateDot1XConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__CreateDot1XConfigurationResponse(struct soap *soap, const char *tag, int id, const struct _tds__CreateDot1XConfigurationResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__CreateDot1XConfigurationResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__CreateDot1XConfigurationResponse * SOAP_FMAC4 soap_in__tds__CreateDot1XConfigurationResponse(struct soap *soap, const char *tag, struct _tds__CreateDot1XConfigurationResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__CreateDot1XConfigurationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__CreateDot1XConfigurationResponse, sizeof(struct _tds__CreateDot1XConfigurationResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__CreateDot1XConfigurationResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__CreateDot1XConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__CreateDot1XConfigurationResponse, 0, sizeof(struct _tds__CreateDot1XConfigurationResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__CreateDot1XConfigurationResponse(struct soap *soap, const struct _tds__CreateDot1XConfigurationResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__CreateDot1XConfigurationResponse);
	if (soap_out__tds__CreateDot1XConfigurationResponse(soap, tag?tag:"tds:CreateDot1XConfigurationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__CreateDot1XConfigurationResponse * SOAP_FMAC4 soap_get__tds__CreateDot1XConfigurationResponse(struct soap *soap, struct _tds__CreateDot1XConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__CreateDot1XConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__Dot1XConfiguration(struct soap *soap, struct tt__Dot1XConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->Dot1XConfigurationToken);
	soap_default_string(soap, &a->Identity);
	soap_default_string(soap, &a->AnonymousID);
	soap_default_int(soap, &a->EAPMethod);
	a->__sizeCACertificateID = 0;
	a->CACertificateID = NULL;
	a->EAPMethodConfiguration = NULL;
	a->Extension = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__Dot1XConfiguration(struct soap *soap, const struct tt__Dot1XConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_tt__ReferenceToken(soap, &a->Dot1XConfigurationToken);
	soap_serialize_string(soap, &a->Identity);
	soap_serialize_string(soap, &a->AnonymousID);
	soap_embedded(soap, &a->EAPMethod, SOAP_TYPE_int);
	if (a->CACertificateID)
	{	int i;
		for (i = 0; i < a->__sizeCACertificateID; i++)
		{
			soap_serialize_xsd__token(soap, a->CACertificateID + i);
		}
	}
	soap_serialize_PointerTott__EAPMethodConfiguration(soap, &a->EAPMethodConfiguration);
	soap_serialize_PointerTott__Dot1XConfigurationExtension(soap, &a->Extension);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Dot1XConfiguration(struct soap *soap, const char *tag, int id, const struct tt__Dot1XConfiguration *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Dot1XConfiguration), type))
		return soap->error;
	if (a->Dot1XConfigurationToken)
	{	if (soap_out_tt__ReferenceToken(soap, "tt:Dot1XConfigurationToken", -1, &a->Dot1XConfigurationToken, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:Dot1XConfigurationToken"))
		return soap->error;
	if (a->Identity)
	{	if (soap_out_string(soap, "tt:Identity", -1, &a->Identity, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:Identity"))
		return soap->error;
	if (soap_out_string(soap, "tt:AnonymousID", -1, &a->AnonymousID, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:EAPMethod", -1, &a->EAPMethod, ""))
		return soap->error;
	if (a->CACertificateID)
	{	int i;
		for (i = 0; i < a->__sizeCACertificateID; i++)
			if (soap_out_xsd__token(soap, "tt:CACertificateID", -1, a->CACertificateID + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTott__EAPMethodConfiguration(soap, "tt:EAPMethodConfiguration", -1, &a->EAPMethodConfiguration, ""))
		return soap->error;
	if (soap_out_PointerTott__Dot1XConfigurationExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__Dot1XConfiguration * SOAP_FMAC4 soap_in_tt__Dot1XConfiguration(struct soap *soap, const char *tag, struct tt__Dot1XConfiguration *a, const char *type)
{
	size_t soap_flag_Dot1XConfigurationToken = 1;
	size_t soap_flag_Identity = 1;
	size_t soap_flag_AnonymousID = 1;
	size_t soap_flag_EAPMethod = 1;
	struct soap_blist *soap_blist_CACertificateID = NULL;
	size_t soap_flag_EAPMethodConfiguration = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__Dot1XConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Dot1XConfiguration, sizeof(struct tt__Dot1XConfiguration), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__Dot1XConfiguration(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Dot1XConfigurationToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "tt:Dot1XConfigurationToken", &a->Dot1XConfigurationToken, "tt:ReferenceToken"))
				{	soap_flag_Dot1XConfigurationToken--;
					continue;
				}
			if (soap_flag_Identity && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "tt:Identity", &a->Identity, "xsd:string"))
				{	soap_flag_Identity--;
					continue;
				}
			if (soap_flag_AnonymousID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "tt:AnonymousID", &a->AnonymousID, "xsd:string"))
				{	soap_flag_AnonymousID--;
					continue;
				}
			if (soap_flag_EAPMethod && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "tt:EAPMethod", &a->EAPMethod, "xsd:int"))
				{	soap_flag_EAPMethod--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:CACertificateID", 1, NULL))
			{	if (a->CACertificateID == NULL)
				{	if (soap_blist_CACertificateID == NULL)
						soap_blist_CACertificateID = soap_new_block(soap);
					a->CACertificateID = (char **)soap_push_block(soap, soap_blist_CACertificateID, sizeof(char *));
					if (a->CACertificateID == NULL)
						return NULL;
					*a->CACertificateID = NULL;
				}
				soap_revert(soap);
				if (soap_in_xsd__token(soap, "tt:CACertificateID", a->CACertificateID, "xsd:token"))
				{	a->__sizeCACertificateID++;
					a->CACertificateID = NULL;
					continue;
				}
			}
			if (soap_flag_EAPMethodConfiguration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__EAPMethodConfiguration(soap, "tt:EAPMethodConfiguration", &a->EAPMethodConfiguration, "tt:EAPMethodConfiguration"))
				{	soap_flag_EAPMethodConfiguration--;
					continue;
				}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__Dot1XConfigurationExtension(soap, "tt:Extension", &a->Extension, "tt:Dot1XConfigurationExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->CACertificateID)
			soap_pop_block(soap, soap_blist_CACertificateID);
		if (a->__sizeCACertificateID)
			a->CACertificateID = (char **)soap_save_block(soap, soap_blist_CACertificateID, NULL, 1);
		else
		{	a->CACertificateID = NULL;
			if (soap_blist_CACertificateID)
				soap_end_block(soap, soap_blist_CACertificateID);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__Dot1XConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Dot1XConfiguration, 0, sizeof(struct tt__Dot1XConfiguration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Dot1XConfigurationToken > 0 || soap_flag_Identity > 0 || soap_flag_EAPMethod > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Dot1XConfiguration(struct soap *soap, const struct tt__Dot1XConfiguration *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__Dot1XConfiguration);
	if (soap_out_tt__Dot1XConfiguration(soap, tag?tag:"tt:Dot1XConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Dot1XConfiguration * SOAP_FMAC4 soap_get_tt__Dot1XConfiguration(struct soap *soap, struct tt__Dot1XConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Dot1XConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__CreateDot1XConfiguration(struct soap *soap, struct _tds__CreateDot1XConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Dot1XConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__CreateDot1XConfiguration(struct soap *soap, const struct _tds__CreateDot1XConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTott__Dot1XConfiguration(soap, &a->Dot1XConfiguration);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__CreateDot1XConfiguration(struct soap *soap, const char *tag, int id, const struct _tds__CreateDot1XConfiguration *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__CreateDot1XConfiguration), type))
		return soap->error;
	if (a->Dot1XConfiguration)
	{	if (soap_out_PointerTott__Dot1XConfiguration(soap, "tds:Dot1XConfiguration", -1, &a->Dot1XConfiguration, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tds:Dot1XConfiguration"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__CreateDot1XConfiguration * SOAP_FMAC4 soap_in__tds__CreateDot1XConfiguration(struct soap *soap, const char *tag, struct _tds__CreateDot1XConfiguration *a, const char *type)
{
	size_t soap_flag_Dot1XConfiguration = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__CreateDot1XConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__CreateDot1XConfiguration, sizeof(struct _tds__CreateDot1XConfiguration), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__CreateDot1XConfiguration(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Dot1XConfiguration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__Dot1XConfiguration(soap, "tds:Dot1XConfiguration", &a->Dot1XConfiguration, "tt:Dot1XConfiguration"))
				{	soap_flag_Dot1XConfiguration--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__CreateDot1XConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__CreateDot1XConfiguration, 0, sizeof(struct _tds__CreateDot1XConfiguration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Dot1XConfiguration > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__CreateDot1XConfiguration(struct soap *soap, const struct _tds__CreateDot1XConfiguration *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__CreateDot1XConfiguration);
	if (soap_out__tds__CreateDot1XConfiguration(soap, tag?tag:"tds:CreateDot1XConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__CreateDot1XConfiguration * SOAP_FMAC4 soap_get__tds__CreateDot1XConfiguration(struct soap *soap, struct _tds__CreateDot1XConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__CreateDot1XConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__LoadCACertificatesResponse(struct soap *soap, struct _tds__LoadCACertificatesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__LoadCACertificatesResponse(struct soap *soap, const struct _tds__LoadCACertificatesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__LoadCACertificatesResponse(struct soap *soap, const char *tag, int id, const struct _tds__LoadCACertificatesResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__LoadCACertificatesResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__LoadCACertificatesResponse * SOAP_FMAC4 soap_in__tds__LoadCACertificatesResponse(struct soap *soap, const char *tag, struct _tds__LoadCACertificatesResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__LoadCACertificatesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__LoadCACertificatesResponse, sizeof(struct _tds__LoadCACertificatesResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__LoadCACertificatesResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__LoadCACertificatesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__LoadCACertificatesResponse, 0, sizeof(struct _tds__LoadCACertificatesResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__LoadCACertificatesResponse(struct soap *soap, const struct _tds__LoadCACertificatesResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__LoadCACertificatesResponse);
	if (soap_out__tds__LoadCACertificatesResponse(soap, tag?tag:"tds:LoadCACertificatesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__LoadCACertificatesResponse * SOAP_FMAC4 soap_get__tds__LoadCACertificatesResponse(struct soap *soap, struct _tds__LoadCACertificatesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__LoadCACertificatesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__LoadCACertificates(struct soap *soap, struct _tds__LoadCACertificates *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeCACertificate = 0;
	a->CACertificate = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__LoadCACertificates(struct soap *soap, const struct _tds__LoadCACertificates *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->CACertificate)
	{	int i;
		for (i = 0; i < a->__sizeCACertificate; i++)
		{
			soap_embedded(soap, a->CACertificate + i, SOAP_TYPE_tt__Certificate);
			soap_serialize_tt__Certificate(soap, a->CACertificate + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__LoadCACertificates(struct soap *soap, const char *tag, int id, const struct _tds__LoadCACertificates *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__LoadCACertificates), type))
		return soap->error;
	if (a->CACertificate)
	{	int i;
		for (i = 0; i < a->__sizeCACertificate; i++)
			if (soap_out_tt__Certificate(soap, "tds:CACertificate", -1, a->CACertificate + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__LoadCACertificates * SOAP_FMAC4 soap_in__tds__LoadCACertificates(struct soap *soap, const char *tag, struct _tds__LoadCACertificates *a, const char *type)
{
	struct soap_blist *soap_blist_CACertificate = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__LoadCACertificates *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__LoadCACertificates, sizeof(struct _tds__LoadCACertificates), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__LoadCACertificates(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tds:CACertificate", 1, NULL))
			{	if (a->CACertificate == NULL)
				{	if (soap_blist_CACertificate == NULL)
						soap_blist_CACertificate = soap_new_block(soap);
					a->CACertificate = (struct tt__Certificate *)soap_push_block(soap, soap_blist_CACertificate, sizeof(struct tt__Certificate));
					if (a->CACertificate == NULL)
						return NULL;
					soap_default_tt__Certificate(soap, a->CACertificate);
				}
				soap_revert(soap);
				if (soap_in_tt__Certificate(soap, "tds:CACertificate", a->CACertificate, "tt:Certificate"))
				{	a->__sizeCACertificate++;
					a->CACertificate = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->CACertificate)
			soap_pop_block(soap, soap_blist_CACertificate);
		if (a->__sizeCACertificate)
			a->CACertificate = (struct tt__Certificate *)soap_save_block(soap, soap_blist_CACertificate, NULL, 1);
		else
		{	a->CACertificate = NULL;
			if (soap_blist_CACertificate)
				soap_end_block(soap, soap_blist_CACertificate);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__LoadCACertificates *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__LoadCACertificates, 0, sizeof(struct _tds__LoadCACertificates), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeCACertificate < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__LoadCACertificates(struct soap *soap, const struct _tds__LoadCACertificates *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__LoadCACertificates);
	if (soap_out__tds__LoadCACertificates(soap, tag?tag:"tds:LoadCACertificates", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__LoadCACertificates * SOAP_FMAC4 soap_get__tds__LoadCACertificates(struct soap *soap, struct _tds__LoadCACertificates *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__LoadCACertificates(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__CertificateInformation(struct soap *soap, struct tt__CertificateInformation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__token(soap, &a->CertificateID);
	soap_default_string(soap, &a->IssuerDN);
	soap_default_string(soap, &a->SubjectDN);
	a->KeyUsage = NULL;
	a->ExtendedKeyUsage = NULL;
	a->KeyLength = NULL;
	soap_default_string(soap, &a->Version);
	soap_default_string(soap, &a->SerialNum);
	soap_default_string(soap, &a->SignatureAlgorithm);
	a->Validity = NULL;
	a->Extension = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__CertificateInformation(struct soap *soap, const struct tt__CertificateInformation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_xsd__token(soap, &a->CertificateID);
	soap_serialize_string(soap, &a->IssuerDN);
	soap_serialize_string(soap, &a->SubjectDN);
	soap_serialize_PointerTott__CertificateUsage(soap, &a->KeyUsage);
	soap_serialize_PointerTott__CertificateUsage(soap, &a->ExtendedKeyUsage);
	soap_serialize_PointerToint(soap, &a->KeyLength);
	soap_serialize_string(soap, &a->Version);
	soap_serialize_string(soap, &a->SerialNum);
	soap_serialize_string(soap, &a->SignatureAlgorithm);
	soap_serialize_PointerTott__DateTimeRange(soap, &a->Validity);
	soap_serialize_PointerTott__CertificateInformationExtension(soap, &a->Extension);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__CertificateInformation(struct soap *soap, const char *tag, int id, const struct tt__CertificateInformation *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__CertificateInformation), type))
		return soap->error;
	if (a->CertificateID)
	{	if (soap_out_xsd__token(soap, "tt:CertificateID", -1, &a->CertificateID, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:CertificateID"))
		return soap->error;
	if (soap_out_string(soap, "tt:IssuerDN", -1, &a->IssuerDN, ""))
		return soap->error;
	if (soap_out_string(soap, "tt:SubjectDN", -1, &a->SubjectDN, ""))
		return soap->error;
	if (soap_out_PointerTott__CertificateUsage(soap, "tt:KeyUsage", -1, &a->KeyUsage, ""))
		return soap->error;
	if (soap_out_PointerTott__CertificateUsage(soap, "tt:ExtendedKeyUsage", -1, &a->ExtendedKeyUsage, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "tt:KeyLength", -1, &a->KeyLength, ""))
		return soap->error;
	if (soap_out_string(soap, "tt:Version", -1, &a->Version, ""))
		return soap->error;
	if (soap_out_string(soap, "tt:SerialNum", -1, &a->SerialNum, ""))
		return soap->error;
	if (soap_out_string(soap, "tt:SignatureAlgorithm", -1, &a->SignatureAlgorithm, ""))
		return soap->error;
	if (soap_out_PointerTott__DateTimeRange(soap, "tt:Validity", -1, &a->Validity, ""))
		return soap->error;
	if (soap_out_PointerTott__CertificateInformationExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__CertificateInformation * SOAP_FMAC4 soap_in_tt__CertificateInformation(struct soap *soap, const char *tag, struct tt__CertificateInformation *a, const char *type)
{
	size_t soap_flag_CertificateID = 1;
	size_t soap_flag_IssuerDN = 1;
	size_t soap_flag_SubjectDN = 1;
	size_t soap_flag_KeyUsage = 1;
	size_t soap_flag_ExtendedKeyUsage = 1;
	size_t soap_flag_KeyLength = 1;
	size_t soap_flag_Version = 1;
	size_t soap_flag_SerialNum = 1;
	size_t soap_flag_SignatureAlgorithm = 1;
	size_t soap_flag_Validity = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__CertificateInformation *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__CertificateInformation, sizeof(struct tt__CertificateInformation), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__CertificateInformation(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CertificateID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__token(soap, "tt:CertificateID", &a->CertificateID, "xsd:token"))
				{	soap_flag_CertificateID--;
					continue;
				}
			if (soap_flag_IssuerDN && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "tt:IssuerDN", &a->IssuerDN, "xsd:string"))
				{	soap_flag_IssuerDN--;
					continue;
				}
			if (soap_flag_SubjectDN && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "tt:SubjectDN", &a->SubjectDN, "xsd:string"))
				{	soap_flag_SubjectDN--;
					continue;
				}
			if (soap_flag_KeyUsage && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__CertificateUsage(soap, "tt:KeyUsage", &a->KeyUsage, "tt:CertificateUsage"))
				{	soap_flag_KeyUsage--;
					continue;
				}
			if (soap_flag_ExtendedKeyUsage && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__CertificateUsage(soap, "tt:ExtendedKeyUsage", &a->ExtendedKeyUsage, "tt:CertificateUsage"))
				{	soap_flag_ExtendedKeyUsage--;
					continue;
				}
			if (soap_flag_KeyLength && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "tt:KeyLength", &a->KeyLength, "xsd:int"))
				{	soap_flag_KeyLength--;
					continue;
				}
			if (soap_flag_Version && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "tt:Version", &a->Version, "xsd:string"))
				{	soap_flag_Version--;
					continue;
				}
			if (soap_flag_SerialNum && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "tt:SerialNum", &a->SerialNum, "xsd:string"))
				{	soap_flag_SerialNum--;
					continue;
				}
			if (soap_flag_SignatureAlgorithm && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "tt:SignatureAlgorithm", &a->SignatureAlgorithm, "xsd:string"))
				{	soap_flag_SignatureAlgorithm--;
					continue;
				}
			if (soap_flag_Validity && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__DateTimeRange(soap, "tt:Validity", &a->Validity, "tt:DateTimeRange"))
				{	soap_flag_Validity--;
					continue;
				}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__CertificateInformationExtension(soap, "tt:Extension", &a->Extension, "tt:CertificateInformationExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__CertificateInformation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__CertificateInformation, 0, sizeof(struct tt__CertificateInformation), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_CertificateID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__CertificateInformation(struct soap *soap, const struct tt__CertificateInformation *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__CertificateInformation);
	if (soap_out_tt__CertificateInformation(soap, tag?tag:"tt:CertificateInformation", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__CertificateInformation * SOAP_FMAC4 soap_get_tt__CertificateInformation(struct soap *soap, struct tt__CertificateInformation *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__CertificateInformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetCertificateInformationResponse(struct soap *soap, struct _tds__GetCertificateInformationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->CertificateInformation = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetCertificateInformationResponse(struct soap *soap, const struct _tds__GetCertificateInformationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTott__CertificateInformation(soap, &a->CertificateInformation);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetCertificateInformationResponse(struct soap *soap, const char *tag, int id, const struct _tds__GetCertificateInformationResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetCertificateInformationResponse), type))
		return soap->error;
	if (a->CertificateInformation)
		soap_element_result(soap, "tds:CertificateInformation");
	if (a->CertificateInformation)
	{	if (soap_out_PointerTott__CertificateInformation(soap, "tds:CertificateInformation", -1, &a->CertificateInformation, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tds:CertificateInformation"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetCertificateInformationResponse * SOAP_FMAC4 soap_in__tds__GetCertificateInformationResponse(struct soap *soap, const char *tag, struct _tds__GetCertificateInformationResponse *a, const char *type)
{
	size_t soap_flag_CertificateInformation = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__GetCertificateInformationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetCertificateInformationResponse, sizeof(struct _tds__GetCertificateInformationResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetCertificateInformationResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CertificateInformation && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__CertificateInformation(soap, "tds:CertificateInformation", &a->CertificateInformation, "tt:CertificateInformation"))
				{	soap_flag_CertificateInformation--;
					continue;
				}
			soap_check_result(soap, "tds:CertificateInformation");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__GetCertificateInformationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetCertificateInformationResponse, 0, sizeof(struct _tds__GetCertificateInformationResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_CertificateInformation > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetCertificateInformationResponse(struct soap *soap, const struct _tds__GetCertificateInformationResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__GetCertificateInformationResponse);
	if (soap_out__tds__GetCertificateInformationResponse(soap, tag?tag:"tds:GetCertificateInformationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetCertificateInformationResponse * SOAP_FMAC4 soap_get__tds__GetCertificateInformationResponse(struct soap *soap, struct _tds__GetCertificateInformationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetCertificateInformationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetCertificateInformation(struct soap *soap, struct _tds__GetCertificateInformation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__token(soap, &a->CertificateID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetCertificateInformation(struct soap *soap, const struct _tds__GetCertificateInformation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_xsd__token(soap, &a->CertificateID);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetCertificateInformation(struct soap *soap, const char *tag, int id, const struct _tds__GetCertificateInformation *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetCertificateInformation), type))
		return soap->error;
	if (a->CertificateID)
	{	if (soap_out_xsd__token(soap, "tds:CertificateID", -1, &a->CertificateID, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tds:CertificateID"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetCertificateInformation * SOAP_FMAC4 soap_in__tds__GetCertificateInformation(struct soap *soap, const char *tag, struct _tds__GetCertificateInformation *a, const char *type)
{
	size_t soap_flag_CertificateID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__GetCertificateInformation *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetCertificateInformation, sizeof(struct _tds__GetCertificateInformation), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetCertificateInformation(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CertificateID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__token(soap, "tds:CertificateID", &a->CertificateID, "xsd:token"))
				{	soap_flag_CertificateID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__GetCertificateInformation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetCertificateInformation, 0, sizeof(struct _tds__GetCertificateInformation), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_CertificateID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetCertificateInformation(struct soap *soap, const struct _tds__GetCertificateInformation *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__GetCertificateInformation);
	if (soap_out__tds__GetCertificateInformation(soap, tag?tag:"tds:GetCertificateInformation", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetCertificateInformation * SOAP_FMAC4 soap_get__tds__GetCertificateInformation(struct soap *soap, struct _tds__GetCertificateInformation *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetCertificateInformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__LoadCertificateWithPrivateKeyResponse(struct soap *soap, struct _tds__LoadCertificateWithPrivateKeyResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__LoadCertificateWithPrivateKeyResponse(struct soap *soap, const struct _tds__LoadCertificateWithPrivateKeyResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__LoadCertificateWithPrivateKeyResponse(struct soap *soap, const char *tag, int id, const struct _tds__LoadCertificateWithPrivateKeyResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__LoadCertificateWithPrivateKeyResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__LoadCertificateWithPrivateKeyResponse * SOAP_FMAC4 soap_in__tds__LoadCertificateWithPrivateKeyResponse(struct soap *soap, const char *tag, struct _tds__LoadCertificateWithPrivateKeyResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__LoadCertificateWithPrivateKeyResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__LoadCertificateWithPrivateKeyResponse, sizeof(struct _tds__LoadCertificateWithPrivateKeyResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__LoadCertificateWithPrivateKeyResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__LoadCertificateWithPrivateKeyResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__LoadCertificateWithPrivateKeyResponse, 0, sizeof(struct _tds__LoadCertificateWithPrivateKeyResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__LoadCertificateWithPrivateKeyResponse(struct soap *soap, const struct _tds__LoadCertificateWithPrivateKeyResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__LoadCertificateWithPrivateKeyResponse);
	if (soap_out__tds__LoadCertificateWithPrivateKeyResponse(soap, tag?tag:"tds:LoadCertificateWithPrivateKeyResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__LoadCertificateWithPrivateKeyResponse * SOAP_FMAC4 soap_get__tds__LoadCertificateWithPrivateKeyResponse(struct soap *soap, struct _tds__LoadCertificateWithPrivateKeyResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__LoadCertificateWithPrivateKeyResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__CertificateWithPrivateKey(struct soap *soap, struct tt__CertificateWithPrivateKey *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__token(soap, &a->CertificateID);
	a->Certificate = NULL;
	a->PrivateKey = NULL;
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__CertificateWithPrivateKey(struct soap *soap, const struct tt__CertificateWithPrivateKey *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_xsd__token(soap, &a->CertificateID);
	soap_serialize_PointerTott__BinaryData(soap, &a->Certificate);
	soap_serialize_PointerTott__BinaryData(soap, &a->PrivateKey);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__CertificateWithPrivateKey(struct soap *soap, const char *tag, int id, const struct tt__CertificateWithPrivateKey *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__CertificateWithPrivateKey), type))
		return soap->error;
	if (soap_out_xsd__token(soap, "tt:CertificateID", -1, &a->CertificateID, ""))
		return soap->error;
	if (a->Certificate)
	{	if (soap_out_PointerTott__BinaryData(soap, "tt:Certificate", -1, &a->Certificate, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:Certificate"))
		return soap->error;
	if (a->PrivateKey)
	{	if (soap_out_PointerTott__BinaryData(soap, "tt:PrivateKey", -1, &a->PrivateKey, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:PrivateKey"))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__CertificateWithPrivateKey * SOAP_FMAC4 soap_in_tt__CertificateWithPrivateKey(struct soap *soap, const char *tag, struct tt__CertificateWithPrivateKey *a, const char *type)
{
	size_t soap_flag_CertificateID = 1;
	size_t soap_flag_Certificate = 1;
	size_t soap_flag_PrivateKey = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__CertificateWithPrivateKey *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__CertificateWithPrivateKey, sizeof(struct tt__CertificateWithPrivateKey), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__CertificateWithPrivateKey(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CertificateID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__token(soap, "tt:CertificateID", &a->CertificateID, "xsd:token"))
				{	soap_flag_CertificateID--;
					continue;
				}
			if (soap_flag_Certificate && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__BinaryData(soap, "tt:Certificate", &a->Certificate, "tt:BinaryData"))
				{	soap_flag_Certificate--;
					continue;
				}
			if (soap_flag_PrivateKey && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__BinaryData(soap, "tt:PrivateKey", &a->PrivateKey, "tt:BinaryData"))
				{	soap_flag_PrivateKey--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__CertificateWithPrivateKey *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__CertificateWithPrivateKey, 0, sizeof(struct tt__CertificateWithPrivateKey), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Certificate > 0 || soap_flag_PrivateKey > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__CertificateWithPrivateKey(struct soap *soap, const struct tt__CertificateWithPrivateKey *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__CertificateWithPrivateKey);
	if (soap_out_tt__CertificateWithPrivateKey(soap, tag?tag:"tt:CertificateWithPrivateKey", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__CertificateWithPrivateKey * SOAP_FMAC4 soap_get_tt__CertificateWithPrivateKey(struct soap *soap, struct tt__CertificateWithPrivateKey *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__CertificateWithPrivateKey(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__LoadCertificateWithPrivateKey(struct soap *soap, struct _tds__LoadCertificateWithPrivateKey *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeCertificateWithPrivateKey = 0;
	a->CertificateWithPrivateKey = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__LoadCertificateWithPrivateKey(struct soap *soap, const struct _tds__LoadCertificateWithPrivateKey *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->CertificateWithPrivateKey)
	{	int i;
		for (i = 0; i < a->__sizeCertificateWithPrivateKey; i++)
		{
			soap_embedded(soap, a->CertificateWithPrivateKey + i, SOAP_TYPE_tt__CertificateWithPrivateKey);
			soap_serialize_tt__CertificateWithPrivateKey(soap, a->CertificateWithPrivateKey + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__LoadCertificateWithPrivateKey(struct soap *soap, const char *tag, int id, const struct _tds__LoadCertificateWithPrivateKey *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__LoadCertificateWithPrivateKey), type))
		return soap->error;
	if (a->CertificateWithPrivateKey)
	{	int i;
		for (i = 0; i < a->__sizeCertificateWithPrivateKey; i++)
			if (soap_out_tt__CertificateWithPrivateKey(soap, "tds:CertificateWithPrivateKey", -1, a->CertificateWithPrivateKey + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__LoadCertificateWithPrivateKey * SOAP_FMAC4 soap_in__tds__LoadCertificateWithPrivateKey(struct soap *soap, const char *tag, struct _tds__LoadCertificateWithPrivateKey *a, const char *type)
{
	struct soap_blist *soap_blist_CertificateWithPrivateKey = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__LoadCertificateWithPrivateKey *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__LoadCertificateWithPrivateKey, sizeof(struct _tds__LoadCertificateWithPrivateKey), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__LoadCertificateWithPrivateKey(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tds:CertificateWithPrivateKey", 1, NULL))
			{	if (a->CertificateWithPrivateKey == NULL)
				{	if (soap_blist_CertificateWithPrivateKey == NULL)
						soap_blist_CertificateWithPrivateKey = soap_new_block(soap);
					a->CertificateWithPrivateKey = (struct tt__CertificateWithPrivateKey *)soap_push_block(soap, soap_blist_CertificateWithPrivateKey, sizeof(struct tt__CertificateWithPrivateKey));
					if (a->CertificateWithPrivateKey == NULL)
						return NULL;
					soap_default_tt__CertificateWithPrivateKey(soap, a->CertificateWithPrivateKey);
				}
				soap_revert(soap);
				if (soap_in_tt__CertificateWithPrivateKey(soap, "tds:CertificateWithPrivateKey", a->CertificateWithPrivateKey, "tt:CertificateWithPrivateKey"))
				{	a->__sizeCertificateWithPrivateKey++;
					a->CertificateWithPrivateKey = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->CertificateWithPrivateKey)
			soap_pop_block(soap, soap_blist_CertificateWithPrivateKey);
		if (a->__sizeCertificateWithPrivateKey)
			a->CertificateWithPrivateKey = (struct tt__CertificateWithPrivateKey *)soap_save_block(soap, soap_blist_CertificateWithPrivateKey, NULL, 1);
		else
		{	a->CertificateWithPrivateKey = NULL;
			if (soap_blist_CertificateWithPrivateKey)
				soap_end_block(soap, soap_blist_CertificateWithPrivateKey);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__LoadCertificateWithPrivateKey *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__LoadCertificateWithPrivateKey, 0, sizeof(struct _tds__LoadCertificateWithPrivateKey), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeCertificateWithPrivateKey < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__LoadCertificateWithPrivateKey(struct soap *soap, const struct _tds__LoadCertificateWithPrivateKey *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__LoadCertificateWithPrivateKey);
	if (soap_out__tds__LoadCertificateWithPrivateKey(soap, tag?tag:"tds:LoadCertificateWithPrivateKey", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__LoadCertificateWithPrivateKey * SOAP_FMAC4 soap_get__tds__LoadCertificateWithPrivateKey(struct soap *soap, struct _tds__LoadCertificateWithPrivateKey *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__LoadCertificateWithPrivateKey(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetCACertificatesResponse(struct soap *soap, struct _tds__GetCACertificatesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeCACertificate = 0;
	a->CACertificate = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetCACertificatesResponse(struct soap *soap, const struct _tds__GetCACertificatesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->CACertificate)
	{	int i;
		for (i = 0; i < a->__sizeCACertificate; i++)
		{
			soap_embedded(soap, a->CACertificate + i, SOAP_TYPE_tt__Certificate);
			soap_serialize_tt__Certificate(soap, a->CACertificate + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetCACertificatesResponse(struct soap *soap, const char *tag, int id, const struct _tds__GetCACertificatesResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetCACertificatesResponse), type))
		return soap->error;
	soap_element_result(soap, "-sizeCACertificate");
	if (a->CACertificate)
	{	int i;
		for (i = 0; i < a->__sizeCACertificate; i++)
			if (soap_out_tt__Certificate(soap, "tds:CACertificate", -1, a->CACertificate + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetCACertificatesResponse * SOAP_FMAC4 soap_in__tds__GetCACertificatesResponse(struct soap *soap, const char *tag, struct _tds__GetCACertificatesResponse *a, const char *type)
{
	struct soap_blist *soap_blist_CACertificate = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__GetCACertificatesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetCACertificatesResponse, sizeof(struct _tds__GetCACertificatesResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetCACertificatesResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tds:CACertificate", 1, NULL))
			{	if (a->CACertificate == NULL)
				{	if (soap_blist_CACertificate == NULL)
						soap_blist_CACertificate = soap_new_block(soap);
					a->CACertificate = (struct tt__Certificate *)soap_push_block(soap, soap_blist_CACertificate, sizeof(struct tt__Certificate));
					if (a->CACertificate == NULL)
						return NULL;
					soap_default_tt__Certificate(soap, a->CACertificate);
				}
				soap_revert(soap);
				if (soap_in_tt__Certificate(soap, "tds:CACertificate", a->CACertificate, "tt:Certificate"))
				{	a->__sizeCACertificate++;
					a->CACertificate = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizeCACertificate");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->CACertificate)
			soap_pop_block(soap, soap_blist_CACertificate);
		if (a->__sizeCACertificate)
			a->CACertificate = (struct tt__Certificate *)soap_save_block(soap, soap_blist_CACertificate, NULL, 1);
		else
		{	a->CACertificate = NULL;
			if (soap_blist_CACertificate)
				soap_end_block(soap, soap_blist_CACertificate);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__GetCACertificatesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetCACertificatesResponse, 0, sizeof(struct _tds__GetCACertificatesResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetCACertificatesResponse(struct soap *soap, const struct _tds__GetCACertificatesResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__GetCACertificatesResponse);
	if (soap_out__tds__GetCACertificatesResponse(soap, tag?tag:"tds:GetCACertificatesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetCACertificatesResponse * SOAP_FMAC4 soap_get__tds__GetCACertificatesResponse(struct soap *soap, struct _tds__GetCACertificatesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetCACertificatesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetCACertificates(struct soap *soap, struct _tds__GetCACertificates *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetCACertificates(struct soap *soap, const struct _tds__GetCACertificates *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetCACertificates(struct soap *soap, const char *tag, int id, const struct _tds__GetCACertificates *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetCACertificates), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetCACertificates * SOAP_FMAC4 soap_in__tds__GetCACertificates(struct soap *soap, const char *tag, struct _tds__GetCACertificates *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__GetCACertificates *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetCACertificates, sizeof(struct _tds__GetCACertificates), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetCACertificates(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__GetCACertificates *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetCACertificates, 0, sizeof(struct _tds__GetCACertificates), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetCACertificates(struct soap *soap, const struct _tds__GetCACertificates *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__GetCACertificates);
	if (soap_out__tds__GetCACertificates(soap, tag?tag:"tds:GetCACertificates", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetCACertificates * SOAP_FMAC4 soap_get__tds__GetCACertificates(struct soap *soap, struct _tds__GetCACertificates *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetCACertificates(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__SetClientCertificateModeResponse(struct soap *soap, struct _tds__SetClientCertificateModeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__SetClientCertificateModeResponse(struct soap *soap, const struct _tds__SetClientCertificateModeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetClientCertificateModeResponse(struct soap *soap, const char *tag, int id, const struct _tds__SetClientCertificateModeResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetClientCertificateModeResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__SetClientCertificateModeResponse * SOAP_FMAC4 soap_in__tds__SetClientCertificateModeResponse(struct soap *soap, const char *tag, struct _tds__SetClientCertificateModeResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__SetClientCertificateModeResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetClientCertificateModeResponse, sizeof(struct _tds__SetClientCertificateModeResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__SetClientCertificateModeResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__SetClientCertificateModeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetClientCertificateModeResponse, 0, sizeof(struct _tds__SetClientCertificateModeResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__SetClientCertificateModeResponse(struct soap *soap, const struct _tds__SetClientCertificateModeResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__SetClientCertificateModeResponse);
	if (soap_out__tds__SetClientCertificateModeResponse(soap, tag?tag:"tds:SetClientCertificateModeResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetClientCertificateModeResponse * SOAP_FMAC4 soap_get__tds__SetClientCertificateModeResponse(struct soap *soap, struct _tds__SetClientCertificateModeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetClientCertificateModeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__SetClientCertificateMode(struct soap *soap, struct _tds__SetClientCertificateMode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__boolean_(soap, &a->Enabled);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__SetClientCertificateMode(struct soap *soap, const struct _tds__SetClientCertificateMode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->Enabled, SOAP_TYPE_xsd__boolean_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetClientCertificateMode(struct soap *soap, const char *tag, int id, const struct _tds__SetClientCertificateMode *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetClientCertificateMode), type))
		return soap->error;
	if (soap_out_xsd__boolean_(soap, "tds:Enabled", -1, &a->Enabled, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__SetClientCertificateMode * SOAP_FMAC4 soap_in__tds__SetClientCertificateMode(struct soap *soap, const char *tag, struct _tds__SetClientCertificateMode *a, const char *type)
{
	size_t soap_flag_Enabled = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__SetClientCertificateMode *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetClientCertificateMode, sizeof(struct _tds__SetClientCertificateMode), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__SetClientCertificateMode(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Enabled && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean_(soap, "tds:Enabled", &a->Enabled, "xsd:boolean"))
				{	soap_flag_Enabled--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__SetClientCertificateMode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetClientCertificateMode, 0, sizeof(struct _tds__SetClientCertificateMode), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Enabled > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__SetClientCertificateMode(struct soap *soap, const struct _tds__SetClientCertificateMode *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__SetClientCertificateMode);
	if (soap_out__tds__SetClientCertificateMode(soap, tag?tag:"tds:SetClientCertificateMode", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetClientCertificateMode * SOAP_FMAC4 soap_get__tds__SetClientCertificateMode(struct soap *soap, struct _tds__SetClientCertificateMode *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetClientCertificateMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetClientCertificateModeResponse(struct soap *soap, struct _tds__GetClientCertificateModeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__boolean_(soap, &a->Enabled);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetClientCertificateModeResponse(struct soap *soap, const struct _tds__GetClientCertificateModeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->Enabled, SOAP_TYPE_xsd__boolean_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetClientCertificateModeResponse(struct soap *soap, const char *tag, int id, const struct _tds__GetClientCertificateModeResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetClientCertificateModeResponse), type))
		return soap->error;
	soap_element_result(soap, "tds:Enabled");
	if (soap_out_xsd__boolean_(soap, "tds:Enabled", -1, &a->Enabled, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetClientCertificateModeResponse * SOAP_FMAC4 soap_in__tds__GetClientCertificateModeResponse(struct soap *soap, const char *tag, struct _tds__GetClientCertificateModeResponse *a, const char *type)
{
	size_t soap_flag_Enabled = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__GetClientCertificateModeResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetClientCertificateModeResponse, sizeof(struct _tds__GetClientCertificateModeResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetClientCertificateModeResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Enabled && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean_(soap, "tds:Enabled", &a->Enabled, "xsd:boolean"))
				{	soap_flag_Enabled--;
					continue;
				}
			soap_check_result(soap, "tds:Enabled");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__GetClientCertificateModeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetClientCertificateModeResponse, 0, sizeof(struct _tds__GetClientCertificateModeResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Enabled > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetClientCertificateModeResponse(struct soap *soap, const struct _tds__GetClientCertificateModeResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__GetClientCertificateModeResponse);
	if (soap_out__tds__GetClientCertificateModeResponse(soap, tag?tag:"tds:GetClientCertificateModeResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetClientCertificateModeResponse * SOAP_FMAC4 soap_get__tds__GetClientCertificateModeResponse(struct soap *soap, struct _tds__GetClientCertificateModeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetClientCertificateModeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetClientCertificateMode(struct soap *soap, struct _tds__GetClientCertificateMode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetClientCertificateMode(struct soap *soap, const struct _tds__GetClientCertificateMode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetClientCertificateMode(struct soap *soap, const char *tag, int id, const struct _tds__GetClientCertificateMode *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetClientCertificateMode), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetClientCertificateMode * SOAP_FMAC4 soap_in__tds__GetClientCertificateMode(struct soap *soap, const char *tag, struct _tds__GetClientCertificateMode *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__GetClientCertificateMode *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetClientCertificateMode, sizeof(struct _tds__GetClientCertificateMode), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetClientCertificateMode(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__GetClientCertificateMode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetClientCertificateMode, 0, sizeof(struct _tds__GetClientCertificateMode), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetClientCertificateMode(struct soap *soap, const struct _tds__GetClientCertificateMode *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__GetClientCertificateMode);
	if (soap_out__tds__GetClientCertificateMode(soap, tag?tag:"tds:GetClientCertificateMode", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetClientCertificateMode * SOAP_FMAC4 soap_get__tds__GetClientCertificateMode(struct soap *soap, struct _tds__GetClientCertificateMode *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetClientCertificateMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__LoadCertificatesResponse(struct soap *soap, struct _tds__LoadCertificatesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__LoadCertificatesResponse(struct soap *soap, const struct _tds__LoadCertificatesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__LoadCertificatesResponse(struct soap *soap, const char *tag, int id, const struct _tds__LoadCertificatesResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__LoadCertificatesResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__LoadCertificatesResponse * SOAP_FMAC4 soap_in__tds__LoadCertificatesResponse(struct soap *soap, const char *tag, struct _tds__LoadCertificatesResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__LoadCertificatesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__LoadCertificatesResponse, sizeof(struct _tds__LoadCertificatesResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__LoadCertificatesResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__LoadCertificatesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__LoadCertificatesResponse, 0, sizeof(struct _tds__LoadCertificatesResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__LoadCertificatesResponse(struct soap *soap, const struct _tds__LoadCertificatesResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__LoadCertificatesResponse);
	if (soap_out__tds__LoadCertificatesResponse(soap, tag?tag:"tds:LoadCertificatesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__LoadCertificatesResponse * SOAP_FMAC4 soap_get__tds__LoadCertificatesResponse(struct soap *soap, struct _tds__LoadCertificatesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__LoadCertificatesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__LoadCertificates(struct soap *soap, struct _tds__LoadCertificates *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeNVTCertificate = 0;
	a->NVTCertificate = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__LoadCertificates(struct soap *soap, const struct _tds__LoadCertificates *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->NVTCertificate)
	{	int i;
		for (i = 0; i < a->__sizeNVTCertificate; i++)
		{
			soap_embedded(soap, a->NVTCertificate + i, SOAP_TYPE_tt__Certificate);
			soap_serialize_tt__Certificate(soap, a->NVTCertificate + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__LoadCertificates(struct soap *soap, const char *tag, int id, const struct _tds__LoadCertificates *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__LoadCertificates), type))
		return soap->error;
	if (a->NVTCertificate)
	{	int i;
		for (i = 0; i < a->__sizeNVTCertificate; i++)
			if (soap_out_tt__Certificate(soap, "tds:NVTCertificate", -1, a->NVTCertificate + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__LoadCertificates * SOAP_FMAC4 soap_in__tds__LoadCertificates(struct soap *soap, const char *tag, struct _tds__LoadCertificates *a, const char *type)
{
	struct soap_blist *soap_blist_NVTCertificate = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__LoadCertificates *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__LoadCertificates, sizeof(struct _tds__LoadCertificates), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__LoadCertificates(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tds:NVTCertificate", 1, NULL))
			{	if (a->NVTCertificate == NULL)
				{	if (soap_blist_NVTCertificate == NULL)
						soap_blist_NVTCertificate = soap_new_block(soap);
					a->NVTCertificate = (struct tt__Certificate *)soap_push_block(soap, soap_blist_NVTCertificate, sizeof(struct tt__Certificate));
					if (a->NVTCertificate == NULL)
						return NULL;
					soap_default_tt__Certificate(soap, a->NVTCertificate);
				}
				soap_revert(soap);
				if (soap_in_tt__Certificate(soap, "tds:NVTCertificate", a->NVTCertificate, "tt:Certificate"))
				{	a->__sizeNVTCertificate++;
					a->NVTCertificate = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->NVTCertificate)
			soap_pop_block(soap, soap_blist_NVTCertificate);
		if (a->__sizeNVTCertificate)
			a->NVTCertificate = (struct tt__Certificate *)soap_save_block(soap, soap_blist_NVTCertificate, NULL, 1);
		else
		{	a->NVTCertificate = NULL;
			if (soap_blist_NVTCertificate)
				soap_end_block(soap, soap_blist_NVTCertificate);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__LoadCertificates *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__LoadCertificates, 0, sizeof(struct _tds__LoadCertificates), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeNVTCertificate < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__LoadCertificates(struct soap *soap, const struct _tds__LoadCertificates *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__LoadCertificates);
	if (soap_out__tds__LoadCertificates(soap, tag?tag:"tds:LoadCertificates", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__LoadCertificates * SOAP_FMAC4 soap_get__tds__LoadCertificates(struct soap *soap, struct _tds__LoadCertificates *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__LoadCertificates(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetPkcs10RequestResponse(struct soap *soap, struct _tds__GetPkcs10RequestResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Pkcs10Request = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetPkcs10RequestResponse(struct soap *soap, const struct _tds__GetPkcs10RequestResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTott__BinaryData(soap, &a->Pkcs10Request);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetPkcs10RequestResponse(struct soap *soap, const char *tag, int id, const struct _tds__GetPkcs10RequestResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetPkcs10RequestResponse), type))
		return soap->error;
	if (a->Pkcs10Request)
		soap_element_result(soap, "tds:Pkcs10Request");
	if (a->Pkcs10Request)
	{	if (soap_out_PointerTott__BinaryData(soap, "tds:Pkcs10Request", -1, &a->Pkcs10Request, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tds:Pkcs10Request"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetPkcs10RequestResponse * SOAP_FMAC4 soap_in__tds__GetPkcs10RequestResponse(struct soap *soap, const char *tag, struct _tds__GetPkcs10RequestResponse *a, const char *type)
{
	size_t soap_flag_Pkcs10Request = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__GetPkcs10RequestResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetPkcs10RequestResponse, sizeof(struct _tds__GetPkcs10RequestResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetPkcs10RequestResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Pkcs10Request && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__BinaryData(soap, "tds:Pkcs10Request", &a->Pkcs10Request, "tt:BinaryData"))
				{	soap_flag_Pkcs10Request--;
					continue;
				}
			soap_check_result(soap, "tds:Pkcs10Request");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__GetPkcs10RequestResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetPkcs10RequestResponse, 0, sizeof(struct _tds__GetPkcs10RequestResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Pkcs10Request > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetPkcs10RequestResponse(struct soap *soap, const struct _tds__GetPkcs10RequestResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__GetPkcs10RequestResponse);
	if (soap_out__tds__GetPkcs10RequestResponse(soap, tag?tag:"tds:GetPkcs10RequestResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetPkcs10RequestResponse * SOAP_FMAC4 soap_get__tds__GetPkcs10RequestResponse(struct soap *soap, struct _tds__GetPkcs10RequestResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetPkcs10RequestResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetPkcs10Request(struct soap *soap, struct _tds__GetPkcs10Request *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__token(soap, &a->CertificateID);
	soap_default_string(soap, &a->Subject);
	a->Attributes = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetPkcs10Request(struct soap *soap, const struct _tds__GetPkcs10Request *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_xsd__token(soap, &a->CertificateID);
	soap_serialize_string(soap, &a->Subject);
	soap_serialize_PointerTott__BinaryData(soap, &a->Attributes);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetPkcs10Request(struct soap *soap, const char *tag, int id, const struct _tds__GetPkcs10Request *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetPkcs10Request), type))
		return soap->error;
	if (a->CertificateID)
	{	if (soap_out_xsd__token(soap, "tds:CertificateID", -1, &a->CertificateID, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tds:CertificateID"))
		return soap->error;
	if (soap_out_string(soap, "tds:Subject", -1, &a->Subject, ""))
		return soap->error;
	if (soap_out_PointerTott__BinaryData(soap, "tds:Attributes", -1, &a->Attributes, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetPkcs10Request * SOAP_FMAC4 soap_in__tds__GetPkcs10Request(struct soap *soap, const char *tag, struct _tds__GetPkcs10Request *a, const char *type)
{
	size_t soap_flag_CertificateID = 1;
	size_t soap_flag_Subject = 1;
	size_t soap_flag_Attributes = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__GetPkcs10Request *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetPkcs10Request, sizeof(struct _tds__GetPkcs10Request), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetPkcs10Request(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CertificateID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__token(soap, "tds:CertificateID", &a->CertificateID, "xsd:token"))
				{	soap_flag_CertificateID--;
					continue;
				}
			if (soap_flag_Subject && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "tds:Subject", &a->Subject, "xsd:string"))
				{	soap_flag_Subject--;
					continue;
				}
			if (soap_flag_Attributes && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__BinaryData(soap, "tds:Attributes", &a->Attributes, "tt:BinaryData"))
				{	soap_flag_Attributes--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__GetPkcs10Request *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetPkcs10Request, 0, sizeof(struct _tds__GetPkcs10Request), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_CertificateID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetPkcs10Request(struct soap *soap, const struct _tds__GetPkcs10Request *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__GetPkcs10Request);
	if (soap_out__tds__GetPkcs10Request(soap, tag?tag:"tds:GetPkcs10Request", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetPkcs10Request * SOAP_FMAC4 soap_get__tds__GetPkcs10Request(struct soap *soap, struct _tds__GetPkcs10Request *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetPkcs10Request(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__DeleteCertificatesResponse(struct soap *soap, struct _tds__DeleteCertificatesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__DeleteCertificatesResponse(struct soap *soap, const struct _tds__DeleteCertificatesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__DeleteCertificatesResponse(struct soap *soap, const char *tag, int id, const struct _tds__DeleteCertificatesResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__DeleteCertificatesResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__DeleteCertificatesResponse * SOAP_FMAC4 soap_in__tds__DeleteCertificatesResponse(struct soap *soap, const char *tag, struct _tds__DeleteCertificatesResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__DeleteCertificatesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__DeleteCertificatesResponse, sizeof(struct _tds__DeleteCertificatesResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__DeleteCertificatesResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__DeleteCertificatesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__DeleteCertificatesResponse, 0, sizeof(struct _tds__DeleteCertificatesResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__DeleteCertificatesResponse(struct soap *soap, const struct _tds__DeleteCertificatesResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__DeleteCertificatesResponse);
	if (soap_out__tds__DeleteCertificatesResponse(soap, tag?tag:"tds:DeleteCertificatesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__DeleteCertificatesResponse * SOAP_FMAC4 soap_get__tds__DeleteCertificatesResponse(struct soap *soap, struct _tds__DeleteCertificatesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__DeleteCertificatesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__DeleteCertificates(struct soap *soap, struct _tds__DeleteCertificates *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeCertificateID = 0;
	a->CertificateID = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__DeleteCertificates(struct soap *soap, const struct _tds__DeleteCertificates *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->CertificateID)
	{	int i;
		for (i = 0; i < a->__sizeCertificateID; i++)
		{
			soap_serialize_xsd__token(soap, a->CertificateID + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__DeleteCertificates(struct soap *soap, const char *tag, int id, const struct _tds__DeleteCertificates *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__DeleteCertificates), type))
		return soap->error;
	if (a->CertificateID)
	{	int i;
		for (i = 0; i < a->__sizeCertificateID; i++)
			if (soap_out_xsd__token(soap, "tds:CertificateID", -1, a->CertificateID + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__DeleteCertificates * SOAP_FMAC4 soap_in__tds__DeleteCertificates(struct soap *soap, const char *tag, struct _tds__DeleteCertificates *a, const char *type)
{
	struct soap_blist *soap_blist_CertificateID = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__DeleteCertificates *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__DeleteCertificates, sizeof(struct _tds__DeleteCertificates), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__DeleteCertificates(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tds:CertificateID", 1, NULL))
			{	if (a->CertificateID == NULL)
				{	if (soap_blist_CertificateID == NULL)
						soap_blist_CertificateID = soap_new_block(soap);
					a->CertificateID = (char **)soap_push_block(soap, soap_blist_CertificateID, sizeof(char *));
					if (a->CertificateID == NULL)
						return NULL;
					*a->CertificateID = NULL;
				}
				soap_revert(soap);
				if (soap_in_xsd__token(soap, "tds:CertificateID", a->CertificateID, "xsd:token"))
				{	a->__sizeCertificateID++;
					a->CertificateID = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->CertificateID)
			soap_pop_block(soap, soap_blist_CertificateID);
		if (a->__sizeCertificateID)
			a->CertificateID = (char **)soap_save_block(soap, soap_blist_CertificateID, NULL, 1);
		else
		{	a->CertificateID = NULL;
			if (soap_blist_CertificateID)
				soap_end_block(soap, soap_blist_CertificateID);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__DeleteCertificates *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__DeleteCertificates, 0, sizeof(struct _tds__DeleteCertificates), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeCertificateID < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__DeleteCertificates(struct soap *soap, const struct _tds__DeleteCertificates *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__DeleteCertificates);
	if (soap_out__tds__DeleteCertificates(soap, tag?tag:"tds:DeleteCertificates", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__DeleteCertificates * SOAP_FMAC4 soap_get__tds__DeleteCertificates(struct soap *soap, struct _tds__DeleteCertificates *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__DeleteCertificates(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__SetCertificatesStatusResponse(struct soap *soap, struct _tds__SetCertificatesStatusResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__SetCertificatesStatusResponse(struct soap *soap, const struct _tds__SetCertificatesStatusResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetCertificatesStatusResponse(struct soap *soap, const char *tag, int id, const struct _tds__SetCertificatesStatusResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetCertificatesStatusResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__SetCertificatesStatusResponse * SOAP_FMAC4 soap_in__tds__SetCertificatesStatusResponse(struct soap *soap, const char *tag, struct _tds__SetCertificatesStatusResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__SetCertificatesStatusResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetCertificatesStatusResponse, sizeof(struct _tds__SetCertificatesStatusResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__SetCertificatesStatusResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__SetCertificatesStatusResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetCertificatesStatusResponse, 0, sizeof(struct _tds__SetCertificatesStatusResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__SetCertificatesStatusResponse(struct soap *soap, const struct _tds__SetCertificatesStatusResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__SetCertificatesStatusResponse);
	if (soap_out__tds__SetCertificatesStatusResponse(soap, tag?tag:"tds:SetCertificatesStatusResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetCertificatesStatusResponse * SOAP_FMAC4 soap_get__tds__SetCertificatesStatusResponse(struct soap *soap, struct _tds__SetCertificatesStatusResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetCertificatesStatusResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__SetCertificatesStatus(struct soap *soap, struct _tds__SetCertificatesStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeCertificateStatus = 0;
	a->CertificateStatus = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__SetCertificatesStatus(struct soap *soap, const struct _tds__SetCertificatesStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->CertificateStatus)
	{	int i;
		for (i = 0; i < a->__sizeCertificateStatus; i++)
		{
			soap_embedded(soap, a->CertificateStatus + i, SOAP_TYPE_tt__CertificateStatus);
			soap_serialize_tt__CertificateStatus(soap, a->CertificateStatus + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetCertificatesStatus(struct soap *soap, const char *tag, int id, const struct _tds__SetCertificatesStatus *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetCertificatesStatus), type))
		return soap->error;
	if (a->CertificateStatus)
	{	int i;
		for (i = 0; i < a->__sizeCertificateStatus; i++)
			if (soap_out_tt__CertificateStatus(soap, "tds:CertificateStatus", -1, a->CertificateStatus + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__SetCertificatesStatus * SOAP_FMAC4 soap_in__tds__SetCertificatesStatus(struct soap *soap, const char *tag, struct _tds__SetCertificatesStatus *a, const char *type)
{
	struct soap_blist *soap_blist_CertificateStatus = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__SetCertificatesStatus *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetCertificatesStatus, sizeof(struct _tds__SetCertificatesStatus), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__SetCertificatesStatus(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tds:CertificateStatus", 1, NULL))
			{	if (a->CertificateStatus == NULL)
				{	if (soap_blist_CertificateStatus == NULL)
						soap_blist_CertificateStatus = soap_new_block(soap);
					a->CertificateStatus = (struct tt__CertificateStatus *)soap_push_block(soap, soap_blist_CertificateStatus, sizeof(struct tt__CertificateStatus));
					if (a->CertificateStatus == NULL)
						return NULL;
					soap_default_tt__CertificateStatus(soap, a->CertificateStatus);
				}
				soap_revert(soap);
				if (soap_in_tt__CertificateStatus(soap, "tds:CertificateStatus", a->CertificateStatus, "tt:CertificateStatus"))
				{	a->__sizeCertificateStatus++;
					a->CertificateStatus = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->CertificateStatus)
			soap_pop_block(soap, soap_blist_CertificateStatus);
		if (a->__sizeCertificateStatus)
			a->CertificateStatus = (struct tt__CertificateStatus *)soap_save_block(soap, soap_blist_CertificateStatus, NULL, 1);
		else
		{	a->CertificateStatus = NULL;
			if (soap_blist_CertificateStatus)
				soap_end_block(soap, soap_blist_CertificateStatus);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__SetCertificatesStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetCertificatesStatus, 0, sizeof(struct _tds__SetCertificatesStatus), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__SetCertificatesStatus(struct soap *soap, const struct _tds__SetCertificatesStatus *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__SetCertificatesStatus);
	if (soap_out__tds__SetCertificatesStatus(soap, tag?tag:"tds:SetCertificatesStatus", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetCertificatesStatus * SOAP_FMAC4 soap_get__tds__SetCertificatesStatus(struct soap *soap, struct _tds__SetCertificatesStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetCertificatesStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__CertificateStatus(struct soap *soap, struct tt__CertificateStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__token(soap, &a->CertificateID);
	soap_default_xsd__boolean_(soap, &a->Status);
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__CertificateStatus(struct soap *soap, const struct tt__CertificateStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_xsd__token(soap, &a->CertificateID);
	soap_embedded(soap, &a->Status, SOAP_TYPE_xsd__boolean_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__CertificateStatus(struct soap *soap, const char *tag, int id, const struct tt__CertificateStatus *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__CertificateStatus), type))
		return soap->error;
	if (a->CertificateID)
	{	if (soap_out_xsd__token(soap, "tt:CertificateID", -1, &a->CertificateID, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:CertificateID"))
		return soap->error;
	if (soap_out_xsd__boolean_(soap, "tt:Status", -1, &a->Status, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__CertificateStatus * SOAP_FMAC4 soap_in_tt__CertificateStatus(struct soap *soap, const char *tag, struct tt__CertificateStatus *a, const char *type)
{
	size_t soap_flag_CertificateID = 1;
	size_t soap_flag_Status = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__CertificateStatus *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__CertificateStatus, sizeof(struct tt__CertificateStatus), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__CertificateStatus(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CertificateID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__token(soap, "tt:CertificateID", &a->CertificateID, "xsd:token"))
				{	soap_flag_CertificateID--;
					continue;
				}
			if (soap_flag_Status && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean_(soap, "tt:Status", &a->Status, "xsd:boolean"))
				{	soap_flag_Status--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__CertificateStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__CertificateStatus, 0, sizeof(struct tt__CertificateStatus), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_CertificateID > 0 || soap_flag_Status > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__CertificateStatus(struct soap *soap, const struct tt__CertificateStatus *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__CertificateStatus);
	if (soap_out_tt__CertificateStatus(soap, tag?tag:"tt:CertificateStatus", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__CertificateStatus * SOAP_FMAC4 soap_get_tt__CertificateStatus(struct soap *soap, struct tt__CertificateStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__CertificateStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetCertificatesStatusResponse(struct soap *soap, struct _tds__GetCertificatesStatusResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeCertificateStatus = 0;
	a->CertificateStatus = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetCertificatesStatusResponse(struct soap *soap, const struct _tds__GetCertificatesStatusResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->CertificateStatus)
	{	int i;
		for (i = 0; i < a->__sizeCertificateStatus; i++)
		{
			soap_embedded(soap, a->CertificateStatus + i, SOAP_TYPE_tt__CertificateStatus);
			soap_serialize_tt__CertificateStatus(soap, a->CertificateStatus + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetCertificatesStatusResponse(struct soap *soap, const char *tag, int id, const struct _tds__GetCertificatesStatusResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetCertificatesStatusResponse), type))
		return soap->error;
	soap_element_result(soap, "-sizeCertificateStatus");
	if (a->CertificateStatus)
	{	int i;
		for (i = 0; i < a->__sizeCertificateStatus; i++)
			if (soap_out_tt__CertificateStatus(soap, "tds:CertificateStatus", -1, a->CertificateStatus + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetCertificatesStatusResponse * SOAP_FMAC4 soap_in__tds__GetCertificatesStatusResponse(struct soap *soap, const char *tag, struct _tds__GetCertificatesStatusResponse *a, const char *type)
{
	struct soap_blist *soap_blist_CertificateStatus = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__GetCertificatesStatusResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetCertificatesStatusResponse, sizeof(struct _tds__GetCertificatesStatusResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetCertificatesStatusResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tds:CertificateStatus", 1, NULL))
			{	if (a->CertificateStatus == NULL)
				{	if (soap_blist_CertificateStatus == NULL)
						soap_blist_CertificateStatus = soap_new_block(soap);
					a->CertificateStatus = (struct tt__CertificateStatus *)soap_push_block(soap, soap_blist_CertificateStatus, sizeof(struct tt__CertificateStatus));
					if (a->CertificateStatus == NULL)
						return NULL;
					soap_default_tt__CertificateStatus(soap, a->CertificateStatus);
				}
				soap_revert(soap);
				if (soap_in_tt__CertificateStatus(soap, "tds:CertificateStatus", a->CertificateStatus, "tt:CertificateStatus"))
				{	a->__sizeCertificateStatus++;
					a->CertificateStatus = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizeCertificateStatus");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->CertificateStatus)
			soap_pop_block(soap, soap_blist_CertificateStatus);
		if (a->__sizeCertificateStatus)
			a->CertificateStatus = (struct tt__CertificateStatus *)soap_save_block(soap, soap_blist_CertificateStatus, NULL, 1);
		else
		{	a->CertificateStatus = NULL;
			if (soap_blist_CertificateStatus)
				soap_end_block(soap, soap_blist_CertificateStatus);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__GetCertificatesStatusResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetCertificatesStatusResponse, 0, sizeof(struct _tds__GetCertificatesStatusResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetCertificatesStatusResponse(struct soap *soap, const struct _tds__GetCertificatesStatusResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__GetCertificatesStatusResponse);
	if (soap_out__tds__GetCertificatesStatusResponse(soap, tag?tag:"tds:GetCertificatesStatusResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetCertificatesStatusResponse * SOAP_FMAC4 soap_get__tds__GetCertificatesStatusResponse(struct soap *soap, struct _tds__GetCertificatesStatusResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetCertificatesStatusResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetCertificatesStatus(struct soap *soap, struct _tds__GetCertificatesStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetCertificatesStatus(struct soap *soap, const struct _tds__GetCertificatesStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetCertificatesStatus(struct soap *soap, const char *tag, int id, const struct _tds__GetCertificatesStatus *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetCertificatesStatus), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetCertificatesStatus * SOAP_FMAC4 soap_in__tds__GetCertificatesStatus(struct soap *soap, const char *tag, struct _tds__GetCertificatesStatus *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__GetCertificatesStatus *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetCertificatesStatus, sizeof(struct _tds__GetCertificatesStatus), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetCertificatesStatus(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__GetCertificatesStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetCertificatesStatus, 0, sizeof(struct _tds__GetCertificatesStatus), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetCertificatesStatus(struct soap *soap, const struct _tds__GetCertificatesStatus *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__GetCertificatesStatus);
	if (soap_out__tds__GetCertificatesStatus(soap, tag?tag:"tds:GetCertificatesStatus", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetCertificatesStatus * SOAP_FMAC4 soap_get__tds__GetCertificatesStatus(struct soap *soap, struct _tds__GetCertificatesStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetCertificatesStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetCertificatesResponse(struct soap *soap, struct _tds__GetCertificatesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeNvtCertificate = 0;
	a->NvtCertificate = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetCertificatesResponse(struct soap *soap, const struct _tds__GetCertificatesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->NvtCertificate)
	{	int i;
		for (i = 0; i < a->__sizeNvtCertificate; i++)
		{
			soap_embedded(soap, a->NvtCertificate + i, SOAP_TYPE_tt__Certificate);
			soap_serialize_tt__Certificate(soap, a->NvtCertificate + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetCertificatesResponse(struct soap *soap, const char *tag, int id, const struct _tds__GetCertificatesResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetCertificatesResponse), type))
		return soap->error;
	soap_element_result(soap, "-sizeNvtCertificate");
	if (a->NvtCertificate)
	{	int i;
		for (i = 0; i < a->__sizeNvtCertificate; i++)
			if (soap_out_tt__Certificate(soap, "tds:NvtCertificate", -1, a->NvtCertificate + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetCertificatesResponse * SOAP_FMAC4 soap_in__tds__GetCertificatesResponse(struct soap *soap, const char *tag, struct _tds__GetCertificatesResponse *a, const char *type)
{
	struct soap_blist *soap_blist_NvtCertificate = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__GetCertificatesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetCertificatesResponse, sizeof(struct _tds__GetCertificatesResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetCertificatesResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tds:NvtCertificate", 1, NULL))
			{	if (a->NvtCertificate == NULL)
				{	if (soap_blist_NvtCertificate == NULL)
						soap_blist_NvtCertificate = soap_new_block(soap);
					a->NvtCertificate = (struct tt__Certificate *)soap_push_block(soap, soap_blist_NvtCertificate, sizeof(struct tt__Certificate));
					if (a->NvtCertificate == NULL)
						return NULL;
					soap_default_tt__Certificate(soap, a->NvtCertificate);
				}
				soap_revert(soap);
				if (soap_in_tt__Certificate(soap, "tds:NvtCertificate", a->NvtCertificate, "tt:Certificate"))
				{	a->__sizeNvtCertificate++;
					a->NvtCertificate = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizeNvtCertificate");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->NvtCertificate)
			soap_pop_block(soap, soap_blist_NvtCertificate);
		if (a->__sizeNvtCertificate)
			a->NvtCertificate = (struct tt__Certificate *)soap_save_block(soap, soap_blist_NvtCertificate, NULL, 1);
		else
		{	a->NvtCertificate = NULL;
			if (soap_blist_NvtCertificate)
				soap_end_block(soap, soap_blist_NvtCertificate);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__GetCertificatesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetCertificatesResponse, 0, sizeof(struct _tds__GetCertificatesResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetCertificatesResponse(struct soap *soap, const struct _tds__GetCertificatesResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__GetCertificatesResponse);
	if (soap_out__tds__GetCertificatesResponse(soap, tag?tag:"tds:GetCertificatesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetCertificatesResponse * SOAP_FMAC4 soap_get__tds__GetCertificatesResponse(struct soap *soap, struct _tds__GetCertificatesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetCertificatesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetCertificates(struct soap *soap, struct _tds__GetCertificates *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetCertificates(struct soap *soap, const struct _tds__GetCertificates *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetCertificates(struct soap *soap, const char *tag, int id, const struct _tds__GetCertificates *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetCertificates), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetCertificates * SOAP_FMAC4 soap_in__tds__GetCertificates(struct soap *soap, const char *tag, struct _tds__GetCertificates *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__GetCertificates *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetCertificates, sizeof(struct _tds__GetCertificates), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetCertificates(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__GetCertificates *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetCertificates, 0, sizeof(struct _tds__GetCertificates), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetCertificates(struct soap *soap, const struct _tds__GetCertificates *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__GetCertificates);
	if (soap_out__tds__GetCertificates(soap, tag?tag:"tds:GetCertificates", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetCertificates * SOAP_FMAC4 soap_get__tds__GetCertificates(struct soap *soap, struct _tds__GetCertificates *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetCertificates(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__Certificate(struct soap *soap, struct tt__Certificate *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__token(soap, &a->CertificateID);
	a->Certificate = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__Certificate(struct soap *soap, const struct tt__Certificate *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_xsd__token(soap, &a->CertificateID);
	soap_serialize_PointerTott__BinaryData(soap, &a->Certificate);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Certificate(struct soap *soap, const char *tag, int id, const struct tt__Certificate *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Certificate), type))
		return soap->error;
	if (a->CertificateID)
	{	if (soap_out_xsd__token(soap, "tt:CertificateID", -1, &a->CertificateID, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:CertificateID"))
		return soap->error;
	if (a->Certificate)
	{	if (soap_out_PointerTott__BinaryData(soap, "tt:Certificate", -1, &a->Certificate, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:Certificate"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__Certificate * SOAP_FMAC4 soap_in_tt__Certificate(struct soap *soap, const char *tag, struct tt__Certificate *a, const char *type)
{
	size_t soap_flag_CertificateID = 1;
	size_t soap_flag_Certificate = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__Certificate *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Certificate, sizeof(struct tt__Certificate), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__Certificate(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CertificateID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__token(soap, "tt:CertificateID", &a->CertificateID, "xsd:token"))
				{	soap_flag_CertificateID--;
					continue;
				}
			if (soap_flag_Certificate && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__BinaryData(soap, "tt:Certificate", &a->Certificate, "tt:BinaryData"))
				{	soap_flag_Certificate--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__Certificate *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Certificate, 0, sizeof(struct tt__Certificate), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_CertificateID > 0 || soap_flag_Certificate > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Certificate(struct soap *soap, const struct tt__Certificate *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__Certificate);
	if (soap_out_tt__Certificate(soap, tag?tag:"tt:Certificate", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Certificate * SOAP_FMAC4 soap_get_tt__Certificate(struct soap *soap, struct tt__Certificate *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Certificate(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__CreateCertificateResponse(struct soap *soap, struct _tds__CreateCertificateResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->NvtCertificate = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__CreateCertificateResponse(struct soap *soap, const struct _tds__CreateCertificateResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTott__Certificate(soap, &a->NvtCertificate);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__CreateCertificateResponse(struct soap *soap, const char *tag, int id, const struct _tds__CreateCertificateResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__CreateCertificateResponse), type))
		return soap->error;
	if (a->NvtCertificate)
		soap_element_result(soap, "tds:NvtCertificate");
	if (a->NvtCertificate)
	{	if (soap_out_PointerTott__Certificate(soap, "tds:NvtCertificate", -1, &a->NvtCertificate, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tds:NvtCertificate"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__CreateCertificateResponse * SOAP_FMAC4 soap_in__tds__CreateCertificateResponse(struct soap *soap, const char *tag, struct _tds__CreateCertificateResponse *a, const char *type)
{
	size_t soap_flag_NvtCertificate = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__CreateCertificateResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__CreateCertificateResponse, sizeof(struct _tds__CreateCertificateResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__CreateCertificateResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_NvtCertificate && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__Certificate(soap, "tds:NvtCertificate", &a->NvtCertificate, "tt:Certificate"))
				{	soap_flag_NvtCertificate--;
					continue;
				}
			soap_check_result(soap, "tds:NvtCertificate");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__CreateCertificateResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__CreateCertificateResponse, 0, sizeof(struct _tds__CreateCertificateResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_NvtCertificate > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__CreateCertificateResponse(struct soap *soap, const struct _tds__CreateCertificateResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__CreateCertificateResponse);
	if (soap_out__tds__CreateCertificateResponse(soap, tag?tag:"tds:CreateCertificateResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__CreateCertificateResponse * SOAP_FMAC4 soap_get__tds__CreateCertificateResponse(struct soap *soap, struct _tds__CreateCertificateResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__CreateCertificateResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__CreateCertificate(struct soap *soap, struct _tds__CreateCertificate *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__token(soap, &a->CertificateID);
	soap_default_string(soap, &a->Subject);
	a->ValidNotBefore = NULL;
	a->ValidNotAfter = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__CreateCertificate(struct soap *soap, const struct _tds__CreateCertificate *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_xsd__token(soap, &a->CertificateID);
	soap_serialize_string(soap, &a->Subject);
	soap_serialize_PointerTotime(soap, &a->ValidNotBefore);
	soap_serialize_PointerTotime(soap, &a->ValidNotAfter);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__CreateCertificate(struct soap *soap, const char *tag, int id, const struct _tds__CreateCertificate *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__CreateCertificate), type))
		return soap->error;
	if (soap_out_xsd__token(soap, "tds:CertificateID", -1, &a->CertificateID, ""))
		return soap->error;
	if (soap_out_string(soap, "tds:Subject", -1, &a->Subject, ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "tds:ValidNotBefore", -1, &a->ValidNotBefore, ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "tds:ValidNotAfter", -1, &a->ValidNotAfter, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__CreateCertificate * SOAP_FMAC4 soap_in__tds__CreateCertificate(struct soap *soap, const char *tag, struct _tds__CreateCertificate *a, const char *type)
{
	size_t soap_flag_CertificateID = 1;
	size_t soap_flag_Subject = 1;
	size_t soap_flag_ValidNotBefore = 1;
	size_t soap_flag_ValidNotAfter = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__CreateCertificate *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__CreateCertificate, sizeof(struct _tds__CreateCertificate), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__CreateCertificate(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CertificateID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__token(soap, "tds:CertificateID", &a->CertificateID, "xsd:token"))
				{	soap_flag_CertificateID--;
					continue;
				}
			if (soap_flag_Subject && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "tds:Subject", &a->Subject, "xsd:string"))
				{	soap_flag_Subject--;
					continue;
				}
			if (soap_flag_ValidNotBefore && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "tds:ValidNotBefore", &a->ValidNotBefore, "xsd:dateTime"))
				{	soap_flag_ValidNotBefore--;
					continue;
				}
			if (soap_flag_ValidNotAfter && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "tds:ValidNotAfter", &a->ValidNotAfter, "xsd:dateTime"))
				{	soap_flag_ValidNotAfter--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__CreateCertificate *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__CreateCertificate, 0, sizeof(struct _tds__CreateCertificate), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__CreateCertificate(struct soap *soap, const struct _tds__CreateCertificate *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__CreateCertificate);
	if (soap_out__tds__CreateCertificate(soap, tag?tag:"tds:CreateCertificate", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__CreateCertificate * SOAP_FMAC4 soap_get__tds__CreateCertificate(struct soap *soap, struct _tds__CreateCertificate *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__CreateCertificate(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__SetAccessPolicyResponse(struct soap *soap, struct _tds__SetAccessPolicyResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__SetAccessPolicyResponse(struct soap *soap, const struct _tds__SetAccessPolicyResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetAccessPolicyResponse(struct soap *soap, const char *tag, int id, const struct _tds__SetAccessPolicyResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetAccessPolicyResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__SetAccessPolicyResponse * SOAP_FMAC4 soap_in__tds__SetAccessPolicyResponse(struct soap *soap, const char *tag, struct _tds__SetAccessPolicyResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__SetAccessPolicyResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetAccessPolicyResponse, sizeof(struct _tds__SetAccessPolicyResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__SetAccessPolicyResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__SetAccessPolicyResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetAccessPolicyResponse, 0, sizeof(struct _tds__SetAccessPolicyResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__SetAccessPolicyResponse(struct soap *soap, const struct _tds__SetAccessPolicyResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__SetAccessPolicyResponse);
	if (soap_out__tds__SetAccessPolicyResponse(soap, tag?tag:"tds:SetAccessPolicyResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetAccessPolicyResponse * SOAP_FMAC4 soap_get__tds__SetAccessPolicyResponse(struct soap *soap, struct _tds__SetAccessPolicyResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetAccessPolicyResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__SetAccessPolicy(struct soap *soap, struct _tds__SetAccessPolicy *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->PolicyFile = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__SetAccessPolicy(struct soap *soap, const struct _tds__SetAccessPolicy *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTott__BinaryData(soap, &a->PolicyFile);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetAccessPolicy(struct soap *soap, const char *tag, int id, const struct _tds__SetAccessPolicy *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetAccessPolicy), type))
		return soap->error;
	if (a->PolicyFile)
	{	if (soap_out_PointerTott__BinaryData(soap, "tds:PolicyFile", -1, &a->PolicyFile, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tds:PolicyFile"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__SetAccessPolicy * SOAP_FMAC4 soap_in__tds__SetAccessPolicy(struct soap *soap, const char *tag, struct _tds__SetAccessPolicy *a, const char *type)
{
	size_t soap_flag_PolicyFile = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__SetAccessPolicy *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetAccessPolicy, sizeof(struct _tds__SetAccessPolicy), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__SetAccessPolicy(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_PolicyFile && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__BinaryData(soap, "tds:PolicyFile", &a->PolicyFile, "tt:BinaryData"))
				{	soap_flag_PolicyFile--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__SetAccessPolicy *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetAccessPolicy, 0, sizeof(struct _tds__SetAccessPolicy), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_PolicyFile > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__SetAccessPolicy(struct soap *soap, const struct _tds__SetAccessPolicy *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__SetAccessPolicy);
	if (soap_out__tds__SetAccessPolicy(soap, tag?tag:"tds:SetAccessPolicy", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetAccessPolicy * SOAP_FMAC4 soap_get__tds__SetAccessPolicy(struct soap *soap, struct _tds__SetAccessPolicy *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetAccessPolicy(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__BinaryData(struct soap *soap, struct tt__BinaryData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Data);
	soap_default__xmime__contentType(soap, &a->xmime__contentType);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__BinaryData(struct soap *soap, const struct tt__BinaryData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Data);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__BinaryData(struct soap *soap, const char *tag, int id, const struct tt__BinaryData *a, const char *type)
{
	if (a->xmime__contentType)
		soap_set_attr(soap, "xmime:contentType", a->xmime__contentType, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__BinaryData), type))
		return soap->error;
	if (a->Data)
	{	if (soap_out_string(soap, "tt:Data", -1, &a->Data, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:Data"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__BinaryData * SOAP_FMAC4 soap_in_tt__BinaryData(struct soap *soap, const char *tag, struct tt__BinaryData *a, const char *type)
{
	size_t soap_flag_Data = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__BinaryData *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__BinaryData, sizeof(struct tt__BinaryData), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__BinaryData(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "xmime:contentType", 0), &a->xmime__contentType, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Data && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "tt:Data", &a->Data, "xsd:string"))
				{	soap_flag_Data--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__BinaryData *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__BinaryData, 0, sizeof(struct tt__BinaryData), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Data > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__BinaryData(struct soap *soap, const struct tt__BinaryData *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__BinaryData);
	if (soap_out_tt__BinaryData(soap, tag?tag:"tt:BinaryData", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__BinaryData * SOAP_FMAC4 soap_get_tt__BinaryData(struct soap *soap, struct tt__BinaryData *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__BinaryData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetAccessPolicyResponse(struct soap *soap, struct _tds__GetAccessPolicyResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->PolicyFile = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetAccessPolicyResponse(struct soap *soap, const struct _tds__GetAccessPolicyResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTott__BinaryData(soap, &a->PolicyFile);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetAccessPolicyResponse(struct soap *soap, const char *tag, int id, const struct _tds__GetAccessPolicyResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetAccessPolicyResponse), type))
		return soap->error;
	if (a->PolicyFile)
		soap_element_result(soap, "tds:PolicyFile");
	if (a->PolicyFile)
	{	if (soap_out_PointerTott__BinaryData(soap, "tds:PolicyFile", -1, &a->PolicyFile, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tds:PolicyFile"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetAccessPolicyResponse * SOAP_FMAC4 soap_in__tds__GetAccessPolicyResponse(struct soap *soap, const char *tag, struct _tds__GetAccessPolicyResponse *a, const char *type)
{
	size_t soap_flag_PolicyFile = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__GetAccessPolicyResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetAccessPolicyResponse, sizeof(struct _tds__GetAccessPolicyResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetAccessPolicyResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_PolicyFile && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__BinaryData(soap, "tds:PolicyFile", &a->PolicyFile, "tt:BinaryData"))
				{	soap_flag_PolicyFile--;
					continue;
				}
			soap_check_result(soap, "tds:PolicyFile");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__GetAccessPolicyResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetAccessPolicyResponse, 0, sizeof(struct _tds__GetAccessPolicyResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_PolicyFile > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetAccessPolicyResponse(struct soap *soap, const struct _tds__GetAccessPolicyResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__GetAccessPolicyResponse);
	if (soap_out__tds__GetAccessPolicyResponse(soap, tag?tag:"tds:GetAccessPolicyResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetAccessPolicyResponse * SOAP_FMAC4 soap_get__tds__GetAccessPolicyResponse(struct soap *soap, struct _tds__GetAccessPolicyResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetAccessPolicyResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetAccessPolicy(struct soap *soap, struct _tds__GetAccessPolicy *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetAccessPolicy(struct soap *soap, const struct _tds__GetAccessPolicy *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetAccessPolicy(struct soap *soap, const char *tag, int id, const struct _tds__GetAccessPolicy *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetAccessPolicy), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetAccessPolicy * SOAP_FMAC4 soap_in__tds__GetAccessPolicy(struct soap *soap, const char *tag, struct _tds__GetAccessPolicy *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__GetAccessPolicy *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetAccessPolicy, sizeof(struct _tds__GetAccessPolicy), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetAccessPolicy(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__GetAccessPolicy *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetAccessPolicy, 0, sizeof(struct _tds__GetAccessPolicy), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetAccessPolicy(struct soap *soap, const struct _tds__GetAccessPolicy *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__GetAccessPolicy);
	if (soap_out__tds__GetAccessPolicy(soap, tag?tag:"tds:GetAccessPolicy", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetAccessPolicy * SOAP_FMAC4 soap_get__tds__GetAccessPolicy(struct soap *soap, struct _tds__GetAccessPolicy *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetAccessPolicy(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__RemoveIPAddressFilterResponse(struct soap *soap, struct _tds__RemoveIPAddressFilterResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__RemoveIPAddressFilterResponse(struct soap *soap, const struct _tds__RemoveIPAddressFilterResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__RemoveIPAddressFilterResponse(struct soap *soap, const char *tag, int id, const struct _tds__RemoveIPAddressFilterResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__RemoveIPAddressFilterResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__RemoveIPAddressFilterResponse * SOAP_FMAC4 soap_in__tds__RemoveIPAddressFilterResponse(struct soap *soap, const char *tag, struct _tds__RemoveIPAddressFilterResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__RemoveIPAddressFilterResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__RemoveIPAddressFilterResponse, sizeof(struct _tds__RemoveIPAddressFilterResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__RemoveIPAddressFilterResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__RemoveIPAddressFilterResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__RemoveIPAddressFilterResponse, 0, sizeof(struct _tds__RemoveIPAddressFilterResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__RemoveIPAddressFilterResponse(struct soap *soap, const struct _tds__RemoveIPAddressFilterResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__RemoveIPAddressFilterResponse);
	if (soap_out__tds__RemoveIPAddressFilterResponse(soap, tag?tag:"tds:RemoveIPAddressFilterResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__RemoveIPAddressFilterResponse * SOAP_FMAC4 soap_get__tds__RemoveIPAddressFilterResponse(struct soap *soap, struct _tds__RemoveIPAddressFilterResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__RemoveIPAddressFilterResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__RemoveIPAddressFilter(struct soap *soap, struct _tds__RemoveIPAddressFilter *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->IPAddressFilter = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__RemoveIPAddressFilter(struct soap *soap, const struct _tds__RemoveIPAddressFilter *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTott__IPAddressFilter(soap, &a->IPAddressFilter);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__RemoveIPAddressFilter(struct soap *soap, const char *tag, int id, const struct _tds__RemoveIPAddressFilter *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__RemoveIPAddressFilter), type))
		return soap->error;
	if (a->IPAddressFilter)
	{	if (soap_out_PointerTott__IPAddressFilter(soap, "tds:IPAddressFilter", -1, &a->IPAddressFilter, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tds:IPAddressFilter"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__RemoveIPAddressFilter * SOAP_FMAC4 soap_in__tds__RemoveIPAddressFilter(struct soap *soap, const char *tag, struct _tds__RemoveIPAddressFilter *a, const char *type)
{
	size_t soap_flag_IPAddressFilter = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__RemoveIPAddressFilter *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__RemoveIPAddressFilter, sizeof(struct _tds__RemoveIPAddressFilter), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__RemoveIPAddressFilter(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_IPAddressFilter && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IPAddressFilter(soap, "tds:IPAddressFilter", &a->IPAddressFilter, "tt:IPAddressFilter"))
				{	soap_flag_IPAddressFilter--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__RemoveIPAddressFilter *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__RemoveIPAddressFilter, 0, sizeof(struct _tds__RemoveIPAddressFilter), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_IPAddressFilter > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__RemoveIPAddressFilter(struct soap *soap, const struct _tds__RemoveIPAddressFilter *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__RemoveIPAddressFilter);
	if (soap_out__tds__RemoveIPAddressFilter(soap, tag?tag:"tds:RemoveIPAddressFilter", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__RemoveIPAddressFilter * SOAP_FMAC4 soap_get__tds__RemoveIPAddressFilter(struct soap *soap, struct _tds__RemoveIPAddressFilter *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__RemoveIPAddressFilter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__AddIPAddressFilterResponse(struct soap *soap, struct _tds__AddIPAddressFilterResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__AddIPAddressFilterResponse(struct soap *soap, const struct _tds__AddIPAddressFilterResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__AddIPAddressFilterResponse(struct soap *soap, const char *tag, int id, const struct _tds__AddIPAddressFilterResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__AddIPAddressFilterResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__AddIPAddressFilterResponse * SOAP_FMAC4 soap_in__tds__AddIPAddressFilterResponse(struct soap *soap, const char *tag, struct _tds__AddIPAddressFilterResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__AddIPAddressFilterResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__AddIPAddressFilterResponse, sizeof(struct _tds__AddIPAddressFilterResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__AddIPAddressFilterResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__AddIPAddressFilterResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__AddIPAddressFilterResponse, 0, sizeof(struct _tds__AddIPAddressFilterResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__AddIPAddressFilterResponse(struct soap *soap, const struct _tds__AddIPAddressFilterResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__AddIPAddressFilterResponse);
	if (soap_out__tds__AddIPAddressFilterResponse(soap, tag?tag:"tds:AddIPAddressFilterResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__AddIPAddressFilterResponse * SOAP_FMAC4 soap_get__tds__AddIPAddressFilterResponse(struct soap *soap, struct _tds__AddIPAddressFilterResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__AddIPAddressFilterResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__AddIPAddressFilter(struct soap *soap, struct _tds__AddIPAddressFilter *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->IPAddressFilter = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__AddIPAddressFilter(struct soap *soap, const struct _tds__AddIPAddressFilter *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTott__IPAddressFilter(soap, &a->IPAddressFilter);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__AddIPAddressFilter(struct soap *soap, const char *tag, int id, const struct _tds__AddIPAddressFilter *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__AddIPAddressFilter), type))
		return soap->error;
	if (a->IPAddressFilter)
	{	if (soap_out_PointerTott__IPAddressFilter(soap, "tds:IPAddressFilter", -1, &a->IPAddressFilter, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tds:IPAddressFilter"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__AddIPAddressFilter * SOAP_FMAC4 soap_in__tds__AddIPAddressFilter(struct soap *soap, const char *tag, struct _tds__AddIPAddressFilter *a, const char *type)
{
	size_t soap_flag_IPAddressFilter = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__AddIPAddressFilter *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__AddIPAddressFilter, sizeof(struct _tds__AddIPAddressFilter), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__AddIPAddressFilter(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_IPAddressFilter && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IPAddressFilter(soap, "tds:IPAddressFilter", &a->IPAddressFilter, "tt:IPAddressFilter"))
				{	soap_flag_IPAddressFilter--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__AddIPAddressFilter *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__AddIPAddressFilter, 0, sizeof(struct _tds__AddIPAddressFilter), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_IPAddressFilter > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__AddIPAddressFilter(struct soap *soap, const struct _tds__AddIPAddressFilter *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__AddIPAddressFilter);
	if (soap_out__tds__AddIPAddressFilter(soap, tag?tag:"tds:AddIPAddressFilter", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__AddIPAddressFilter * SOAP_FMAC4 soap_get__tds__AddIPAddressFilter(struct soap *soap, struct _tds__AddIPAddressFilter *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__AddIPAddressFilter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__SetIPAddressFilterResponse(struct soap *soap, struct _tds__SetIPAddressFilterResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__SetIPAddressFilterResponse(struct soap *soap, const struct _tds__SetIPAddressFilterResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetIPAddressFilterResponse(struct soap *soap, const char *tag, int id, const struct _tds__SetIPAddressFilterResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetIPAddressFilterResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__SetIPAddressFilterResponse * SOAP_FMAC4 soap_in__tds__SetIPAddressFilterResponse(struct soap *soap, const char *tag, struct _tds__SetIPAddressFilterResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__SetIPAddressFilterResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetIPAddressFilterResponse, sizeof(struct _tds__SetIPAddressFilterResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__SetIPAddressFilterResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__SetIPAddressFilterResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetIPAddressFilterResponse, 0, sizeof(struct _tds__SetIPAddressFilterResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__SetIPAddressFilterResponse(struct soap *soap, const struct _tds__SetIPAddressFilterResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__SetIPAddressFilterResponse);
	if (soap_out__tds__SetIPAddressFilterResponse(soap, tag?tag:"tds:SetIPAddressFilterResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetIPAddressFilterResponse * SOAP_FMAC4 soap_get__tds__SetIPAddressFilterResponse(struct soap *soap, struct _tds__SetIPAddressFilterResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetIPAddressFilterResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__SetIPAddressFilter(struct soap *soap, struct _tds__SetIPAddressFilter *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->IPAddressFilter = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__SetIPAddressFilter(struct soap *soap, const struct _tds__SetIPAddressFilter *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTott__IPAddressFilter(soap, &a->IPAddressFilter);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetIPAddressFilter(struct soap *soap, const char *tag, int id, const struct _tds__SetIPAddressFilter *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetIPAddressFilter), type))
		return soap->error;
	if (a->IPAddressFilter)
	{	if (soap_out_PointerTott__IPAddressFilter(soap, "tds:IPAddressFilter", -1, &a->IPAddressFilter, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tds:IPAddressFilter"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__SetIPAddressFilter * SOAP_FMAC4 soap_in__tds__SetIPAddressFilter(struct soap *soap, const char *tag, struct _tds__SetIPAddressFilter *a, const char *type)
{
	size_t soap_flag_IPAddressFilter = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__SetIPAddressFilter *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetIPAddressFilter, sizeof(struct _tds__SetIPAddressFilter), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__SetIPAddressFilter(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_IPAddressFilter && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IPAddressFilter(soap, "tds:IPAddressFilter", &a->IPAddressFilter, "tt:IPAddressFilter"))
				{	soap_flag_IPAddressFilter--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__SetIPAddressFilter *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetIPAddressFilter, 0, sizeof(struct _tds__SetIPAddressFilter), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_IPAddressFilter > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__SetIPAddressFilter(struct soap *soap, const struct _tds__SetIPAddressFilter *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__SetIPAddressFilter);
	if (soap_out__tds__SetIPAddressFilter(soap, tag?tag:"tds:SetIPAddressFilter", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetIPAddressFilter * SOAP_FMAC4 soap_get__tds__SetIPAddressFilter(struct soap *soap, struct _tds__SetIPAddressFilter *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetIPAddressFilter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__IPAddressFilter(struct soap *soap, struct tt__IPAddressFilter *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__IPAddressFilterType(soap, &a->Type);
	a->__sizeIPv4Address = 0;
	a->IPv4Address = NULL;
	a->__sizeIPv6Address = 0;
	a->IPv6Address = NULL;
	a->Extension = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__IPAddressFilter(struct soap *soap, const struct tt__IPAddressFilter *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->IPv4Address)
	{	int i;
		for (i = 0; i < a->__sizeIPv4Address; i++)
		{
			soap_embedded(soap, a->IPv4Address + i, SOAP_TYPE_tt__PrefixedIPv4Address);
			soap_serialize_tt__PrefixedIPv4Address(soap, a->IPv4Address + i);
		}
	}
	if (a->IPv6Address)
	{	int i;
		for (i = 0; i < a->__sizeIPv6Address; i++)
		{
			soap_embedded(soap, a->IPv6Address + i, SOAP_TYPE_tt__PrefixedIPv6Address);
			soap_serialize_tt__PrefixedIPv6Address(soap, a->IPv6Address + i);
		}
	}
	soap_serialize_PointerTott__IPAddressFilterExtension(soap, &a->Extension);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IPAddressFilter(struct soap *soap, const char *tag, int id, const struct tt__IPAddressFilter *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__IPAddressFilter), type))
		return soap->error;
	if (soap_out_tt__IPAddressFilterType(soap, "tt:Type", -1, &a->Type, ""))
		return soap->error;
	if (a->IPv4Address)
	{	int i;
		for (i = 0; i < a->__sizeIPv4Address; i++)
			if (soap_out_tt__PrefixedIPv4Address(soap, "tt:IPv4Address", -1, a->IPv4Address + i, ""))
				return soap->error;
	}
	if (a->IPv6Address)
	{	int i;
		for (i = 0; i < a->__sizeIPv6Address; i++)
			if (soap_out_tt__PrefixedIPv6Address(soap, "tt:IPv6Address", -1, a->IPv6Address + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTott__IPAddressFilterExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__IPAddressFilter * SOAP_FMAC4 soap_in_tt__IPAddressFilter(struct soap *soap, const char *tag, struct tt__IPAddressFilter *a, const char *type)
{
	size_t soap_flag_Type = 1;
	struct soap_blist *soap_blist_IPv4Address = NULL;
	struct soap_blist *soap_blist_IPv6Address = NULL;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__IPAddressFilter *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IPAddressFilter, sizeof(struct tt__IPAddressFilter), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__IPAddressFilter(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Type && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_tt__IPAddressFilterType(soap, "tt:Type", &a->Type, "tt:IPAddressFilterType"))
				{	soap_flag_Type--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:IPv4Address", 1, NULL))
			{	if (a->IPv4Address == NULL)
				{	if (soap_blist_IPv4Address == NULL)
						soap_blist_IPv4Address = soap_new_block(soap);
					a->IPv4Address = (struct tt__PrefixedIPv4Address *)soap_push_block(soap, soap_blist_IPv4Address, sizeof(struct tt__PrefixedIPv4Address));
					if (a->IPv4Address == NULL)
						return NULL;
					soap_default_tt__PrefixedIPv4Address(soap, a->IPv4Address);
				}
				soap_revert(soap);
				if (soap_in_tt__PrefixedIPv4Address(soap, "tt:IPv4Address", a->IPv4Address, "tt:PrefixedIPv4Address"))
				{	a->__sizeIPv4Address++;
					a->IPv4Address = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:IPv6Address", 1, NULL))
			{	if (a->IPv6Address == NULL)
				{	if (soap_blist_IPv6Address == NULL)
						soap_blist_IPv6Address = soap_new_block(soap);
					a->IPv6Address = (struct tt__PrefixedIPv6Address *)soap_push_block(soap, soap_blist_IPv6Address, sizeof(struct tt__PrefixedIPv6Address));
					if (a->IPv6Address == NULL)
						return NULL;
					soap_default_tt__PrefixedIPv6Address(soap, a->IPv6Address);
				}
				soap_revert(soap);
				if (soap_in_tt__PrefixedIPv6Address(soap, "tt:IPv6Address", a->IPv6Address, "tt:PrefixedIPv6Address"))
				{	a->__sizeIPv6Address++;
					a->IPv6Address = NULL;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IPAddressFilterExtension(soap, "tt:Extension", &a->Extension, "tt:IPAddressFilterExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->IPv4Address)
			soap_pop_block(soap, soap_blist_IPv4Address);
		if (a->__sizeIPv4Address)
			a->IPv4Address = (struct tt__PrefixedIPv4Address *)soap_save_block(soap, soap_blist_IPv4Address, NULL, 1);
		else
		{	a->IPv4Address = NULL;
			if (soap_blist_IPv4Address)
				soap_end_block(soap, soap_blist_IPv4Address);
		}
		if (a->IPv6Address)
			soap_pop_block(soap, soap_blist_IPv6Address);
		if (a->__sizeIPv6Address)
			a->IPv6Address = (struct tt__PrefixedIPv6Address *)soap_save_block(soap, soap_blist_IPv6Address, NULL, 1);
		else
		{	a->IPv6Address = NULL;
			if (soap_blist_IPv6Address)
				soap_end_block(soap, soap_blist_IPv6Address);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__IPAddressFilter *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__IPAddressFilter, 0, sizeof(struct tt__IPAddressFilter), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Type > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__IPAddressFilter(struct soap *soap, const struct tt__IPAddressFilter *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__IPAddressFilter);
	if (soap_out_tt__IPAddressFilter(soap, tag?tag:"tt:IPAddressFilter", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__IPAddressFilter * SOAP_FMAC4 soap_get_tt__IPAddressFilter(struct soap *soap, struct tt__IPAddressFilter *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__IPAddressFilter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetIPAddressFilterResponse(struct soap *soap, struct _tds__GetIPAddressFilterResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->IPAddressFilter = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetIPAddressFilterResponse(struct soap *soap, const struct _tds__GetIPAddressFilterResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTott__IPAddressFilter(soap, &a->IPAddressFilter);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetIPAddressFilterResponse(struct soap *soap, const char *tag, int id, const struct _tds__GetIPAddressFilterResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetIPAddressFilterResponse), type))
		return soap->error;
	if (a->IPAddressFilter)
		soap_element_result(soap, "tds:IPAddressFilter");
	if (a->IPAddressFilter)
	{	if (soap_out_PointerTott__IPAddressFilter(soap, "tds:IPAddressFilter", -1, &a->IPAddressFilter, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tds:IPAddressFilter"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetIPAddressFilterResponse * SOAP_FMAC4 soap_in__tds__GetIPAddressFilterResponse(struct soap *soap, const char *tag, struct _tds__GetIPAddressFilterResponse *a, const char *type)
{
	size_t soap_flag_IPAddressFilter = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__GetIPAddressFilterResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetIPAddressFilterResponse, sizeof(struct _tds__GetIPAddressFilterResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetIPAddressFilterResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_IPAddressFilter && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IPAddressFilter(soap, "tds:IPAddressFilter", &a->IPAddressFilter, "tt:IPAddressFilter"))
				{	soap_flag_IPAddressFilter--;
					continue;
				}
			soap_check_result(soap, "tds:IPAddressFilter");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__GetIPAddressFilterResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetIPAddressFilterResponse, 0, sizeof(struct _tds__GetIPAddressFilterResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_IPAddressFilter > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetIPAddressFilterResponse(struct soap *soap, const struct _tds__GetIPAddressFilterResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__GetIPAddressFilterResponse);
	if (soap_out__tds__GetIPAddressFilterResponse(soap, tag?tag:"tds:GetIPAddressFilterResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetIPAddressFilterResponse * SOAP_FMAC4 soap_get__tds__GetIPAddressFilterResponse(struct soap *soap, struct _tds__GetIPAddressFilterResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetIPAddressFilterResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetIPAddressFilter(struct soap *soap, struct _tds__GetIPAddressFilter *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetIPAddressFilter(struct soap *soap, const struct _tds__GetIPAddressFilter *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetIPAddressFilter(struct soap *soap, const char *tag, int id, const struct _tds__GetIPAddressFilter *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetIPAddressFilter), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetIPAddressFilter * SOAP_FMAC4 soap_in__tds__GetIPAddressFilter(struct soap *soap, const char *tag, struct _tds__GetIPAddressFilter *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__GetIPAddressFilter *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetIPAddressFilter, sizeof(struct _tds__GetIPAddressFilter), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetIPAddressFilter(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__GetIPAddressFilter *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetIPAddressFilter, 0, sizeof(struct _tds__GetIPAddressFilter), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetIPAddressFilter(struct soap *soap, const struct _tds__GetIPAddressFilter *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__GetIPAddressFilter);
	if (soap_out__tds__GetIPAddressFilter(soap, tag?tag:"tds:GetIPAddressFilter", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetIPAddressFilter * SOAP_FMAC4 soap_get__tds__GetIPAddressFilter(struct soap *soap, struct _tds__GetIPAddressFilter *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetIPAddressFilter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__SetZeroConfigurationResponse(struct soap *soap, struct _tds__SetZeroConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__SetZeroConfigurationResponse(struct soap *soap, const struct _tds__SetZeroConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetZeroConfigurationResponse(struct soap *soap, const char *tag, int id, const struct _tds__SetZeroConfigurationResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetZeroConfigurationResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__SetZeroConfigurationResponse * SOAP_FMAC4 soap_in__tds__SetZeroConfigurationResponse(struct soap *soap, const char *tag, struct _tds__SetZeroConfigurationResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__SetZeroConfigurationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetZeroConfigurationResponse, sizeof(struct _tds__SetZeroConfigurationResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__SetZeroConfigurationResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__SetZeroConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetZeroConfigurationResponse, 0, sizeof(struct _tds__SetZeroConfigurationResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__SetZeroConfigurationResponse(struct soap *soap, const struct _tds__SetZeroConfigurationResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__SetZeroConfigurationResponse);
	if (soap_out__tds__SetZeroConfigurationResponse(soap, tag?tag:"tds:SetZeroConfigurationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetZeroConfigurationResponse * SOAP_FMAC4 soap_get__tds__SetZeroConfigurationResponse(struct soap *soap, struct _tds__SetZeroConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetZeroConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__SetZeroConfiguration(struct soap *soap, struct _tds__SetZeroConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->InterfaceToken);
	soap_default_xsd__boolean_(soap, &a->Enabled);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__SetZeroConfiguration(struct soap *soap, const struct _tds__SetZeroConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_tt__ReferenceToken(soap, &a->InterfaceToken);
	soap_embedded(soap, &a->Enabled, SOAP_TYPE_xsd__boolean_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetZeroConfiguration(struct soap *soap, const char *tag, int id, const struct _tds__SetZeroConfiguration *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetZeroConfiguration), type))
		return soap->error;
	if (a->InterfaceToken)
	{	if (soap_out_tt__ReferenceToken(soap, "tds:InterfaceToken", -1, &a->InterfaceToken, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tds:InterfaceToken"))
		return soap->error;
	if (soap_out_xsd__boolean_(soap, "tds:Enabled", -1, &a->Enabled, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__SetZeroConfiguration * SOAP_FMAC4 soap_in__tds__SetZeroConfiguration(struct soap *soap, const char *tag, struct _tds__SetZeroConfiguration *a, const char *type)
{
	size_t soap_flag_InterfaceToken = 1;
	size_t soap_flag_Enabled = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__SetZeroConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetZeroConfiguration, sizeof(struct _tds__SetZeroConfiguration), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__SetZeroConfiguration(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_InterfaceToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "tds:InterfaceToken", &a->InterfaceToken, "tt:ReferenceToken"))
				{	soap_flag_InterfaceToken--;
					continue;
				}
			if (soap_flag_Enabled && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean_(soap, "tds:Enabled", &a->Enabled, "xsd:boolean"))
				{	soap_flag_Enabled--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__SetZeroConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetZeroConfiguration, 0, sizeof(struct _tds__SetZeroConfiguration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_InterfaceToken > 0 || soap_flag_Enabled > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__SetZeroConfiguration(struct soap *soap, const struct _tds__SetZeroConfiguration *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__SetZeroConfiguration);
	if (soap_out__tds__SetZeroConfiguration(soap, tag?tag:"tds:SetZeroConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetZeroConfiguration * SOAP_FMAC4 soap_get__tds__SetZeroConfiguration(struct soap *soap, struct _tds__SetZeroConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetZeroConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__NetworkZeroConfiguration(struct soap *soap, struct tt__NetworkZeroConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->InterfaceToken);
	soap_default_xsd__boolean_(soap, &a->Enabled);
	a->__sizeAddresses = 0;
	a->Addresses = NULL;
	a->Extension = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__NetworkZeroConfiguration(struct soap *soap, const struct tt__NetworkZeroConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_tt__ReferenceToken(soap, &a->InterfaceToken);
	soap_embedded(soap, &a->Enabled, SOAP_TYPE_xsd__boolean_);
	if (a->Addresses)
	{	int i;
		for (i = 0; i < a->__sizeAddresses; i++)
		{
			soap_serialize_tt__IPv4Address(soap, a->Addresses + i);
		}
	}
	soap_serialize_PointerTott__NetworkZeroConfigurationExtension(soap, &a->Extension);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__NetworkZeroConfiguration(struct soap *soap, const char *tag, int id, const struct tt__NetworkZeroConfiguration *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__NetworkZeroConfiguration), type))
		return soap->error;
	if (a->InterfaceToken)
	{	if (soap_out_tt__ReferenceToken(soap, "tt:InterfaceToken", -1, &a->InterfaceToken, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:InterfaceToken"))
		return soap->error;
	if (soap_out_xsd__boolean_(soap, "tt:Enabled", -1, &a->Enabled, ""))
		return soap->error;
	if (a->Addresses)
	{	int i;
		for (i = 0; i < a->__sizeAddresses; i++)
			if (soap_out_tt__IPv4Address(soap, "tt:Addresses", -1, a->Addresses + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTott__NetworkZeroConfigurationExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__NetworkZeroConfiguration * SOAP_FMAC4 soap_in_tt__NetworkZeroConfiguration(struct soap *soap, const char *tag, struct tt__NetworkZeroConfiguration *a, const char *type)
{
	size_t soap_flag_InterfaceToken = 1;
	size_t soap_flag_Enabled = 1;
	struct soap_blist *soap_blist_Addresses = NULL;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__NetworkZeroConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__NetworkZeroConfiguration, sizeof(struct tt__NetworkZeroConfiguration), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__NetworkZeroConfiguration(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_InterfaceToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "tt:InterfaceToken", &a->InterfaceToken, "tt:ReferenceToken"))
				{	soap_flag_InterfaceToken--;
					continue;
				}
			if (soap_flag_Enabled && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean_(soap, "tt:Enabled", &a->Enabled, "xsd:boolean"))
				{	soap_flag_Enabled--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Addresses", 1, NULL))
			{	if (a->Addresses == NULL)
				{	if (soap_blist_Addresses == NULL)
						soap_blist_Addresses = soap_new_block(soap);
					a->Addresses = (char **)soap_push_block(soap, soap_blist_Addresses, sizeof(char *));
					if (a->Addresses == NULL)
						return NULL;
					*a->Addresses = NULL;
				}
				soap_revert(soap);
				if (soap_in_tt__IPv4Address(soap, "tt:Addresses", a->Addresses, "tt:IPv4Address"))
				{	a->__sizeAddresses++;
					a->Addresses = NULL;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__NetworkZeroConfigurationExtension(soap, "tt:Extension", &a->Extension, "tt:NetworkZeroConfigurationExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Addresses)
			soap_pop_block(soap, soap_blist_Addresses);
		if (a->__sizeAddresses)
			a->Addresses = (char **)soap_save_block(soap, soap_blist_Addresses, NULL, 1);
		else
		{	a->Addresses = NULL;
			if (soap_blist_Addresses)
				soap_end_block(soap, soap_blist_Addresses);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__NetworkZeroConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__NetworkZeroConfiguration, 0, sizeof(struct tt__NetworkZeroConfiguration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_InterfaceToken > 0 || soap_flag_Enabled > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__NetworkZeroConfiguration(struct soap *soap, const struct tt__NetworkZeroConfiguration *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__NetworkZeroConfiguration);
	if (soap_out_tt__NetworkZeroConfiguration(soap, tag?tag:"tt:NetworkZeroConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__NetworkZeroConfiguration * SOAP_FMAC4 soap_get_tt__NetworkZeroConfiguration(struct soap *soap, struct tt__NetworkZeroConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__NetworkZeroConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetZeroConfigurationResponse(struct soap *soap, struct _tds__GetZeroConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ZeroConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetZeroConfigurationResponse(struct soap *soap, const struct _tds__GetZeroConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTott__NetworkZeroConfiguration(soap, &a->ZeroConfiguration);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetZeroConfigurationResponse(struct soap *soap, const char *tag, int id, const struct _tds__GetZeroConfigurationResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetZeroConfigurationResponse), type))
		return soap->error;
	if (a->ZeroConfiguration)
		soap_element_result(soap, "tds:ZeroConfiguration");
	if (a->ZeroConfiguration)
	{	if (soap_out_PointerTott__NetworkZeroConfiguration(soap, "tds:ZeroConfiguration", -1, &a->ZeroConfiguration, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tds:ZeroConfiguration"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetZeroConfigurationResponse * SOAP_FMAC4 soap_in__tds__GetZeroConfigurationResponse(struct soap *soap, const char *tag, struct _tds__GetZeroConfigurationResponse *a, const char *type)
{
	size_t soap_flag_ZeroConfiguration = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__GetZeroConfigurationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetZeroConfigurationResponse, sizeof(struct _tds__GetZeroConfigurationResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetZeroConfigurationResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ZeroConfiguration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__NetworkZeroConfiguration(soap, "tds:ZeroConfiguration", &a->ZeroConfiguration, "tt:NetworkZeroConfiguration"))
				{	soap_flag_ZeroConfiguration--;
					continue;
				}
			soap_check_result(soap, "tds:ZeroConfiguration");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__GetZeroConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetZeroConfigurationResponse, 0, sizeof(struct _tds__GetZeroConfigurationResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ZeroConfiguration > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetZeroConfigurationResponse(struct soap *soap, const struct _tds__GetZeroConfigurationResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__GetZeroConfigurationResponse);
	if (soap_out__tds__GetZeroConfigurationResponse(soap, tag?tag:"tds:GetZeroConfigurationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetZeroConfigurationResponse * SOAP_FMAC4 soap_get__tds__GetZeroConfigurationResponse(struct soap *soap, struct _tds__GetZeroConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetZeroConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetZeroConfiguration(struct soap *soap, struct _tds__GetZeroConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetZeroConfiguration(struct soap *soap, const struct _tds__GetZeroConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetZeroConfiguration(struct soap *soap, const char *tag, int id, const struct _tds__GetZeroConfiguration *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetZeroConfiguration), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetZeroConfiguration * SOAP_FMAC4 soap_in__tds__GetZeroConfiguration(struct soap *soap, const char *tag, struct _tds__GetZeroConfiguration *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__GetZeroConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetZeroConfiguration, sizeof(struct _tds__GetZeroConfiguration), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetZeroConfiguration(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__GetZeroConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetZeroConfiguration, 0, sizeof(struct _tds__GetZeroConfiguration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetZeroConfiguration(struct soap *soap, const struct _tds__GetZeroConfiguration *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__GetZeroConfiguration);
	if (soap_out__tds__GetZeroConfiguration(soap, tag?tag:"tds:GetZeroConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetZeroConfiguration * SOAP_FMAC4 soap_get__tds__GetZeroConfiguration(struct soap *soap, struct _tds__GetZeroConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetZeroConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__SetNetworkDefaultGatewayResponse(struct soap *soap, struct _tds__SetNetworkDefaultGatewayResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__SetNetworkDefaultGatewayResponse(struct soap *soap, const struct _tds__SetNetworkDefaultGatewayResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetNetworkDefaultGatewayResponse(struct soap *soap, const char *tag, int id, const struct _tds__SetNetworkDefaultGatewayResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetNetworkDefaultGatewayResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__SetNetworkDefaultGatewayResponse * SOAP_FMAC4 soap_in__tds__SetNetworkDefaultGatewayResponse(struct soap *soap, const char *tag, struct _tds__SetNetworkDefaultGatewayResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__SetNetworkDefaultGatewayResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetNetworkDefaultGatewayResponse, sizeof(struct _tds__SetNetworkDefaultGatewayResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__SetNetworkDefaultGatewayResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__SetNetworkDefaultGatewayResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetNetworkDefaultGatewayResponse, 0, sizeof(struct _tds__SetNetworkDefaultGatewayResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__SetNetworkDefaultGatewayResponse(struct soap *soap, const struct _tds__SetNetworkDefaultGatewayResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__SetNetworkDefaultGatewayResponse);
	if (soap_out__tds__SetNetworkDefaultGatewayResponse(soap, tag?tag:"tds:SetNetworkDefaultGatewayResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetNetworkDefaultGatewayResponse * SOAP_FMAC4 soap_get__tds__SetNetworkDefaultGatewayResponse(struct soap *soap, struct _tds__SetNetworkDefaultGatewayResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetNetworkDefaultGatewayResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__SetNetworkDefaultGateway(struct soap *soap, struct _tds__SetNetworkDefaultGateway *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeIPv4Address = 0;
	a->IPv4Address = NULL;
	a->__sizeIPv6Address = 0;
	a->IPv6Address = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__SetNetworkDefaultGateway(struct soap *soap, const struct _tds__SetNetworkDefaultGateway *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->IPv4Address)
	{	int i;
		for (i = 0; i < a->__sizeIPv4Address; i++)
		{
			soap_serialize_tt__IPv4Address(soap, a->IPv4Address + i);
		}
	}
	if (a->IPv6Address)
	{	int i;
		for (i = 0; i < a->__sizeIPv6Address; i++)
		{
			soap_serialize_tt__IPv6Address(soap, a->IPv6Address + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetNetworkDefaultGateway(struct soap *soap, const char *tag, int id, const struct _tds__SetNetworkDefaultGateway *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetNetworkDefaultGateway), type))
		return soap->error;
	if (a->IPv4Address)
	{	int i;
		for (i = 0; i < a->__sizeIPv4Address; i++)
			if (soap_out_tt__IPv4Address(soap, "tds:IPv4Address", -1, a->IPv4Address + i, ""))
				return soap->error;
	}
	if (a->IPv6Address)
	{	int i;
		for (i = 0; i < a->__sizeIPv6Address; i++)
			if (soap_out_tt__IPv6Address(soap, "tds:IPv6Address", -1, a->IPv6Address + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__SetNetworkDefaultGateway * SOAP_FMAC4 soap_in__tds__SetNetworkDefaultGateway(struct soap *soap, const char *tag, struct _tds__SetNetworkDefaultGateway *a, const char *type)
{
	struct soap_blist *soap_blist_IPv4Address = NULL;
	struct soap_blist *soap_blist_IPv6Address = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__SetNetworkDefaultGateway *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetNetworkDefaultGateway, sizeof(struct _tds__SetNetworkDefaultGateway), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__SetNetworkDefaultGateway(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tds:IPv4Address", 1, NULL))
			{	if (a->IPv4Address == NULL)
				{	if (soap_blist_IPv4Address == NULL)
						soap_blist_IPv4Address = soap_new_block(soap);
					a->IPv4Address = (char **)soap_push_block(soap, soap_blist_IPv4Address, sizeof(char *));
					if (a->IPv4Address == NULL)
						return NULL;
					*a->IPv4Address = NULL;
				}
				soap_revert(soap);
				if (soap_in_tt__IPv4Address(soap, "tds:IPv4Address", a->IPv4Address, "tt:IPv4Address"))
				{	a->__sizeIPv4Address++;
					a->IPv4Address = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tds:IPv6Address", 1, NULL))
			{	if (a->IPv6Address == NULL)
				{	if (soap_blist_IPv6Address == NULL)
						soap_blist_IPv6Address = soap_new_block(soap);
					a->IPv6Address = (char **)soap_push_block(soap, soap_blist_IPv6Address, sizeof(char *));
					if (a->IPv6Address == NULL)
						return NULL;
					*a->IPv6Address = NULL;
				}
				soap_revert(soap);
				if (soap_in_tt__IPv6Address(soap, "tds:IPv6Address", a->IPv6Address, "tt:IPv6Address"))
				{	a->__sizeIPv6Address++;
					a->IPv6Address = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->IPv4Address)
			soap_pop_block(soap, soap_blist_IPv4Address);
		if (a->__sizeIPv4Address)
			a->IPv4Address = (char **)soap_save_block(soap, soap_blist_IPv4Address, NULL, 1);
		else
		{	a->IPv4Address = NULL;
			if (soap_blist_IPv4Address)
				soap_end_block(soap, soap_blist_IPv4Address);
		}
		if (a->IPv6Address)
			soap_pop_block(soap, soap_blist_IPv6Address);
		if (a->__sizeIPv6Address)
			a->IPv6Address = (char **)soap_save_block(soap, soap_blist_IPv6Address, NULL, 1);
		else
		{	a->IPv6Address = NULL;
			if (soap_blist_IPv6Address)
				soap_end_block(soap, soap_blist_IPv6Address);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__SetNetworkDefaultGateway *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetNetworkDefaultGateway, 0, sizeof(struct _tds__SetNetworkDefaultGateway), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__SetNetworkDefaultGateway(struct soap *soap, const struct _tds__SetNetworkDefaultGateway *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__SetNetworkDefaultGateway);
	if (soap_out__tds__SetNetworkDefaultGateway(soap, tag?tag:"tds:SetNetworkDefaultGateway", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetNetworkDefaultGateway * SOAP_FMAC4 soap_get__tds__SetNetworkDefaultGateway(struct soap *soap, struct _tds__SetNetworkDefaultGateway *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetNetworkDefaultGateway(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__NetworkGateway(struct soap *soap, struct tt__NetworkGateway *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeIPv4Address = 0;
	a->IPv4Address = NULL;
	a->__sizeIPv6Address = 0;
	a->IPv6Address = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__NetworkGateway(struct soap *soap, const struct tt__NetworkGateway *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->IPv4Address)
	{	int i;
		for (i = 0; i < a->__sizeIPv4Address; i++)
		{
			soap_serialize_tt__IPv4Address(soap, a->IPv4Address + i);
		}
	}
	if (a->IPv6Address)
	{	int i;
		for (i = 0; i < a->__sizeIPv6Address; i++)
		{
			soap_serialize_tt__IPv6Address(soap, a->IPv6Address + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__NetworkGateway(struct soap *soap, const char *tag, int id, const struct tt__NetworkGateway *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__NetworkGateway), type))
		return soap->error;
	if (a->IPv4Address)
	{	int i;
		for (i = 0; i < a->__sizeIPv4Address; i++)
			if (soap_out_tt__IPv4Address(soap, "tt:IPv4Address", -1, a->IPv4Address + i, ""))
				return soap->error;
	}
	if (a->IPv6Address)
	{	int i;
		for (i = 0; i < a->__sizeIPv6Address; i++)
			if (soap_out_tt__IPv6Address(soap, "tt:IPv6Address", -1, a->IPv6Address + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__NetworkGateway * SOAP_FMAC4 soap_in_tt__NetworkGateway(struct soap *soap, const char *tag, struct tt__NetworkGateway *a, const char *type)
{
	struct soap_blist *soap_blist_IPv4Address = NULL;
	struct soap_blist *soap_blist_IPv6Address = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__NetworkGateway *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__NetworkGateway, sizeof(struct tt__NetworkGateway), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__NetworkGateway(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:IPv4Address", 1, NULL))
			{	if (a->IPv4Address == NULL)
				{	if (soap_blist_IPv4Address == NULL)
						soap_blist_IPv4Address = soap_new_block(soap);
					a->IPv4Address = (char **)soap_push_block(soap, soap_blist_IPv4Address, sizeof(char *));
					if (a->IPv4Address == NULL)
						return NULL;
					*a->IPv4Address = NULL;
				}
				soap_revert(soap);
				if (soap_in_tt__IPv4Address(soap, "tt:IPv4Address", a->IPv4Address, "tt:IPv4Address"))
				{	a->__sizeIPv4Address++;
					a->IPv4Address = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:IPv6Address", 1, NULL))
			{	if (a->IPv6Address == NULL)
				{	if (soap_blist_IPv6Address == NULL)
						soap_blist_IPv6Address = soap_new_block(soap);
					a->IPv6Address = (char **)soap_push_block(soap, soap_blist_IPv6Address, sizeof(char *));
					if (a->IPv6Address == NULL)
						return NULL;
					*a->IPv6Address = NULL;
				}
				soap_revert(soap);
				if (soap_in_tt__IPv6Address(soap, "tt:IPv6Address", a->IPv6Address, "tt:IPv6Address"))
				{	a->__sizeIPv6Address++;
					a->IPv6Address = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->IPv4Address)
			soap_pop_block(soap, soap_blist_IPv4Address);
		if (a->__sizeIPv4Address)
			a->IPv4Address = (char **)soap_save_block(soap, soap_blist_IPv4Address, NULL, 1);
		else
		{	a->IPv4Address = NULL;
			if (soap_blist_IPv4Address)
				soap_end_block(soap, soap_blist_IPv4Address);
		}
		if (a->IPv6Address)
			soap_pop_block(soap, soap_blist_IPv6Address);
		if (a->__sizeIPv6Address)
			a->IPv6Address = (char **)soap_save_block(soap, soap_blist_IPv6Address, NULL, 1);
		else
		{	a->IPv6Address = NULL;
			if (soap_blist_IPv6Address)
				soap_end_block(soap, soap_blist_IPv6Address);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__NetworkGateway *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__NetworkGateway, 0, sizeof(struct tt__NetworkGateway), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__NetworkGateway(struct soap *soap, const struct tt__NetworkGateway *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__NetworkGateway);
	if (soap_out_tt__NetworkGateway(soap, tag?tag:"tt:NetworkGateway", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__NetworkGateway * SOAP_FMAC4 soap_get_tt__NetworkGateway(struct soap *soap, struct tt__NetworkGateway *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__NetworkGateway(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetNetworkDefaultGatewayResponse(struct soap *soap, struct _tds__GetNetworkDefaultGatewayResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->NetworkGateway = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetNetworkDefaultGatewayResponse(struct soap *soap, const struct _tds__GetNetworkDefaultGatewayResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTott__NetworkGateway(soap, &a->NetworkGateway);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetNetworkDefaultGatewayResponse(struct soap *soap, const char *tag, int id, const struct _tds__GetNetworkDefaultGatewayResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetNetworkDefaultGatewayResponse), type))
		return soap->error;
	if (a->NetworkGateway)
		soap_element_result(soap, "tds:NetworkGateway");
	if (a->NetworkGateway)
	{	if (soap_out_PointerTott__NetworkGateway(soap, "tds:NetworkGateway", -1, &a->NetworkGateway, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tds:NetworkGateway"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetNetworkDefaultGatewayResponse * SOAP_FMAC4 soap_in__tds__GetNetworkDefaultGatewayResponse(struct soap *soap, const char *tag, struct _tds__GetNetworkDefaultGatewayResponse *a, const char *type)
{
	size_t soap_flag_NetworkGateway = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__GetNetworkDefaultGatewayResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetNetworkDefaultGatewayResponse, sizeof(struct _tds__GetNetworkDefaultGatewayResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetNetworkDefaultGatewayResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_NetworkGateway && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__NetworkGateway(soap, "tds:NetworkGateway", &a->NetworkGateway, "tt:NetworkGateway"))
				{	soap_flag_NetworkGateway--;
					continue;
				}
			soap_check_result(soap, "tds:NetworkGateway");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__GetNetworkDefaultGatewayResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetNetworkDefaultGatewayResponse, 0, sizeof(struct _tds__GetNetworkDefaultGatewayResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_NetworkGateway > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetNetworkDefaultGatewayResponse(struct soap *soap, const struct _tds__GetNetworkDefaultGatewayResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__GetNetworkDefaultGatewayResponse);
	if (soap_out__tds__GetNetworkDefaultGatewayResponse(soap, tag?tag:"tds:GetNetworkDefaultGatewayResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetNetworkDefaultGatewayResponse * SOAP_FMAC4 soap_get__tds__GetNetworkDefaultGatewayResponse(struct soap *soap, struct _tds__GetNetworkDefaultGatewayResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetNetworkDefaultGatewayResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetNetworkDefaultGateway(struct soap *soap, struct _tds__GetNetworkDefaultGateway *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetNetworkDefaultGateway(struct soap *soap, const struct _tds__GetNetworkDefaultGateway *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetNetworkDefaultGateway(struct soap *soap, const char *tag, int id, const struct _tds__GetNetworkDefaultGateway *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetNetworkDefaultGateway), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetNetworkDefaultGateway * SOAP_FMAC4 soap_in__tds__GetNetworkDefaultGateway(struct soap *soap, const char *tag, struct _tds__GetNetworkDefaultGateway *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__GetNetworkDefaultGateway *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetNetworkDefaultGateway, sizeof(struct _tds__GetNetworkDefaultGateway), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetNetworkDefaultGateway(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__GetNetworkDefaultGateway *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetNetworkDefaultGateway, 0, sizeof(struct _tds__GetNetworkDefaultGateway), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetNetworkDefaultGateway(struct soap *soap, const struct _tds__GetNetworkDefaultGateway *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__GetNetworkDefaultGateway);
	if (soap_out__tds__GetNetworkDefaultGateway(soap, tag?tag:"tds:GetNetworkDefaultGateway", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetNetworkDefaultGateway * SOAP_FMAC4 soap_get__tds__GetNetworkDefaultGateway(struct soap *soap, struct _tds__GetNetworkDefaultGateway *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetNetworkDefaultGateway(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__SetNetworkProtocolsResponse(struct soap *soap, struct _tds__SetNetworkProtocolsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__SetNetworkProtocolsResponse(struct soap *soap, const struct _tds__SetNetworkProtocolsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetNetworkProtocolsResponse(struct soap *soap, const char *tag, int id, const struct _tds__SetNetworkProtocolsResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetNetworkProtocolsResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__SetNetworkProtocolsResponse * SOAP_FMAC4 soap_in__tds__SetNetworkProtocolsResponse(struct soap *soap, const char *tag, struct _tds__SetNetworkProtocolsResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__SetNetworkProtocolsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetNetworkProtocolsResponse, sizeof(struct _tds__SetNetworkProtocolsResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__SetNetworkProtocolsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__SetNetworkProtocolsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetNetworkProtocolsResponse, 0, sizeof(struct _tds__SetNetworkProtocolsResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__SetNetworkProtocolsResponse(struct soap *soap, const struct _tds__SetNetworkProtocolsResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__SetNetworkProtocolsResponse);
	if (soap_out__tds__SetNetworkProtocolsResponse(soap, tag?tag:"tds:SetNetworkProtocolsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetNetworkProtocolsResponse * SOAP_FMAC4 soap_get__tds__SetNetworkProtocolsResponse(struct soap *soap, struct _tds__SetNetworkProtocolsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetNetworkProtocolsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__SetNetworkProtocols(struct soap *soap, struct _tds__SetNetworkProtocols *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeNetworkProtocols = 0;
	a->NetworkProtocols = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__SetNetworkProtocols(struct soap *soap, const struct _tds__SetNetworkProtocols *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->NetworkProtocols)
	{	int i;
		for (i = 0; i < a->__sizeNetworkProtocols; i++)
		{
			soap_embedded(soap, a->NetworkProtocols + i, SOAP_TYPE_tt__NetworkProtocol);
			soap_serialize_tt__NetworkProtocol(soap, a->NetworkProtocols + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetNetworkProtocols(struct soap *soap, const char *tag, int id, const struct _tds__SetNetworkProtocols *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetNetworkProtocols), type))
		return soap->error;
	if (a->NetworkProtocols)
	{	int i;
		for (i = 0; i < a->__sizeNetworkProtocols; i++)
			if (soap_out_tt__NetworkProtocol(soap, "tds:NetworkProtocols", -1, a->NetworkProtocols + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__SetNetworkProtocols * SOAP_FMAC4 soap_in__tds__SetNetworkProtocols(struct soap *soap, const char *tag, struct _tds__SetNetworkProtocols *a, const char *type)
{
	struct soap_blist *soap_blist_NetworkProtocols = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__SetNetworkProtocols *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetNetworkProtocols, sizeof(struct _tds__SetNetworkProtocols), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__SetNetworkProtocols(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tds:NetworkProtocols", 1, NULL))
			{	if (a->NetworkProtocols == NULL)
				{	if (soap_blist_NetworkProtocols == NULL)
						soap_blist_NetworkProtocols = soap_new_block(soap);
					a->NetworkProtocols = (struct tt__NetworkProtocol *)soap_push_block(soap, soap_blist_NetworkProtocols, sizeof(struct tt__NetworkProtocol));
					if (a->NetworkProtocols == NULL)
						return NULL;
					soap_default_tt__NetworkProtocol(soap, a->NetworkProtocols);
				}
				soap_revert(soap);
				if (soap_in_tt__NetworkProtocol(soap, "tds:NetworkProtocols", a->NetworkProtocols, "tt:NetworkProtocol"))
				{	a->__sizeNetworkProtocols++;
					a->NetworkProtocols = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->NetworkProtocols)
			soap_pop_block(soap, soap_blist_NetworkProtocols);
		if (a->__sizeNetworkProtocols)
			a->NetworkProtocols = (struct tt__NetworkProtocol *)soap_save_block(soap, soap_blist_NetworkProtocols, NULL, 1);
		else
		{	a->NetworkProtocols = NULL;
			if (soap_blist_NetworkProtocols)
				soap_end_block(soap, soap_blist_NetworkProtocols);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__SetNetworkProtocols *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetNetworkProtocols, 0, sizeof(struct _tds__SetNetworkProtocols), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeNetworkProtocols < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__SetNetworkProtocols(struct soap *soap, const struct _tds__SetNetworkProtocols *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__SetNetworkProtocols);
	if (soap_out__tds__SetNetworkProtocols(soap, tag?tag:"tds:SetNetworkProtocols", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetNetworkProtocols * SOAP_FMAC4 soap_get__tds__SetNetworkProtocols(struct soap *soap, struct _tds__SetNetworkProtocols *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetNetworkProtocols(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__NetworkProtocol(struct soap *soap, struct tt__NetworkProtocol *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__NetworkProtocolType(soap, &a->Name);
	soap_default_xsd__boolean_(soap, &a->Enabled);
	a->__sizePort = 0;
	a->Port = NULL;
	a->Extension = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__NetworkProtocol(struct soap *soap, const struct tt__NetworkProtocol *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->Enabled, SOAP_TYPE_xsd__boolean_);
	if (a->Port)
	{	int i;
		for (i = 0; i < a->__sizePort; i++)
		{
			soap_embedded(soap, a->Port + i, SOAP_TYPE_int);
		}
	}
	soap_serialize_PointerTott__NetworkProtocolExtension(soap, &a->Extension);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__NetworkProtocol(struct soap *soap, const char *tag, int id, const struct tt__NetworkProtocol *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__NetworkProtocol), type))
		return soap->error;
	if (soap_out_tt__NetworkProtocolType(soap, "tt:Name", -1, &a->Name, ""))
		return soap->error;
	if (soap_out_xsd__boolean_(soap, "tt:Enabled", -1, &a->Enabled, ""))
		return soap->error;
	if (a->Port)
	{	int i;
		for (i = 0; i < a->__sizePort; i++)
			if (soap_out_int(soap, "tt:Port", -1, a->Port + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTott__NetworkProtocolExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__NetworkProtocol * SOAP_FMAC4 soap_in_tt__NetworkProtocol(struct soap *soap, const char *tag, struct tt__NetworkProtocol *a, const char *type)
{
	size_t soap_flag_Name = 1;
	size_t soap_flag_Enabled = 1;
	struct soap_blist *soap_blist_Port = NULL;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__NetworkProtocol *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__NetworkProtocol, sizeof(struct tt__NetworkProtocol), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__NetworkProtocol(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_tt__NetworkProtocolType(soap, "tt:Name", &a->Name, "tt:NetworkProtocolType"))
				{	soap_flag_Name--;
					continue;
				}
			if (soap_flag_Enabled && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean_(soap, "tt:Enabled", &a->Enabled, "xsd:boolean"))
				{	soap_flag_Enabled--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Port", 1, NULL))
			{	if (a->Port == NULL)
				{	if (soap_blist_Port == NULL)
						soap_blist_Port = soap_new_block(soap);
					a->Port = (int *)soap_push_block(soap, soap_blist_Port, sizeof(int));
					if (a->Port == NULL)
						return NULL;
					soap_default_int(soap, a->Port);
				}
				soap_revert(soap);
				if (soap_in_int(soap, "tt:Port", a->Port, "xsd:int"))
				{	a->__sizePort++;
					a->Port = NULL;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__NetworkProtocolExtension(soap, "tt:Extension", &a->Extension, "tt:NetworkProtocolExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Port)
			soap_pop_block(soap, soap_blist_Port);
		if (a->__sizePort)
			a->Port = (int *)soap_save_block(soap, soap_blist_Port, NULL, 1);
		else
		{	a->Port = NULL;
			if (soap_blist_Port)
				soap_end_block(soap, soap_blist_Port);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__NetworkProtocol *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__NetworkProtocol, 0, sizeof(struct tt__NetworkProtocol), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Name > 0 || soap_flag_Enabled > 0 || a->__sizePort < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__NetworkProtocol(struct soap *soap, const struct tt__NetworkProtocol *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__NetworkProtocol);
	if (soap_out_tt__NetworkProtocol(soap, tag?tag:"tt:NetworkProtocol", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__NetworkProtocol * SOAP_FMAC4 soap_get_tt__NetworkProtocol(struct soap *soap, struct tt__NetworkProtocol *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__NetworkProtocol(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetNetworkProtocolsResponse(struct soap *soap, struct _tds__GetNetworkProtocolsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeNetworkProtocols = 0;
	a->NetworkProtocols = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetNetworkProtocolsResponse(struct soap *soap, const struct _tds__GetNetworkProtocolsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->NetworkProtocols)
	{	int i;
		for (i = 0; i < a->__sizeNetworkProtocols; i++)
		{
			soap_embedded(soap, a->NetworkProtocols + i, SOAP_TYPE_tt__NetworkProtocol);
			soap_serialize_tt__NetworkProtocol(soap, a->NetworkProtocols + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetNetworkProtocolsResponse(struct soap *soap, const char *tag, int id, const struct _tds__GetNetworkProtocolsResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetNetworkProtocolsResponse), type))
		return soap->error;
	soap_element_result(soap, "-sizeNetworkProtocols");
	if (a->NetworkProtocols)
	{	int i;
		for (i = 0; i < a->__sizeNetworkProtocols; i++)
			if (soap_out_tt__NetworkProtocol(soap, "tds:NetworkProtocols", -1, a->NetworkProtocols + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetNetworkProtocolsResponse * SOAP_FMAC4 soap_in__tds__GetNetworkProtocolsResponse(struct soap *soap, const char *tag, struct _tds__GetNetworkProtocolsResponse *a, const char *type)
{
	struct soap_blist *soap_blist_NetworkProtocols = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__GetNetworkProtocolsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetNetworkProtocolsResponse, sizeof(struct _tds__GetNetworkProtocolsResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetNetworkProtocolsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tds:NetworkProtocols", 1, NULL))
			{	if (a->NetworkProtocols == NULL)
				{	if (soap_blist_NetworkProtocols == NULL)
						soap_blist_NetworkProtocols = soap_new_block(soap);
					a->NetworkProtocols = (struct tt__NetworkProtocol *)soap_push_block(soap, soap_blist_NetworkProtocols, sizeof(struct tt__NetworkProtocol));
					if (a->NetworkProtocols == NULL)
						return NULL;
					soap_default_tt__NetworkProtocol(soap, a->NetworkProtocols);
				}
				soap_revert(soap);
				if (soap_in_tt__NetworkProtocol(soap, "tds:NetworkProtocols", a->NetworkProtocols, "tt:NetworkProtocol"))
				{	a->__sizeNetworkProtocols++;
					a->NetworkProtocols = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizeNetworkProtocols");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->NetworkProtocols)
			soap_pop_block(soap, soap_blist_NetworkProtocols);
		if (a->__sizeNetworkProtocols)
			a->NetworkProtocols = (struct tt__NetworkProtocol *)soap_save_block(soap, soap_blist_NetworkProtocols, NULL, 1);
		else
		{	a->NetworkProtocols = NULL;
			if (soap_blist_NetworkProtocols)
				soap_end_block(soap, soap_blist_NetworkProtocols);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__GetNetworkProtocolsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetNetworkProtocolsResponse, 0, sizeof(struct _tds__GetNetworkProtocolsResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetNetworkProtocolsResponse(struct soap *soap, const struct _tds__GetNetworkProtocolsResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__GetNetworkProtocolsResponse);
	if (soap_out__tds__GetNetworkProtocolsResponse(soap, tag?tag:"tds:GetNetworkProtocolsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetNetworkProtocolsResponse * SOAP_FMAC4 soap_get__tds__GetNetworkProtocolsResponse(struct soap *soap, struct _tds__GetNetworkProtocolsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetNetworkProtocolsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetNetworkProtocols(struct soap *soap, struct _tds__GetNetworkProtocols *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetNetworkProtocols(struct soap *soap, const struct _tds__GetNetworkProtocols *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetNetworkProtocols(struct soap *soap, const char *tag, int id, const struct _tds__GetNetworkProtocols *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetNetworkProtocols), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetNetworkProtocols * SOAP_FMAC4 soap_in__tds__GetNetworkProtocols(struct soap *soap, const char *tag, struct _tds__GetNetworkProtocols *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__GetNetworkProtocols *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetNetworkProtocols, sizeof(struct _tds__GetNetworkProtocols), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetNetworkProtocols(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__GetNetworkProtocols *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetNetworkProtocols, 0, sizeof(struct _tds__GetNetworkProtocols), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetNetworkProtocols(struct soap *soap, const struct _tds__GetNetworkProtocols *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__GetNetworkProtocols);
	if (soap_out__tds__GetNetworkProtocols(soap, tag?tag:"tds:GetNetworkProtocols", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetNetworkProtocols * SOAP_FMAC4 soap_get__tds__GetNetworkProtocols(struct soap *soap, struct _tds__GetNetworkProtocols *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetNetworkProtocols(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__SetNetworkInterfacesResponse(struct soap *soap, struct _tds__SetNetworkInterfacesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__boolean_(soap, &a->RebootNeeded);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__SetNetworkInterfacesResponse(struct soap *soap, const struct _tds__SetNetworkInterfacesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->RebootNeeded, SOAP_TYPE_xsd__boolean_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetNetworkInterfacesResponse(struct soap *soap, const char *tag, int id, const struct _tds__SetNetworkInterfacesResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetNetworkInterfacesResponse), type))
		return soap->error;
	soap_element_result(soap, "tds:RebootNeeded");
	if (soap_out_xsd__boolean_(soap, "tds:RebootNeeded", -1, &a->RebootNeeded, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__SetNetworkInterfacesResponse * SOAP_FMAC4 soap_in__tds__SetNetworkInterfacesResponse(struct soap *soap, const char *tag, struct _tds__SetNetworkInterfacesResponse *a, const char *type)
{
	size_t soap_flag_RebootNeeded = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__SetNetworkInterfacesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetNetworkInterfacesResponse, sizeof(struct _tds__SetNetworkInterfacesResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__SetNetworkInterfacesResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RebootNeeded && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean_(soap, "tds:RebootNeeded", &a->RebootNeeded, "xsd:boolean"))
				{	soap_flag_RebootNeeded--;
					continue;
				}
			soap_check_result(soap, "tds:RebootNeeded");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__SetNetworkInterfacesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetNetworkInterfacesResponse, 0, sizeof(struct _tds__SetNetworkInterfacesResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_RebootNeeded > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__SetNetworkInterfacesResponse(struct soap *soap, const struct _tds__SetNetworkInterfacesResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__SetNetworkInterfacesResponse);
	if (soap_out__tds__SetNetworkInterfacesResponse(soap, tag?tag:"tds:SetNetworkInterfacesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetNetworkInterfacesResponse * SOAP_FMAC4 soap_get__tds__SetNetworkInterfacesResponse(struct soap *soap, struct _tds__SetNetworkInterfacesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetNetworkInterfacesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__NetworkInterfaceSetConfiguration(struct soap *soap, struct tt__NetworkInterfaceSetConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Enabled = NULL;
	a->Link = NULL;
	a->MTU = NULL;
	a->IPv4 = NULL;
	a->IPv6 = NULL;
	a->Extension = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__NetworkInterfaceSetConfiguration(struct soap *soap, const struct tt__NetworkInterfaceSetConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__boolean_(soap, &a->Enabled);
	soap_serialize_PointerTott__NetworkInterfaceConnectionSetting(soap, &a->Link);
	soap_serialize_PointerToint(soap, &a->MTU);
	soap_serialize_PointerTott__IPv4NetworkInterfaceSetConfiguration(soap, &a->IPv4);
	soap_serialize_PointerTott__IPv6NetworkInterfaceSetConfiguration(soap, &a->IPv6);
	soap_serialize_PointerTott__NetworkInterfaceSetConfigurationExtension(soap, &a->Extension);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__NetworkInterfaceSetConfiguration(struct soap *soap, const char *tag, int id, const struct tt__NetworkInterfaceSetConfiguration *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__NetworkInterfaceSetConfiguration), type))
		return soap->error;
	if (soap_out_PointerToxsd__boolean_(soap, "tt:Enabled", -1, &a->Enabled, ""))
		return soap->error;
	if (soap_out_PointerTott__NetworkInterfaceConnectionSetting(soap, "tt:Link", -1, &a->Link, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "tt:MTU", -1, &a->MTU, ""))
		return soap->error;
	if (soap_out_PointerTott__IPv4NetworkInterfaceSetConfiguration(soap, "tt:IPv4", -1, &a->IPv4, ""))
		return soap->error;
	if (soap_out_PointerTott__IPv6NetworkInterfaceSetConfiguration(soap, "tt:IPv6", -1, &a->IPv6, ""))
		return soap->error;
	if (soap_out_PointerTott__NetworkInterfaceSetConfigurationExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__NetworkInterfaceSetConfiguration * SOAP_FMAC4 soap_in_tt__NetworkInterfaceSetConfiguration(struct soap *soap, const char *tag, struct tt__NetworkInterfaceSetConfiguration *a, const char *type)
{
	size_t soap_flag_Enabled = 1;
	size_t soap_flag_Link = 1;
	size_t soap_flag_MTU = 1;
	size_t soap_flag_IPv4 = 1;
	size_t soap_flag_IPv6 = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__NetworkInterfaceSetConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__NetworkInterfaceSetConfiguration, sizeof(struct tt__NetworkInterfaceSetConfiguration), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__NetworkInterfaceSetConfiguration(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Enabled && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__boolean_(soap, "tt:Enabled", &a->Enabled, "xsd:boolean"))
				{	soap_flag_Enabled--;
					continue;
				}
			if (soap_flag_Link && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__NetworkInterfaceConnectionSetting(soap, "tt:Link", &a->Link, "tt:NetworkInterfaceConnectionSetting"))
				{	soap_flag_Link--;
					continue;
				}
			if (soap_flag_MTU && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "tt:MTU", &a->MTU, "xsd:int"))
				{	soap_flag_MTU--;
					continue;
				}
			if (soap_flag_IPv4 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IPv4NetworkInterfaceSetConfiguration(soap, "tt:IPv4", &a->IPv4, "tt:IPv4NetworkInterfaceSetConfiguration"))
				{	soap_flag_IPv4--;
					continue;
				}
			if (soap_flag_IPv6 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IPv6NetworkInterfaceSetConfiguration(soap, "tt:IPv6", &a->IPv6, "tt:IPv6NetworkInterfaceSetConfiguration"))
				{	soap_flag_IPv6--;
					continue;
				}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__NetworkInterfaceSetConfigurationExtension(soap, "tt:Extension", &a->Extension, "tt:NetworkInterfaceSetConfigurationExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__NetworkInterfaceSetConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__NetworkInterfaceSetConfiguration, 0, sizeof(struct tt__NetworkInterfaceSetConfiguration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__NetworkInterfaceSetConfiguration(struct soap *soap, const struct tt__NetworkInterfaceSetConfiguration *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__NetworkInterfaceSetConfiguration);
	if (soap_out_tt__NetworkInterfaceSetConfiguration(soap, tag?tag:"tt:NetworkInterfaceSetConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__NetworkInterfaceSetConfiguration * SOAP_FMAC4 soap_get_tt__NetworkInterfaceSetConfiguration(struct soap *soap, struct tt__NetworkInterfaceSetConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__NetworkInterfaceSetConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__SetNetworkInterfaces(struct soap *soap, struct _tds__SetNetworkInterfaces *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->InterfaceToken);
	a->NetworkInterface = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__SetNetworkInterfaces(struct soap *soap, const struct _tds__SetNetworkInterfaces *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_tt__ReferenceToken(soap, &a->InterfaceToken);
	soap_serialize_PointerTott__NetworkInterfaceSetConfiguration(soap, &a->NetworkInterface);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetNetworkInterfaces(struct soap *soap, const char *tag, int id, const struct _tds__SetNetworkInterfaces *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetNetworkInterfaces), type))
		return soap->error;
	if (a->InterfaceToken)
	{	if (soap_out_tt__ReferenceToken(soap, "tds:InterfaceToken", -1, &a->InterfaceToken, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tds:InterfaceToken"))
		return soap->error;
	if (a->NetworkInterface)
	{	if (soap_out_PointerTott__NetworkInterfaceSetConfiguration(soap, "tds:NetworkInterface", -1, &a->NetworkInterface, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tds:NetworkInterface"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__SetNetworkInterfaces * SOAP_FMAC4 soap_in__tds__SetNetworkInterfaces(struct soap *soap, const char *tag, struct _tds__SetNetworkInterfaces *a, const char *type)
{
	size_t soap_flag_InterfaceToken = 1;
	size_t soap_flag_NetworkInterface = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__SetNetworkInterfaces *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetNetworkInterfaces, sizeof(struct _tds__SetNetworkInterfaces), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__SetNetworkInterfaces(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_InterfaceToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "tds:InterfaceToken", &a->InterfaceToken, "tt:ReferenceToken"))
				{	soap_flag_InterfaceToken--;
					continue;
				}
			if (soap_flag_NetworkInterface && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__NetworkInterfaceSetConfiguration(soap, "tds:NetworkInterface", &a->NetworkInterface, "tt:NetworkInterfaceSetConfiguration"))
				{	soap_flag_NetworkInterface--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__SetNetworkInterfaces *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetNetworkInterfaces, 0, sizeof(struct _tds__SetNetworkInterfaces), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_InterfaceToken > 0 || soap_flag_NetworkInterface > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__SetNetworkInterfaces(struct soap *soap, const struct _tds__SetNetworkInterfaces *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__SetNetworkInterfaces);
	if (soap_out__tds__SetNetworkInterfaces(soap, tag?tag:"tds:SetNetworkInterfaces", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetNetworkInterfaces * SOAP_FMAC4 soap_get__tds__SetNetworkInterfaces(struct soap *soap, struct _tds__SetNetworkInterfaces *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetNetworkInterfaces(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__NetworkInterface(struct soap *soap, struct tt__NetworkInterface *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->token);
	soap_default_xsd__boolean_(soap, &a->Enabled);
	a->Info = NULL;
	a->Link = NULL;
	a->IPv4 = NULL;
	a->IPv6 = NULL;
	a->Extension = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__NetworkInterface(struct soap *soap, const struct tt__NetworkInterface *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->Enabled, SOAP_TYPE_xsd__boolean_);
	soap_serialize_PointerTott__NetworkInterfaceInfo(soap, &a->Info);
	soap_serialize_PointerTott__NetworkInterfaceLink(soap, &a->Link);
	soap_serialize_PointerTott__IPv4NetworkInterface(soap, &a->IPv4);
	soap_serialize_PointerTott__IPv6NetworkInterface(soap, &a->IPv6);
	soap_serialize_PointerTott__NetworkInterfaceExtension(soap, &a->Extension);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__NetworkInterface(struct soap *soap, const char *tag, int id, const struct tt__NetworkInterface *a, const char *type)
{
	if (a->token)
		soap_set_attr(soap, "token", a->token, 1);
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__NetworkInterface), type))
		return soap->error;
	if (soap_out_xsd__boolean_(soap, "tt:Enabled", -1, &a->Enabled, ""))
		return soap->error;
	if (soap_out_PointerTott__NetworkInterfaceInfo(soap, "tt:Info", -1, &a->Info, ""))
		return soap->error;
	if (soap_out_PointerTott__NetworkInterfaceLink(soap, "tt:Link", -1, &a->Link, ""))
		return soap->error;
	if (soap_out_PointerTott__IPv4NetworkInterface(soap, "tt:IPv4", -1, &a->IPv4, ""))
		return soap->error;
	if (soap_out_PointerTott__IPv6NetworkInterface(soap, "tt:IPv6", -1, &a->IPv6, ""))
		return soap->error;
	if (soap_out_PointerTott__NetworkInterfaceExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__NetworkInterface * SOAP_FMAC4 soap_in_tt__NetworkInterface(struct soap *soap, const char *tag, struct tt__NetworkInterface *a, const char *type)
{
	size_t soap_flag_Enabled = 1;
	size_t soap_flag_Info = 1;
	size_t soap_flag_Link = 1;
	size_t soap_flag_IPv4 = 1;
	size_t soap_flag_IPv6 = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__NetworkInterface *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__NetworkInterface, sizeof(struct tt__NetworkInterface), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__NetworkInterface(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "token", 1), &a->token, -1, 64))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Enabled && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean_(soap, "tt:Enabled", &a->Enabled, "xsd:boolean"))
				{	soap_flag_Enabled--;
					continue;
				}
			if (soap_flag_Info && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__NetworkInterfaceInfo(soap, "tt:Info", &a->Info, "tt:NetworkInterfaceInfo"))
				{	soap_flag_Info--;
					continue;
				}
			if (soap_flag_Link && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__NetworkInterfaceLink(soap, "tt:Link", &a->Link, "tt:NetworkInterfaceLink"))
				{	soap_flag_Link--;
					continue;
				}
			if (soap_flag_IPv4 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IPv4NetworkInterface(soap, "tt:IPv4", &a->IPv4, "tt:IPv4NetworkInterface"))
				{	soap_flag_IPv4--;
					continue;
				}
			if (soap_flag_IPv6 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IPv6NetworkInterface(soap, "tt:IPv6", &a->IPv6, "tt:IPv6NetworkInterface"))
				{	soap_flag_IPv6--;
					continue;
				}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__NetworkInterfaceExtension(soap, "tt:Extension", &a->Extension, "tt:NetworkInterfaceExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__NetworkInterface *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__NetworkInterface, 0, sizeof(struct tt__NetworkInterface), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Enabled > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__NetworkInterface(struct soap *soap, const struct tt__NetworkInterface *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__NetworkInterface);
	if (soap_out_tt__NetworkInterface(soap, tag?tag:"tt:NetworkInterface", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__NetworkInterface * SOAP_FMAC4 soap_get_tt__NetworkInterface(struct soap *soap, struct tt__NetworkInterface *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__NetworkInterface(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetNetworkInterfacesResponse(struct soap *soap, struct _tds__GetNetworkInterfacesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeNetworkInterfaces = 0;
	a->NetworkInterfaces = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetNetworkInterfacesResponse(struct soap *soap, const struct _tds__GetNetworkInterfacesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->NetworkInterfaces)
	{	int i;
		for (i = 0; i < a->__sizeNetworkInterfaces; i++)
		{
			soap_embedded(soap, a->NetworkInterfaces + i, SOAP_TYPE_tt__NetworkInterface);
			soap_serialize_tt__NetworkInterface(soap, a->NetworkInterfaces + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetNetworkInterfacesResponse(struct soap *soap, const char *tag, int id, const struct _tds__GetNetworkInterfacesResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetNetworkInterfacesResponse), type))
		return soap->error;
	soap_element_result(soap, "-sizeNetworkInterfaces");
	if (a->NetworkInterfaces)
	{	int i;
		for (i = 0; i < a->__sizeNetworkInterfaces; i++)
			if (soap_out_tt__NetworkInterface(soap, "tds:NetworkInterfaces", -1, a->NetworkInterfaces + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetNetworkInterfacesResponse * SOAP_FMAC4 soap_in__tds__GetNetworkInterfacesResponse(struct soap *soap, const char *tag, struct _tds__GetNetworkInterfacesResponse *a, const char *type)
{
	struct soap_blist *soap_blist_NetworkInterfaces = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__GetNetworkInterfacesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetNetworkInterfacesResponse, sizeof(struct _tds__GetNetworkInterfacesResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetNetworkInterfacesResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tds:NetworkInterfaces", 1, NULL))
			{	if (a->NetworkInterfaces == NULL)
				{	if (soap_blist_NetworkInterfaces == NULL)
						soap_blist_NetworkInterfaces = soap_new_block(soap);
					a->NetworkInterfaces = (struct tt__NetworkInterface *)soap_push_block(soap, soap_blist_NetworkInterfaces, sizeof(struct tt__NetworkInterface));
					if (a->NetworkInterfaces == NULL)
						return NULL;
					soap_default_tt__NetworkInterface(soap, a->NetworkInterfaces);
				}
				soap_revert(soap);
				if (soap_in_tt__NetworkInterface(soap, "tds:NetworkInterfaces", a->NetworkInterfaces, "tt:NetworkInterface"))
				{	a->__sizeNetworkInterfaces++;
					a->NetworkInterfaces = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizeNetworkInterfaces");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->NetworkInterfaces)
			soap_pop_block(soap, soap_blist_NetworkInterfaces);
		if (a->__sizeNetworkInterfaces)
			a->NetworkInterfaces = (struct tt__NetworkInterface *)soap_save_block(soap, soap_blist_NetworkInterfaces, NULL, 1);
		else
		{	a->NetworkInterfaces = NULL;
			if (soap_blist_NetworkInterfaces)
				soap_end_block(soap, soap_blist_NetworkInterfaces);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__GetNetworkInterfacesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetNetworkInterfacesResponse, 0, sizeof(struct _tds__GetNetworkInterfacesResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeNetworkInterfaces < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetNetworkInterfacesResponse(struct soap *soap, const struct _tds__GetNetworkInterfacesResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__GetNetworkInterfacesResponse);
	if (soap_out__tds__GetNetworkInterfacesResponse(soap, tag?tag:"tds:GetNetworkInterfacesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetNetworkInterfacesResponse * SOAP_FMAC4 soap_get__tds__GetNetworkInterfacesResponse(struct soap *soap, struct _tds__GetNetworkInterfacesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetNetworkInterfacesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetNetworkInterfaces(struct soap *soap, struct _tds__GetNetworkInterfaces *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetNetworkInterfaces(struct soap *soap, const struct _tds__GetNetworkInterfaces *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetNetworkInterfaces(struct soap *soap, const char *tag, int id, const struct _tds__GetNetworkInterfaces *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetNetworkInterfaces), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetNetworkInterfaces * SOAP_FMAC4 soap_in__tds__GetNetworkInterfaces(struct soap *soap, const char *tag, struct _tds__GetNetworkInterfaces *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__GetNetworkInterfaces *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetNetworkInterfaces, sizeof(struct _tds__GetNetworkInterfaces), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetNetworkInterfaces(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__GetNetworkInterfaces *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetNetworkInterfaces, 0, sizeof(struct _tds__GetNetworkInterfaces), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetNetworkInterfaces(struct soap *soap, const struct _tds__GetNetworkInterfaces *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__GetNetworkInterfaces);
	if (soap_out__tds__GetNetworkInterfaces(soap, tag?tag:"tds:GetNetworkInterfaces", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetNetworkInterfaces * SOAP_FMAC4 soap_get__tds__GetNetworkInterfaces(struct soap *soap, struct _tds__GetNetworkInterfaces *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetNetworkInterfaces(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__SetDynamicDNSResponse(struct soap *soap, struct _tds__SetDynamicDNSResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__SetDynamicDNSResponse(struct soap *soap, const struct _tds__SetDynamicDNSResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetDynamicDNSResponse(struct soap *soap, const char *tag, int id, const struct _tds__SetDynamicDNSResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetDynamicDNSResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__SetDynamicDNSResponse * SOAP_FMAC4 soap_in__tds__SetDynamicDNSResponse(struct soap *soap, const char *tag, struct _tds__SetDynamicDNSResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__SetDynamicDNSResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetDynamicDNSResponse, sizeof(struct _tds__SetDynamicDNSResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__SetDynamicDNSResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__SetDynamicDNSResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetDynamicDNSResponse, 0, sizeof(struct _tds__SetDynamicDNSResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__SetDynamicDNSResponse(struct soap *soap, const struct _tds__SetDynamicDNSResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__SetDynamicDNSResponse);
	if (soap_out__tds__SetDynamicDNSResponse(soap, tag?tag:"tds:SetDynamicDNSResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetDynamicDNSResponse * SOAP_FMAC4 soap_get__tds__SetDynamicDNSResponse(struct soap *soap, struct _tds__SetDynamicDNSResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetDynamicDNSResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__SetDynamicDNS(struct soap *soap, struct _tds__SetDynamicDNS *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__DynamicDNSType(soap, &a->Type);
	a->Name = NULL;
	soap_default_string(soap, &a->TTL);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__SetDynamicDNS(struct soap *soap, const struct _tds__SetDynamicDNS *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTott__DNSName(soap, &a->Name);
	soap_serialize_string(soap, &a->TTL);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetDynamicDNS(struct soap *soap, const char *tag, int id, const struct _tds__SetDynamicDNS *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetDynamicDNS), type))
		return soap->error;
	if (soap_out_tt__DynamicDNSType(soap, "tds:Type", -1, &a->Type, ""))
		return soap->error;
	if (soap_out_PointerTott__DNSName(soap, "tds:Name", -1, &a->Name, ""))
		return soap->error;
	if (soap_out_string(soap, "tds:TTL", -1, &a->TTL, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__SetDynamicDNS * SOAP_FMAC4 soap_in__tds__SetDynamicDNS(struct soap *soap, const char *tag, struct _tds__SetDynamicDNS *a, const char *type)
{
	size_t soap_flag_Type = 1;
	size_t soap_flag_Name = 1;
	size_t soap_flag_TTL = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__SetDynamicDNS *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetDynamicDNS, sizeof(struct _tds__SetDynamicDNS), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__SetDynamicDNS(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Type && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_tt__DynamicDNSType(soap, "tds:Type", &a->Type, "tt:DynamicDNSType"))
				{	soap_flag_Type--;
					continue;
				}
			if (soap_flag_Name && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__DNSName(soap, "tds:Name", &a->Name, "tt:DNSName"))
				{	soap_flag_Name--;
					continue;
				}
			if (soap_flag_TTL && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "tds:TTL", &a->TTL, "xsd:string"))
				{	soap_flag_TTL--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__SetDynamicDNS *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetDynamicDNS, 0, sizeof(struct _tds__SetDynamicDNS), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Type > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__SetDynamicDNS(struct soap *soap, const struct _tds__SetDynamicDNS *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__SetDynamicDNS);
	if (soap_out__tds__SetDynamicDNS(soap, tag?tag:"tds:SetDynamicDNS", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetDynamicDNS * SOAP_FMAC4 soap_get__tds__SetDynamicDNS(struct soap *soap, struct _tds__SetDynamicDNS *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetDynamicDNS(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__DynamicDNSInformation(struct soap *soap, struct tt__DynamicDNSInformation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__DynamicDNSType(soap, &a->Type);
	a->Name = NULL;
	soap_default_string(soap, &a->TTL);
	a->Extension = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__DynamicDNSInformation(struct soap *soap, const struct tt__DynamicDNSInformation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTott__DNSName(soap, &a->Name);
	soap_serialize_string(soap, &a->TTL);
	soap_serialize_PointerTott__DynamicDNSInformationExtension(soap, &a->Extension);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__DynamicDNSInformation(struct soap *soap, const char *tag, int id, const struct tt__DynamicDNSInformation *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__DynamicDNSInformation), type))
		return soap->error;
	if (soap_out_tt__DynamicDNSType(soap, "tt:Type", -1, &a->Type, ""))
		return soap->error;
	if (soap_out_PointerTott__DNSName(soap, "tt:Name", -1, &a->Name, ""))
		return soap->error;
	if (soap_out_string(soap, "tt:TTL", -1, &a->TTL, ""))
		return soap->error;
	if (soap_out_PointerTott__DynamicDNSInformationExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__DynamicDNSInformation * SOAP_FMAC4 soap_in_tt__DynamicDNSInformation(struct soap *soap, const char *tag, struct tt__DynamicDNSInformation *a, const char *type)
{
	size_t soap_flag_Type = 1;
	size_t soap_flag_Name = 1;
	size_t soap_flag_TTL = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__DynamicDNSInformation *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__DynamicDNSInformation, sizeof(struct tt__DynamicDNSInformation), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__DynamicDNSInformation(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Type && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_tt__DynamicDNSType(soap, "tt:Type", &a->Type, "tt:DynamicDNSType"))
				{	soap_flag_Type--;
					continue;
				}
			if (soap_flag_Name && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__DNSName(soap, "tt:Name", &a->Name, "tt:DNSName"))
				{	soap_flag_Name--;
					continue;
				}
			if (soap_flag_TTL && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "tt:TTL", &a->TTL, "xsd:string"))
				{	soap_flag_TTL--;
					continue;
				}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__DynamicDNSInformationExtension(soap, "tt:Extension", &a->Extension, "tt:DynamicDNSInformationExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__DynamicDNSInformation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__DynamicDNSInformation, 0, sizeof(struct tt__DynamicDNSInformation), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Type > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__DynamicDNSInformation(struct soap *soap, const struct tt__DynamicDNSInformation *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__DynamicDNSInformation);
	if (soap_out_tt__DynamicDNSInformation(soap, tag?tag:"tt:DynamicDNSInformation", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__DynamicDNSInformation * SOAP_FMAC4 soap_get_tt__DynamicDNSInformation(struct soap *soap, struct tt__DynamicDNSInformation *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__DynamicDNSInformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetDynamicDNSResponse(struct soap *soap, struct _tds__GetDynamicDNSResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->DynamicDNSInformation = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetDynamicDNSResponse(struct soap *soap, const struct _tds__GetDynamicDNSResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTott__DynamicDNSInformation(soap, &a->DynamicDNSInformation);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetDynamicDNSResponse(struct soap *soap, const char *tag, int id, const struct _tds__GetDynamicDNSResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetDynamicDNSResponse), type))
		return soap->error;
	if (a->DynamicDNSInformation)
		soap_element_result(soap, "tds:DynamicDNSInformation");
	if (a->DynamicDNSInformation)
	{	if (soap_out_PointerTott__DynamicDNSInformation(soap, "tds:DynamicDNSInformation", -1, &a->DynamicDNSInformation, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tds:DynamicDNSInformation"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetDynamicDNSResponse * SOAP_FMAC4 soap_in__tds__GetDynamicDNSResponse(struct soap *soap, const char *tag, struct _tds__GetDynamicDNSResponse *a, const char *type)
{
	size_t soap_flag_DynamicDNSInformation = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__GetDynamicDNSResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetDynamicDNSResponse, sizeof(struct _tds__GetDynamicDNSResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetDynamicDNSResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_DynamicDNSInformation && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__DynamicDNSInformation(soap, "tds:DynamicDNSInformation", &a->DynamicDNSInformation, "tt:DynamicDNSInformation"))
				{	soap_flag_DynamicDNSInformation--;
					continue;
				}
			soap_check_result(soap, "tds:DynamicDNSInformation");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__GetDynamicDNSResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetDynamicDNSResponse, 0, sizeof(struct _tds__GetDynamicDNSResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_DynamicDNSInformation > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetDynamicDNSResponse(struct soap *soap, const struct _tds__GetDynamicDNSResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__GetDynamicDNSResponse);
	if (soap_out__tds__GetDynamicDNSResponse(soap, tag?tag:"tds:GetDynamicDNSResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetDynamicDNSResponse * SOAP_FMAC4 soap_get__tds__GetDynamicDNSResponse(struct soap *soap, struct _tds__GetDynamicDNSResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetDynamicDNSResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetDynamicDNS(struct soap *soap, struct _tds__GetDynamicDNS *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetDynamicDNS(struct soap *soap, const struct _tds__GetDynamicDNS *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetDynamicDNS(struct soap *soap, const char *tag, int id, const struct _tds__GetDynamicDNS *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetDynamicDNS), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetDynamicDNS * SOAP_FMAC4 soap_in__tds__GetDynamicDNS(struct soap *soap, const char *tag, struct _tds__GetDynamicDNS *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__GetDynamicDNS *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetDynamicDNS, sizeof(struct _tds__GetDynamicDNS), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetDynamicDNS(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__GetDynamicDNS *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetDynamicDNS, 0, sizeof(struct _tds__GetDynamicDNS), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetDynamicDNS(struct soap *soap, const struct _tds__GetDynamicDNS *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__GetDynamicDNS);
	if (soap_out__tds__GetDynamicDNS(soap, tag?tag:"tds:GetDynamicDNS", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetDynamicDNS * SOAP_FMAC4 soap_get__tds__GetDynamicDNS(struct soap *soap, struct _tds__GetDynamicDNS *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetDynamicDNS(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__SetNTPResponse(struct soap *soap, struct _tds__SetNTPResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__SetNTPResponse(struct soap *soap, const struct _tds__SetNTPResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetNTPResponse(struct soap *soap, const char *tag, int id, const struct _tds__SetNTPResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetNTPResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__SetNTPResponse * SOAP_FMAC4 soap_in__tds__SetNTPResponse(struct soap *soap, const char *tag, struct _tds__SetNTPResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__SetNTPResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetNTPResponse, sizeof(struct _tds__SetNTPResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__SetNTPResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__SetNTPResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetNTPResponse, 0, sizeof(struct _tds__SetNTPResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__SetNTPResponse(struct soap *soap, const struct _tds__SetNTPResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__SetNTPResponse);
	if (soap_out__tds__SetNTPResponse(soap, tag?tag:"tds:SetNTPResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetNTPResponse * SOAP_FMAC4 soap_get__tds__SetNTPResponse(struct soap *soap, struct _tds__SetNTPResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetNTPResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__SetNTP(struct soap *soap, struct _tds__SetNTP *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__boolean_(soap, &a->FromDHCP);
	a->__sizeNTPManual = 0;
	a->NTPManual = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__SetNTP(struct soap *soap, const struct _tds__SetNTP *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->FromDHCP, SOAP_TYPE_xsd__boolean_);
	if (a->NTPManual)
	{	int i;
		for (i = 0; i < a->__sizeNTPManual; i++)
		{
			soap_embedded(soap, a->NTPManual + i, SOAP_TYPE_tt__NetworkHost);
			soap_serialize_tt__NetworkHost(soap, a->NTPManual + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetNTP(struct soap *soap, const char *tag, int id, const struct _tds__SetNTP *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetNTP), type))
		return soap->error;
	if (soap_out_xsd__boolean_(soap, "tds:FromDHCP", -1, &a->FromDHCP, ""))
		return soap->error;
	if (a->NTPManual)
	{	int i;
		for (i = 0; i < a->__sizeNTPManual; i++)
			if (soap_out_tt__NetworkHost(soap, "tds:NTPManual", -1, a->NTPManual + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__SetNTP * SOAP_FMAC4 soap_in__tds__SetNTP(struct soap *soap, const char *tag, struct _tds__SetNTP *a, const char *type)
{
	size_t soap_flag_FromDHCP = 1;
	struct soap_blist *soap_blist_NTPManual = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__SetNTP *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetNTP, sizeof(struct _tds__SetNTP), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__SetNTP(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_FromDHCP && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean_(soap, "tds:FromDHCP", &a->FromDHCP, "xsd:boolean"))
				{	soap_flag_FromDHCP--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tds:NTPManual", 1, NULL))
			{	if (a->NTPManual == NULL)
				{	if (soap_blist_NTPManual == NULL)
						soap_blist_NTPManual = soap_new_block(soap);
					a->NTPManual = (struct tt__NetworkHost *)soap_push_block(soap, soap_blist_NTPManual, sizeof(struct tt__NetworkHost));
					if (a->NTPManual == NULL)
						return NULL;
					soap_default_tt__NetworkHost(soap, a->NTPManual);
				}
				soap_revert(soap);
				if (soap_in_tt__NetworkHost(soap, "tds:NTPManual", a->NTPManual, "tt:NetworkHost"))
				{	a->__sizeNTPManual++;
					a->NTPManual = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->NTPManual)
			soap_pop_block(soap, soap_blist_NTPManual);
		if (a->__sizeNTPManual)
			a->NTPManual = (struct tt__NetworkHost *)soap_save_block(soap, soap_blist_NTPManual, NULL, 1);
		else
		{	a->NTPManual = NULL;
			if (soap_blist_NTPManual)
				soap_end_block(soap, soap_blist_NTPManual);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__SetNTP *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetNTP, 0, sizeof(struct _tds__SetNTP), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_FromDHCP > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__SetNTP(struct soap *soap, const struct _tds__SetNTP *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__SetNTP);
	if (soap_out__tds__SetNTP(soap, tag?tag:"tds:SetNTP", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetNTP * SOAP_FMAC4 soap_get__tds__SetNTP(struct soap *soap, struct _tds__SetNTP *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetNTP(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__NTPInformation(struct soap *soap, struct tt__NTPInformation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__boolean_(soap, &a->FromDHCP);
	a->__sizeNTPFromDHCP = 0;
	a->NTPFromDHCP = NULL;
	a->__sizeNTPManual = 0;
	a->NTPManual = NULL;
	a->Extension = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__NTPInformation(struct soap *soap, const struct tt__NTPInformation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->FromDHCP, SOAP_TYPE_xsd__boolean_);
	if (a->NTPFromDHCP)
	{	int i;
		for (i = 0; i < a->__sizeNTPFromDHCP; i++)
		{
			soap_embedded(soap, a->NTPFromDHCP + i, SOAP_TYPE_tt__NetworkHost);
			soap_serialize_tt__NetworkHost(soap, a->NTPFromDHCP + i);
		}
	}
	if (a->NTPManual)
	{	int i;
		for (i = 0; i < a->__sizeNTPManual; i++)
		{
			soap_embedded(soap, a->NTPManual + i, SOAP_TYPE_tt__NetworkHost);
			soap_serialize_tt__NetworkHost(soap, a->NTPManual + i);
		}
	}
	soap_serialize_PointerTott__NTPInformationExtension(soap, &a->Extension);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__NTPInformation(struct soap *soap, const char *tag, int id, const struct tt__NTPInformation *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__NTPInformation), type))
		return soap->error;
	if (soap_out_xsd__boolean_(soap, "tt:FromDHCP", -1, &a->FromDHCP, ""))
		return soap->error;
	if (a->NTPFromDHCP)
	{	int i;
		for (i = 0; i < a->__sizeNTPFromDHCP; i++)
			if (soap_out_tt__NetworkHost(soap, "tt:NTPFromDHCP", -1, a->NTPFromDHCP + i, ""))
				return soap->error;
	}
	if (a->NTPManual)
	{	int i;
		for (i = 0; i < a->__sizeNTPManual; i++)
			if (soap_out_tt__NetworkHost(soap, "tt:NTPManual", -1, a->NTPManual + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTott__NTPInformationExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__NTPInformation * SOAP_FMAC4 soap_in_tt__NTPInformation(struct soap *soap, const char *tag, struct tt__NTPInformation *a, const char *type)
{
	size_t soap_flag_FromDHCP = 1;
	struct soap_blist *soap_blist_NTPFromDHCP = NULL;
	struct soap_blist *soap_blist_NTPManual = NULL;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__NTPInformation *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__NTPInformation, sizeof(struct tt__NTPInformation), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__NTPInformation(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_FromDHCP && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean_(soap, "tt:FromDHCP", &a->FromDHCP, "xsd:boolean"))
				{	soap_flag_FromDHCP--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:NTPFromDHCP", 1, NULL))
			{	if (a->NTPFromDHCP == NULL)
				{	if (soap_blist_NTPFromDHCP == NULL)
						soap_blist_NTPFromDHCP = soap_new_block(soap);
					a->NTPFromDHCP = (struct tt__NetworkHost *)soap_push_block(soap, soap_blist_NTPFromDHCP, sizeof(struct tt__NetworkHost));
					if (a->NTPFromDHCP == NULL)
						return NULL;
					soap_default_tt__NetworkHost(soap, a->NTPFromDHCP);
				}
				soap_revert(soap);
				if (soap_in_tt__NetworkHost(soap, "tt:NTPFromDHCP", a->NTPFromDHCP, "tt:NetworkHost"))
				{	a->__sizeNTPFromDHCP++;
					a->NTPFromDHCP = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:NTPManual", 1, NULL))
			{	if (a->NTPManual == NULL)
				{	if (soap_blist_NTPManual == NULL)
						soap_blist_NTPManual = soap_new_block(soap);
					a->NTPManual = (struct tt__NetworkHost *)soap_push_block(soap, soap_blist_NTPManual, sizeof(struct tt__NetworkHost));
					if (a->NTPManual == NULL)
						return NULL;
					soap_default_tt__NetworkHost(soap, a->NTPManual);
				}
				soap_revert(soap);
				if (soap_in_tt__NetworkHost(soap, "tt:NTPManual", a->NTPManual, "tt:NetworkHost"))
				{	a->__sizeNTPManual++;
					a->NTPManual = NULL;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__NTPInformationExtension(soap, "tt:Extension", &a->Extension, "tt:NTPInformationExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->NTPFromDHCP)
			soap_pop_block(soap, soap_blist_NTPFromDHCP);
		if (a->__sizeNTPFromDHCP)
			a->NTPFromDHCP = (struct tt__NetworkHost *)soap_save_block(soap, soap_blist_NTPFromDHCP, NULL, 1);
		else
		{	a->NTPFromDHCP = NULL;
			if (soap_blist_NTPFromDHCP)
				soap_end_block(soap, soap_blist_NTPFromDHCP);
		}
		if (a->NTPManual)
			soap_pop_block(soap, soap_blist_NTPManual);
		if (a->__sizeNTPManual)
			a->NTPManual = (struct tt__NetworkHost *)soap_save_block(soap, soap_blist_NTPManual, NULL, 1);
		else
		{	a->NTPManual = NULL;
			if (soap_blist_NTPManual)
				soap_end_block(soap, soap_blist_NTPManual);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__NTPInformation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__NTPInformation, 0, sizeof(struct tt__NTPInformation), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_FromDHCP > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__NTPInformation(struct soap *soap, const struct tt__NTPInformation *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__NTPInformation);
	if (soap_out_tt__NTPInformation(soap, tag?tag:"tt:NTPInformation", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__NTPInformation * SOAP_FMAC4 soap_get_tt__NTPInformation(struct soap *soap, struct tt__NTPInformation *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__NTPInformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetNTPResponse(struct soap *soap, struct _tds__GetNTPResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->NTPInformation = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetNTPResponse(struct soap *soap, const struct _tds__GetNTPResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTott__NTPInformation(soap, &a->NTPInformation);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetNTPResponse(struct soap *soap, const char *tag, int id, const struct _tds__GetNTPResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetNTPResponse), type))
		return soap->error;
	if (a->NTPInformation)
		soap_element_result(soap, "tds:NTPInformation");
	if (a->NTPInformation)
	{	if (soap_out_PointerTott__NTPInformation(soap, "tds:NTPInformation", -1, &a->NTPInformation, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tds:NTPInformation"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetNTPResponse * SOAP_FMAC4 soap_in__tds__GetNTPResponse(struct soap *soap, const char *tag, struct _tds__GetNTPResponse *a, const char *type)
{
	size_t soap_flag_NTPInformation = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__GetNTPResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetNTPResponse, sizeof(struct _tds__GetNTPResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetNTPResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_NTPInformation && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__NTPInformation(soap, "tds:NTPInformation", &a->NTPInformation, "tt:NTPInformation"))
				{	soap_flag_NTPInformation--;
					continue;
				}
			soap_check_result(soap, "tds:NTPInformation");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__GetNTPResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetNTPResponse, 0, sizeof(struct _tds__GetNTPResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_NTPInformation > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetNTPResponse(struct soap *soap, const struct _tds__GetNTPResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__GetNTPResponse);
	if (soap_out__tds__GetNTPResponse(soap, tag?tag:"tds:GetNTPResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetNTPResponse * SOAP_FMAC4 soap_get__tds__GetNTPResponse(struct soap *soap, struct _tds__GetNTPResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetNTPResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetNTP(struct soap *soap, struct _tds__GetNTP *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetNTP(struct soap *soap, const struct _tds__GetNTP *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetNTP(struct soap *soap, const char *tag, int id, const struct _tds__GetNTP *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetNTP), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetNTP * SOAP_FMAC4 soap_in__tds__GetNTP(struct soap *soap, const char *tag, struct _tds__GetNTP *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__GetNTP *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetNTP, sizeof(struct _tds__GetNTP), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetNTP(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__GetNTP *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetNTP, 0, sizeof(struct _tds__GetNTP), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetNTP(struct soap *soap, const struct _tds__GetNTP *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__GetNTP);
	if (soap_out__tds__GetNTP(soap, tag?tag:"tds:GetNTP", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetNTP * SOAP_FMAC4 soap_get__tds__GetNTP(struct soap *soap, struct _tds__GetNTP *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetNTP(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__SetDNSResponse(struct soap *soap, struct _tds__SetDNSResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__SetDNSResponse(struct soap *soap, const struct _tds__SetDNSResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetDNSResponse(struct soap *soap, const char *tag, int id, const struct _tds__SetDNSResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetDNSResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__SetDNSResponse * SOAP_FMAC4 soap_in__tds__SetDNSResponse(struct soap *soap, const char *tag, struct _tds__SetDNSResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__SetDNSResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetDNSResponse, sizeof(struct _tds__SetDNSResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__SetDNSResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__SetDNSResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetDNSResponse, 0, sizeof(struct _tds__SetDNSResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__SetDNSResponse(struct soap *soap, const struct _tds__SetDNSResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__SetDNSResponse);
	if (soap_out__tds__SetDNSResponse(soap, tag?tag:"tds:SetDNSResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetDNSResponse * SOAP_FMAC4 soap_get__tds__SetDNSResponse(struct soap *soap, struct _tds__SetDNSResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetDNSResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__IPAddress(struct soap *soap, struct tt__IPAddress *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__IPType(soap, &a->Type);
	a->IPv4Address = NULL;
	a->IPv6Address = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__IPAddress(struct soap *soap, const struct tt__IPAddress *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTott__IPv4Address(soap, &a->IPv4Address);
	soap_serialize_PointerTott__IPv6Address(soap, &a->IPv6Address);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IPAddress(struct soap *soap, const char *tag, int id, const struct tt__IPAddress *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__IPAddress), type))
		return soap->error;
	if (soap_out_tt__IPType(soap, "tt:Type", -1, &a->Type, ""))
		return soap->error;
	if (soap_out_PointerTott__IPv4Address(soap, "tt:IPv4Address", -1, &a->IPv4Address, ""))
		return soap->error;
	if (soap_out_PointerTott__IPv6Address(soap, "tt:IPv6Address", -1, &a->IPv6Address, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__IPAddress * SOAP_FMAC4 soap_in_tt__IPAddress(struct soap *soap, const char *tag, struct tt__IPAddress *a, const char *type)
{
	size_t soap_flag_Type = 1;
	size_t soap_flag_IPv4Address = 1;
	size_t soap_flag_IPv6Address = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__IPAddress *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IPAddress, sizeof(struct tt__IPAddress), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__IPAddress(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Type && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_tt__IPType(soap, "tt:Type", &a->Type, "tt:IPType"))
				{	soap_flag_Type--;
					continue;
				}
			if (soap_flag_IPv4Address && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IPv4Address(soap, "tt:IPv4Address", &a->IPv4Address, "tt:IPv4Address"))
				{	soap_flag_IPv4Address--;
					continue;
				}
			if (soap_flag_IPv6Address && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IPv6Address(soap, "tt:IPv6Address", &a->IPv6Address, "tt:IPv6Address"))
				{	soap_flag_IPv6Address--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__IPAddress *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__IPAddress, 0, sizeof(struct tt__IPAddress), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Type > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__IPAddress(struct soap *soap, const struct tt__IPAddress *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__IPAddress);
	if (soap_out_tt__IPAddress(soap, tag?tag:"tt:IPAddress", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__IPAddress * SOAP_FMAC4 soap_get_tt__IPAddress(struct soap *soap, struct tt__IPAddress *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__IPAddress(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__SetDNS(struct soap *soap, struct _tds__SetDNS *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__boolean_(soap, &a->FromDHCP);
	a->__sizeSearchDomain = 0;
	a->SearchDomain = NULL;
	a->__sizeDNSManual = 0;
	a->DNSManual = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__SetDNS(struct soap *soap, const struct _tds__SetDNS *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->FromDHCP, SOAP_TYPE_xsd__boolean_);
	if (a->SearchDomain)
	{	int i;
		for (i = 0; i < a->__sizeSearchDomain; i++)
		{
			soap_serialize_xsd__token(soap, a->SearchDomain + i);
		}
	}
	if (a->DNSManual)
	{	int i;
		for (i = 0; i < a->__sizeDNSManual; i++)
		{
			soap_embedded(soap, a->DNSManual + i, SOAP_TYPE_tt__IPAddress);
			soap_serialize_tt__IPAddress(soap, a->DNSManual + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetDNS(struct soap *soap, const char *tag, int id, const struct _tds__SetDNS *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetDNS), type))
		return soap->error;
	if (soap_out_xsd__boolean_(soap, "tds:FromDHCP", -1, &a->FromDHCP, ""))
		return soap->error;
	if (a->SearchDomain)
	{	int i;
		for (i = 0; i < a->__sizeSearchDomain; i++)
			if (soap_out_xsd__token(soap, "tds:SearchDomain", -1, a->SearchDomain + i, ""))
				return soap->error;
	}
	if (a->DNSManual)
	{	int i;
		for (i = 0; i < a->__sizeDNSManual; i++)
			if (soap_out_tt__IPAddress(soap, "tds:DNSManual", -1, a->DNSManual + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__SetDNS * SOAP_FMAC4 soap_in__tds__SetDNS(struct soap *soap, const char *tag, struct _tds__SetDNS *a, const char *type)
{
	size_t soap_flag_FromDHCP = 1;
	struct soap_blist *soap_blist_SearchDomain = NULL;
	struct soap_blist *soap_blist_DNSManual = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__SetDNS *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetDNS, sizeof(struct _tds__SetDNS), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__SetDNS(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_FromDHCP && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean_(soap, "tds:FromDHCP", &a->FromDHCP, "xsd:boolean"))
				{	soap_flag_FromDHCP--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tds:SearchDomain", 1, NULL))
			{	if (a->SearchDomain == NULL)
				{	if (soap_blist_SearchDomain == NULL)
						soap_blist_SearchDomain = soap_new_block(soap);
					a->SearchDomain = (char **)soap_push_block(soap, soap_blist_SearchDomain, sizeof(char *));
					if (a->SearchDomain == NULL)
						return NULL;
					*a->SearchDomain = NULL;
				}
				soap_revert(soap);
				if (soap_in_xsd__token(soap, "tds:SearchDomain", a->SearchDomain, "xsd:token"))
				{	a->__sizeSearchDomain++;
					a->SearchDomain = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tds:DNSManual", 1, NULL))
			{	if (a->DNSManual == NULL)
				{	if (soap_blist_DNSManual == NULL)
						soap_blist_DNSManual = soap_new_block(soap);
					a->DNSManual = (struct tt__IPAddress *)soap_push_block(soap, soap_blist_DNSManual, sizeof(struct tt__IPAddress));
					if (a->DNSManual == NULL)
						return NULL;
					soap_default_tt__IPAddress(soap, a->DNSManual);
				}
				soap_revert(soap);
				if (soap_in_tt__IPAddress(soap, "tds:DNSManual", a->DNSManual, "tt:IPAddress"))
				{	a->__sizeDNSManual++;
					a->DNSManual = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->SearchDomain)
			soap_pop_block(soap, soap_blist_SearchDomain);
		if (a->__sizeSearchDomain)
			a->SearchDomain = (char **)soap_save_block(soap, soap_blist_SearchDomain, NULL, 1);
		else
		{	a->SearchDomain = NULL;
			if (soap_blist_SearchDomain)
				soap_end_block(soap, soap_blist_SearchDomain);
		}
		if (a->DNSManual)
			soap_pop_block(soap, soap_blist_DNSManual);
		if (a->__sizeDNSManual)
			a->DNSManual = (struct tt__IPAddress *)soap_save_block(soap, soap_blist_DNSManual, NULL, 1);
		else
		{	a->DNSManual = NULL;
			if (soap_blist_DNSManual)
				soap_end_block(soap, soap_blist_DNSManual);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__SetDNS *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetDNS, 0, sizeof(struct _tds__SetDNS), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_FromDHCP > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__SetDNS(struct soap *soap, const struct _tds__SetDNS *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__SetDNS);
	if (soap_out__tds__SetDNS(soap, tag?tag:"tds:SetDNS", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetDNS * SOAP_FMAC4 soap_get__tds__SetDNS(struct soap *soap, struct _tds__SetDNS *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetDNS(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__DNSInformation(struct soap *soap, struct tt__DNSInformation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__boolean_(soap, &a->FromDHCP);
	a->__sizeSearchDomain = 0;
	a->SearchDomain = NULL;
	a->__sizeDNSFromDHCP = 0;
	a->DNSFromDHCP = NULL;
	a->__sizeDNSManual = 0;
	a->DNSManual = NULL;
	a->Extension = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__DNSInformation(struct soap *soap, const struct tt__DNSInformation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->FromDHCP, SOAP_TYPE_xsd__boolean_);
	if (a->SearchDomain)
	{	int i;
		for (i = 0; i < a->__sizeSearchDomain; i++)
		{
			soap_serialize_xsd__token(soap, a->SearchDomain + i);
		}
	}
	if (a->DNSFromDHCP)
	{	int i;
		for (i = 0; i < a->__sizeDNSFromDHCP; i++)
		{
			soap_embedded(soap, a->DNSFromDHCP + i, SOAP_TYPE_tt__IPAddress);
			soap_serialize_tt__IPAddress(soap, a->DNSFromDHCP + i);
		}
	}
	if (a->DNSManual)
	{	int i;
		for (i = 0; i < a->__sizeDNSManual; i++)
		{
			soap_embedded(soap, a->DNSManual + i, SOAP_TYPE_tt__IPAddress);
			soap_serialize_tt__IPAddress(soap, a->DNSManual + i);
		}
	}
	soap_serialize_PointerTott__DNSInformationExtension(soap, &a->Extension);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__DNSInformation(struct soap *soap, const char *tag, int id, const struct tt__DNSInformation *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__DNSInformation), type))
		return soap->error;
	if (soap_out_xsd__boolean_(soap, "tt:FromDHCP", -1, &a->FromDHCP, ""))
		return soap->error;
	if (a->SearchDomain)
	{	int i;
		for (i = 0; i < a->__sizeSearchDomain; i++)
			if (soap_out_xsd__token(soap, "tt:SearchDomain", -1, a->SearchDomain + i, ""))
				return soap->error;
	}
	if (a->DNSFromDHCP)
	{	int i;
		for (i = 0; i < a->__sizeDNSFromDHCP; i++)
			if (soap_out_tt__IPAddress(soap, "tt:DNSFromDHCP", -1, a->DNSFromDHCP + i, ""))
				return soap->error;
	}
	if (a->DNSManual)
	{	int i;
		for (i = 0; i < a->__sizeDNSManual; i++)
			if (soap_out_tt__IPAddress(soap, "tt:DNSManual", -1, a->DNSManual + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTott__DNSInformationExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__DNSInformation * SOAP_FMAC4 soap_in_tt__DNSInformation(struct soap *soap, const char *tag, struct tt__DNSInformation *a, const char *type)
{
	size_t soap_flag_FromDHCP = 1;
	struct soap_blist *soap_blist_SearchDomain = NULL;
	struct soap_blist *soap_blist_DNSFromDHCP = NULL;
	struct soap_blist *soap_blist_DNSManual = NULL;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__DNSInformation *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__DNSInformation, sizeof(struct tt__DNSInformation), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__DNSInformation(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_FromDHCP && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean_(soap, "tt:FromDHCP", &a->FromDHCP, "xsd:boolean"))
				{	soap_flag_FromDHCP--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:SearchDomain", 1, NULL))
			{	if (a->SearchDomain == NULL)
				{	if (soap_blist_SearchDomain == NULL)
						soap_blist_SearchDomain = soap_new_block(soap);
					a->SearchDomain = (char **)soap_push_block(soap, soap_blist_SearchDomain, sizeof(char *));
					if (a->SearchDomain == NULL)
						return NULL;
					*a->SearchDomain = NULL;
				}
				soap_revert(soap);
				if (soap_in_xsd__token(soap, "tt:SearchDomain", a->SearchDomain, "xsd:token"))
				{	a->__sizeSearchDomain++;
					a->SearchDomain = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:DNSFromDHCP", 1, NULL))
			{	if (a->DNSFromDHCP == NULL)
				{	if (soap_blist_DNSFromDHCP == NULL)
						soap_blist_DNSFromDHCP = soap_new_block(soap);
					a->DNSFromDHCP = (struct tt__IPAddress *)soap_push_block(soap, soap_blist_DNSFromDHCP, sizeof(struct tt__IPAddress));
					if (a->DNSFromDHCP == NULL)
						return NULL;
					soap_default_tt__IPAddress(soap, a->DNSFromDHCP);
				}
				soap_revert(soap);
				if (soap_in_tt__IPAddress(soap, "tt:DNSFromDHCP", a->DNSFromDHCP, "tt:IPAddress"))
				{	a->__sizeDNSFromDHCP++;
					a->DNSFromDHCP = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:DNSManual", 1, NULL))
			{	if (a->DNSManual == NULL)
				{	if (soap_blist_DNSManual == NULL)
						soap_blist_DNSManual = soap_new_block(soap);
					a->DNSManual = (struct tt__IPAddress *)soap_push_block(soap, soap_blist_DNSManual, sizeof(struct tt__IPAddress));
					if (a->DNSManual == NULL)
						return NULL;
					soap_default_tt__IPAddress(soap, a->DNSManual);
				}
				soap_revert(soap);
				if (soap_in_tt__IPAddress(soap, "tt:DNSManual", a->DNSManual, "tt:IPAddress"))
				{	a->__sizeDNSManual++;
					a->DNSManual = NULL;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__DNSInformationExtension(soap, "tt:Extension", &a->Extension, "tt:DNSInformationExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->SearchDomain)
			soap_pop_block(soap, soap_blist_SearchDomain);
		if (a->__sizeSearchDomain)
			a->SearchDomain = (char **)soap_save_block(soap, soap_blist_SearchDomain, NULL, 1);
		else
		{	a->SearchDomain = NULL;
			if (soap_blist_SearchDomain)
				soap_end_block(soap, soap_blist_SearchDomain);
		}
		if (a->DNSFromDHCP)
			soap_pop_block(soap, soap_blist_DNSFromDHCP);
		if (a->__sizeDNSFromDHCP)
			a->DNSFromDHCP = (struct tt__IPAddress *)soap_save_block(soap, soap_blist_DNSFromDHCP, NULL, 1);
		else
		{	a->DNSFromDHCP = NULL;
			if (soap_blist_DNSFromDHCP)
				soap_end_block(soap, soap_blist_DNSFromDHCP);
		}
		if (a->DNSManual)
			soap_pop_block(soap, soap_blist_DNSManual);
		if (a->__sizeDNSManual)
			a->DNSManual = (struct tt__IPAddress *)soap_save_block(soap, soap_blist_DNSManual, NULL, 1);
		else
		{	a->DNSManual = NULL;
			if (soap_blist_DNSManual)
				soap_end_block(soap, soap_blist_DNSManual);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__DNSInformation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__DNSInformation, 0, sizeof(struct tt__DNSInformation), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_FromDHCP > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__DNSInformation(struct soap *soap, const struct tt__DNSInformation *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__DNSInformation);
	if (soap_out_tt__DNSInformation(soap, tag?tag:"tt:DNSInformation", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__DNSInformation * SOAP_FMAC4 soap_get_tt__DNSInformation(struct soap *soap, struct tt__DNSInformation *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__DNSInformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetDNSResponse(struct soap *soap, struct _tds__GetDNSResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->DNSInformation = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetDNSResponse(struct soap *soap, const struct _tds__GetDNSResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTott__DNSInformation(soap, &a->DNSInformation);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetDNSResponse(struct soap *soap, const char *tag, int id, const struct _tds__GetDNSResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetDNSResponse), type))
		return soap->error;
	if (a->DNSInformation)
		soap_element_result(soap, "tds:DNSInformation");
	if (a->DNSInformation)
	{	if (soap_out_PointerTott__DNSInformation(soap, "tds:DNSInformation", -1, &a->DNSInformation, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tds:DNSInformation"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetDNSResponse * SOAP_FMAC4 soap_in__tds__GetDNSResponse(struct soap *soap, const char *tag, struct _tds__GetDNSResponse *a, const char *type)
{
	size_t soap_flag_DNSInformation = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__GetDNSResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetDNSResponse, sizeof(struct _tds__GetDNSResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetDNSResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_DNSInformation && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__DNSInformation(soap, "tds:DNSInformation", &a->DNSInformation, "tt:DNSInformation"))
				{	soap_flag_DNSInformation--;
					continue;
				}
			soap_check_result(soap, "tds:DNSInformation");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__GetDNSResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetDNSResponse, 0, sizeof(struct _tds__GetDNSResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_DNSInformation > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetDNSResponse(struct soap *soap, const struct _tds__GetDNSResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__GetDNSResponse);
	if (soap_out__tds__GetDNSResponse(soap, tag?tag:"tds:GetDNSResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetDNSResponse * SOAP_FMAC4 soap_get__tds__GetDNSResponse(struct soap *soap, struct _tds__GetDNSResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetDNSResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetDNS(struct soap *soap, struct _tds__GetDNS *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetDNS(struct soap *soap, const struct _tds__GetDNS *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetDNS(struct soap *soap, const char *tag, int id, const struct _tds__GetDNS *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetDNS), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetDNS * SOAP_FMAC4 soap_in__tds__GetDNS(struct soap *soap, const char *tag, struct _tds__GetDNS *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__GetDNS *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetDNS, sizeof(struct _tds__GetDNS), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetDNS(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__GetDNS *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetDNS, 0, sizeof(struct _tds__GetDNS), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetDNS(struct soap *soap, const struct _tds__GetDNS *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__GetDNS);
	if (soap_out__tds__GetDNS(soap, tag?tag:"tds:GetDNS", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetDNS * SOAP_FMAC4 soap_get__tds__GetDNS(struct soap *soap, struct _tds__GetDNS *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetDNS(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__SetHostnameFromDHCPResponse(struct soap *soap, struct _tds__SetHostnameFromDHCPResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__boolean_(soap, &a->RebootNeeded);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__SetHostnameFromDHCPResponse(struct soap *soap, const struct _tds__SetHostnameFromDHCPResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->RebootNeeded, SOAP_TYPE_xsd__boolean_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetHostnameFromDHCPResponse(struct soap *soap, const char *tag, int id, const struct _tds__SetHostnameFromDHCPResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetHostnameFromDHCPResponse), type))
		return soap->error;
	soap_element_result(soap, "tds:RebootNeeded");
	if (soap_out_xsd__boolean_(soap, "tds:RebootNeeded", -1, &a->RebootNeeded, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__SetHostnameFromDHCPResponse * SOAP_FMAC4 soap_in__tds__SetHostnameFromDHCPResponse(struct soap *soap, const char *tag, struct _tds__SetHostnameFromDHCPResponse *a, const char *type)
{
	size_t soap_flag_RebootNeeded = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__SetHostnameFromDHCPResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetHostnameFromDHCPResponse, sizeof(struct _tds__SetHostnameFromDHCPResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__SetHostnameFromDHCPResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RebootNeeded && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean_(soap, "tds:RebootNeeded", &a->RebootNeeded, "xsd:boolean"))
				{	soap_flag_RebootNeeded--;
					continue;
				}
			soap_check_result(soap, "tds:RebootNeeded");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__SetHostnameFromDHCPResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetHostnameFromDHCPResponse, 0, sizeof(struct _tds__SetHostnameFromDHCPResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_RebootNeeded > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__SetHostnameFromDHCPResponse(struct soap *soap, const struct _tds__SetHostnameFromDHCPResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__SetHostnameFromDHCPResponse);
	if (soap_out__tds__SetHostnameFromDHCPResponse(soap, tag?tag:"tds:SetHostnameFromDHCPResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetHostnameFromDHCPResponse * SOAP_FMAC4 soap_get__tds__SetHostnameFromDHCPResponse(struct soap *soap, struct _tds__SetHostnameFromDHCPResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetHostnameFromDHCPResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__SetHostnameFromDHCP(struct soap *soap, struct _tds__SetHostnameFromDHCP *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__boolean_(soap, &a->FromDHCP);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__SetHostnameFromDHCP(struct soap *soap, const struct _tds__SetHostnameFromDHCP *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->FromDHCP, SOAP_TYPE_xsd__boolean_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetHostnameFromDHCP(struct soap *soap, const char *tag, int id, const struct _tds__SetHostnameFromDHCP *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetHostnameFromDHCP), type))
		return soap->error;
	if (soap_out_xsd__boolean_(soap, "tds:FromDHCP", -1, &a->FromDHCP, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__SetHostnameFromDHCP * SOAP_FMAC4 soap_in__tds__SetHostnameFromDHCP(struct soap *soap, const char *tag, struct _tds__SetHostnameFromDHCP *a, const char *type)
{
	size_t soap_flag_FromDHCP = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__SetHostnameFromDHCP *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetHostnameFromDHCP, sizeof(struct _tds__SetHostnameFromDHCP), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__SetHostnameFromDHCP(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_FromDHCP && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean_(soap, "tds:FromDHCP", &a->FromDHCP, "xsd:boolean"))
				{	soap_flag_FromDHCP--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__SetHostnameFromDHCP *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetHostnameFromDHCP, 0, sizeof(struct _tds__SetHostnameFromDHCP), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_FromDHCP > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__SetHostnameFromDHCP(struct soap *soap, const struct _tds__SetHostnameFromDHCP *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__SetHostnameFromDHCP);
	if (soap_out__tds__SetHostnameFromDHCP(soap, tag?tag:"tds:SetHostnameFromDHCP", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetHostnameFromDHCP * SOAP_FMAC4 soap_get__tds__SetHostnameFromDHCP(struct soap *soap, struct _tds__SetHostnameFromDHCP *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetHostnameFromDHCP(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__SetHostnameResponse(struct soap *soap, struct _tds__SetHostnameResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__SetHostnameResponse(struct soap *soap, const struct _tds__SetHostnameResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetHostnameResponse(struct soap *soap, const char *tag, int id, const struct _tds__SetHostnameResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetHostnameResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__SetHostnameResponse * SOAP_FMAC4 soap_in__tds__SetHostnameResponse(struct soap *soap, const char *tag, struct _tds__SetHostnameResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__SetHostnameResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetHostnameResponse, sizeof(struct _tds__SetHostnameResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__SetHostnameResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__SetHostnameResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetHostnameResponse, 0, sizeof(struct _tds__SetHostnameResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__SetHostnameResponse(struct soap *soap, const struct _tds__SetHostnameResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__SetHostnameResponse);
	if (soap_out__tds__SetHostnameResponse(soap, tag?tag:"tds:SetHostnameResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetHostnameResponse * SOAP_FMAC4 soap_get__tds__SetHostnameResponse(struct soap *soap, struct _tds__SetHostnameResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetHostnameResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__SetHostname(struct soap *soap, struct _tds__SetHostname *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__token(soap, &a->Name);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__SetHostname(struct soap *soap, const struct _tds__SetHostname *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_xsd__token(soap, &a->Name);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetHostname(struct soap *soap, const char *tag, int id, const struct _tds__SetHostname *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetHostname), type))
		return soap->error;
	if (a->Name)
	{	if (soap_out_xsd__token(soap, "tds:Name", -1, &a->Name, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tds:Name"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__SetHostname * SOAP_FMAC4 soap_in__tds__SetHostname(struct soap *soap, const char *tag, struct _tds__SetHostname *a, const char *type)
{
	size_t soap_flag_Name = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__SetHostname *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetHostname, sizeof(struct _tds__SetHostname), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__SetHostname(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__token(soap, "tds:Name", &a->Name, "xsd:token"))
				{	soap_flag_Name--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__SetHostname *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetHostname, 0, sizeof(struct _tds__SetHostname), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Name > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__SetHostname(struct soap *soap, const struct _tds__SetHostname *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__SetHostname);
	if (soap_out__tds__SetHostname(soap, tag?tag:"tds:SetHostname", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetHostname * SOAP_FMAC4 soap_get__tds__SetHostname(struct soap *soap, struct _tds__SetHostname *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetHostname(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__HostnameInformation(struct soap *soap, struct tt__HostnameInformation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__boolean_(soap, &a->FromDHCP);
	soap_default_xsd__token(soap, &a->Name);
	a->Extension = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__HostnameInformation(struct soap *soap, const struct tt__HostnameInformation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->FromDHCP, SOAP_TYPE_xsd__boolean_);
	soap_serialize_xsd__token(soap, &a->Name);
	soap_serialize_PointerTott__HostnameInformationExtension(soap, &a->Extension);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__HostnameInformation(struct soap *soap, const char *tag, int id, const struct tt__HostnameInformation *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__HostnameInformation), type))
		return soap->error;
	if (soap_out_xsd__boolean_(soap, "tt:FromDHCP", -1, &a->FromDHCP, ""))
		return soap->error;
	if (soap_out_xsd__token(soap, "tt:Name", -1, &a->Name, ""))
		return soap->error;
	if (soap_out_PointerTott__HostnameInformationExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__HostnameInformation * SOAP_FMAC4 soap_in_tt__HostnameInformation(struct soap *soap, const char *tag, struct tt__HostnameInformation *a, const char *type)
{
	size_t soap_flag_FromDHCP = 1;
	size_t soap_flag_Name = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__HostnameInformation *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__HostnameInformation, sizeof(struct tt__HostnameInformation), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__HostnameInformation(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_FromDHCP && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean_(soap, "tt:FromDHCP", &a->FromDHCP, "xsd:boolean"))
				{	soap_flag_FromDHCP--;
					continue;
				}
			if (soap_flag_Name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__token(soap, "tt:Name", &a->Name, "xsd:token"))
				{	soap_flag_Name--;
					continue;
				}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__HostnameInformationExtension(soap, "tt:Extension", &a->Extension, "tt:HostnameInformationExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__HostnameInformation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__HostnameInformation, 0, sizeof(struct tt__HostnameInformation), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_FromDHCP > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__HostnameInformation(struct soap *soap, const struct tt__HostnameInformation *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__HostnameInformation);
	if (soap_out_tt__HostnameInformation(soap, tag?tag:"tt:HostnameInformation", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__HostnameInformation * SOAP_FMAC4 soap_get_tt__HostnameInformation(struct soap *soap, struct tt__HostnameInformation *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__HostnameInformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetHostnameResponse(struct soap *soap, struct _tds__GetHostnameResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->HostnameInformation = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetHostnameResponse(struct soap *soap, const struct _tds__GetHostnameResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTott__HostnameInformation(soap, &a->HostnameInformation);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetHostnameResponse(struct soap *soap, const char *tag, int id, const struct _tds__GetHostnameResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetHostnameResponse), type))
		return soap->error;
	if (a->HostnameInformation)
		soap_element_result(soap, "tds:HostnameInformation");
	if (a->HostnameInformation)
	{	if (soap_out_PointerTott__HostnameInformation(soap, "tds:HostnameInformation", -1, &a->HostnameInformation, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tds:HostnameInformation"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetHostnameResponse * SOAP_FMAC4 soap_in__tds__GetHostnameResponse(struct soap *soap, const char *tag, struct _tds__GetHostnameResponse *a, const char *type)
{
	size_t soap_flag_HostnameInformation = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__GetHostnameResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetHostnameResponse, sizeof(struct _tds__GetHostnameResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetHostnameResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_HostnameInformation && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__HostnameInformation(soap, "tds:HostnameInformation", &a->HostnameInformation, "tt:HostnameInformation"))
				{	soap_flag_HostnameInformation--;
					continue;
				}
			soap_check_result(soap, "tds:HostnameInformation");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__GetHostnameResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetHostnameResponse, 0, sizeof(struct _tds__GetHostnameResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_HostnameInformation > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetHostnameResponse(struct soap *soap, const struct _tds__GetHostnameResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__GetHostnameResponse);
	if (soap_out__tds__GetHostnameResponse(soap, tag?tag:"tds:GetHostnameResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetHostnameResponse * SOAP_FMAC4 soap_get__tds__GetHostnameResponse(struct soap *soap, struct _tds__GetHostnameResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetHostnameResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetHostname(struct soap *soap, struct _tds__GetHostname *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetHostname(struct soap *soap, const struct _tds__GetHostname *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetHostname(struct soap *soap, const char *tag, int id, const struct _tds__GetHostname *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetHostname), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetHostname * SOAP_FMAC4 soap_in__tds__GetHostname(struct soap *soap, const char *tag, struct _tds__GetHostname *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__GetHostname *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetHostname, sizeof(struct _tds__GetHostname), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetHostname(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__GetHostname *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetHostname, 0, sizeof(struct _tds__GetHostname), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetHostname(struct soap *soap, const struct _tds__GetHostname *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__GetHostname);
	if (soap_out__tds__GetHostname(soap, tag?tag:"tds:GetHostname", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetHostname * SOAP_FMAC4 soap_get__tds__GetHostname(struct soap *soap, struct _tds__GetHostname *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetHostname(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__Capabilities(struct soap *soap, struct tt__Capabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Analytics = NULL;
	a->Device = NULL;
	a->Events = NULL;
	a->Imaging = NULL;
	a->Media = NULL;
	a->PTZ = NULL;
	a->Extension = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__Capabilities(struct soap *soap, const struct tt__Capabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTott__AnalyticsCapabilities(soap, &a->Analytics);
	soap_serialize_PointerTott__DeviceCapabilities(soap, &a->Device);
	soap_serialize_PointerTott__EventCapabilities(soap, &a->Events);
	soap_serialize_PointerTott__ImagingCapabilities(soap, &a->Imaging);
	soap_serialize_PointerTott__MediaCapabilities(soap, &a->Media);
	soap_serialize_PointerTott__PTZCapabilities(soap, &a->PTZ);
	soap_serialize_PointerTott__CapabilitiesExtension(soap, &a->Extension);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Capabilities(struct soap *soap, const char *tag, int id, const struct tt__Capabilities *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Capabilities), type))
		return soap->error;
	if (soap_out_PointerTott__AnalyticsCapabilities(soap, "tt:Analytics", -1, &a->Analytics, ""))
		return soap->error;
	if (soap_out_PointerTott__DeviceCapabilities(soap, "tt:Device", -1, &a->Device, ""))
		return soap->error;
	if (soap_out_PointerTott__EventCapabilities(soap, "tt:Events", -1, &a->Events, ""))
		return soap->error;
	if (soap_out_PointerTott__ImagingCapabilities(soap, "tt:Imaging", -1, &a->Imaging, ""))
		return soap->error;
	if (soap_out_PointerTott__MediaCapabilities(soap, "tt:Media", -1, &a->Media, ""))
		return soap->error;
	if (soap_out_PointerTott__PTZCapabilities(soap, "tt:PTZ", -1, &a->PTZ, ""))
		return soap->error;
	if (soap_out_PointerTott__CapabilitiesExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__Capabilities * SOAP_FMAC4 soap_in_tt__Capabilities(struct soap *soap, const char *tag, struct tt__Capabilities *a, const char *type)
{
	size_t soap_flag_Analytics = 1;
	size_t soap_flag_Device = 1;
	size_t soap_flag_Events = 1;
	size_t soap_flag_Imaging = 1;
	size_t soap_flag_Media = 1;
	size_t soap_flag_PTZ = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__Capabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Capabilities, sizeof(struct tt__Capabilities), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__Capabilities(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Analytics && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__AnalyticsCapabilities(soap, "tt:Analytics", &a->Analytics, "tt:AnalyticsCapabilities"))
				{	soap_flag_Analytics--;
					continue;
				}
			if (soap_flag_Device && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__DeviceCapabilities(soap, "tt:Device", &a->Device, "tt:DeviceCapabilities"))
				{	soap_flag_Device--;
					continue;
				}
			if (soap_flag_Events && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__EventCapabilities(soap, "tt:Events", &a->Events, "tt:EventCapabilities"))
				{	soap_flag_Events--;
					continue;
				}
			if (soap_flag_Imaging && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__ImagingCapabilities(soap, "tt:Imaging", &a->Imaging, "tt:ImagingCapabilities"))
				{	soap_flag_Imaging--;
					continue;
				}
			if (soap_flag_Media && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__MediaCapabilities(soap, "tt:Media", &a->Media, "tt:MediaCapabilities"))
				{	soap_flag_Media--;
					continue;
				}
			if (soap_flag_PTZ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__PTZCapabilities(soap, "tt:PTZ", &a->PTZ, "tt:PTZCapabilities"))
				{	soap_flag_PTZ--;
					continue;
				}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__CapabilitiesExtension(soap, "tt:Extension", &a->Extension, "tt:CapabilitiesExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__Capabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Capabilities, 0, sizeof(struct tt__Capabilities), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Capabilities(struct soap *soap, const struct tt__Capabilities *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__Capabilities);
	if (soap_out_tt__Capabilities(soap, tag?tag:"tt:Capabilities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Capabilities * SOAP_FMAC4 soap_get_tt__Capabilities(struct soap *soap, struct tt__Capabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Capabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetCapabilitiesResponse(struct soap *soap, struct _tds__GetCapabilitiesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Capabilities = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetCapabilitiesResponse(struct soap *soap, const struct _tds__GetCapabilitiesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTott__Capabilities(soap, &a->Capabilities);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetCapabilitiesResponse(struct soap *soap, const char *tag, int id, const struct _tds__GetCapabilitiesResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetCapabilitiesResponse), type))
		return soap->error;
	if (a->Capabilities)
		soap_element_result(soap, "tds:Capabilities");
	if (a->Capabilities)
	{	if (soap_out_PointerTott__Capabilities(soap, "tds:Capabilities", -1, &a->Capabilities, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tds:Capabilities"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetCapabilitiesResponse * SOAP_FMAC4 soap_in__tds__GetCapabilitiesResponse(struct soap *soap, const char *tag, struct _tds__GetCapabilitiesResponse *a, const char *type)
{
	size_t soap_flag_Capabilities = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__GetCapabilitiesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetCapabilitiesResponse, sizeof(struct _tds__GetCapabilitiesResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetCapabilitiesResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Capabilities && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__Capabilities(soap, "tds:Capabilities", &a->Capabilities, "tt:Capabilities"))
				{	soap_flag_Capabilities--;
					continue;
				}
			soap_check_result(soap, "tds:Capabilities");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__GetCapabilitiesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetCapabilitiesResponse, 0, sizeof(struct _tds__GetCapabilitiesResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Capabilities > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetCapabilitiesResponse(struct soap *soap, const struct _tds__GetCapabilitiesResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__GetCapabilitiesResponse);
	if (soap_out__tds__GetCapabilitiesResponse(soap, tag?tag:"tds:GetCapabilitiesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetCapabilitiesResponse * SOAP_FMAC4 soap_get__tds__GetCapabilitiesResponse(struct soap *soap, struct _tds__GetCapabilitiesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetCapabilitiesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetCapabilities(struct soap *soap, struct _tds__GetCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeCategory = 0;
	a->Category = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetCapabilities(struct soap *soap, const struct _tds__GetCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->Category)
	{	int i;
		for (i = 0; i < a->__sizeCategory; i++)
		{
			soap_embedded(soap, a->Category + i, SOAP_TYPE_tt__CapabilityCategory);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetCapabilities(struct soap *soap, const char *tag, int id, const struct _tds__GetCapabilities *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetCapabilities), type))
		return soap->error;
	if (a->Category)
	{	int i;
		for (i = 0; i < a->__sizeCategory; i++)
			if (soap_out_tt__CapabilityCategory(soap, "tds:Category", -1, a->Category + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetCapabilities * SOAP_FMAC4 soap_in__tds__GetCapabilities(struct soap *soap, const char *tag, struct _tds__GetCapabilities *a, const char *type)
{
	struct soap_blist *soap_blist_Category = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__GetCapabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetCapabilities, sizeof(struct _tds__GetCapabilities), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetCapabilities(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tds:Category", 1, NULL))
			{	if (a->Category == NULL)
				{	if (soap_blist_Category == NULL)
						soap_blist_Category = soap_new_block(soap);
					a->Category = (enum tt__CapabilityCategory *)soap_push_block(soap, soap_blist_Category, sizeof(enum tt__CapabilityCategory));
					if (a->Category == NULL)
						return NULL;
					soap_default_tt__CapabilityCategory(soap, a->Category);
				}
				soap_revert(soap);
				if (soap_in_tt__CapabilityCategory(soap, "tds:Category", a->Category, "tt:CapabilityCategory"))
				{	a->__sizeCategory++;
					a->Category = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Category)
			soap_pop_block(soap, soap_blist_Category);
		if (a->__sizeCategory)
			a->Category = (enum tt__CapabilityCategory *)soap_save_block(soap, soap_blist_Category, NULL, 1);
		else
		{	a->Category = NULL;
			if (soap_blist_Category)
				soap_end_block(soap, soap_blist_Category);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__GetCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetCapabilities, 0, sizeof(struct _tds__GetCapabilities), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetCapabilities(struct soap *soap, const struct _tds__GetCapabilities *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__GetCapabilities);
	if (soap_out__tds__GetCapabilities(soap, tag?tag:"tds:GetCapabilities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetCapabilities * SOAP_FMAC4 soap_get__tds__GetCapabilities(struct soap *soap, struct _tds__GetCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetWsdlUrlResponse(struct soap *soap, struct _tds__GetWsdlUrlResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->WsdlUrl);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetWsdlUrlResponse(struct soap *soap, const struct _tds__GetWsdlUrlResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->WsdlUrl);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetWsdlUrlResponse(struct soap *soap, const char *tag, int id, const struct _tds__GetWsdlUrlResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetWsdlUrlResponse), type))
		return soap->error;
	if (a->WsdlUrl)
		soap_element_result(soap, "tds:WsdlUrl");
	if (a->WsdlUrl)
	{	if (soap_out_string(soap, "tds:WsdlUrl", -1, &a->WsdlUrl, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tds:WsdlUrl"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetWsdlUrlResponse * SOAP_FMAC4 soap_in__tds__GetWsdlUrlResponse(struct soap *soap, const char *tag, struct _tds__GetWsdlUrlResponse *a, const char *type)
{
	size_t soap_flag_WsdlUrl = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__GetWsdlUrlResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetWsdlUrlResponse, sizeof(struct _tds__GetWsdlUrlResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetWsdlUrlResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_WsdlUrl && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "tds:WsdlUrl", &a->WsdlUrl, "xsd:string"))
				{	soap_flag_WsdlUrl--;
					continue;
				}
			soap_check_result(soap, "tds:WsdlUrl");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__GetWsdlUrlResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetWsdlUrlResponse, 0, sizeof(struct _tds__GetWsdlUrlResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_WsdlUrl > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetWsdlUrlResponse(struct soap *soap, const struct _tds__GetWsdlUrlResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__GetWsdlUrlResponse);
	if (soap_out__tds__GetWsdlUrlResponse(soap, tag?tag:"tds:GetWsdlUrlResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetWsdlUrlResponse * SOAP_FMAC4 soap_get__tds__GetWsdlUrlResponse(struct soap *soap, struct _tds__GetWsdlUrlResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetWsdlUrlResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetWsdlUrl(struct soap *soap, struct _tds__GetWsdlUrl *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetWsdlUrl(struct soap *soap, const struct _tds__GetWsdlUrl *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetWsdlUrl(struct soap *soap, const char *tag, int id, const struct _tds__GetWsdlUrl *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetWsdlUrl), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetWsdlUrl * SOAP_FMAC4 soap_in__tds__GetWsdlUrl(struct soap *soap, const char *tag, struct _tds__GetWsdlUrl *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__GetWsdlUrl *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetWsdlUrl, sizeof(struct _tds__GetWsdlUrl), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetWsdlUrl(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__GetWsdlUrl *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetWsdlUrl, 0, sizeof(struct _tds__GetWsdlUrl), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetWsdlUrl(struct soap *soap, const struct _tds__GetWsdlUrl *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__GetWsdlUrl);
	if (soap_out__tds__GetWsdlUrl(soap, tag?tag:"tds:GetWsdlUrl", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetWsdlUrl * SOAP_FMAC4 soap_get__tds__GetWsdlUrl(struct soap *soap, struct _tds__GetWsdlUrl *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetWsdlUrl(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__SetUserResponse(struct soap *soap, struct _tds__SetUserResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__SetUserResponse(struct soap *soap, const struct _tds__SetUserResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetUserResponse(struct soap *soap, const char *tag, int id, const struct _tds__SetUserResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetUserResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__SetUserResponse * SOAP_FMAC4 soap_in__tds__SetUserResponse(struct soap *soap, const char *tag, struct _tds__SetUserResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__SetUserResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetUserResponse, sizeof(struct _tds__SetUserResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__SetUserResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__SetUserResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetUserResponse, 0, sizeof(struct _tds__SetUserResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__SetUserResponse(struct soap *soap, const struct _tds__SetUserResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__SetUserResponse);
	if (soap_out__tds__SetUserResponse(soap, tag?tag:"tds:SetUserResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetUserResponse * SOAP_FMAC4 soap_get__tds__SetUserResponse(struct soap *soap, struct _tds__SetUserResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetUserResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__SetUser(struct soap *soap, struct _tds__SetUser *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeUser = 0;
	a->User = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__SetUser(struct soap *soap, const struct _tds__SetUser *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->User)
	{	int i;
		for (i = 0; i < a->__sizeUser; i++)
		{
			soap_embedded(soap, a->User + i, SOAP_TYPE_tt__User);
			soap_serialize_tt__User(soap, a->User + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetUser(struct soap *soap, const char *tag, int id, const struct _tds__SetUser *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetUser), type))
		return soap->error;
	if (a->User)
	{	int i;
		for (i = 0; i < a->__sizeUser; i++)
			if (soap_out_tt__User(soap, "tds:User", -1, a->User + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__SetUser * SOAP_FMAC4 soap_in__tds__SetUser(struct soap *soap, const char *tag, struct _tds__SetUser *a, const char *type)
{
	struct soap_blist *soap_blist_User = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__SetUser *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetUser, sizeof(struct _tds__SetUser), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__SetUser(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tds:User", 1, NULL))
			{	if (a->User == NULL)
				{	if (soap_blist_User == NULL)
						soap_blist_User = soap_new_block(soap);
					a->User = (struct tt__User *)soap_push_block(soap, soap_blist_User, sizeof(struct tt__User));
					if (a->User == NULL)
						return NULL;
					soap_default_tt__User(soap, a->User);
				}
				soap_revert(soap);
				if (soap_in_tt__User(soap, "tds:User", a->User, "tt:User"))
				{	a->__sizeUser++;
					a->User = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->User)
			soap_pop_block(soap, soap_blist_User);
		if (a->__sizeUser)
			a->User = (struct tt__User *)soap_save_block(soap, soap_blist_User, NULL, 1);
		else
		{	a->User = NULL;
			if (soap_blist_User)
				soap_end_block(soap, soap_blist_User);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__SetUser *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetUser, 0, sizeof(struct _tds__SetUser), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeUser < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__SetUser(struct soap *soap, const struct _tds__SetUser *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__SetUser);
	if (soap_out__tds__SetUser(soap, tag?tag:"tds:SetUser", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetUser * SOAP_FMAC4 soap_get__tds__SetUser(struct soap *soap, struct _tds__SetUser *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetUser(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__DeleteUsersResponse(struct soap *soap, struct _tds__DeleteUsersResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__DeleteUsersResponse(struct soap *soap, const struct _tds__DeleteUsersResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__DeleteUsersResponse(struct soap *soap, const char *tag, int id, const struct _tds__DeleteUsersResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__DeleteUsersResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__DeleteUsersResponse * SOAP_FMAC4 soap_in__tds__DeleteUsersResponse(struct soap *soap, const char *tag, struct _tds__DeleteUsersResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__DeleteUsersResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__DeleteUsersResponse, sizeof(struct _tds__DeleteUsersResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__DeleteUsersResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__DeleteUsersResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__DeleteUsersResponse, 0, sizeof(struct _tds__DeleteUsersResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__DeleteUsersResponse(struct soap *soap, const struct _tds__DeleteUsersResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__DeleteUsersResponse);
	if (soap_out__tds__DeleteUsersResponse(soap, tag?tag:"tds:DeleteUsersResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__DeleteUsersResponse * SOAP_FMAC4 soap_get__tds__DeleteUsersResponse(struct soap *soap, struct _tds__DeleteUsersResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__DeleteUsersResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__DeleteUsers(struct soap *soap, struct _tds__DeleteUsers *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeUsername = 0;
	a->Username = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__DeleteUsers(struct soap *soap, const struct _tds__DeleteUsers *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->Username)
	{	int i;
		for (i = 0; i < a->__sizeUsername; i++)
		{
			soap_serialize_string(soap, a->Username + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__DeleteUsers(struct soap *soap, const char *tag, int id, const struct _tds__DeleteUsers *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__DeleteUsers), type))
		return soap->error;
	if (a->Username)
	{	int i;
		for (i = 0; i < a->__sizeUsername; i++)
			if (soap_out_string(soap, "tds:Username", -1, a->Username + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__DeleteUsers * SOAP_FMAC4 soap_in__tds__DeleteUsers(struct soap *soap, const char *tag, struct _tds__DeleteUsers *a, const char *type)
{
	struct soap_blist *soap_blist_Username = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__DeleteUsers *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__DeleteUsers, sizeof(struct _tds__DeleteUsers), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__DeleteUsers(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tds:Username", 1, NULL))
			{	if (a->Username == NULL)
				{	if (soap_blist_Username == NULL)
						soap_blist_Username = soap_new_block(soap);
					a->Username = (char **)soap_push_block(soap, soap_blist_Username, sizeof(char *));
					if (a->Username == NULL)
						return NULL;
					*a->Username = NULL;
				}
				soap_revert(soap);
				if (soap_in_string(soap, "tds:Username", a->Username, "xsd:string"))
				{	a->__sizeUsername++;
					a->Username = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Username)
			soap_pop_block(soap, soap_blist_Username);
		if (a->__sizeUsername)
			a->Username = (char **)soap_save_block(soap, soap_blist_Username, NULL, 1);
		else
		{	a->Username = NULL;
			if (soap_blist_Username)
				soap_end_block(soap, soap_blist_Username);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__DeleteUsers *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__DeleteUsers, 0, sizeof(struct _tds__DeleteUsers), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeUsername < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__DeleteUsers(struct soap *soap, const struct _tds__DeleteUsers *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__DeleteUsers);
	if (soap_out__tds__DeleteUsers(soap, tag?tag:"tds:DeleteUsers", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__DeleteUsers * SOAP_FMAC4 soap_get__tds__DeleteUsers(struct soap *soap, struct _tds__DeleteUsers *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__DeleteUsers(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__CreateUsersResponse(struct soap *soap, struct _tds__CreateUsersResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__CreateUsersResponse(struct soap *soap, const struct _tds__CreateUsersResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__CreateUsersResponse(struct soap *soap, const char *tag, int id, const struct _tds__CreateUsersResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__CreateUsersResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__CreateUsersResponse * SOAP_FMAC4 soap_in__tds__CreateUsersResponse(struct soap *soap, const char *tag, struct _tds__CreateUsersResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__CreateUsersResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__CreateUsersResponse, sizeof(struct _tds__CreateUsersResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__CreateUsersResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__CreateUsersResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__CreateUsersResponse, 0, sizeof(struct _tds__CreateUsersResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__CreateUsersResponse(struct soap *soap, const struct _tds__CreateUsersResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__CreateUsersResponse);
	if (soap_out__tds__CreateUsersResponse(soap, tag?tag:"tds:CreateUsersResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__CreateUsersResponse * SOAP_FMAC4 soap_get__tds__CreateUsersResponse(struct soap *soap, struct _tds__CreateUsersResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__CreateUsersResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__CreateUsers(struct soap *soap, struct _tds__CreateUsers *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeUser = 0;
	a->User = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__CreateUsers(struct soap *soap, const struct _tds__CreateUsers *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->User)
	{	int i;
		for (i = 0; i < a->__sizeUser; i++)
		{
			soap_embedded(soap, a->User + i, SOAP_TYPE_tt__User);
			soap_serialize_tt__User(soap, a->User + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__CreateUsers(struct soap *soap, const char *tag, int id, const struct _tds__CreateUsers *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__CreateUsers), type))
		return soap->error;
	if (a->User)
	{	int i;
		for (i = 0; i < a->__sizeUser; i++)
			if (soap_out_tt__User(soap, "tds:User", -1, a->User + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__CreateUsers * SOAP_FMAC4 soap_in__tds__CreateUsers(struct soap *soap, const char *tag, struct _tds__CreateUsers *a, const char *type)
{
	struct soap_blist *soap_blist_User = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__CreateUsers *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__CreateUsers, sizeof(struct _tds__CreateUsers), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__CreateUsers(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tds:User", 1, NULL))
			{	if (a->User == NULL)
				{	if (soap_blist_User == NULL)
						soap_blist_User = soap_new_block(soap);
					a->User = (struct tt__User *)soap_push_block(soap, soap_blist_User, sizeof(struct tt__User));
					if (a->User == NULL)
						return NULL;
					soap_default_tt__User(soap, a->User);
				}
				soap_revert(soap);
				if (soap_in_tt__User(soap, "tds:User", a->User, "tt:User"))
				{	a->__sizeUser++;
					a->User = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->User)
			soap_pop_block(soap, soap_blist_User);
		if (a->__sizeUser)
			a->User = (struct tt__User *)soap_save_block(soap, soap_blist_User, NULL, 1);
		else
		{	a->User = NULL;
			if (soap_blist_User)
				soap_end_block(soap, soap_blist_User);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__CreateUsers *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__CreateUsers, 0, sizeof(struct _tds__CreateUsers), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeUser < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__CreateUsers(struct soap *soap, const struct _tds__CreateUsers *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__CreateUsers);
	if (soap_out__tds__CreateUsers(soap, tag?tag:"tds:CreateUsers", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__CreateUsers * SOAP_FMAC4 soap_get__tds__CreateUsers(struct soap *soap, struct _tds__CreateUsers *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__CreateUsers(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__User(struct soap *soap, struct tt__User *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Username);
	soap_default_string(soap, &a->Password);
	soap_default_tt__UserLevel(soap, &a->UserLevel);
	a->Extension = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__User(struct soap *soap, const struct tt__User *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Username);
	soap_serialize_string(soap, &a->Password);
	soap_serialize_PointerTott__UserExtension(soap, &a->Extension);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__User(struct soap *soap, const char *tag, int id, const struct tt__User *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__User), type))
		return soap->error;
	if (a->Username)
	{	if (soap_out_string(soap, "tt:Username", -1, &a->Username, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:Username"))
		return soap->error;
	if (soap_out_string(soap, "tt:Password", -1, &a->Password, ""))
		return soap->error;
	if (soap_out_tt__UserLevel(soap, "tt:UserLevel", -1, &a->UserLevel, ""))
		return soap->error;
	if (soap_out_PointerTott__UserExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__User * SOAP_FMAC4 soap_in_tt__User(struct soap *soap, const char *tag, struct tt__User *a, const char *type)
{
	size_t soap_flag_Username = 1;
	size_t soap_flag_Password = 1;
	size_t soap_flag_UserLevel = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__User *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__User, sizeof(struct tt__User), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__User(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Username && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "tt:Username", &a->Username, "xsd:string"))
				{	soap_flag_Username--;
					continue;
				}
			if (soap_flag_Password && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "tt:Password", &a->Password, "xsd:string"))
				{	soap_flag_Password--;
					continue;
				}
			if (soap_flag_UserLevel && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_tt__UserLevel(soap, "tt:UserLevel", &a->UserLevel, "tt:UserLevel"))
				{	soap_flag_UserLevel--;
					continue;
				}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__UserExtension(soap, "tt:Extension", &a->Extension, "tt:UserExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__User *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__User, 0, sizeof(struct tt__User), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Username > 0 || soap_flag_UserLevel > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__User(struct soap *soap, const struct tt__User *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__User);
	if (soap_out_tt__User(soap, tag?tag:"tt:User", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__User * SOAP_FMAC4 soap_get_tt__User(struct soap *soap, struct tt__User *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__User(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetUsersResponse(struct soap *soap, struct _tds__GetUsersResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeUser = 0;
	a->User = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetUsersResponse(struct soap *soap, const struct _tds__GetUsersResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->User)
	{	int i;
		for (i = 0; i < a->__sizeUser; i++)
		{
			soap_embedded(soap, a->User + i, SOAP_TYPE_tt__User);
			soap_serialize_tt__User(soap, a->User + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetUsersResponse(struct soap *soap, const char *tag, int id, const struct _tds__GetUsersResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetUsersResponse), type))
		return soap->error;
	soap_element_result(soap, "-sizeUser");
	if (a->User)
	{	int i;
		for (i = 0; i < a->__sizeUser; i++)
			if (soap_out_tt__User(soap, "tds:User", -1, a->User + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetUsersResponse * SOAP_FMAC4 soap_in__tds__GetUsersResponse(struct soap *soap, const char *tag, struct _tds__GetUsersResponse *a, const char *type)
{
	struct soap_blist *soap_blist_User = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__GetUsersResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetUsersResponse, sizeof(struct _tds__GetUsersResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetUsersResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tds:User", 1, NULL))
			{	if (a->User == NULL)
				{	if (soap_blist_User == NULL)
						soap_blist_User = soap_new_block(soap);
					a->User = (struct tt__User *)soap_push_block(soap, soap_blist_User, sizeof(struct tt__User));
					if (a->User == NULL)
						return NULL;
					soap_default_tt__User(soap, a->User);
				}
				soap_revert(soap);
				if (soap_in_tt__User(soap, "tds:User", a->User, "tt:User"))
				{	a->__sizeUser++;
					a->User = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizeUser");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->User)
			soap_pop_block(soap, soap_blist_User);
		if (a->__sizeUser)
			a->User = (struct tt__User *)soap_save_block(soap, soap_blist_User, NULL, 1);
		else
		{	a->User = NULL;
			if (soap_blist_User)
				soap_end_block(soap, soap_blist_User);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__GetUsersResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetUsersResponse, 0, sizeof(struct _tds__GetUsersResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetUsersResponse(struct soap *soap, const struct _tds__GetUsersResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__GetUsersResponse);
	if (soap_out__tds__GetUsersResponse(soap, tag?tag:"tds:GetUsersResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetUsersResponse * SOAP_FMAC4 soap_get__tds__GetUsersResponse(struct soap *soap, struct _tds__GetUsersResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetUsersResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetUsers(struct soap *soap, struct _tds__GetUsers *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetUsers(struct soap *soap, const struct _tds__GetUsers *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetUsers(struct soap *soap, const char *tag, int id, const struct _tds__GetUsers *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetUsers), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetUsers * SOAP_FMAC4 soap_in__tds__GetUsers(struct soap *soap, const char *tag, struct _tds__GetUsers *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__GetUsers *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetUsers, sizeof(struct _tds__GetUsers), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetUsers(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__GetUsers *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetUsers, 0, sizeof(struct _tds__GetUsers), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetUsers(struct soap *soap, const struct _tds__GetUsers *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__GetUsers);
	if (soap_out__tds__GetUsers(soap, tag?tag:"tds:GetUsers", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetUsers * SOAP_FMAC4 soap_get__tds__GetUsers(struct soap *soap, struct _tds__GetUsers *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetUsers(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__SetRemoteUserResponse(struct soap *soap, struct _tds__SetRemoteUserResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__SetRemoteUserResponse(struct soap *soap, const struct _tds__SetRemoteUserResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetRemoteUserResponse(struct soap *soap, const char *tag, int id, const struct _tds__SetRemoteUserResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetRemoteUserResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__SetRemoteUserResponse * SOAP_FMAC4 soap_in__tds__SetRemoteUserResponse(struct soap *soap, const char *tag, struct _tds__SetRemoteUserResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__SetRemoteUserResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetRemoteUserResponse, sizeof(struct _tds__SetRemoteUserResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__SetRemoteUserResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__SetRemoteUserResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetRemoteUserResponse, 0, sizeof(struct _tds__SetRemoteUserResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__SetRemoteUserResponse(struct soap *soap, const struct _tds__SetRemoteUserResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__SetRemoteUserResponse);
	if (soap_out__tds__SetRemoteUserResponse(soap, tag?tag:"tds:SetRemoteUserResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetRemoteUserResponse * SOAP_FMAC4 soap_get__tds__SetRemoteUserResponse(struct soap *soap, struct _tds__SetRemoteUserResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetRemoteUserResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__SetRemoteUser(struct soap *soap, struct _tds__SetRemoteUser *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->RemoteUser = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__SetRemoteUser(struct soap *soap, const struct _tds__SetRemoteUser *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTott__RemoteUser(soap, &a->RemoteUser);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetRemoteUser(struct soap *soap, const char *tag, int id, const struct _tds__SetRemoteUser *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetRemoteUser), type))
		return soap->error;
	if (soap_out_PointerTott__RemoteUser(soap, "tds:RemoteUser", -1, &a->RemoteUser, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__SetRemoteUser * SOAP_FMAC4 soap_in__tds__SetRemoteUser(struct soap *soap, const char *tag, struct _tds__SetRemoteUser *a, const char *type)
{
	size_t soap_flag_RemoteUser = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__SetRemoteUser *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetRemoteUser, sizeof(struct _tds__SetRemoteUser), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__SetRemoteUser(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RemoteUser && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__RemoteUser(soap, "tds:RemoteUser", &a->RemoteUser, "tt:RemoteUser"))
				{	soap_flag_RemoteUser--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__SetRemoteUser *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetRemoteUser, 0, sizeof(struct _tds__SetRemoteUser), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__SetRemoteUser(struct soap *soap, const struct _tds__SetRemoteUser *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__SetRemoteUser);
	if (soap_out__tds__SetRemoteUser(soap, tag?tag:"tds:SetRemoteUser", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetRemoteUser * SOAP_FMAC4 soap_get__tds__SetRemoteUser(struct soap *soap, struct _tds__SetRemoteUser *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetRemoteUser(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__RemoteUser(struct soap *soap, struct tt__RemoteUser *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Username);
	soap_default_string(soap, &a->Password);
	soap_default_xsd__boolean_(soap, &a->UseDerivedPassword);
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__RemoteUser(struct soap *soap, const struct tt__RemoteUser *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Username);
	soap_serialize_string(soap, &a->Password);
	soap_embedded(soap, &a->UseDerivedPassword, SOAP_TYPE_xsd__boolean_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__RemoteUser(struct soap *soap, const char *tag, int id, const struct tt__RemoteUser *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__RemoteUser), type))
		return soap->error;
	if (a->Username)
	{	if (soap_out_string(soap, "tt:Username", -1, &a->Username, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:Username"))
		return soap->error;
	if (soap_out_string(soap, "tt:Password", -1, &a->Password, ""))
		return soap->error;
	if (soap_out_xsd__boolean_(soap, "tt:UseDerivedPassword", -1, &a->UseDerivedPassword, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__RemoteUser * SOAP_FMAC4 soap_in_tt__RemoteUser(struct soap *soap, const char *tag, struct tt__RemoteUser *a, const char *type)
{
	size_t soap_flag_Username = 1;
	size_t soap_flag_Password = 1;
	size_t soap_flag_UseDerivedPassword = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__RemoteUser *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RemoteUser, sizeof(struct tt__RemoteUser), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__RemoteUser(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Username && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "tt:Username", &a->Username, "xsd:string"))
				{	soap_flag_Username--;
					continue;
				}
			if (soap_flag_Password && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "tt:Password", &a->Password, "xsd:string"))
				{	soap_flag_Password--;
					continue;
				}
			if (soap_flag_UseDerivedPassword && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean_(soap, "tt:UseDerivedPassword", &a->UseDerivedPassword, "xsd:boolean"))
				{	soap_flag_UseDerivedPassword--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__RemoteUser *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__RemoteUser, 0, sizeof(struct tt__RemoteUser), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Username > 0 || soap_flag_UseDerivedPassword > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__RemoteUser(struct soap *soap, const struct tt__RemoteUser *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__RemoteUser);
	if (soap_out_tt__RemoteUser(soap, tag?tag:"tt:RemoteUser", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__RemoteUser * SOAP_FMAC4 soap_get_tt__RemoteUser(struct soap *soap, struct tt__RemoteUser *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__RemoteUser(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetRemoteUserResponse(struct soap *soap, struct _tds__GetRemoteUserResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->RemoteUser = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetRemoteUserResponse(struct soap *soap, const struct _tds__GetRemoteUserResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTott__RemoteUser(soap, &a->RemoteUser);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetRemoteUserResponse(struct soap *soap, const char *tag, int id, const struct _tds__GetRemoteUserResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetRemoteUserResponse), type))
		return soap->error;
	if (a->RemoteUser)
		soap_element_result(soap, "tds:RemoteUser");
	if (soap_out_PointerTott__RemoteUser(soap, "tds:RemoteUser", -1, &a->RemoteUser, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetRemoteUserResponse * SOAP_FMAC4 soap_in__tds__GetRemoteUserResponse(struct soap *soap, const char *tag, struct _tds__GetRemoteUserResponse *a, const char *type)
{
	size_t soap_flag_RemoteUser = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__GetRemoteUserResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetRemoteUserResponse, sizeof(struct _tds__GetRemoteUserResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetRemoteUserResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RemoteUser && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__RemoteUser(soap, "tds:RemoteUser", &a->RemoteUser, "tt:RemoteUser"))
				{	soap_flag_RemoteUser--;
					continue;
				}
			soap_check_result(soap, "tds:RemoteUser");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__GetRemoteUserResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetRemoteUserResponse, 0, sizeof(struct _tds__GetRemoteUserResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetRemoteUserResponse(struct soap *soap, const struct _tds__GetRemoteUserResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__GetRemoteUserResponse);
	if (soap_out__tds__GetRemoteUserResponse(soap, tag?tag:"tds:GetRemoteUserResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetRemoteUserResponse * SOAP_FMAC4 soap_get__tds__GetRemoteUserResponse(struct soap *soap, struct _tds__GetRemoteUserResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetRemoteUserResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetRemoteUser(struct soap *soap, struct _tds__GetRemoteUser *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetRemoteUser(struct soap *soap, const struct _tds__GetRemoteUser *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetRemoteUser(struct soap *soap, const char *tag, int id, const struct _tds__GetRemoteUser *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetRemoteUser), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetRemoteUser * SOAP_FMAC4 soap_in__tds__GetRemoteUser(struct soap *soap, const char *tag, struct _tds__GetRemoteUser *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__GetRemoteUser *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetRemoteUser, sizeof(struct _tds__GetRemoteUser), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetRemoteUser(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__GetRemoteUser *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetRemoteUser, 0, sizeof(struct _tds__GetRemoteUser), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetRemoteUser(struct soap *soap, const struct _tds__GetRemoteUser *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__GetRemoteUser);
	if (soap_out__tds__GetRemoteUser(soap, tag?tag:"tds:GetRemoteUser", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetRemoteUser * SOAP_FMAC4 soap_get__tds__GetRemoteUser(struct soap *soap, struct _tds__GetRemoteUser *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetRemoteUser(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetEndpointReferenceResponse(struct soap *soap, struct _tds__GetEndpointReferenceResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->GUID);
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetEndpointReferenceResponse(struct soap *soap, const struct _tds__GetEndpointReferenceResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->GUID);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetEndpointReferenceResponse(struct soap *soap, const char *tag, int id, const struct _tds__GetEndpointReferenceResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetEndpointReferenceResponse), type))
		return soap->error;
	if (a->GUID)
		soap_element_result(soap, "tds:GUID");
	if (a->GUID)
	{	if (soap_out_string(soap, "tds:GUID", -1, &a->GUID, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tds:GUID"))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetEndpointReferenceResponse * SOAP_FMAC4 soap_in__tds__GetEndpointReferenceResponse(struct soap *soap, const char *tag, struct _tds__GetEndpointReferenceResponse *a, const char *type)
{
	size_t soap_flag_GUID = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__GetEndpointReferenceResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetEndpointReferenceResponse, sizeof(struct _tds__GetEndpointReferenceResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetEndpointReferenceResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GUID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "tds:GUID", &a->GUID, "xsd:string"))
				{	soap_flag_GUID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			soap_check_result(soap, "tds:GUID");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__GetEndpointReferenceResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetEndpointReferenceResponse, 0, sizeof(struct _tds__GetEndpointReferenceResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_GUID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetEndpointReferenceResponse(struct soap *soap, const struct _tds__GetEndpointReferenceResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__GetEndpointReferenceResponse);
	if (soap_out__tds__GetEndpointReferenceResponse(soap, tag?tag:"tds:GetEndpointReferenceResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetEndpointReferenceResponse * SOAP_FMAC4 soap_get__tds__GetEndpointReferenceResponse(struct soap *soap, struct _tds__GetEndpointReferenceResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetEndpointReferenceResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetEndpointReference(struct soap *soap, struct _tds__GetEndpointReference *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetEndpointReference(struct soap *soap, const struct _tds__GetEndpointReference *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetEndpointReference(struct soap *soap, const char *tag, int id, const struct _tds__GetEndpointReference *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetEndpointReference), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetEndpointReference * SOAP_FMAC4 soap_in__tds__GetEndpointReference(struct soap *soap, const char *tag, struct _tds__GetEndpointReference *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__GetEndpointReference *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetEndpointReference, sizeof(struct _tds__GetEndpointReference), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetEndpointReference(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__GetEndpointReference *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetEndpointReference, 0, sizeof(struct _tds__GetEndpointReference), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetEndpointReference(struct soap *soap, const struct _tds__GetEndpointReference *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__GetEndpointReference);
	if (soap_out__tds__GetEndpointReference(soap, tag?tag:"tds:GetEndpointReference", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetEndpointReference * SOAP_FMAC4 soap_get__tds__GetEndpointReference(struct soap *soap, struct _tds__GetEndpointReference *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetEndpointReference(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__SetDPAddressesResponse(struct soap *soap, struct _tds__SetDPAddressesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__SetDPAddressesResponse(struct soap *soap, const struct _tds__SetDPAddressesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetDPAddressesResponse(struct soap *soap, const char *tag, int id, const struct _tds__SetDPAddressesResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetDPAddressesResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__SetDPAddressesResponse * SOAP_FMAC4 soap_in__tds__SetDPAddressesResponse(struct soap *soap, const char *tag, struct _tds__SetDPAddressesResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__SetDPAddressesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetDPAddressesResponse, sizeof(struct _tds__SetDPAddressesResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__SetDPAddressesResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__SetDPAddressesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetDPAddressesResponse, 0, sizeof(struct _tds__SetDPAddressesResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__SetDPAddressesResponse(struct soap *soap, const struct _tds__SetDPAddressesResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__SetDPAddressesResponse);
	if (soap_out__tds__SetDPAddressesResponse(soap, tag?tag:"tds:SetDPAddressesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetDPAddressesResponse * SOAP_FMAC4 soap_get__tds__SetDPAddressesResponse(struct soap *soap, struct _tds__SetDPAddressesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetDPAddressesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__SetDPAddresses(struct soap *soap, struct _tds__SetDPAddresses *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeDPAddress = 0;
	a->DPAddress = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__SetDPAddresses(struct soap *soap, const struct _tds__SetDPAddresses *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->DPAddress)
	{	int i;
		for (i = 0; i < a->__sizeDPAddress; i++)
		{
			soap_embedded(soap, a->DPAddress + i, SOAP_TYPE_tt__NetworkHost);
			soap_serialize_tt__NetworkHost(soap, a->DPAddress + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetDPAddresses(struct soap *soap, const char *tag, int id, const struct _tds__SetDPAddresses *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetDPAddresses), type))
		return soap->error;
	if (a->DPAddress)
	{	int i;
		for (i = 0; i < a->__sizeDPAddress; i++)
			if (soap_out_tt__NetworkHost(soap, "tds:DPAddress", -1, a->DPAddress + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__SetDPAddresses * SOAP_FMAC4 soap_in__tds__SetDPAddresses(struct soap *soap, const char *tag, struct _tds__SetDPAddresses *a, const char *type)
{
	struct soap_blist *soap_blist_DPAddress = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__SetDPAddresses *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetDPAddresses, sizeof(struct _tds__SetDPAddresses), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__SetDPAddresses(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tds:DPAddress", 1, NULL))
			{	if (a->DPAddress == NULL)
				{	if (soap_blist_DPAddress == NULL)
						soap_blist_DPAddress = soap_new_block(soap);
					a->DPAddress = (struct tt__NetworkHost *)soap_push_block(soap, soap_blist_DPAddress, sizeof(struct tt__NetworkHost));
					if (a->DPAddress == NULL)
						return NULL;
					soap_default_tt__NetworkHost(soap, a->DPAddress);
				}
				soap_revert(soap);
				if (soap_in_tt__NetworkHost(soap, "tds:DPAddress", a->DPAddress, "tt:NetworkHost"))
				{	a->__sizeDPAddress++;
					a->DPAddress = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->DPAddress)
			soap_pop_block(soap, soap_blist_DPAddress);
		if (a->__sizeDPAddress)
			a->DPAddress = (struct tt__NetworkHost *)soap_save_block(soap, soap_blist_DPAddress, NULL, 1);
		else
		{	a->DPAddress = NULL;
			if (soap_blist_DPAddress)
				soap_end_block(soap, soap_blist_DPAddress);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__SetDPAddresses *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetDPAddresses, 0, sizeof(struct _tds__SetDPAddresses), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__SetDPAddresses(struct soap *soap, const struct _tds__SetDPAddresses *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__SetDPAddresses);
	if (soap_out__tds__SetDPAddresses(soap, tag?tag:"tds:SetDPAddresses", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetDPAddresses * SOAP_FMAC4 soap_get__tds__SetDPAddresses(struct soap *soap, struct _tds__SetDPAddresses *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetDPAddresses(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__NetworkHost(struct soap *soap, struct tt__NetworkHost *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__NetworkHostType(soap, &a->Type);
	a->IPv4Address = NULL;
	a->IPv6Address = NULL;
	a->DNSname = NULL;
	a->Extension = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__NetworkHost(struct soap *soap, const struct tt__NetworkHost *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTott__IPv4Address(soap, &a->IPv4Address);
	soap_serialize_PointerTott__IPv6Address(soap, &a->IPv6Address);
	soap_serialize_PointerTott__DNSName(soap, &a->DNSname);
	soap_serialize_PointerTott__NetworkHostExtension(soap, &a->Extension);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__NetworkHost(struct soap *soap, const char *tag, int id, const struct tt__NetworkHost *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__NetworkHost), type))
		return soap->error;
	if (soap_out_tt__NetworkHostType(soap, "tt:Type", -1, &a->Type, ""))
		return soap->error;
	if (soap_out_PointerTott__IPv4Address(soap, "tt:IPv4Address", -1, &a->IPv4Address, ""))
		return soap->error;
	if (soap_out_PointerTott__IPv6Address(soap, "tt:IPv6Address", -1, &a->IPv6Address, ""))
		return soap->error;
	if (soap_out_PointerTott__DNSName(soap, "tt:DNSname", -1, &a->DNSname, ""))
		return soap->error;
	if (soap_out_PointerTott__NetworkHostExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__NetworkHost * SOAP_FMAC4 soap_in_tt__NetworkHost(struct soap *soap, const char *tag, struct tt__NetworkHost *a, const char *type)
{
	size_t soap_flag_Type = 1;
	size_t soap_flag_IPv4Address = 1;
	size_t soap_flag_IPv6Address = 1;
	size_t soap_flag_DNSname = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__NetworkHost *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__NetworkHost, sizeof(struct tt__NetworkHost), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__NetworkHost(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Type && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_tt__NetworkHostType(soap, "tt:Type", &a->Type, "tt:NetworkHostType"))
				{	soap_flag_Type--;
					continue;
				}
			if (soap_flag_IPv4Address && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IPv4Address(soap, "tt:IPv4Address", &a->IPv4Address, "tt:IPv4Address"))
				{	soap_flag_IPv4Address--;
					continue;
				}
			if (soap_flag_IPv6Address && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IPv6Address(soap, "tt:IPv6Address", &a->IPv6Address, "tt:IPv6Address"))
				{	soap_flag_IPv6Address--;
					continue;
				}
			if (soap_flag_DNSname && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__DNSName(soap, "tt:DNSname", &a->DNSname, "tt:DNSName"))
				{	soap_flag_DNSname--;
					continue;
				}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__NetworkHostExtension(soap, "tt:Extension", &a->Extension, "tt:NetworkHostExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__NetworkHost *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__NetworkHost, 0, sizeof(struct tt__NetworkHost), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Type > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__NetworkHost(struct soap *soap, const struct tt__NetworkHost *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__NetworkHost);
	if (soap_out_tt__NetworkHost(soap, tag?tag:"tt:NetworkHost", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__NetworkHost * SOAP_FMAC4 soap_get_tt__NetworkHost(struct soap *soap, struct tt__NetworkHost *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__NetworkHost(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetDPAddressesResponse(struct soap *soap, struct _tds__GetDPAddressesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeDPAddress = 0;
	a->DPAddress = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetDPAddressesResponse(struct soap *soap, const struct _tds__GetDPAddressesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->DPAddress)
	{	int i;
		for (i = 0; i < a->__sizeDPAddress; i++)
		{
			soap_embedded(soap, a->DPAddress + i, SOAP_TYPE_tt__NetworkHost);
			soap_serialize_tt__NetworkHost(soap, a->DPAddress + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetDPAddressesResponse(struct soap *soap, const char *tag, int id, const struct _tds__GetDPAddressesResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetDPAddressesResponse), type))
		return soap->error;
	soap_element_result(soap, "-sizeDPAddress");
	if (a->DPAddress)
	{	int i;
		for (i = 0; i < a->__sizeDPAddress; i++)
			if (soap_out_tt__NetworkHost(soap, "tds:DPAddress", -1, a->DPAddress + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetDPAddressesResponse * SOAP_FMAC4 soap_in__tds__GetDPAddressesResponse(struct soap *soap, const char *tag, struct _tds__GetDPAddressesResponse *a, const char *type)
{
	struct soap_blist *soap_blist_DPAddress = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__GetDPAddressesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetDPAddressesResponse, sizeof(struct _tds__GetDPAddressesResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetDPAddressesResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tds:DPAddress", 1, NULL))
			{	if (a->DPAddress == NULL)
				{	if (soap_blist_DPAddress == NULL)
						soap_blist_DPAddress = soap_new_block(soap);
					a->DPAddress = (struct tt__NetworkHost *)soap_push_block(soap, soap_blist_DPAddress, sizeof(struct tt__NetworkHost));
					if (a->DPAddress == NULL)
						return NULL;
					soap_default_tt__NetworkHost(soap, a->DPAddress);
				}
				soap_revert(soap);
				if (soap_in_tt__NetworkHost(soap, "tds:DPAddress", a->DPAddress, "tt:NetworkHost"))
				{	a->__sizeDPAddress++;
					a->DPAddress = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizeDPAddress");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->DPAddress)
			soap_pop_block(soap, soap_blist_DPAddress);
		if (a->__sizeDPAddress)
			a->DPAddress = (struct tt__NetworkHost *)soap_save_block(soap, soap_blist_DPAddress, NULL, 1);
		else
		{	a->DPAddress = NULL;
			if (soap_blist_DPAddress)
				soap_end_block(soap, soap_blist_DPAddress);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__GetDPAddressesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetDPAddressesResponse, 0, sizeof(struct _tds__GetDPAddressesResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetDPAddressesResponse(struct soap *soap, const struct _tds__GetDPAddressesResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__GetDPAddressesResponse);
	if (soap_out__tds__GetDPAddressesResponse(soap, tag?tag:"tds:GetDPAddressesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetDPAddressesResponse * SOAP_FMAC4 soap_get__tds__GetDPAddressesResponse(struct soap *soap, struct _tds__GetDPAddressesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetDPAddressesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetDPAddresses(struct soap *soap, struct _tds__GetDPAddresses *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetDPAddresses(struct soap *soap, const struct _tds__GetDPAddresses *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetDPAddresses(struct soap *soap, const char *tag, int id, const struct _tds__GetDPAddresses *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetDPAddresses), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetDPAddresses * SOAP_FMAC4 soap_in__tds__GetDPAddresses(struct soap *soap, const char *tag, struct _tds__GetDPAddresses *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__GetDPAddresses *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetDPAddresses, sizeof(struct _tds__GetDPAddresses), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetDPAddresses(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__GetDPAddresses *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetDPAddresses, 0, sizeof(struct _tds__GetDPAddresses), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetDPAddresses(struct soap *soap, const struct _tds__GetDPAddresses *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__GetDPAddresses);
	if (soap_out__tds__GetDPAddresses(soap, tag?tag:"tds:GetDPAddresses", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetDPAddresses * SOAP_FMAC4 soap_get__tds__GetDPAddresses(struct soap *soap, struct _tds__GetDPAddresses *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetDPAddresses(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__SetRemoteDiscoveryModeResponse(struct soap *soap, struct _tds__SetRemoteDiscoveryModeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__SetRemoteDiscoveryModeResponse(struct soap *soap, const struct _tds__SetRemoteDiscoveryModeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetRemoteDiscoveryModeResponse(struct soap *soap, const char *tag, int id, const struct _tds__SetRemoteDiscoveryModeResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetRemoteDiscoveryModeResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__SetRemoteDiscoveryModeResponse * SOAP_FMAC4 soap_in__tds__SetRemoteDiscoveryModeResponse(struct soap *soap, const char *tag, struct _tds__SetRemoteDiscoveryModeResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__SetRemoteDiscoveryModeResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetRemoteDiscoveryModeResponse, sizeof(struct _tds__SetRemoteDiscoveryModeResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__SetRemoteDiscoveryModeResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__SetRemoteDiscoveryModeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetRemoteDiscoveryModeResponse, 0, sizeof(struct _tds__SetRemoteDiscoveryModeResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__SetRemoteDiscoveryModeResponse(struct soap *soap, const struct _tds__SetRemoteDiscoveryModeResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__SetRemoteDiscoveryModeResponse);
	if (soap_out__tds__SetRemoteDiscoveryModeResponse(soap, tag?tag:"tds:SetRemoteDiscoveryModeResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetRemoteDiscoveryModeResponse * SOAP_FMAC4 soap_get__tds__SetRemoteDiscoveryModeResponse(struct soap *soap, struct _tds__SetRemoteDiscoveryModeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetRemoteDiscoveryModeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__SetRemoteDiscoveryMode(struct soap *soap, struct _tds__SetRemoteDiscoveryMode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__DiscoveryMode(soap, &a->RemoteDiscoveryMode);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__SetRemoteDiscoveryMode(struct soap *soap, const struct _tds__SetRemoteDiscoveryMode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetRemoteDiscoveryMode(struct soap *soap, const char *tag, int id, const struct _tds__SetRemoteDiscoveryMode *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetRemoteDiscoveryMode), type))
		return soap->error;
	if (soap_out_tt__DiscoveryMode(soap, "tds:RemoteDiscoveryMode", -1, &a->RemoteDiscoveryMode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__SetRemoteDiscoveryMode * SOAP_FMAC4 soap_in__tds__SetRemoteDiscoveryMode(struct soap *soap, const char *tag, struct _tds__SetRemoteDiscoveryMode *a, const char *type)
{
	size_t soap_flag_RemoteDiscoveryMode = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__SetRemoteDiscoveryMode *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetRemoteDiscoveryMode, sizeof(struct _tds__SetRemoteDiscoveryMode), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__SetRemoteDiscoveryMode(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RemoteDiscoveryMode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_tt__DiscoveryMode(soap, "tds:RemoteDiscoveryMode", &a->RemoteDiscoveryMode, "tt:DiscoveryMode"))
				{	soap_flag_RemoteDiscoveryMode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__SetRemoteDiscoveryMode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetRemoteDiscoveryMode, 0, sizeof(struct _tds__SetRemoteDiscoveryMode), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_RemoteDiscoveryMode > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__SetRemoteDiscoveryMode(struct soap *soap, const struct _tds__SetRemoteDiscoveryMode *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__SetRemoteDiscoveryMode);
	if (soap_out__tds__SetRemoteDiscoveryMode(soap, tag?tag:"tds:SetRemoteDiscoveryMode", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetRemoteDiscoveryMode * SOAP_FMAC4 soap_get__tds__SetRemoteDiscoveryMode(struct soap *soap, struct _tds__SetRemoteDiscoveryMode *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetRemoteDiscoveryMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetRemoteDiscoveryModeResponse(struct soap *soap, struct _tds__GetRemoteDiscoveryModeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__DiscoveryMode(soap, &a->RemoteDiscoveryMode);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetRemoteDiscoveryModeResponse(struct soap *soap, const struct _tds__GetRemoteDiscoveryModeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetRemoteDiscoveryModeResponse(struct soap *soap, const char *tag, int id, const struct _tds__GetRemoteDiscoveryModeResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetRemoteDiscoveryModeResponse), type))
		return soap->error;
	soap_element_result(soap, "tds:RemoteDiscoveryMode");
	if (soap_out_tt__DiscoveryMode(soap, "tds:RemoteDiscoveryMode", -1, &a->RemoteDiscoveryMode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetRemoteDiscoveryModeResponse * SOAP_FMAC4 soap_in__tds__GetRemoteDiscoveryModeResponse(struct soap *soap, const char *tag, struct _tds__GetRemoteDiscoveryModeResponse *a, const char *type)
{
	size_t soap_flag_RemoteDiscoveryMode = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__GetRemoteDiscoveryModeResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetRemoteDiscoveryModeResponse, sizeof(struct _tds__GetRemoteDiscoveryModeResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetRemoteDiscoveryModeResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RemoteDiscoveryMode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_tt__DiscoveryMode(soap, "tds:RemoteDiscoveryMode", &a->RemoteDiscoveryMode, "tt:DiscoveryMode"))
				{	soap_flag_RemoteDiscoveryMode--;
					continue;
				}
			soap_check_result(soap, "tds:RemoteDiscoveryMode");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__GetRemoteDiscoveryModeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetRemoteDiscoveryModeResponse, 0, sizeof(struct _tds__GetRemoteDiscoveryModeResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_RemoteDiscoveryMode > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetRemoteDiscoveryModeResponse(struct soap *soap, const struct _tds__GetRemoteDiscoveryModeResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__GetRemoteDiscoveryModeResponse);
	if (soap_out__tds__GetRemoteDiscoveryModeResponse(soap, tag?tag:"tds:GetRemoteDiscoveryModeResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetRemoteDiscoveryModeResponse * SOAP_FMAC4 soap_get__tds__GetRemoteDiscoveryModeResponse(struct soap *soap, struct _tds__GetRemoteDiscoveryModeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetRemoteDiscoveryModeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetRemoteDiscoveryMode(struct soap *soap, struct _tds__GetRemoteDiscoveryMode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetRemoteDiscoveryMode(struct soap *soap, const struct _tds__GetRemoteDiscoveryMode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetRemoteDiscoveryMode(struct soap *soap, const char *tag, int id, const struct _tds__GetRemoteDiscoveryMode *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetRemoteDiscoveryMode), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetRemoteDiscoveryMode * SOAP_FMAC4 soap_in__tds__GetRemoteDiscoveryMode(struct soap *soap, const char *tag, struct _tds__GetRemoteDiscoveryMode *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__GetRemoteDiscoveryMode *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetRemoteDiscoveryMode, sizeof(struct _tds__GetRemoteDiscoveryMode), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetRemoteDiscoveryMode(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__GetRemoteDiscoveryMode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetRemoteDiscoveryMode, 0, sizeof(struct _tds__GetRemoteDiscoveryMode), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetRemoteDiscoveryMode(struct soap *soap, const struct _tds__GetRemoteDiscoveryMode *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__GetRemoteDiscoveryMode);
	if (soap_out__tds__GetRemoteDiscoveryMode(soap, tag?tag:"tds:GetRemoteDiscoveryMode", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetRemoteDiscoveryMode * SOAP_FMAC4 soap_get__tds__GetRemoteDiscoveryMode(struct soap *soap, struct _tds__GetRemoteDiscoveryMode *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetRemoteDiscoveryMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__SetDiscoveryModeResponse(struct soap *soap, struct _tds__SetDiscoveryModeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__SetDiscoveryModeResponse(struct soap *soap, const struct _tds__SetDiscoveryModeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetDiscoveryModeResponse(struct soap *soap, const char *tag, int id, const struct _tds__SetDiscoveryModeResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetDiscoveryModeResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__SetDiscoveryModeResponse * SOAP_FMAC4 soap_in__tds__SetDiscoveryModeResponse(struct soap *soap, const char *tag, struct _tds__SetDiscoveryModeResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__SetDiscoveryModeResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetDiscoveryModeResponse, sizeof(struct _tds__SetDiscoveryModeResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__SetDiscoveryModeResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__SetDiscoveryModeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetDiscoveryModeResponse, 0, sizeof(struct _tds__SetDiscoveryModeResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__SetDiscoveryModeResponse(struct soap *soap, const struct _tds__SetDiscoveryModeResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__SetDiscoveryModeResponse);
	if (soap_out__tds__SetDiscoveryModeResponse(soap, tag?tag:"tds:SetDiscoveryModeResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetDiscoveryModeResponse * SOAP_FMAC4 soap_get__tds__SetDiscoveryModeResponse(struct soap *soap, struct _tds__SetDiscoveryModeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetDiscoveryModeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__SetDiscoveryMode(struct soap *soap, struct _tds__SetDiscoveryMode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__DiscoveryMode(soap, &a->DiscoveryMode);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__SetDiscoveryMode(struct soap *soap, const struct _tds__SetDiscoveryMode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetDiscoveryMode(struct soap *soap, const char *tag, int id, const struct _tds__SetDiscoveryMode *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetDiscoveryMode), type))
		return soap->error;
	if (soap_out_tt__DiscoveryMode(soap, "tds:DiscoveryMode", -1, &a->DiscoveryMode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__SetDiscoveryMode * SOAP_FMAC4 soap_in__tds__SetDiscoveryMode(struct soap *soap, const char *tag, struct _tds__SetDiscoveryMode *a, const char *type)
{
	size_t soap_flag_DiscoveryMode = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__SetDiscoveryMode *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetDiscoveryMode, sizeof(struct _tds__SetDiscoveryMode), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__SetDiscoveryMode(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_DiscoveryMode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_tt__DiscoveryMode(soap, "tds:DiscoveryMode", &a->DiscoveryMode, "tt:DiscoveryMode"))
				{	soap_flag_DiscoveryMode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__SetDiscoveryMode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetDiscoveryMode, 0, sizeof(struct _tds__SetDiscoveryMode), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_DiscoveryMode > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__SetDiscoveryMode(struct soap *soap, const struct _tds__SetDiscoveryMode *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__SetDiscoveryMode);
	if (soap_out__tds__SetDiscoveryMode(soap, tag?tag:"tds:SetDiscoveryMode", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetDiscoveryMode * SOAP_FMAC4 soap_get__tds__SetDiscoveryMode(struct soap *soap, struct _tds__SetDiscoveryMode *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetDiscoveryMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetDiscoveryModeResponse(struct soap *soap, struct _tds__GetDiscoveryModeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__DiscoveryMode(soap, &a->DiscoveryMode);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetDiscoveryModeResponse(struct soap *soap, const struct _tds__GetDiscoveryModeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetDiscoveryModeResponse(struct soap *soap, const char *tag, int id, const struct _tds__GetDiscoveryModeResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetDiscoveryModeResponse), type))
		return soap->error;
	soap_element_result(soap, "tds:DiscoveryMode");
	if (soap_out_tt__DiscoveryMode(soap, "tds:DiscoveryMode", -1, &a->DiscoveryMode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetDiscoveryModeResponse * SOAP_FMAC4 soap_in__tds__GetDiscoveryModeResponse(struct soap *soap, const char *tag, struct _tds__GetDiscoveryModeResponse *a, const char *type)
{
	size_t soap_flag_DiscoveryMode = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__GetDiscoveryModeResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetDiscoveryModeResponse, sizeof(struct _tds__GetDiscoveryModeResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetDiscoveryModeResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_DiscoveryMode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_tt__DiscoveryMode(soap, "tds:DiscoveryMode", &a->DiscoveryMode, "tt:DiscoveryMode"))
				{	soap_flag_DiscoveryMode--;
					continue;
				}
			soap_check_result(soap, "tds:DiscoveryMode");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__GetDiscoveryModeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetDiscoveryModeResponse, 0, sizeof(struct _tds__GetDiscoveryModeResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_DiscoveryMode > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetDiscoveryModeResponse(struct soap *soap, const struct _tds__GetDiscoveryModeResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__GetDiscoveryModeResponse);
	if (soap_out__tds__GetDiscoveryModeResponse(soap, tag?tag:"tds:GetDiscoveryModeResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetDiscoveryModeResponse * SOAP_FMAC4 soap_get__tds__GetDiscoveryModeResponse(struct soap *soap, struct _tds__GetDiscoveryModeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetDiscoveryModeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetDiscoveryMode(struct soap *soap, struct _tds__GetDiscoveryMode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetDiscoveryMode(struct soap *soap, const struct _tds__GetDiscoveryMode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetDiscoveryMode(struct soap *soap, const char *tag, int id, const struct _tds__GetDiscoveryMode *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetDiscoveryMode), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetDiscoveryMode * SOAP_FMAC4 soap_in__tds__GetDiscoveryMode(struct soap *soap, const char *tag, struct _tds__GetDiscoveryMode *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__GetDiscoveryMode *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetDiscoveryMode, sizeof(struct _tds__GetDiscoveryMode), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetDiscoveryMode(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__GetDiscoveryMode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetDiscoveryMode, 0, sizeof(struct _tds__GetDiscoveryMode), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetDiscoveryMode(struct soap *soap, const struct _tds__GetDiscoveryMode *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__GetDiscoveryMode);
	if (soap_out__tds__GetDiscoveryMode(soap, tag?tag:"tds:GetDiscoveryMode", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetDiscoveryMode * SOAP_FMAC4 soap_get__tds__GetDiscoveryMode(struct soap *soap, struct _tds__GetDiscoveryMode *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetDiscoveryMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__RemoveScopesResponse(struct soap *soap, struct _tds__RemoveScopesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeScopeItem = 0;
	a->ScopeItem = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__RemoveScopesResponse(struct soap *soap, const struct _tds__RemoveScopesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->ScopeItem)
	{	int i;
		for (i = 0; i < a->__sizeScopeItem; i++)
		{
			soap_serialize_string(soap, a->ScopeItem + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__RemoveScopesResponse(struct soap *soap, const char *tag, int id, const struct _tds__RemoveScopesResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__RemoveScopesResponse), type))
		return soap->error;
	soap_element_result(soap, "-sizeScopeItem");
	if (a->ScopeItem)
	{	int i;
		for (i = 0; i < a->__sizeScopeItem; i++)
			if (soap_out_string(soap, "tds:ScopeItem", -1, a->ScopeItem + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__RemoveScopesResponse * SOAP_FMAC4 soap_in__tds__RemoveScopesResponse(struct soap *soap, const char *tag, struct _tds__RemoveScopesResponse *a, const char *type)
{
	struct soap_blist *soap_blist_ScopeItem = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__RemoveScopesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__RemoveScopesResponse, sizeof(struct _tds__RemoveScopesResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__RemoveScopesResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tds:ScopeItem", 1, NULL))
			{	if (a->ScopeItem == NULL)
				{	if (soap_blist_ScopeItem == NULL)
						soap_blist_ScopeItem = soap_new_block(soap);
					a->ScopeItem = (char **)soap_push_block(soap, soap_blist_ScopeItem, sizeof(char *));
					if (a->ScopeItem == NULL)
						return NULL;
					*a->ScopeItem = NULL;
				}
				soap_revert(soap);
				if (soap_in_string(soap, "tds:ScopeItem", a->ScopeItem, "xsd:string"))
				{	a->__sizeScopeItem++;
					a->ScopeItem = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizeScopeItem");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ScopeItem)
			soap_pop_block(soap, soap_blist_ScopeItem);
		if (a->__sizeScopeItem)
			a->ScopeItem = (char **)soap_save_block(soap, soap_blist_ScopeItem, NULL, 1);
		else
		{	a->ScopeItem = NULL;
			if (soap_blist_ScopeItem)
				soap_end_block(soap, soap_blist_ScopeItem);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__RemoveScopesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__RemoveScopesResponse, 0, sizeof(struct _tds__RemoveScopesResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__RemoveScopesResponse(struct soap *soap, const struct _tds__RemoveScopesResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__RemoveScopesResponse);
	if (soap_out__tds__RemoveScopesResponse(soap, tag?tag:"tds:RemoveScopesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__RemoveScopesResponse * SOAP_FMAC4 soap_get__tds__RemoveScopesResponse(struct soap *soap, struct _tds__RemoveScopesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__RemoveScopesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__RemoveScopes(struct soap *soap, struct _tds__RemoveScopes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeScopeItem = 0;
	a->ScopeItem = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__RemoveScopes(struct soap *soap, const struct _tds__RemoveScopes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->ScopeItem)
	{	int i;
		for (i = 0; i < a->__sizeScopeItem; i++)
		{
			soap_serialize_string(soap, a->ScopeItem + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__RemoveScopes(struct soap *soap, const char *tag, int id, const struct _tds__RemoveScopes *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__RemoveScopes), type))
		return soap->error;
	if (a->ScopeItem)
	{	int i;
		for (i = 0; i < a->__sizeScopeItem; i++)
			if (soap_out_string(soap, "tds:ScopeItem", -1, a->ScopeItem + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__RemoveScopes * SOAP_FMAC4 soap_in__tds__RemoveScopes(struct soap *soap, const char *tag, struct _tds__RemoveScopes *a, const char *type)
{
	struct soap_blist *soap_blist_ScopeItem = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__RemoveScopes *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__RemoveScopes, sizeof(struct _tds__RemoveScopes), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__RemoveScopes(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tds:ScopeItem", 1, NULL))
			{	if (a->ScopeItem == NULL)
				{	if (soap_blist_ScopeItem == NULL)
						soap_blist_ScopeItem = soap_new_block(soap);
					a->ScopeItem = (char **)soap_push_block(soap, soap_blist_ScopeItem, sizeof(char *));
					if (a->ScopeItem == NULL)
						return NULL;
					*a->ScopeItem = NULL;
				}
				soap_revert(soap);
				if (soap_in_string(soap, "tds:ScopeItem", a->ScopeItem, "xsd:string"))
				{	a->__sizeScopeItem++;
					a->ScopeItem = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ScopeItem)
			soap_pop_block(soap, soap_blist_ScopeItem);
		if (a->__sizeScopeItem)
			a->ScopeItem = (char **)soap_save_block(soap, soap_blist_ScopeItem, NULL, 1);
		else
		{	a->ScopeItem = NULL;
			if (soap_blist_ScopeItem)
				soap_end_block(soap, soap_blist_ScopeItem);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__RemoveScopes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__RemoveScopes, 0, sizeof(struct _tds__RemoveScopes), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeScopeItem < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__RemoveScopes(struct soap *soap, const struct _tds__RemoveScopes *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__RemoveScopes);
	if (soap_out__tds__RemoveScopes(soap, tag?tag:"tds:RemoveScopes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__RemoveScopes * SOAP_FMAC4 soap_get__tds__RemoveScopes(struct soap *soap, struct _tds__RemoveScopes *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__RemoveScopes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__AddScopesResponse(struct soap *soap, struct _tds__AddScopesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__AddScopesResponse(struct soap *soap, const struct _tds__AddScopesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__AddScopesResponse(struct soap *soap, const char *tag, int id, const struct _tds__AddScopesResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__AddScopesResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__AddScopesResponse * SOAP_FMAC4 soap_in__tds__AddScopesResponse(struct soap *soap, const char *tag, struct _tds__AddScopesResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__AddScopesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__AddScopesResponse, sizeof(struct _tds__AddScopesResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__AddScopesResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__AddScopesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__AddScopesResponse, 0, sizeof(struct _tds__AddScopesResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__AddScopesResponse(struct soap *soap, const struct _tds__AddScopesResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__AddScopesResponse);
	if (soap_out__tds__AddScopesResponse(soap, tag?tag:"tds:AddScopesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__AddScopesResponse * SOAP_FMAC4 soap_get__tds__AddScopesResponse(struct soap *soap, struct _tds__AddScopesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__AddScopesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__AddScopes(struct soap *soap, struct _tds__AddScopes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeScopeItem = 0;
	a->ScopeItem = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__AddScopes(struct soap *soap, const struct _tds__AddScopes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->ScopeItem)
	{	int i;
		for (i = 0; i < a->__sizeScopeItem; i++)
		{
			soap_serialize_string(soap, a->ScopeItem + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__AddScopes(struct soap *soap, const char *tag, int id, const struct _tds__AddScopes *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__AddScopes), type))
		return soap->error;
	if (a->ScopeItem)
	{	int i;
		for (i = 0; i < a->__sizeScopeItem; i++)
			if (soap_out_string(soap, "tds:ScopeItem", -1, a->ScopeItem + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__AddScopes * SOAP_FMAC4 soap_in__tds__AddScopes(struct soap *soap, const char *tag, struct _tds__AddScopes *a, const char *type)
{
	struct soap_blist *soap_blist_ScopeItem = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__AddScopes *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__AddScopes, sizeof(struct _tds__AddScopes), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__AddScopes(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tds:ScopeItem", 1, NULL))
			{	if (a->ScopeItem == NULL)
				{	if (soap_blist_ScopeItem == NULL)
						soap_blist_ScopeItem = soap_new_block(soap);
					a->ScopeItem = (char **)soap_push_block(soap, soap_blist_ScopeItem, sizeof(char *));
					if (a->ScopeItem == NULL)
						return NULL;
					*a->ScopeItem = NULL;
				}
				soap_revert(soap);
				if (soap_in_string(soap, "tds:ScopeItem", a->ScopeItem, "xsd:string"))
				{	a->__sizeScopeItem++;
					a->ScopeItem = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ScopeItem)
			soap_pop_block(soap, soap_blist_ScopeItem);
		if (a->__sizeScopeItem)
			a->ScopeItem = (char **)soap_save_block(soap, soap_blist_ScopeItem, NULL, 1);
		else
		{	a->ScopeItem = NULL;
			if (soap_blist_ScopeItem)
				soap_end_block(soap, soap_blist_ScopeItem);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__AddScopes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__AddScopes, 0, sizeof(struct _tds__AddScopes), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeScopeItem < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__AddScopes(struct soap *soap, const struct _tds__AddScopes *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__AddScopes);
	if (soap_out__tds__AddScopes(soap, tag?tag:"tds:AddScopes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__AddScopes * SOAP_FMAC4 soap_get__tds__AddScopes(struct soap *soap, struct _tds__AddScopes *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__AddScopes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__SetScopesResponse(struct soap *soap, struct _tds__SetScopesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__SetScopesResponse(struct soap *soap, const struct _tds__SetScopesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetScopesResponse(struct soap *soap, const char *tag, int id, const struct _tds__SetScopesResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetScopesResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__SetScopesResponse * SOAP_FMAC4 soap_in__tds__SetScopesResponse(struct soap *soap, const char *tag, struct _tds__SetScopesResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__SetScopesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetScopesResponse, sizeof(struct _tds__SetScopesResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__SetScopesResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__SetScopesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetScopesResponse, 0, sizeof(struct _tds__SetScopesResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__SetScopesResponse(struct soap *soap, const struct _tds__SetScopesResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__SetScopesResponse);
	if (soap_out__tds__SetScopesResponse(soap, tag?tag:"tds:SetScopesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetScopesResponse * SOAP_FMAC4 soap_get__tds__SetScopesResponse(struct soap *soap, struct _tds__SetScopesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetScopesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__SetScopes(struct soap *soap, struct _tds__SetScopes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeScopes = 0;
	a->Scopes = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__SetScopes(struct soap *soap, const struct _tds__SetScopes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->Scopes)
	{	int i;
		for (i = 0; i < a->__sizeScopes; i++)
		{
			soap_serialize_string(soap, a->Scopes + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetScopes(struct soap *soap, const char *tag, int id, const struct _tds__SetScopes *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetScopes), type))
		return soap->error;
	if (a->Scopes)
	{	int i;
		for (i = 0; i < a->__sizeScopes; i++)
			if (soap_out_string(soap, "tds:Scopes", -1, a->Scopes + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__SetScopes * SOAP_FMAC4 soap_in__tds__SetScopes(struct soap *soap, const char *tag, struct _tds__SetScopes *a, const char *type)
{
	struct soap_blist *soap_blist_Scopes = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__SetScopes *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetScopes, sizeof(struct _tds__SetScopes), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__SetScopes(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tds:Scopes", 1, NULL))
			{	if (a->Scopes == NULL)
				{	if (soap_blist_Scopes == NULL)
						soap_blist_Scopes = soap_new_block(soap);
					a->Scopes = (char **)soap_push_block(soap, soap_blist_Scopes, sizeof(char *));
					if (a->Scopes == NULL)
						return NULL;
					*a->Scopes = NULL;
				}
				soap_revert(soap);
				if (soap_in_string(soap, "tds:Scopes", a->Scopes, "xsd:string"))
				{	a->__sizeScopes++;
					a->Scopes = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Scopes)
			soap_pop_block(soap, soap_blist_Scopes);
		if (a->__sizeScopes)
			a->Scopes = (char **)soap_save_block(soap, soap_blist_Scopes, NULL, 1);
		else
		{	a->Scopes = NULL;
			if (soap_blist_Scopes)
				soap_end_block(soap, soap_blist_Scopes);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__SetScopes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetScopes, 0, sizeof(struct _tds__SetScopes), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeScopes < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__SetScopes(struct soap *soap, const struct _tds__SetScopes *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__SetScopes);
	if (soap_out__tds__SetScopes(soap, tag?tag:"tds:SetScopes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetScopes * SOAP_FMAC4 soap_get__tds__SetScopes(struct soap *soap, struct _tds__SetScopes *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetScopes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__Scope(struct soap *soap, struct tt__Scope *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ScopeDefinition(soap, &a->ScopeDef);
	soap_default_string(soap, &a->ScopeItem);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__Scope(struct soap *soap, const struct tt__Scope *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->ScopeItem);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Scope(struct soap *soap, const char *tag, int id, const struct tt__Scope *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Scope), type))
		return soap->error;
	if (soap_out_tt__ScopeDefinition(soap, "tt:ScopeDef", -1, &a->ScopeDef, ""))
		return soap->error;
	if (a->ScopeItem)
	{	if (soap_out_string(soap, "tt:ScopeItem", -1, &a->ScopeItem, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:ScopeItem"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__Scope * SOAP_FMAC4 soap_in_tt__Scope(struct soap *soap, const char *tag, struct tt__Scope *a, const char *type)
{
	size_t soap_flag_ScopeDef = 1;
	size_t soap_flag_ScopeItem = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__Scope *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Scope, sizeof(struct tt__Scope), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__Scope(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ScopeDef && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_tt__ScopeDefinition(soap, "tt:ScopeDef", &a->ScopeDef, "tt:ScopeDefinition"))
				{	soap_flag_ScopeDef--;
					continue;
				}
			if (soap_flag_ScopeItem && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "tt:ScopeItem", &a->ScopeItem, "xsd:string"))
				{	soap_flag_ScopeItem--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__Scope *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Scope, 0, sizeof(struct tt__Scope), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ScopeDef > 0 || soap_flag_ScopeItem > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Scope(struct soap *soap, const struct tt__Scope *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__Scope);
	if (soap_out_tt__Scope(soap, tag?tag:"tt:Scope", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Scope * SOAP_FMAC4 soap_get_tt__Scope(struct soap *soap, struct tt__Scope *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Scope(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetScopesResponse(struct soap *soap, struct _tds__GetScopesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeScopes = 0;
	a->Scopes = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetScopesResponse(struct soap *soap, const struct _tds__GetScopesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->Scopes)
	{	int i;
		for (i = 0; i < a->__sizeScopes; i++)
		{
			soap_embedded(soap, a->Scopes + i, SOAP_TYPE_tt__Scope);
			soap_serialize_tt__Scope(soap, a->Scopes + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetScopesResponse(struct soap *soap, const char *tag, int id, const struct _tds__GetScopesResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetScopesResponse), type))
		return soap->error;
	soap_element_result(soap, "-sizeScopes");
	if (a->Scopes)
	{	int i;
		for (i = 0; i < a->__sizeScopes; i++)
			if (soap_out_tt__Scope(soap, "tds:Scopes", -1, a->Scopes + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetScopesResponse * SOAP_FMAC4 soap_in__tds__GetScopesResponse(struct soap *soap, const char *tag, struct _tds__GetScopesResponse *a, const char *type)
{
	struct soap_blist *soap_blist_Scopes = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__GetScopesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetScopesResponse, sizeof(struct _tds__GetScopesResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetScopesResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tds:Scopes", 1, NULL))
			{	if (a->Scopes == NULL)
				{	if (soap_blist_Scopes == NULL)
						soap_blist_Scopes = soap_new_block(soap);
					a->Scopes = (struct tt__Scope *)soap_push_block(soap, soap_blist_Scopes, sizeof(struct tt__Scope));
					if (a->Scopes == NULL)
						return NULL;
					soap_default_tt__Scope(soap, a->Scopes);
				}
				soap_revert(soap);
				if (soap_in_tt__Scope(soap, "tds:Scopes", a->Scopes, "tt:Scope"))
				{	a->__sizeScopes++;
					a->Scopes = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizeScopes");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Scopes)
			soap_pop_block(soap, soap_blist_Scopes);
		if (a->__sizeScopes)
			a->Scopes = (struct tt__Scope *)soap_save_block(soap, soap_blist_Scopes, NULL, 1);
		else
		{	a->Scopes = NULL;
			if (soap_blist_Scopes)
				soap_end_block(soap, soap_blist_Scopes);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__GetScopesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetScopesResponse, 0, sizeof(struct _tds__GetScopesResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeScopes < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetScopesResponse(struct soap *soap, const struct _tds__GetScopesResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__GetScopesResponse);
	if (soap_out__tds__GetScopesResponse(soap, tag?tag:"tds:GetScopesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetScopesResponse * SOAP_FMAC4 soap_get__tds__GetScopesResponse(struct soap *soap, struct _tds__GetScopesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetScopesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetScopes(struct soap *soap, struct _tds__GetScopes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetScopes(struct soap *soap, const struct _tds__GetScopes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetScopes(struct soap *soap, const char *tag, int id, const struct _tds__GetScopes *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetScopes), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetScopes * SOAP_FMAC4 soap_in__tds__GetScopes(struct soap *soap, const char *tag, struct _tds__GetScopes *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__GetScopes *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetScopes, sizeof(struct _tds__GetScopes), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetScopes(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__GetScopes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetScopes, 0, sizeof(struct _tds__GetScopes), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetScopes(struct soap *soap, const struct _tds__GetScopes *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__GetScopes);
	if (soap_out__tds__GetScopes(soap, tag?tag:"tds:GetScopes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetScopes * SOAP_FMAC4 soap_get__tds__GetScopes(struct soap *soap, struct _tds__GetScopes *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetScopes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__SystemLog(struct soap *soap, struct tt__SystemLog *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Binary = NULL;
	soap_default_string(soap, &a->String);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__SystemLog(struct soap *soap, const struct tt__SystemLog *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTott__AttachmentData(soap, &a->Binary);
	soap_serialize_string(soap, &a->String);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__SystemLog(struct soap *soap, const char *tag, int id, const struct tt__SystemLog *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__SystemLog), type))
		return soap->error;
	if (soap_out_PointerTott__AttachmentData(soap, "tt:Binary", -1, &a->Binary, ""))
		return soap->error;
	if (soap_out_string(soap, "tt:String", -1, &a->String, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__SystemLog * SOAP_FMAC4 soap_in_tt__SystemLog(struct soap *soap, const char *tag, struct tt__SystemLog *a, const char *type)
{
	size_t soap_flag_Binary = 1;
	size_t soap_flag_String = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__SystemLog *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__SystemLog, sizeof(struct tt__SystemLog), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__SystemLog(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Binary && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__AttachmentData(soap, "tt:Binary", &a->Binary, "tt:AttachmentData"))
				{	soap_flag_Binary--;
					continue;
				}
			if (soap_flag_String && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "tt:String", &a->String, "xsd:string"))
				{	soap_flag_String--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__SystemLog *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__SystemLog, 0, sizeof(struct tt__SystemLog), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__SystemLog(struct soap *soap, const struct tt__SystemLog *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__SystemLog);
	if (soap_out_tt__SystemLog(soap, tag?tag:"tt:SystemLog", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__SystemLog * SOAP_FMAC4 soap_get_tt__SystemLog(struct soap *soap, struct tt__SystemLog *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__SystemLog(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetSystemLogResponse(struct soap *soap, struct _tds__GetSystemLogResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->SystemLog = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetSystemLogResponse(struct soap *soap, const struct _tds__GetSystemLogResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTott__SystemLog(soap, &a->SystemLog);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetSystemLogResponse(struct soap *soap, const char *tag, int id, const struct _tds__GetSystemLogResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetSystemLogResponse), type))
		return soap->error;
	if (a->SystemLog)
		soap_element_result(soap, "tds:SystemLog");
	if (a->SystemLog)
	{	if (soap_out_PointerTott__SystemLog(soap, "tds:SystemLog", -1, &a->SystemLog, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tds:SystemLog"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetSystemLogResponse * SOAP_FMAC4 soap_in__tds__GetSystemLogResponse(struct soap *soap, const char *tag, struct _tds__GetSystemLogResponse *a, const char *type)
{
	size_t soap_flag_SystemLog = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__GetSystemLogResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetSystemLogResponse, sizeof(struct _tds__GetSystemLogResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetSystemLogResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SystemLog && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__SystemLog(soap, "tds:SystemLog", &a->SystemLog, "tt:SystemLog"))
				{	soap_flag_SystemLog--;
					continue;
				}
			soap_check_result(soap, "tds:SystemLog");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__GetSystemLogResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetSystemLogResponse, 0, sizeof(struct _tds__GetSystemLogResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_SystemLog > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetSystemLogResponse(struct soap *soap, const struct _tds__GetSystemLogResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__GetSystemLogResponse);
	if (soap_out__tds__GetSystemLogResponse(soap, tag?tag:"tds:GetSystemLogResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetSystemLogResponse * SOAP_FMAC4 soap_get__tds__GetSystemLogResponse(struct soap *soap, struct _tds__GetSystemLogResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetSystemLogResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetSystemLog(struct soap *soap, struct _tds__GetSystemLog *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__SystemLogType(soap, &a->LogType);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetSystemLog(struct soap *soap, const struct _tds__GetSystemLog *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetSystemLog(struct soap *soap, const char *tag, int id, const struct _tds__GetSystemLog *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetSystemLog), type))
		return soap->error;
	if (soap_out_tt__SystemLogType(soap, "tds:LogType", -1, &a->LogType, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetSystemLog * SOAP_FMAC4 soap_in__tds__GetSystemLog(struct soap *soap, const char *tag, struct _tds__GetSystemLog *a, const char *type)
{
	size_t soap_flag_LogType = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__GetSystemLog *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetSystemLog, sizeof(struct _tds__GetSystemLog), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetSystemLog(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_LogType && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_tt__SystemLogType(soap, "tds:LogType", &a->LogType, "tt:SystemLogType"))
				{	soap_flag_LogType--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__GetSystemLog *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetSystemLog, 0, sizeof(struct _tds__GetSystemLog), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_LogType > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetSystemLog(struct soap *soap, const struct _tds__GetSystemLog *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__GetSystemLog);
	if (soap_out__tds__GetSystemLog(soap, tag?tag:"tds:GetSystemLog", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetSystemLog * SOAP_FMAC4 soap_get__tds__GetSystemLog(struct soap *soap, struct _tds__GetSystemLog *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetSystemLog(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__SupportInformation(struct soap *soap, struct tt__SupportInformation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Binary = NULL;
	soap_default_string(soap, &a->String);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__SupportInformation(struct soap *soap, const struct tt__SupportInformation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTott__AttachmentData(soap, &a->Binary);
	soap_serialize_string(soap, &a->String);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__SupportInformation(struct soap *soap, const char *tag, int id, const struct tt__SupportInformation *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__SupportInformation), type))
		return soap->error;
	if (soap_out_PointerTott__AttachmentData(soap, "tt:Binary", -1, &a->Binary, ""))
		return soap->error;
	if (soap_out_string(soap, "tt:String", -1, &a->String, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__SupportInformation * SOAP_FMAC4 soap_in_tt__SupportInformation(struct soap *soap, const char *tag, struct tt__SupportInformation *a, const char *type)
{
	size_t soap_flag_Binary = 1;
	size_t soap_flag_String = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__SupportInformation *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__SupportInformation, sizeof(struct tt__SupportInformation), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__SupportInformation(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Binary && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__AttachmentData(soap, "tt:Binary", &a->Binary, "tt:AttachmentData"))
				{	soap_flag_Binary--;
					continue;
				}
			if (soap_flag_String && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "tt:String", &a->String, "xsd:string"))
				{	soap_flag_String--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__SupportInformation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__SupportInformation, 0, sizeof(struct tt__SupportInformation), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__SupportInformation(struct soap *soap, const struct tt__SupportInformation *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__SupportInformation);
	if (soap_out_tt__SupportInformation(soap, tag?tag:"tt:SupportInformation", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__SupportInformation * SOAP_FMAC4 soap_get_tt__SupportInformation(struct soap *soap, struct tt__SupportInformation *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__SupportInformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetSystemSupportInformationResponse(struct soap *soap, struct _tds__GetSystemSupportInformationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->SupportInformation = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetSystemSupportInformationResponse(struct soap *soap, const struct _tds__GetSystemSupportInformationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTott__SupportInformation(soap, &a->SupportInformation);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetSystemSupportInformationResponse(struct soap *soap, const char *tag, int id, const struct _tds__GetSystemSupportInformationResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetSystemSupportInformationResponse), type))
		return soap->error;
	if (a->SupportInformation)
		soap_element_result(soap, "tds:SupportInformation");
	if (a->SupportInformation)
	{	if (soap_out_PointerTott__SupportInformation(soap, "tds:SupportInformation", -1, &a->SupportInformation, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tds:SupportInformation"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetSystemSupportInformationResponse * SOAP_FMAC4 soap_in__tds__GetSystemSupportInformationResponse(struct soap *soap, const char *tag, struct _tds__GetSystemSupportInformationResponse *a, const char *type)
{
	size_t soap_flag_SupportInformation = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__GetSystemSupportInformationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetSystemSupportInformationResponse, sizeof(struct _tds__GetSystemSupportInformationResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetSystemSupportInformationResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SupportInformation && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__SupportInformation(soap, "tds:SupportInformation", &a->SupportInformation, "tt:SupportInformation"))
				{	soap_flag_SupportInformation--;
					continue;
				}
			soap_check_result(soap, "tds:SupportInformation");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__GetSystemSupportInformationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetSystemSupportInformationResponse, 0, sizeof(struct _tds__GetSystemSupportInformationResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_SupportInformation > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetSystemSupportInformationResponse(struct soap *soap, const struct _tds__GetSystemSupportInformationResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__GetSystemSupportInformationResponse);
	if (soap_out__tds__GetSystemSupportInformationResponse(soap, tag?tag:"tds:GetSystemSupportInformationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetSystemSupportInformationResponse * SOAP_FMAC4 soap_get__tds__GetSystemSupportInformationResponse(struct soap *soap, struct _tds__GetSystemSupportInformationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetSystemSupportInformationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetSystemSupportInformation(struct soap *soap, struct _tds__GetSystemSupportInformation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetSystemSupportInformation(struct soap *soap, const struct _tds__GetSystemSupportInformation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetSystemSupportInformation(struct soap *soap, const char *tag, int id, const struct _tds__GetSystemSupportInformation *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetSystemSupportInformation), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetSystemSupportInformation * SOAP_FMAC4 soap_in__tds__GetSystemSupportInformation(struct soap *soap, const char *tag, struct _tds__GetSystemSupportInformation *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__GetSystemSupportInformation *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetSystemSupportInformation, sizeof(struct _tds__GetSystemSupportInformation), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetSystemSupportInformation(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__GetSystemSupportInformation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetSystemSupportInformation, 0, sizeof(struct _tds__GetSystemSupportInformation), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetSystemSupportInformation(struct soap *soap, const struct _tds__GetSystemSupportInformation *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__GetSystemSupportInformation);
	if (soap_out__tds__GetSystemSupportInformation(soap, tag?tag:"tds:GetSystemSupportInformation", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetSystemSupportInformation * SOAP_FMAC4 soap_get__tds__GetSystemSupportInformation(struct soap *soap, struct _tds__GetSystemSupportInformation *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetSystemSupportInformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetSystemBackupResponse(struct soap *soap, struct _tds__GetSystemBackupResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeBackupFiles = 0;
	a->BackupFiles = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetSystemBackupResponse(struct soap *soap, const struct _tds__GetSystemBackupResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->BackupFiles)
	{	int i;
		for (i = 0; i < a->__sizeBackupFiles; i++)
		{
			soap_embedded(soap, a->BackupFiles + i, SOAP_TYPE_tt__BackupFile);
			soap_serialize_tt__BackupFile(soap, a->BackupFiles + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetSystemBackupResponse(struct soap *soap, const char *tag, int id, const struct _tds__GetSystemBackupResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetSystemBackupResponse), type))
		return soap->error;
	soap_element_result(soap, "-sizeBackupFiles");
	if (a->BackupFiles)
	{	int i;
		for (i = 0; i < a->__sizeBackupFiles; i++)
			if (soap_out_tt__BackupFile(soap, "tds:BackupFiles", -1, a->BackupFiles + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetSystemBackupResponse * SOAP_FMAC4 soap_in__tds__GetSystemBackupResponse(struct soap *soap, const char *tag, struct _tds__GetSystemBackupResponse *a, const char *type)
{
	struct soap_blist *soap_blist_BackupFiles = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__GetSystemBackupResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetSystemBackupResponse, sizeof(struct _tds__GetSystemBackupResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetSystemBackupResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tds:BackupFiles", 1, NULL))
			{	if (a->BackupFiles == NULL)
				{	if (soap_blist_BackupFiles == NULL)
						soap_blist_BackupFiles = soap_new_block(soap);
					a->BackupFiles = (struct tt__BackupFile *)soap_push_block(soap, soap_blist_BackupFiles, sizeof(struct tt__BackupFile));
					if (a->BackupFiles == NULL)
						return NULL;
					soap_default_tt__BackupFile(soap, a->BackupFiles);
				}
				soap_revert(soap);
				if (soap_in_tt__BackupFile(soap, "tds:BackupFiles", a->BackupFiles, "tt:BackupFile"))
				{	a->__sizeBackupFiles++;
					a->BackupFiles = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizeBackupFiles");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->BackupFiles)
			soap_pop_block(soap, soap_blist_BackupFiles);
		if (a->__sizeBackupFiles)
			a->BackupFiles = (struct tt__BackupFile *)soap_save_block(soap, soap_blist_BackupFiles, NULL, 1);
		else
		{	a->BackupFiles = NULL;
			if (soap_blist_BackupFiles)
				soap_end_block(soap, soap_blist_BackupFiles);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__GetSystemBackupResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetSystemBackupResponse, 0, sizeof(struct _tds__GetSystemBackupResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeBackupFiles < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetSystemBackupResponse(struct soap *soap, const struct _tds__GetSystemBackupResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__GetSystemBackupResponse);
	if (soap_out__tds__GetSystemBackupResponse(soap, tag?tag:"tds:GetSystemBackupResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetSystemBackupResponse * SOAP_FMAC4 soap_get__tds__GetSystemBackupResponse(struct soap *soap, struct _tds__GetSystemBackupResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetSystemBackupResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetSystemBackup(struct soap *soap, struct _tds__GetSystemBackup *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetSystemBackup(struct soap *soap, const struct _tds__GetSystemBackup *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetSystemBackup(struct soap *soap, const char *tag, int id, const struct _tds__GetSystemBackup *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetSystemBackup), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetSystemBackup * SOAP_FMAC4 soap_in__tds__GetSystemBackup(struct soap *soap, const char *tag, struct _tds__GetSystemBackup *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__GetSystemBackup *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetSystemBackup, sizeof(struct _tds__GetSystemBackup), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetSystemBackup(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__GetSystemBackup *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetSystemBackup, 0, sizeof(struct _tds__GetSystemBackup), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetSystemBackup(struct soap *soap, const struct _tds__GetSystemBackup *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__GetSystemBackup);
	if (soap_out__tds__GetSystemBackup(soap, tag?tag:"tds:GetSystemBackup", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetSystemBackup * SOAP_FMAC4 soap_get__tds__GetSystemBackup(struct soap *soap, struct _tds__GetSystemBackup *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetSystemBackup(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__RestoreSystemResponse(struct soap *soap, struct _tds__RestoreSystemResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__RestoreSystemResponse(struct soap *soap, const struct _tds__RestoreSystemResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__RestoreSystemResponse(struct soap *soap, const char *tag, int id, const struct _tds__RestoreSystemResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__RestoreSystemResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__RestoreSystemResponse * SOAP_FMAC4 soap_in__tds__RestoreSystemResponse(struct soap *soap, const char *tag, struct _tds__RestoreSystemResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__RestoreSystemResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__RestoreSystemResponse, sizeof(struct _tds__RestoreSystemResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__RestoreSystemResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__RestoreSystemResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__RestoreSystemResponse, 0, sizeof(struct _tds__RestoreSystemResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__RestoreSystemResponse(struct soap *soap, const struct _tds__RestoreSystemResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__RestoreSystemResponse);
	if (soap_out__tds__RestoreSystemResponse(soap, tag?tag:"tds:RestoreSystemResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__RestoreSystemResponse * SOAP_FMAC4 soap_get__tds__RestoreSystemResponse(struct soap *soap, struct _tds__RestoreSystemResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__RestoreSystemResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__BackupFile(struct soap *soap, struct tt__BackupFile *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Name);
	a->Data = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__BackupFile(struct soap *soap, const struct tt__BackupFile *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Name);
	soap_serialize_PointerTott__AttachmentData(soap, &a->Data);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__BackupFile(struct soap *soap, const char *tag, int id, const struct tt__BackupFile *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__BackupFile), type))
		return soap->error;
	if (a->Name)
	{	if (soap_out_string(soap, "tt:Name", -1, &a->Name, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:Name"))
		return soap->error;
	if (a->Data)
	{	if (soap_out_PointerTott__AttachmentData(soap, "tt:Data", -1, &a->Data, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:Data"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__BackupFile * SOAP_FMAC4 soap_in_tt__BackupFile(struct soap *soap, const char *tag, struct tt__BackupFile *a, const char *type)
{
	size_t soap_flag_Name = 1;
	size_t soap_flag_Data = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__BackupFile *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__BackupFile, sizeof(struct tt__BackupFile), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__BackupFile(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "tt:Name", &a->Name, "xsd:string"))
				{	soap_flag_Name--;
					continue;
				}
			if (soap_flag_Data && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__AttachmentData(soap, "tt:Data", &a->Data, "tt:AttachmentData"))
				{	soap_flag_Data--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__BackupFile *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__BackupFile, 0, sizeof(struct tt__BackupFile), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Name > 0 || soap_flag_Data > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__BackupFile(struct soap *soap, const struct tt__BackupFile *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__BackupFile);
	if (soap_out_tt__BackupFile(soap, tag?tag:"tt:BackupFile", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__BackupFile * SOAP_FMAC4 soap_get_tt__BackupFile(struct soap *soap, struct tt__BackupFile *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__BackupFile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__RestoreSystem(struct soap *soap, struct _tds__RestoreSystem *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeBackupFiles = 0;
	a->BackupFiles = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__RestoreSystem(struct soap *soap, const struct _tds__RestoreSystem *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->BackupFiles)
	{	int i;
		for (i = 0; i < a->__sizeBackupFiles; i++)
		{
			soap_embedded(soap, a->BackupFiles + i, SOAP_TYPE_tt__BackupFile);
			soap_serialize_tt__BackupFile(soap, a->BackupFiles + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__RestoreSystem(struct soap *soap, const char *tag, int id, const struct _tds__RestoreSystem *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__RestoreSystem), type))
		return soap->error;
	if (a->BackupFiles)
	{	int i;
		for (i = 0; i < a->__sizeBackupFiles; i++)
			if (soap_out_tt__BackupFile(soap, "tds:BackupFiles", -1, a->BackupFiles + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__RestoreSystem * SOAP_FMAC4 soap_in__tds__RestoreSystem(struct soap *soap, const char *tag, struct _tds__RestoreSystem *a, const char *type)
{
	struct soap_blist *soap_blist_BackupFiles = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__RestoreSystem *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__RestoreSystem, sizeof(struct _tds__RestoreSystem), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__RestoreSystem(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tds:BackupFiles", 1, NULL))
			{	if (a->BackupFiles == NULL)
				{	if (soap_blist_BackupFiles == NULL)
						soap_blist_BackupFiles = soap_new_block(soap);
					a->BackupFiles = (struct tt__BackupFile *)soap_push_block(soap, soap_blist_BackupFiles, sizeof(struct tt__BackupFile));
					if (a->BackupFiles == NULL)
						return NULL;
					soap_default_tt__BackupFile(soap, a->BackupFiles);
				}
				soap_revert(soap);
				if (soap_in_tt__BackupFile(soap, "tds:BackupFiles", a->BackupFiles, "tt:BackupFile"))
				{	a->__sizeBackupFiles++;
					a->BackupFiles = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->BackupFiles)
			soap_pop_block(soap, soap_blist_BackupFiles);
		if (a->__sizeBackupFiles)
			a->BackupFiles = (struct tt__BackupFile *)soap_save_block(soap, soap_blist_BackupFiles, NULL, 1);
		else
		{	a->BackupFiles = NULL;
			if (soap_blist_BackupFiles)
				soap_end_block(soap, soap_blist_BackupFiles);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__RestoreSystem *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__RestoreSystem, 0, sizeof(struct _tds__RestoreSystem), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeBackupFiles < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__RestoreSystem(struct soap *soap, const struct _tds__RestoreSystem *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__RestoreSystem);
	if (soap_out__tds__RestoreSystem(soap, tag?tag:"tds:RestoreSystem", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__RestoreSystem * SOAP_FMAC4 soap_get__tds__RestoreSystem(struct soap *soap, struct _tds__RestoreSystem *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__RestoreSystem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__SystemRebootResponse(struct soap *soap, struct _tds__SystemRebootResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Message);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__SystemRebootResponse(struct soap *soap, const struct _tds__SystemRebootResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Message);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SystemRebootResponse(struct soap *soap, const char *tag, int id, const struct _tds__SystemRebootResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SystemRebootResponse), type))
		return soap->error;
	if (a->Message)
		soap_element_result(soap, "tds:Message");
	if (a->Message)
	{	if (soap_out_string(soap, "tds:Message", -1, &a->Message, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tds:Message"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__SystemRebootResponse * SOAP_FMAC4 soap_in__tds__SystemRebootResponse(struct soap *soap, const char *tag, struct _tds__SystemRebootResponse *a, const char *type)
{
	size_t soap_flag_Message = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__SystemRebootResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SystemRebootResponse, sizeof(struct _tds__SystemRebootResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__SystemRebootResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Message && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "tds:Message", &a->Message, "xsd:string"))
				{	soap_flag_Message--;
					continue;
				}
			soap_check_result(soap, "tds:Message");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__SystemRebootResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SystemRebootResponse, 0, sizeof(struct _tds__SystemRebootResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Message > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__SystemRebootResponse(struct soap *soap, const struct _tds__SystemRebootResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__SystemRebootResponse);
	if (soap_out__tds__SystemRebootResponse(soap, tag?tag:"tds:SystemRebootResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SystemRebootResponse * SOAP_FMAC4 soap_get__tds__SystemRebootResponse(struct soap *soap, struct _tds__SystemRebootResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SystemRebootResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__SystemReboot(struct soap *soap, struct _tds__SystemReboot *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__SystemReboot(struct soap *soap, const struct _tds__SystemReboot *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SystemReboot(struct soap *soap, const char *tag, int id, const struct _tds__SystemReboot *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SystemReboot), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__SystemReboot * SOAP_FMAC4 soap_in__tds__SystemReboot(struct soap *soap, const char *tag, struct _tds__SystemReboot *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__SystemReboot *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SystemReboot, sizeof(struct _tds__SystemReboot), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__SystemReboot(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__SystemReboot *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SystemReboot, 0, sizeof(struct _tds__SystemReboot), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__SystemReboot(struct soap *soap, const struct _tds__SystemReboot *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__SystemReboot);
	if (soap_out__tds__SystemReboot(soap, tag?tag:"tds:SystemReboot", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SystemReboot * SOAP_FMAC4 soap_get__tds__SystemReboot(struct soap *soap, struct _tds__SystemReboot *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SystemReboot(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__UpgradeSystemFirmwareResponse(struct soap *soap, struct _tds__UpgradeSystemFirmwareResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Message);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__UpgradeSystemFirmwareResponse(struct soap *soap, const struct _tds__UpgradeSystemFirmwareResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Message);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__UpgradeSystemFirmwareResponse(struct soap *soap, const char *tag, int id, const struct _tds__UpgradeSystemFirmwareResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__UpgradeSystemFirmwareResponse), type))
		return soap->error;
	if (a->Message)
		soap_element_result(soap, "tds:Message");
	if (soap_out_string(soap, "tds:Message", -1, &a->Message, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__UpgradeSystemFirmwareResponse * SOAP_FMAC4 soap_in__tds__UpgradeSystemFirmwareResponse(struct soap *soap, const char *tag, struct _tds__UpgradeSystemFirmwareResponse *a, const char *type)
{
	size_t soap_flag_Message = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__UpgradeSystemFirmwareResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__UpgradeSystemFirmwareResponse, sizeof(struct _tds__UpgradeSystemFirmwareResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__UpgradeSystemFirmwareResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Message && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "tds:Message", &a->Message, "xsd:string"))
				{	soap_flag_Message--;
					continue;
				}
			soap_check_result(soap, "tds:Message");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__UpgradeSystemFirmwareResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__UpgradeSystemFirmwareResponse, 0, sizeof(struct _tds__UpgradeSystemFirmwareResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__UpgradeSystemFirmwareResponse(struct soap *soap, const struct _tds__UpgradeSystemFirmwareResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__UpgradeSystemFirmwareResponse);
	if (soap_out__tds__UpgradeSystemFirmwareResponse(soap, tag?tag:"tds:UpgradeSystemFirmwareResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__UpgradeSystemFirmwareResponse * SOAP_FMAC4 soap_get__tds__UpgradeSystemFirmwareResponse(struct soap *soap, struct _tds__UpgradeSystemFirmwareResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__UpgradeSystemFirmwareResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__AttachmentData(struct soap *soap, struct tt__AttachmentData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->xop__Include = NULL;
	soap_default__xmime__contentType(soap, &a->xmime__contentType);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__AttachmentData(struct soap *soap, const struct tt__AttachmentData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToxop__Include(soap, &a->xop__Include);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AttachmentData(struct soap *soap, const char *tag, int id, const struct tt__AttachmentData *a, const char *type)
{
	if (a->xmime__contentType)
		soap_set_attr(soap, "xmime:contentType", a->xmime__contentType, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AttachmentData), type))
		return soap->error;
	if (a->xop__Include)
	{	if (soap_out_PointerToxop__Include(soap, "xop:Include", -1, &a->xop__Include, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "xop:Include"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__AttachmentData * SOAP_FMAC4 soap_in_tt__AttachmentData(struct soap *soap, const char *tag, struct tt__AttachmentData *a, const char *type)
{
	size_t soap_flag_xop__Include = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__AttachmentData *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AttachmentData, sizeof(struct tt__AttachmentData), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__AttachmentData(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "xmime:contentType", 0), &a->xmime__contentType, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_xop__Include && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxop__Include(soap, "xop:Include", &a->xop__Include, "xop:Include"))
				{	soap_flag_xop__Include--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__AttachmentData *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AttachmentData, 0, sizeof(struct tt__AttachmentData), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_xop__Include > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__AttachmentData(struct soap *soap, const struct tt__AttachmentData *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__AttachmentData);
	if (soap_out_tt__AttachmentData(soap, tag?tag:"tt:AttachmentData", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AttachmentData * SOAP_FMAC4 soap_get_tt__AttachmentData(struct soap *soap, struct tt__AttachmentData *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AttachmentData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__UpgradeSystemFirmware(struct soap *soap, struct _tds__UpgradeSystemFirmware *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Firmware = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__UpgradeSystemFirmware(struct soap *soap, const struct _tds__UpgradeSystemFirmware *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTott__AttachmentData(soap, &a->Firmware);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__UpgradeSystemFirmware(struct soap *soap, const char *tag, int id, const struct _tds__UpgradeSystemFirmware *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__UpgradeSystemFirmware), type))
		return soap->error;
	if (a->Firmware)
	{	if (soap_out_PointerTott__AttachmentData(soap, "tds:Firmware", -1, &a->Firmware, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tds:Firmware"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__UpgradeSystemFirmware * SOAP_FMAC4 soap_in__tds__UpgradeSystemFirmware(struct soap *soap, const char *tag, struct _tds__UpgradeSystemFirmware *a, const char *type)
{
	size_t soap_flag_Firmware = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__UpgradeSystemFirmware *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__UpgradeSystemFirmware, sizeof(struct _tds__UpgradeSystemFirmware), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__UpgradeSystemFirmware(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Firmware && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__AttachmentData(soap, "tds:Firmware", &a->Firmware, "tt:AttachmentData"))
				{	soap_flag_Firmware--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__UpgradeSystemFirmware *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__UpgradeSystemFirmware, 0, sizeof(struct _tds__UpgradeSystemFirmware), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Firmware > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__UpgradeSystemFirmware(struct soap *soap, const struct _tds__UpgradeSystemFirmware *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__UpgradeSystemFirmware);
	if (soap_out__tds__UpgradeSystemFirmware(soap, tag?tag:"tds:UpgradeSystemFirmware", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__UpgradeSystemFirmware * SOAP_FMAC4 soap_get__tds__UpgradeSystemFirmware(struct soap *soap, struct _tds__UpgradeSystemFirmware *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__UpgradeSystemFirmware(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__SetSystemFactoryDefaultResponse(struct soap *soap, struct _tds__SetSystemFactoryDefaultResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__SetSystemFactoryDefaultResponse(struct soap *soap, const struct _tds__SetSystemFactoryDefaultResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetSystemFactoryDefaultResponse(struct soap *soap, const char *tag, int id, const struct _tds__SetSystemFactoryDefaultResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetSystemFactoryDefaultResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__SetSystemFactoryDefaultResponse * SOAP_FMAC4 soap_in__tds__SetSystemFactoryDefaultResponse(struct soap *soap, const char *tag, struct _tds__SetSystemFactoryDefaultResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__SetSystemFactoryDefaultResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetSystemFactoryDefaultResponse, sizeof(struct _tds__SetSystemFactoryDefaultResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__SetSystemFactoryDefaultResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__SetSystemFactoryDefaultResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetSystemFactoryDefaultResponse, 0, sizeof(struct _tds__SetSystemFactoryDefaultResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__SetSystemFactoryDefaultResponse(struct soap *soap, const struct _tds__SetSystemFactoryDefaultResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__SetSystemFactoryDefaultResponse);
	if (soap_out__tds__SetSystemFactoryDefaultResponse(soap, tag?tag:"tds:SetSystemFactoryDefaultResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetSystemFactoryDefaultResponse * SOAP_FMAC4 soap_get__tds__SetSystemFactoryDefaultResponse(struct soap *soap, struct _tds__SetSystemFactoryDefaultResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetSystemFactoryDefaultResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__SetSystemFactoryDefault(struct soap *soap, struct _tds__SetSystemFactoryDefault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__FactoryDefaultType(soap, &a->FactoryDefault);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__SetSystemFactoryDefault(struct soap *soap, const struct _tds__SetSystemFactoryDefault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetSystemFactoryDefault(struct soap *soap, const char *tag, int id, const struct _tds__SetSystemFactoryDefault *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetSystemFactoryDefault), type))
		return soap->error;
	if (soap_out_tt__FactoryDefaultType(soap, "tds:FactoryDefault", -1, &a->FactoryDefault, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__SetSystemFactoryDefault * SOAP_FMAC4 soap_in__tds__SetSystemFactoryDefault(struct soap *soap, const char *tag, struct _tds__SetSystemFactoryDefault *a, const char *type)
{
	size_t soap_flag_FactoryDefault = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__SetSystemFactoryDefault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetSystemFactoryDefault, sizeof(struct _tds__SetSystemFactoryDefault), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__SetSystemFactoryDefault(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_FactoryDefault && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_tt__FactoryDefaultType(soap, "tds:FactoryDefault", &a->FactoryDefault, "tt:FactoryDefaultType"))
				{	soap_flag_FactoryDefault--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__SetSystemFactoryDefault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetSystemFactoryDefault, 0, sizeof(struct _tds__SetSystemFactoryDefault), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_FactoryDefault > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__SetSystemFactoryDefault(struct soap *soap, const struct _tds__SetSystemFactoryDefault *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__SetSystemFactoryDefault);
	if (soap_out__tds__SetSystemFactoryDefault(soap, tag?tag:"tds:SetSystemFactoryDefault", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetSystemFactoryDefault * SOAP_FMAC4 soap_get__tds__SetSystemFactoryDefault(struct soap *soap, struct _tds__SetSystemFactoryDefault *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetSystemFactoryDefault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__SystemDateTime(struct soap *soap, struct tt__SystemDateTime *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__SetDateTimeType(soap, &a->DateTimeType);
	soap_default_xsd__boolean_(soap, &a->DaylightSavings);
	a->TimeZone = NULL;
	a->UTCDateTime = NULL;
	a->LocalDateTime = NULL;
	a->Extension = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__SystemDateTime(struct soap *soap, const struct tt__SystemDateTime *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->DaylightSavings, SOAP_TYPE_xsd__boolean_);
	soap_serialize_PointerTott__TimeZone(soap, &a->TimeZone);
	soap_serialize_PointerTott__DateTime(soap, &a->UTCDateTime);
	soap_serialize_PointerTott__DateTime(soap, &a->LocalDateTime);
	soap_serialize_PointerTott__SystemDateTimeExtension(soap, &a->Extension);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__SystemDateTime(struct soap *soap, const char *tag, int id, const struct tt__SystemDateTime *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__SystemDateTime), type))
		return soap->error;
	if (soap_out_tt__SetDateTimeType(soap, "tt:DateTimeType", -1, &a->DateTimeType, ""))
		return soap->error;
	if (soap_out_xsd__boolean_(soap, "tt:DaylightSavings", -1, &a->DaylightSavings, ""))
		return soap->error;
	if (soap_out_PointerTott__TimeZone(soap, "tt:TimeZone", -1, &a->TimeZone, ""))
		return soap->error;
	if (soap_out_PointerTott__DateTime(soap, "tt:UTCDateTime", -1, &a->UTCDateTime, ""))
		return soap->error;
	if (soap_out_PointerTott__DateTime(soap, "tt:LocalDateTime", -1, &a->LocalDateTime, ""))
		return soap->error;
	if (soap_out_PointerTott__SystemDateTimeExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__SystemDateTime * SOAP_FMAC4 soap_in_tt__SystemDateTime(struct soap *soap, const char *tag, struct tt__SystemDateTime *a, const char *type)
{
	size_t soap_flag_DateTimeType = 1;
	size_t soap_flag_DaylightSavings = 1;
	size_t soap_flag_TimeZone = 1;
	size_t soap_flag_UTCDateTime = 1;
	size_t soap_flag_LocalDateTime = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__SystemDateTime *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__SystemDateTime, sizeof(struct tt__SystemDateTime), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__SystemDateTime(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_DateTimeType && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_tt__SetDateTimeType(soap, "tt:DateTimeType", &a->DateTimeType, "tt:SetDateTimeType"))
				{	soap_flag_DateTimeType--;
					continue;
				}
			if (soap_flag_DaylightSavings && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean_(soap, "tt:DaylightSavings", &a->DaylightSavings, "xsd:boolean"))
				{	soap_flag_DaylightSavings--;
					continue;
				}
			if (soap_flag_TimeZone && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__TimeZone(soap, "tt:TimeZone", &a->TimeZone, "tt:TimeZone"))
				{	soap_flag_TimeZone--;
					continue;
				}
			if (soap_flag_UTCDateTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__DateTime(soap, "tt:UTCDateTime", &a->UTCDateTime, "tt:DateTime"))
				{	soap_flag_UTCDateTime--;
					continue;
				}
			if (soap_flag_LocalDateTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__DateTime(soap, "tt:LocalDateTime", &a->LocalDateTime, "tt:DateTime"))
				{	soap_flag_LocalDateTime--;
					continue;
				}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__SystemDateTimeExtension(soap, "tt:Extension", &a->Extension, "tt:SystemDateTimeExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__SystemDateTime *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__SystemDateTime, 0, sizeof(struct tt__SystemDateTime), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_DateTimeType > 0 || soap_flag_DaylightSavings > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__SystemDateTime(struct soap *soap, const struct tt__SystemDateTime *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__SystemDateTime);
	if (soap_out_tt__SystemDateTime(soap, tag?tag:"tt:SystemDateTime", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__SystemDateTime * SOAP_FMAC4 soap_get_tt__SystemDateTime(struct soap *soap, struct tt__SystemDateTime *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__SystemDateTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetSystemDateAndTimeResponse(struct soap *soap, struct _tds__GetSystemDateAndTimeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->SystemDateAndTime = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetSystemDateAndTimeResponse(struct soap *soap, const struct _tds__GetSystemDateAndTimeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTott__SystemDateTime(soap, &a->SystemDateAndTime);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetSystemDateAndTimeResponse(struct soap *soap, const char *tag, int id, const struct _tds__GetSystemDateAndTimeResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetSystemDateAndTimeResponse), type))
		return soap->error;
	if (a->SystemDateAndTime)
		soap_element_result(soap, "tds:SystemDateAndTime");
	if (a->SystemDateAndTime)
	{	if (soap_out_PointerTott__SystemDateTime(soap, "tds:SystemDateAndTime", -1, &a->SystemDateAndTime, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tds:SystemDateAndTime"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetSystemDateAndTimeResponse * SOAP_FMAC4 soap_in__tds__GetSystemDateAndTimeResponse(struct soap *soap, const char *tag, struct _tds__GetSystemDateAndTimeResponse *a, const char *type)
{
	size_t soap_flag_SystemDateAndTime = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__GetSystemDateAndTimeResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetSystemDateAndTimeResponse, sizeof(struct _tds__GetSystemDateAndTimeResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetSystemDateAndTimeResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SystemDateAndTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__SystemDateTime(soap, "tds:SystemDateAndTime", &a->SystemDateAndTime, "tt:SystemDateTime"))
				{	soap_flag_SystemDateAndTime--;
					continue;
				}
			soap_check_result(soap, "tds:SystemDateAndTime");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__GetSystemDateAndTimeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetSystemDateAndTimeResponse, 0, sizeof(struct _tds__GetSystemDateAndTimeResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_SystemDateAndTime > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetSystemDateAndTimeResponse(struct soap *soap, const struct _tds__GetSystemDateAndTimeResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__GetSystemDateAndTimeResponse);
	if (soap_out__tds__GetSystemDateAndTimeResponse(soap, tag?tag:"tds:GetSystemDateAndTimeResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetSystemDateAndTimeResponse * SOAP_FMAC4 soap_get__tds__GetSystemDateAndTimeResponse(struct soap *soap, struct _tds__GetSystemDateAndTimeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetSystemDateAndTimeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetSystemDateAndTime(struct soap *soap, struct _tds__GetSystemDateAndTime *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetSystemDateAndTime(struct soap *soap, const struct _tds__GetSystemDateAndTime *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetSystemDateAndTime(struct soap *soap, const char *tag, int id, const struct _tds__GetSystemDateAndTime *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetSystemDateAndTime), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetSystemDateAndTime * SOAP_FMAC4 soap_in__tds__GetSystemDateAndTime(struct soap *soap, const char *tag, struct _tds__GetSystemDateAndTime *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__GetSystemDateAndTime *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetSystemDateAndTime, sizeof(struct _tds__GetSystemDateAndTime), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetSystemDateAndTime(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__GetSystemDateAndTime *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetSystemDateAndTime, 0, sizeof(struct _tds__GetSystemDateAndTime), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetSystemDateAndTime(struct soap *soap, const struct _tds__GetSystemDateAndTime *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__GetSystemDateAndTime);
	if (soap_out__tds__GetSystemDateAndTime(soap, tag?tag:"tds:GetSystemDateAndTime", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetSystemDateAndTime * SOAP_FMAC4 soap_get__tds__GetSystemDateAndTime(struct soap *soap, struct _tds__GetSystemDateAndTime *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetSystemDateAndTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__SetSystemDateAndTimeResponse(struct soap *soap, struct _tds__SetSystemDateAndTimeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__SetSystemDateAndTimeResponse(struct soap *soap, const struct _tds__SetSystemDateAndTimeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetSystemDateAndTimeResponse(struct soap *soap, const char *tag, int id, const struct _tds__SetSystemDateAndTimeResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetSystemDateAndTimeResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__SetSystemDateAndTimeResponse * SOAP_FMAC4 soap_in__tds__SetSystemDateAndTimeResponse(struct soap *soap, const char *tag, struct _tds__SetSystemDateAndTimeResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__SetSystemDateAndTimeResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetSystemDateAndTimeResponse, sizeof(struct _tds__SetSystemDateAndTimeResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__SetSystemDateAndTimeResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__SetSystemDateAndTimeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetSystemDateAndTimeResponse, 0, sizeof(struct _tds__SetSystemDateAndTimeResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__SetSystemDateAndTimeResponse(struct soap *soap, const struct _tds__SetSystemDateAndTimeResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__SetSystemDateAndTimeResponse);
	if (soap_out__tds__SetSystemDateAndTimeResponse(soap, tag?tag:"tds:SetSystemDateAndTimeResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetSystemDateAndTimeResponse * SOAP_FMAC4 soap_get__tds__SetSystemDateAndTimeResponse(struct soap *soap, struct _tds__SetSystemDateAndTimeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetSystemDateAndTimeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__DateTime(struct soap *soap, struct tt__DateTime *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Time = NULL;
	a->Date = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__DateTime(struct soap *soap, const struct tt__DateTime *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTott__Time(soap, &a->Time);
	soap_serialize_PointerTott__Date(soap, &a->Date);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__DateTime(struct soap *soap, const char *tag, int id, const struct tt__DateTime *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__DateTime), type))
		return soap->error;
	if (a->Time)
	{	if (soap_out_PointerTott__Time(soap, "tt:Time", -1, &a->Time, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:Time"))
		return soap->error;
	if (a->Date)
	{	if (soap_out_PointerTott__Date(soap, "tt:Date", -1, &a->Date, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:Date"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__DateTime * SOAP_FMAC4 soap_in_tt__DateTime(struct soap *soap, const char *tag, struct tt__DateTime *a, const char *type)
{
	size_t soap_flag_Time = 1;
	size_t soap_flag_Date = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__DateTime *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__DateTime, sizeof(struct tt__DateTime), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__DateTime(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Time && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__Time(soap, "tt:Time", &a->Time, "tt:Time"))
				{	soap_flag_Time--;
					continue;
				}
			if (soap_flag_Date && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__Date(soap, "tt:Date", &a->Date, "tt:Date"))
				{	soap_flag_Date--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__DateTime *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__DateTime, 0, sizeof(struct tt__DateTime), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Time > 0 || soap_flag_Date > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__DateTime(struct soap *soap, const struct tt__DateTime *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__DateTime);
	if (soap_out_tt__DateTime(soap, tag?tag:"tt:DateTime", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__DateTime * SOAP_FMAC4 soap_get_tt__DateTime(struct soap *soap, struct tt__DateTime *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__DateTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__TimeZone(struct soap *soap, struct tt__TimeZone *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__token(soap, &a->TZ);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__TimeZone(struct soap *soap, const struct tt__TimeZone *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_xsd__token(soap, &a->TZ);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__TimeZone(struct soap *soap, const char *tag, int id, const struct tt__TimeZone *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__TimeZone), type))
		return soap->error;
	if (a->TZ)
	{	if (soap_out_xsd__token(soap, "tt:TZ", -1, &a->TZ, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:TZ"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__TimeZone * SOAP_FMAC4 soap_in_tt__TimeZone(struct soap *soap, const char *tag, struct tt__TimeZone *a, const char *type)
{
	size_t soap_flag_TZ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__TimeZone *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__TimeZone, sizeof(struct tt__TimeZone), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__TimeZone(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_TZ && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__token(soap, "tt:TZ", &a->TZ, "xsd:token"))
				{	soap_flag_TZ--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__TimeZone *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__TimeZone, 0, sizeof(struct tt__TimeZone), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_TZ > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__TimeZone(struct soap *soap, const struct tt__TimeZone *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__TimeZone);
	if (soap_out_tt__TimeZone(soap, tag?tag:"tt:TimeZone", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__TimeZone * SOAP_FMAC4 soap_get_tt__TimeZone(struct soap *soap, struct tt__TimeZone *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__TimeZone(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__SetSystemDateAndTime(struct soap *soap, struct _tds__SetSystemDateAndTime *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__SetDateTimeType(soap, &a->DateTimeType);
	soap_default_xsd__boolean_(soap, &a->DaylightSavings);
	a->TimeZone = NULL;
	a->UTCDateTime = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__SetSystemDateAndTime(struct soap *soap, const struct _tds__SetSystemDateAndTime *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->DaylightSavings, SOAP_TYPE_xsd__boolean_);
	soap_serialize_PointerTott__TimeZone(soap, &a->TimeZone);
	soap_serialize_PointerTott__DateTime(soap, &a->UTCDateTime);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetSystemDateAndTime(struct soap *soap, const char *tag, int id, const struct _tds__SetSystemDateAndTime *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetSystemDateAndTime), type))
		return soap->error;
	if (soap_out_tt__SetDateTimeType(soap, "tds:DateTimeType", -1, &a->DateTimeType, ""))
		return soap->error;
	if (soap_out_xsd__boolean_(soap, "tds:DaylightSavings", -1, &a->DaylightSavings, ""))
		return soap->error;
	if (soap_out_PointerTott__TimeZone(soap, "tds:TimeZone", -1, &a->TimeZone, ""))
		return soap->error;
	if (soap_out_PointerTott__DateTime(soap, "tds:UTCDateTime", -1, &a->UTCDateTime, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__SetSystemDateAndTime * SOAP_FMAC4 soap_in__tds__SetSystemDateAndTime(struct soap *soap, const char *tag, struct _tds__SetSystemDateAndTime *a, const char *type)
{
	size_t soap_flag_DateTimeType = 1;
	size_t soap_flag_DaylightSavings = 1;
	size_t soap_flag_TimeZone = 1;
	size_t soap_flag_UTCDateTime = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__SetSystemDateAndTime *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetSystemDateAndTime, sizeof(struct _tds__SetSystemDateAndTime), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__SetSystemDateAndTime(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_DateTimeType && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_tt__SetDateTimeType(soap, "tds:DateTimeType", &a->DateTimeType, "tt:SetDateTimeType"))
				{	soap_flag_DateTimeType--;
					continue;
				}
			if (soap_flag_DaylightSavings && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean_(soap, "tds:DaylightSavings", &a->DaylightSavings, "xsd:boolean"))
				{	soap_flag_DaylightSavings--;
					continue;
				}
			if (soap_flag_TimeZone && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__TimeZone(soap, "tds:TimeZone", &a->TimeZone, "tt:TimeZone"))
				{	soap_flag_TimeZone--;
					continue;
				}
			if (soap_flag_UTCDateTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__DateTime(soap, "tds:UTCDateTime", &a->UTCDateTime, "tt:DateTime"))
				{	soap_flag_UTCDateTime--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__SetSystemDateAndTime *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetSystemDateAndTime, 0, sizeof(struct _tds__SetSystemDateAndTime), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_DateTimeType > 0 || soap_flag_DaylightSavings > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__SetSystemDateAndTime(struct soap *soap, const struct _tds__SetSystemDateAndTime *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__SetSystemDateAndTime);
	if (soap_out__tds__SetSystemDateAndTime(soap, tag?tag:"tds:SetSystemDateAndTime", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetSystemDateAndTime * SOAP_FMAC4 soap_get__tds__SetSystemDateAndTime(struct soap *soap, struct _tds__SetSystemDateAndTime *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetSystemDateAndTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetDeviceInformationResponse(struct soap *soap, struct _tds__GetDeviceInformationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Manufacturer);
	soap_default_string(soap, &a->Model);
	soap_default_string(soap, &a->FirmwareVersion);
	soap_default_string(soap, &a->SerialNumber);
	soap_default_string(soap, &a->HardwareId);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetDeviceInformationResponse(struct soap *soap, const struct _tds__GetDeviceInformationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Manufacturer);
	soap_serialize_string(soap, &a->Model);
	soap_serialize_string(soap, &a->FirmwareVersion);
	soap_serialize_string(soap, &a->SerialNumber);
	soap_serialize_string(soap, &a->HardwareId);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetDeviceInformationResponse(struct soap *soap, const char *tag, int id, const struct _tds__GetDeviceInformationResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetDeviceInformationResponse), type))
		return soap->error;
	if (a->Manufacturer)
		soap_element_result(soap, "tds:Manufacturer");
	if (a->Manufacturer)
	{	if (soap_out_string(soap, "tds:Manufacturer", -1, &a->Manufacturer, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tds:Manufacturer"))
		return soap->error;
	if (a->Model)
	{	if (soap_out_string(soap, "tds:Model", -1, &a->Model, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tds:Model"))
		return soap->error;
	if (a->FirmwareVersion)
	{	if (soap_out_string(soap, "tds:FirmwareVersion", -1, &a->FirmwareVersion, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tds:FirmwareVersion"))
		return soap->error;
	if (a->SerialNumber)
	{	if (soap_out_string(soap, "tds:SerialNumber", -1, &a->SerialNumber, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tds:SerialNumber"))
		return soap->error;
	if (a->HardwareId)
	{	if (soap_out_string(soap, "tds:HardwareId", -1, &a->HardwareId, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tds:HardwareId"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetDeviceInformationResponse * SOAP_FMAC4 soap_in__tds__GetDeviceInformationResponse(struct soap *soap, const char *tag, struct _tds__GetDeviceInformationResponse *a, const char *type)
{
	size_t soap_flag_Manufacturer = 1;
	size_t soap_flag_Model = 1;
	size_t soap_flag_FirmwareVersion = 1;
	size_t soap_flag_SerialNumber = 1;
	size_t soap_flag_HardwareId = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__GetDeviceInformationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetDeviceInformationResponse, sizeof(struct _tds__GetDeviceInformationResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetDeviceInformationResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Manufacturer && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "tds:Manufacturer", &a->Manufacturer, "xsd:string"))
				{	soap_flag_Manufacturer--;
					continue;
				}
			if (soap_flag_Model && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "tds:Model", &a->Model, "xsd:string"))
				{	soap_flag_Model--;
					continue;
				}
			if (soap_flag_FirmwareVersion && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "tds:FirmwareVersion", &a->FirmwareVersion, "xsd:string"))
				{	soap_flag_FirmwareVersion--;
					continue;
				}
			if (soap_flag_SerialNumber && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "tds:SerialNumber", &a->SerialNumber, "xsd:string"))
				{	soap_flag_SerialNumber--;
					continue;
				}
			if (soap_flag_HardwareId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "tds:HardwareId", &a->HardwareId, "xsd:string"))
				{	soap_flag_HardwareId--;
					continue;
				}
			soap_check_result(soap, "tds:Manufacturer");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__GetDeviceInformationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetDeviceInformationResponse, 0, sizeof(struct _tds__GetDeviceInformationResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Manufacturer > 0 || soap_flag_Model > 0 || soap_flag_FirmwareVersion > 0 || soap_flag_SerialNumber > 0 || soap_flag_HardwareId > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetDeviceInformationResponse(struct soap *soap, const struct _tds__GetDeviceInformationResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__GetDeviceInformationResponse);
	if (soap_out__tds__GetDeviceInformationResponse(soap, tag?tag:"tds:GetDeviceInformationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetDeviceInformationResponse * SOAP_FMAC4 soap_get__tds__GetDeviceInformationResponse(struct soap *soap, struct _tds__GetDeviceInformationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetDeviceInformationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetDeviceInformation(struct soap *soap, struct _tds__GetDeviceInformation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetDeviceInformation(struct soap *soap, const struct _tds__GetDeviceInformation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetDeviceInformation(struct soap *soap, const char *tag, int id, const struct _tds__GetDeviceInformation *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetDeviceInformation), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetDeviceInformation * SOAP_FMAC4 soap_in__tds__GetDeviceInformation(struct soap *soap, const char *tag, struct _tds__GetDeviceInformation *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__GetDeviceInformation *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetDeviceInformation, sizeof(struct _tds__GetDeviceInformation), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetDeviceInformation(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__GetDeviceInformation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetDeviceInformation, 0, sizeof(struct _tds__GetDeviceInformation), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetDeviceInformation(struct soap *soap, const struct _tds__GetDeviceInformation *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__GetDeviceInformation);
	if (soap_out__tds__GetDeviceInformation(soap, tag?tag:"tds:GetDeviceInformation", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetDeviceInformation * SOAP_FMAC4 soap_get__tds__GetDeviceInformation(struct soap *soap, struct _tds__GetDeviceInformation *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetDeviceInformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetServiceCapabilitiesResponse(struct soap *soap, struct _tds__GetServiceCapabilitiesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Capabilities = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetServiceCapabilitiesResponse(struct soap *soap, const struct _tds__GetServiceCapabilitiesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTotds__DeviceServiceCapabilities(soap, &a->Capabilities);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetServiceCapabilitiesResponse(struct soap *soap, const char *tag, int id, const struct _tds__GetServiceCapabilitiesResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetServiceCapabilitiesResponse), type))
		return soap->error;
	if (a->Capabilities)
		soap_element_result(soap, "tds:Capabilities");
	if (a->Capabilities)
	{	if (soap_out_PointerTotds__DeviceServiceCapabilities(soap, "tds:Capabilities", -1, &a->Capabilities, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tds:Capabilities"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetServiceCapabilitiesResponse * SOAP_FMAC4 soap_in__tds__GetServiceCapabilitiesResponse(struct soap *soap, const char *tag, struct _tds__GetServiceCapabilitiesResponse *a, const char *type)
{
	size_t soap_flag_Capabilities = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__GetServiceCapabilitiesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetServiceCapabilitiesResponse, sizeof(struct _tds__GetServiceCapabilitiesResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetServiceCapabilitiesResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Capabilities && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotds__DeviceServiceCapabilities(soap, "tds:Capabilities", &a->Capabilities, "tds:DeviceServiceCapabilities"))
				{	soap_flag_Capabilities--;
					continue;
				}
			soap_check_result(soap, "tds:Capabilities");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__GetServiceCapabilitiesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetServiceCapabilitiesResponse, 0, sizeof(struct _tds__GetServiceCapabilitiesResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Capabilities > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetServiceCapabilitiesResponse(struct soap *soap, const struct _tds__GetServiceCapabilitiesResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__GetServiceCapabilitiesResponse);
	if (soap_out__tds__GetServiceCapabilitiesResponse(soap, tag?tag:"tds:GetServiceCapabilitiesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetServiceCapabilitiesResponse * SOAP_FMAC4 soap_get__tds__GetServiceCapabilitiesResponse(struct soap *soap, struct _tds__GetServiceCapabilitiesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetServiceCapabilitiesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetServiceCapabilities(struct soap *soap, struct _tds__GetServiceCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetServiceCapabilities(struct soap *soap, const struct _tds__GetServiceCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetServiceCapabilities(struct soap *soap, const char *tag, int id, const struct _tds__GetServiceCapabilities *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetServiceCapabilities), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetServiceCapabilities * SOAP_FMAC4 soap_in__tds__GetServiceCapabilities(struct soap *soap, const char *tag, struct _tds__GetServiceCapabilities *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__GetServiceCapabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetServiceCapabilities, sizeof(struct _tds__GetServiceCapabilities), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetServiceCapabilities(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__GetServiceCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetServiceCapabilities, 0, sizeof(struct _tds__GetServiceCapabilities), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetServiceCapabilities(struct soap *soap, const struct _tds__GetServiceCapabilities *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__GetServiceCapabilities);
	if (soap_out__tds__GetServiceCapabilities(soap, tag?tag:"tds:GetServiceCapabilities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetServiceCapabilities * SOAP_FMAC4 soap_get__tds__GetServiceCapabilities(struct soap *soap, struct _tds__GetServiceCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetServiceCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetServicesResponse(struct soap *soap, struct _tds__GetServicesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeService = 0;
	a->Service = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetServicesResponse(struct soap *soap, const struct _tds__GetServicesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->Service)
	{	int i;
		for (i = 0; i < a->__sizeService; i++)
		{
			soap_embedded(soap, a->Service + i, SOAP_TYPE_tds__Service);
			soap_serialize_tds__Service(soap, a->Service + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetServicesResponse(struct soap *soap, const char *tag, int id, const struct _tds__GetServicesResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetServicesResponse), type))
		return soap->error;
	soap_element_result(soap, "-sizeService");
	if (a->Service)
	{	int i;
		for (i = 0; i < a->__sizeService; i++)
			if (soap_out_tds__Service(soap, "tds:Service", -1, a->Service + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetServicesResponse * SOAP_FMAC4 soap_in__tds__GetServicesResponse(struct soap *soap, const char *tag, struct _tds__GetServicesResponse *a, const char *type)
{
	struct soap_blist *soap_blist_Service = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__GetServicesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetServicesResponse, sizeof(struct _tds__GetServicesResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetServicesResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tds:Service", 1, NULL))
			{	if (a->Service == NULL)
				{	if (soap_blist_Service == NULL)
						soap_blist_Service = soap_new_block(soap);
					a->Service = (struct tds__Service *)soap_push_block(soap, soap_blist_Service, sizeof(struct tds__Service));
					if (a->Service == NULL)
						return NULL;
					soap_default_tds__Service(soap, a->Service);
				}
				soap_revert(soap);
				if (soap_in_tds__Service(soap, "tds:Service", a->Service, "tds:Service"))
				{	a->__sizeService++;
					a->Service = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizeService");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Service)
			soap_pop_block(soap, soap_blist_Service);
		if (a->__sizeService)
			a->Service = (struct tds__Service *)soap_save_block(soap, soap_blist_Service, NULL, 1);
		else
		{	a->Service = NULL;
			if (soap_blist_Service)
				soap_end_block(soap, soap_blist_Service);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__GetServicesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetServicesResponse, 0, sizeof(struct _tds__GetServicesResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeService < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetServicesResponse(struct soap *soap, const struct _tds__GetServicesResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__GetServicesResponse);
	if (soap_out__tds__GetServicesResponse(soap, tag?tag:"tds:GetServicesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetServicesResponse * SOAP_FMAC4 soap_get__tds__GetServicesResponse(struct soap *soap, struct _tds__GetServicesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetServicesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetServices(struct soap *soap, struct _tds__GetServices *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__boolean_(soap, &a->IncludeCapability);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetServices(struct soap *soap, const struct _tds__GetServices *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->IncludeCapability, SOAP_TYPE_xsd__boolean_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetServices(struct soap *soap, const char *tag, int id, const struct _tds__GetServices *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetServices), type))
		return soap->error;
	if (soap_out_xsd__boolean_(soap, "tds:IncludeCapability", -1, &a->IncludeCapability, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetServices * SOAP_FMAC4 soap_in__tds__GetServices(struct soap *soap, const char *tag, struct _tds__GetServices *a, const char *type)
{
	size_t soap_flag_IncludeCapability = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__GetServices *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetServices, sizeof(struct _tds__GetServices), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetServices(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_IncludeCapability && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean_(soap, "tds:IncludeCapability", &a->IncludeCapability, "xsd:boolean"))
				{	soap_flag_IncludeCapability--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__GetServices *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetServices, 0, sizeof(struct _tds__GetServices), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_IncludeCapability > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetServices(struct soap *soap, const struct _tds__GetServices *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__GetServices);
	if (soap_out__tds__GetServices(soap, tag?tag:"tds:GetServices", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetServices * SOAP_FMAC4 soap_get__tds__GetServices(struct soap *soap, struct _tds__GetServices *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetServices(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tds__SystemCapabilities(struct soap *soap, struct tds__SystemCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->DiscoveryResolve = NULL;
	a->DiscoveryBye = NULL;
	a->RemoteDiscovery = NULL;
	a->SystemBackup = NULL;
	a->SystemLogging = NULL;
	a->FirmwareUpgrade = NULL;
	a->HttpFirmwareUpgrade = NULL;
	a->HttpSystemBackup = NULL;
	a->HttpSystemLogging = NULL;
	a->HttpSupportInformation = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tds__SystemCapabilities(struct soap *soap, const struct tds__SystemCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tds__SystemCapabilities(struct soap *soap, const char *tag, int id, const struct tds__SystemCapabilities *a, const char *type)
{
	if (a->DiscoveryResolve)
		soap_set_attr(soap, "DiscoveryResolve", soap_xsd__boolean_2s(soap, *a->DiscoveryResolve), 1);
	if (a->DiscoveryBye)
		soap_set_attr(soap, "DiscoveryBye", soap_xsd__boolean_2s(soap, *a->DiscoveryBye), 1);
	if (a->RemoteDiscovery)
		soap_set_attr(soap, "RemoteDiscovery", soap_xsd__boolean_2s(soap, *a->RemoteDiscovery), 1);
	if (a->SystemBackup)
		soap_set_attr(soap, "SystemBackup", soap_xsd__boolean_2s(soap, *a->SystemBackup), 1);
	if (a->SystemLogging)
		soap_set_attr(soap, "SystemLogging", soap_xsd__boolean_2s(soap, *a->SystemLogging), 1);
	if (a->FirmwareUpgrade)
		soap_set_attr(soap, "FirmwareUpgrade", soap_xsd__boolean_2s(soap, *a->FirmwareUpgrade), 1);
	if (a->HttpFirmwareUpgrade)
		soap_set_attr(soap, "HttpFirmwareUpgrade", soap_xsd__boolean_2s(soap, *a->HttpFirmwareUpgrade), 1);
	if (a->HttpSystemBackup)
		soap_set_attr(soap, "HttpSystemBackup", soap_xsd__boolean_2s(soap, *a->HttpSystemBackup), 1);
	if (a->HttpSystemLogging)
		soap_set_attr(soap, "HttpSystemLogging", soap_xsd__boolean_2s(soap, *a->HttpSystemLogging), 1);
	if (a->HttpSupportInformation)
		soap_set_attr(soap, "HttpSupportInformation", soap_xsd__boolean_2s(soap, *a->HttpSupportInformation), 1);
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tds__SystemCapabilities), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tds__SystemCapabilities * SOAP_FMAC4 soap_in_tds__SystemCapabilities(struct soap *soap, const char *tag, struct tds__SystemCapabilities *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tds__SystemCapabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tds__SystemCapabilities, sizeof(struct tds__SystemCapabilities), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tds__SystemCapabilities(soap, a);
	{	const char *t = soap_attr_value(soap, "DiscoveryResolve", 0);
		if (t)
		{
			if (!(a->DiscoveryResolve = (enum xsd__boolean_ *)soap_malloc(soap, sizeof(enum xsd__boolean_))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean_(soap, t, a->DiscoveryResolve))
			return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "DiscoveryBye", 0);
		if (t)
		{
			if (!(a->DiscoveryBye = (enum xsd__boolean_ *)soap_malloc(soap, sizeof(enum xsd__boolean_))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean_(soap, t, a->DiscoveryBye))
			return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "RemoteDiscovery", 0);
		if (t)
		{
			if (!(a->RemoteDiscovery = (enum xsd__boolean_ *)soap_malloc(soap, sizeof(enum xsd__boolean_))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean_(soap, t, a->RemoteDiscovery))
			return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "SystemBackup", 0);
		if (t)
		{
			if (!(a->SystemBackup = (enum xsd__boolean_ *)soap_malloc(soap, sizeof(enum xsd__boolean_))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean_(soap, t, a->SystemBackup))
			return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "SystemLogging", 0);
		if (t)
		{
			if (!(a->SystemLogging = (enum xsd__boolean_ *)soap_malloc(soap, sizeof(enum xsd__boolean_))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean_(soap, t, a->SystemLogging))
			return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "FirmwareUpgrade", 0);
		if (t)
		{
			if (!(a->FirmwareUpgrade = (enum xsd__boolean_ *)soap_malloc(soap, sizeof(enum xsd__boolean_))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean_(soap, t, a->FirmwareUpgrade))
			return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "HttpFirmwareUpgrade", 0);
		if (t)
		{
			if (!(a->HttpFirmwareUpgrade = (enum xsd__boolean_ *)soap_malloc(soap, sizeof(enum xsd__boolean_))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean_(soap, t, a->HttpFirmwareUpgrade))
			return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "HttpSystemBackup", 0);
		if (t)
		{
			if (!(a->HttpSystemBackup = (enum xsd__boolean_ *)soap_malloc(soap, sizeof(enum xsd__boolean_))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean_(soap, t, a->HttpSystemBackup))
			return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "HttpSystemLogging", 0);
		if (t)
		{
			if (!(a->HttpSystemLogging = (enum xsd__boolean_ *)soap_malloc(soap, sizeof(enum xsd__boolean_))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean_(soap, t, a->HttpSystemLogging))
			return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "HttpSupportInformation", 0);
		if (t)
		{
			if (!(a->HttpSupportInformation = (enum xsd__boolean_ *)soap_malloc(soap, sizeof(enum xsd__boolean_))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean_(soap, t, a->HttpSupportInformation))
			return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tds__SystemCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tds__SystemCapabilities, 0, sizeof(struct tds__SystemCapabilities), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tds__SystemCapabilities(struct soap *soap, const struct tds__SystemCapabilities *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tds__SystemCapabilities);
	if (soap_out_tds__SystemCapabilities(soap, tag?tag:"tds:SystemCapabilities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tds__SystemCapabilities * SOAP_FMAC4 soap_get_tds__SystemCapabilities(struct soap *soap, struct tds__SystemCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_tds__SystemCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tds__SecurityCapabilities(struct soap *soap, struct tds__SecurityCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->TLS1_x002e0 = NULL;
	a->TLS1_x002e1 = NULL;
	a->TLS1_x002e2 = NULL;
	a->OnboardKeyGeneration = NULL;
	a->AccessPolicyConfig = NULL;
	a->Dot1X = NULL;
	a->RemoteUserHandling = NULL;
	a->X_x002e509Token = NULL;
	a->SAMLToken = NULL;
	a->KerberosToken = NULL;
	a->UsernameToken = NULL;
	a->HttpDigest = NULL;
	a->RELToken = NULL;
	soap_default_tds__EAPMethodTypes(soap, &a->SupportedEAPMethods);
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tds__SecurityCapabilities(struct soap *soap, const struct tds__SecurityCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tds__SecurityCapabilities(struct soap *soap, const char *tag, int id, const struct tds__SecurityCapabilities *a, const char *type)
{
	if (a->TLS1_x002e0)
		soap_set_attr(soap, "TLS1.0", soap_xsd__boolean_2s(soap, *a->TLS1_x002e0), 1);
	if (a->TLS1_x002e1)
		soap_set_attr(soap, "TLS1.1", soap_xsd__boolean_2s(soap, *a->TLS1_x002e1), 1);
	if (a->TLS1_x002e2)
		soap_set_attr(soap, "TLS1.2", soap_xsd__boolean_2s(soap, *a->TLS1_x002e2), 1);
	if (a->OnboardKeyGeneration)
		soap_set_attr(soap, "OnboardKeyGeneration", soap_xsd__boolean_2s(soap, *a->OnboardKeyGeneration), 1);
	if (a->AccessPolicyConfig)
		soap_set_attr(soap, "AccessPolicyConfig", soap_xsd__boolean_2s(soap, *a->AccessPolicyConfig), 1);
	if (a->Dot1X)
		soap_set_attr(soap, "Dot1X", soap_xsd__boolean_2s(soap, *a->Dot1X), 1);
	if (a->RemoteUserHandling)
		soap_set_attr(soap, "RemoteUserHandling", soap_xsd__boolean_2s(soap, *a->RemoteUserHandling), 1);
	if (a->X_x002e509Token)
		soap_set_attr(soap, "X.509Token", soap_xsd__boolean_2s(soap, *a->X_x002e509Token), 1);
	if (a->SAMLToken)
		soap_set_attr(soap, "SAMLToken", soap_xsd__boolean_2s(soap, *a->SAMLToken), 1);
	if (a->KerberosToken)
		soap_set_attr(soap, "KerberosToken", soap_xsd__boolean_2s(soap, *a->KerberosToken), 1);
	if (a->UsernameToken)
		soap_set_attr(soap, "UsernameToken", soap_xsd__boolean_2s(soap, *a->UsernameToken), 1);
	if (a->HttpDigest)
		soap_set_attr(soap, "HttpDigest", soap_xsd__boolean_2s(soap, *a->HttpDigest), 1);
	if (a->RELToken)
		soap_set_attr(soap, "RELToken", soap_xsd__boolean_2s(soap, *a->RELToken), 1);
	if (a->SupportedEAPMethods)
		soap_set_attr(soap, "SupportedEAPMethods", a->SupportedEAPMethods, 1);
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tds__SecurityCapabilities), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tds__SecurityCapabilities * SOAP_FMAC4 soap_in_tds__SecurityCapabilities(struct soap *soap, const char *tag, struct tds__SecurityCapabilities *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tds__SecurityCapabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tds__SecurityCapabilities, sizeof(struct tds__SecurityCapabilities), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tds__SecurityCapabilities(soap, a);
	{	const char *t = soap_attr_value(soap, "TLS1.0", 0);
		if (t)
		{
			if (!(a->TLS1_x002e0 = (enum xsd__boolean_ *)soap_malloc(soap, sizeof(enum xsd__boolean_))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean_(soap, t, a->TLS1_x002e0))
			return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "TLS1.1", 0);
		if (t)
		{
			if (!(a->TLS1_x002e1 = (enum xsd__boolean_ *)soap_malloc(soap, sizeof(enum xsd__boolean_))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean_(soap, t, a->TLS1_x002e1))
			return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "TLS1.2", 0);
		if (t)
		{
			if (!(a->TLS1_x002e2 = (enum xsd__boolean_ *)soap_malloc(soap, sizeof(enum xsd__boolean_))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean_(soap, t, a->TLS1_x002e2))
			return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "OnboardKeyGeneration", 0);
		if (t)
		{
			if (!(a->OnboardKeyGeneration = (enum xsd__boolean_ *)soap_malloc(soap, sizeof(enum xsd__boolean_))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean_(soap, t, a->OnboardKeyGeneration))
			return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "AccessPolicyConfig", 0);
		if (t)
		{
			if (!(a->AccessPolicyConfig = (enum xsd__boolean_ *)soap_malloc(soap, sizeof(enum xsd__boolean_))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean_(soap, t, a->AccessPolicyConfig))
			return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "Dot1X", 0);
		if (t)
		{
			if (!(a->Dot1X = (enum xsd__boolean_ *)soap_malloc(soap, sizeof(enum xsd__boolean_))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean_(soap, t, a->Dot1X))
			return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "RemoteUserHandling", 0);
		if (t)
		{
			if (!(a->RemoteUserHandling = (enum xsd__boolean_ *)soap_malloc(soap, sizeof(enum xsd__boolean_))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean_(soap, t, a->RemoteUserHandling))
			return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "X.509Token", 0);
		if (t)
		{
			if (!(a->X_x002e509Token = (enum xsd__boolean_ *)soap_malloc(soap, sizeof(enum xsd__boolean_))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean_(soap, t, a->X_x002e509Token))
			return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "SAMLToken", 0);
		if (t)
		{
			if (!(a->SAMLToken = (enum xsd__boolean_ *)soap_malloc(soap, sizeof(enum xsd__boolean_))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean_(soap, t, a->SAMLToken))
			return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "KerberosToken", 0);
		if (t)
		{
			if (!(a->KerberosToken = (enum xsd__boolean_ *)soap_malloc(soap, sizeof(enum xsd__boolean_))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean_(soap, t, a->KerberosToken))
			return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "UsernameToken", 0);
		if (t)
		{
			if (!(a->UsernameToken = (enum xsd__boolean_ *)soap_malloc(soap, sizeof(enum xsd__boolean_))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean_(soap, t, a->UsernameToken))
			return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "HttpDigest", 0);
		if (t)
		{
			if (!(a->HttpDigest = (enum xsd__boolean_ *)soap_malloc(soap, sizeof(enum xsd__boolean_))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean_(soap, t, a->HttpDigest))
			return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "RELToken", 0);
		if (t)
		{
			if (!(a->RELToken = (enum xsd__boolean_ *)soap_malloc(soap, sizeof(enum xsd__boolean_))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean_(soap, t, a->RELToken))
			return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2string(soap, soap_attr_value(soap, "SupportedEAPMethods", 0), &a->SupportedEAPMethods, -1, -1))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tds__SecurityCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tds__SecurityCapabilities, 0, sizeof(struct tds__SecurityCapabilities), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tds__SecurityCapabilities(struct soap *soap, const struct tds__SecurityCapabilities *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tds__SecurityCapabilities);
	if (soap_out_tds__SecurityCapabilities(soap, tag?tag:"tds:SecurityCapabilities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tds__SecurityCapabilities * SOAP_FMAC4 soap_get_tds__SecurityCapabilities(struct soap *soap, struct tds__SecurityCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_tds__SecurityCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tds__NetworkCapabilities(struct soap *soap, struct tds__NetworkCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->IPFilter = NULL;
	a->ZeroConfiguration = NULL;
	a->IPVersion6 = NULL;
	a->DynDNS = NULL;
	a->Dot11Configuration = NULL;
	a->HostnameFromDHCP = NULL;
	a->NTP = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tds__NetworkCapabilities(struct soap *soap, const struct tds__NetworkCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tds__NetworkCapabilities(struct soap *soap, const char *tag, int id, const struct tds__NetworkCapabilities *a, const char *type)
{
	if (a->IPFilter)
		soap_set_attr(soap, "IPFilter", soap_xsd__boolean_2s(soap, *a->IPFilter), 1);
	if (a->ZeroConfiguration)
		soap_set_attr(soap, "ZeroConfiguration", soap_xsd__boolean_2s(soap, *a->ZeroConfiguration), 1);
	if (a->IPVersion6)
		soap_set_attr(soap, "IPVersion6", soap_xsd__boolean_2s(soap, *a->IPVersion6), 1);
	if (a->DynDNS)
		soap_set_attr(soap, "DynDNS", soap_xsd__boolean_2s(soap, *a->DynDNS), 1);
	if (a->Dot11Configuration)
		soap_set_attr(soap, "Dot11Configuration", soap_xsd__boolean_2s(soap, *a->Dot11Configuration), 1);
	if (a->HostnameFromDHCP)
		soap_set_attr(soap, "HostnameFromDHCP", soap_xsd__boolean_2s(soap, *a->HostnameFromDHCP), 1);
	if (a->NTP)
		soap_set_attr(soap, "NTP", soap_int2s(soap, *a->NTP), 1);
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tds__NetworkCapabilities), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tds__NetworkCapabilities * SOAP_FMAC4 soap_in_tds__NetworkCapabilities(struct soap *soap, const char *tag, struct tds__NetworkCapabilities *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tds__NetworkCapabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tds__NetworkCapabilities, sizeof(struct tds__NetworkCapabilities), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tds__NetworkCapabilities(soap, a);
	{	const char *t = soap_attr_value(soap, "IPFilter", 0);
		if (t)
		{
			if (!(a->IPFilter = (enum xsd__boolean_ *)soap_malloc(soap, sizeof(enum xsd__boolean_))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean_(soap, t, a->IPFilter))
			return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "ZeroConfiguration", 0);
		if (t)
		{
			if (!(a->ZeroConfiguration = (enum xsd__boolean_ *)soap_malloc(soap, sizeof(enum xsd__boolean_))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean_(soap, t, a->ZeroConfiguration))
			return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "IPVersion6", 0);
		if (t)
		{
			if (!(a->IPVersion6 = (enum xsd__boolean_ *)soap_malloc(soap, sizeof(enum xsd__boolean_))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean_(soap, t, a->IPVersion6))
			return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "DynDNS", 0);
		if (t)
		{
			if (!(a->DynDNS = (enum xsd__boolean_ *)soap_malloc(soap, sizeof(enum xsd__boolean_))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean_(soap, t, a->DynDNS))
			return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "Dot11Configuration", 0);
		if (t)
		{
			if (!(a->Dot11Configuration = (enum xsd__boolean_ *)soap_malloc(soap, sizeof(enum xsd__boolean_))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean_(soap, t, a->Dot11Configuration))
			return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "HostnameFromDHCP", 0);
		if (t)
		{
			if (!(a->HostnameFromDHCP = (enum xsd__boolean_ *)soap_malloc(soap, sizeof(enum xsd__boolean_))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean_(soap, t, a->HostnameFromDHCP))
			return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "NTP", 0);
		if (t)
		{
			if (!(a->NTP = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2int(soap, t, a->NTP))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tds__NetworkCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tds__NetworkCapabilities, 0, sizeof(struct tds__NetworkCapabilities), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tds__NetworkCapabilities(struct soap *soap, const struct tds__NetworkCapabilities *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tds__NetworkCapabilities);
	if (soap_out_tds__NetworkCapabilities(soap, tag?tag:"tds:NetworkCapabilities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tds__NetworkCapabilities * SOAP_FMAC4 soap_get_tds__NetworkCapabilities(struct soap *soap, struct tds__NetworkCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_tds__NetworkCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tds__DeviceServiceCapabilities(struct soap *soap, struct tds__DeviceServiceCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Network = NULL;
	a->Security = NULL;
	a->System = NULL;
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tds__DeviceServiceCapabilities(struct soap *soap, const struct tds__DeviceServiceCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTotds__NetworkCapabilities(soap, &a->Network);
	soap_serialize_PointerTotds__SecurityCapabilities(soap, &a->Security);
	soap_serialize_PointerTotds__SystemCapabilities(soap, &a->System);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tds__DeviceServiceCapabilities(struct soap *soap, const char *tag, int id, const struct tds__DeviceServiceCapabilities *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tds__DeviceServiceCapabilities), type))
		return soap->error;
	if (a->Network)
	{	if (soap_out_PointerTotds__NetworkCapabilities(soap, "tds:Network", -1, &a->Network, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tds:Network"))
		return soap->error;
	if (a->Security)
	{	if (soap_out_PointerTotds__SecurityCapabilities(soap, "tds:Security", -1, &a->Security, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tds:Security"))
		return soap->error;
	if (a->System)
	{	if (soap_out_PointerTotds__SystemCapabilities(soap, "tds:System", -1, &a->System, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tds:System"))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tds__DeviceServiceCapabilities * SOAP_FMAC4 soap_in_tds__DeviceServiceCapabilities(struct soap *soap, const char *tag, struct tds__DeviceServiceCapabilities *a, const char *type)
{
	size_t soap_flag_Network = 1;
	size_t soap_flag_Security = 1;
	size_t soap_flag_System = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tds__DeviceServiceCapabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tds__DeviceServiceCapabilities, sizeof(struct tds__DeviceServiceCapabilities), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tds__DeviceServiceCapabilities(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Network && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotds__NetworkCapabilities(soap, "tds:Network", &a->Network, "tds:NetworkCapabilities"))
				{	soap_flag_Network--;
					continue;
				}
			if (soap_flag_Security && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotds__SecurityCapabilities(soap, "tds:Security", &a->Security, "tds:SecurityCapabilities"))
				{	soap_flag_Security--;
					continue;
				}
			if (soap_flag_System && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotds__SystemCapabilities(soap, "tds:System", &a->System, "tds:SystemCapabilities"))
				{	soap_flag_System--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tds__DeviceServiceCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tds__DeviceServiceCapabilities, 0, sizeof(struct tds__DeviceServiceCapabilities), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Network > 0 || soap_flag_Security > 0 || soap_flag_System > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tds__DeviceServiceCapabilities(struct soap *soap, const struct tds__DeviceServiceCapabilities *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tds__DeviceServiceCapabilities);
	if (soap_out_tds__DeviceServiceCapabilities(soap, tag?tag:"tds:DeviceServiceCapabilities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tds__DeviceServiceCapabilities * SOAP_FMAC4 soap_get_tds__DeviceServiceCapabilities(struct soap *soap, struct tds__DeviceServiceCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_tds__DeviceServiceCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__OnvifVersion(struct soap *soap, struct tt__OnvifVersion *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->Major);
	soap_default_int(soap, &a->Minor);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__OnvifVersion(struct soap *soap, const struct tt__OnvifVersion *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->Major, SOAP_TYPE_int);
	soap_embedded(soap, &a->Minor, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__OnvifVersion(struct soap *soap, const char *tag, int id, const struct tt__OnvifVersion *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__OnvifVersion), type))
		return soap->error;
	if (soap_out_int(soap, "tt:Major", -1, &a->Major, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:Minor", -1, &a->Minor, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__OnvifVersion * SOAP_FMAC4 soap_in_tt__OnvifVersion(struct soap *soap, const char *tag, struct tt__OnvifVersion *a, const char *type)
{
	size_t soap_flag_Major = 1;
	size_t soap_flag_Minor = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__OnvifVersion *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__OnvifVersion, sizeof(struct tt__OnvifVersion), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__OnvifVersion(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Major && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "tt:Major", &a->Major, "xsd:int"))
				{	soap_flag_Major--;
					continue;
				}
			if (soap_flag_Minor && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "tt:Minor", &a->Minor, "xsd:int"))
				{	soap_flag_Minor--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__OnvifVersion *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__OnvifVersion, 0, sizeof(struct tt__OnvifVersion), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Major > 0 || soap_flag_Minor > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__OnvifVersion(struct soap *soap, const struct tt__OnvifVersion *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__OnvifVersion);
	if (soap_out_tt__OnvifVersion(soap, tag?tag:"tt:OnvifVersion", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__OnvifVersion * SOAP_FMAC4 soap_get_tt__OnvifVersion(struct soap *soap, struct tt__OnvifVersion *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__OnvifVersion(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__Service_Capabilities(struct soap *soap, struct _tds__Service_Capabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__Service_Capabilities(struct soap *soap, const struct _tds__Service_Capabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__Service_Capabilities(struct soap *soap, const char *tag, int id, const struct _tds__Service_Capabilities *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__Service_Capabilities), type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__Service_Capabilities * SOAP_FMAC4 soap_in__tds__Service_Capabilities(struct soap *soap, const char *tag, struct _tds__Service_Capabilities *a, const char *type)
{
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__Service_Capabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__Service_Capabilities, sizeof(struct _tds__Service_Capabilities), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__Service_Capabilities(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__Service_Capabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__Service_Capabilities, 0, sizeof(struct _tds__Service_Capabilities), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__Service_Capabilities(struct soap *soap, const struct _tds__Service_Capabilities *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__Service_Capabilities);
	if (soap_out__tds__Service_Capabilities(soap, tag?tag:"tds:Service-Capabilities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__Service_Capabilities * SOAP_FMAC4 soap_get__tds__Service_Capabilities(struct soap *soap, struct _tds__Service_Capabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__Service_Capabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tds__Service(struct soap *soap, struct tds__Service *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Namespace);
	soap_default_string(soap, &a->XAddr);
	a->Capabilities = NULL;
	a->Version = NULL;
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tds__Service(struct soap *soap, const struct tds__Service *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Namespace);
	soap_serialize_string(soap, &a->XAddr);
	soap_serialize_PointerTo_tds__Service_Capabilities(soap, &a->Capabilities);
	soap_serialize_PointerTott__OnvifVersion(soap, &a->Version);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tds__Service(struct soap *soap, const char *tag, int id, const struct tds__Service *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tds__Service), type))
		return soap->error;
	if (a->Namespace)
	{	if (soap_out_string(soap, "tds:Namespace", -1, &a->Namespace, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tds:Namespace"))
		return soap->error;
	if (a->XAddr)
	{	if (soap_out_string(soap, "tds:XAddr", -1, &a->XAddr, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tds:XAddr"))
		return soap->error;
	if (soap_out_PointerTo_tds__Service_Capabilities(soap, "tds:Capabilities", -1, &a->Capabilities, ""))
		return soap->error;
	if (a->Version)
	{	if (soap_out_PointerTott__OnvifVersion(soap, "tds:Version", -1, &a->Version, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tds:Version"))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tds__Service * SOAP_FMAC4 soap_in_tds__Service(struct soap *soap, const char *tag, struct tds__Service *a, const char *type)
{
	size_t soap_flag_Namespace = 1;
	size_t soap_flag_XAddr = 1;
	size_t soap_flag_Capabilities = 1;
	size_t soap_flag_Version = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tds__Service *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tds__Service, sizeof(struct tds__Service), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tds__Service(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Namespace && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "tds:Namespace", &a->Namespace, "xsd:string"))
				{	soap_flag_Namespace--;
					continue;
				}
			if (soap_flag_XAddr && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "tds:XAddr", &a->XAddr, "xsd:string"))
				{	soap_flag_XAddr--;
					continue;
				}
			if (soap_flag_Capabilities && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_tds__Service_Capabilities(soap, "tds:Capabilities", &a->Capabilities, ""))
				{	soap_flag_Capabilities--;
					continue;
				}
			if (soap_flag_Version && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__OnvifVersion(soap, "tds:Version", &a->Version, "tt:OnvifVersion"))
				{	soap_flag_Version--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tds__Service *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tds__Service, 0, sizeof(struct tds__Service), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Namespace > 0 || soap_flag_XAddr > 0 || soap_flag_Version > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tds__Service(struct soap *soap, const struct tds__Service *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tds__Service);
	if (soap_out_tds__Service(soap, tag?tag:"tds:Service", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tds__Service * SOAP_FMAC4 soap_get_tds__Service(struct soap *soap, struct tds__Service *p, const char *tag, const char *type)
{
	if ((p = soap_in_tds__Service(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_d__SigType(struct soap *soap, struct d__SigType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
	soap_default_string(soap, &a->Scheme);
	soap_default_string(soap, &a->KeyId);
	soap_default_xsd__IDREFS(soap, &a->Refs);
	soap_default_string(soap, &a->Sig);
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_d__SigType(struct soap *soap, const struct d__SigType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_d__SigType(struct soap *soap, const char *tag, int id, const struct d__SigType *a, const char *type)
{
	if (a->Scheme)
		soap_set_attr(soap, "Scheme", a->Scheme, 1);
	if (a->KeyId)
		soap_set_attr(soap, "KeyId", a->KeyId, 1);
	if (a->Refs)
		soap_set_attr(soap, "Refs", a->Refs, 1);
	if (a->Sig)
		soap_set_attr(soap, "Sig", a->Sig, 1);
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_d__SigType), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct d__SigType * SOAP_FMAC4 soap_in_d__SigType(struct soap *soap, const char *tag, struct d__SigType *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct d__SigType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_d__SigType, sizeof(struct d__SigType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_d__SigType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Scheme", 1), &a->Scheme, -1, -1))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "KeyId", 0), &a->KeyId, -1, -1))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "Refs", 1), &a->Refs, -1, -1))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "Sig", 1), &a->Sig, -1, -1))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct d__SigType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_d__SigType, 0, sizeof(struct d__SigType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_d__SigType(struct soap *soap, const struct d__SigType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_d__SigType);
	if (soap_out_d__SigType(soap, tag?tag:"d:SigType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct d__SigType * SOAP_FMAC4 soap_get_d__SigType(struct soap *soap, struct d__SigType *p, const char *tag, const char *type)
{
	if ((p = soap_in_d__SigType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_d__SecurityType(struct soap *soap, struct d__SecurityType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Sig = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_d__SecurityType(struct soap *soap, const struct d__SecurityType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTod__SigType(soap, &a->Sig);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_d__SecurityType(struct soap *soap, const char *tag, int id, const struct d__SecurityType *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_d__SecurityType), type))
		return soap->error;
	if (soap_out_PointerTod__SigType(soap, "d:Sig", -1, &a->Sig, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct d__SecurityType * SOAP_FMAC4 soap_in_d__SecurityType(struct soap *soap, const char *tag, struct d__SecurityType *a, const char *type)
{
	size_t soap_flag_Sig = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct d__SecurityType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_d__SecurityType, sizeof(struct d__SecurityType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_d__SecurityType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Sig && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTod__SigType(soap, "d:Sig", &a->Sig, "d:SigType"))
				{	soap_flag_Sig--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct d__SecurityType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_d__SecurityType, 0, sizeof(struct d__SecurityType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_d__SecurityType(struct soap *soap, const struct d__SecurityType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_d__SecurityType);
	if (soap_out_d__SecurityType(soap, tag?tag:"d:SecurityType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct d__SecurityType * SOAP_FMAC4 soap_get_d__SecurityType(struct soap *soap, struct d__SecurityType *p, const char *tag, const char *type)
{
	if ((p = soap_in_d__SecurityType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_d__ResolveMatchType(struct soap *soap, struct d__ResolveMatchType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__wsa__EndpointReference(soap, &a->wsa__EndpointReference);
	soap_default_d__QNameListType(soap, &a->Types);
	a->Scopes = NULL;
	soap_default_d__UriListType(soap, &a->XAddrs);
	soap_default_unsignedInt(soap, &a->MetadataVersion);
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_d__ResolveMatchType(struct soap *soap, const struct d__ResolveMatchType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__wsa__EndpointReference(soap, &a->wsa__EndpointReference);
	soap_serialize_d__QNameListType(soap, &a->Types);
	soap_serialize_PointerTod__ScopesType(soap, &a->Scopes);
	soap_serialize_d__UriListType(soap, &a->XAddrs);
	soap_embedded(soap, &a->MetadataVersion, SOAP_TYPE_unsignedInt);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_d__ResolveMatchType(struct soap *soap, const char *tag, int id, const struct d__ResolveMatchType *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_d__ResolveMatchType), type))
		return soap->error;
	if (soap_out__wsa__EndpointReference(soap, "wsa:EndpointReference", -1, &a->wsa__EndpointReference, ""))
		return soap->error;
	if (soap_out_d__QNameListType(soap, "d:Types", -1, &a->Types, ""))
		return soap->error;
	if (soap_out_PointerTod__ScopesType(soap, "d:Scopes", -1, &a->Scopes, ""))
		return soap->error;
	if (a->XAddrs)
	{	if (soap_out_d__UriListType(soap, "d:XAddrs", -1, &a->XAddrs, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "d:XAddrs"))
		return soap->error;
	if (soap_out_unsignedInt(soap, "d:MetadataVersion", -1, &a->MetadataVersion, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct d__ResolveMatchType * SOAP_FMAC4 soap_in_d__ResolveMatchType(struct soap *soap, const char *tag, struct d__ResolveMatchType *a, const char *type)
{
	size_t soap_flag_wsa__EndpointReference = 1;
	size_t soap_flag_Types = 1;
	size_t soap_flag_Scopes = 1;
	size_t soap_flag_XAddrs = 1;
	size_t soap_flag_MetadataVersion = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct d__ResolveMatchType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_d__ResolveMatchType, sizeof(struct d__ResolveMatchType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_d__ResolveMatchType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsa__EndpointReference && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in__wsa__EndpointReference(soap, "wsa:EndpointReference", &a->wsa__EndpointReference, ""))
				{	soap_flag_wsa__EndpointReference--;
					continue;
				}
			if (soap_flag_Types && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_d__QNameListType(soap, "d:Types", &a->Types, "d:QNameListType"))
				{	soap_flag_Types--;
					continue;
				}
			if (soap_flag_Scopes && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTod__ScopesType(soap, "d:Scopes", &a->Scopes, "d:ScopesType"))
				{	soap_flag_Scopes--;
					continue;
				}
			if (soap_flag_XAddrs && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_d__UriListType(soap, "d:XAddrs", &a->XAddrs, "d:UriListType"))
				{	soap_flag_XAddrs--;
					continue;
				}
			if (soap_flag_MetadataVersion && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, "d:MetadataVersion", &a->MetadataVersion, "xsd:unsignedInt"))
				{	soap_flag_MetadataVersion--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct d__ResolveMatchType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_d__ResolveMatchType, 0, sizeof(struct d__ResolveMatchType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_wsa__EndpointReference > 0 || soap_flag_XAddrs > 0 || soap_flag_MetadataVersion > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_d__ResolveMatchType(struct soap *soap, const struct d__ResolveMatchType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_d__ResolveMatchType);
	if (soap_out_d__ResolveMatchType(soap, tag?tag:"d:ResolveMatchType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct d__ResolveMatchType * SOAP_FMAC4 soap_get_d__ResolveMatchType(struct soap *soap, struct d__ResolveMatchType *p, const char *tag, const char *type)
{
	if ((p = soap_in_d__ResolveMatchType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_d__ResolveMatchesType(struct soap *soap, struct d__ResolveMatchesType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ResolveMatch = NULL;
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_d__ResolveMatchesType(struct soap *soap, const struct d__ResolveMatchesType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTod__ResolveMatchType(soap, &a->ResolveMatch);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_d__ResolveMatchesType(struct soap *soap, const char *tag, int id, const struct d__ResolveMatchesType *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_d__ResolveMatchesType), type))
		return soap->error;
	if (soap_out_PointerTod__ResolveMatchType(soap, "d:ResolveMatch", -1, &a->ResolveMatch, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct d__ResolveMatchesType * SOAP_FMAC4 soap_in_d__ResolveMatchesType(struct soap *soap, const char *tag, struct d__ResolveMatchesType *a, const char *type)
{
	size_t soap_flag_ResolveMatch = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct d__ResolveMatchesType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_d__ResolveMatchesType, sizeof(struct d__ResolveMatchesType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_d__ResolveMatchesType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ResolveMatch && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTod__ResolveMatchType(soap, "d:ResolveMatch", &a->ResolveMatch, "d:ResolveMatchType"))
				{	soap_flag_ResolveMatch--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct d__ResolveMatchesType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_d__ResolveMatchesType, 0, sizeof(struct d__ResolveMatchesType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_d__ResolveMatchesType(struct soap *soap, const struct d__ResolveMatchesType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_d__ResolveMatchesType);
	if (soap_out_d__ResolveMatchesType(soap, tag?tag:"d:ResolveMatchesType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct d__ResolveMatchesType * SOAP_FMAC4 soap_get_d__ResolveMatchesType(struct soap *soap, struct d__ResolveMatchesType *p, const char *tag, const char *type)
{
	if ((p = soap_in_d__ResolveMatchesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_d__ResolveType(struct soap *soap, struct d__ResolveType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__wsa__EndpointReference(soap, &a->wsa__EndpointReference);
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_d__ResolveType(struct soap *soap, const struct d__ResolveType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__wsa__EndpointReference(soap, &a->wsa__EndpointReference);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_d__ResolveType(struct soap *soap, const char *tag, int id, const struct d__ResolveType *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_d__ResolveType), type))
		return soap->error;
	soap_element_result(soap, "wsa:EndpointReference");
	if (soap_out__wsa__EndpointReference(soap, "wsa:EndpointReference", -1, &a->wsa__EndpointReference, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct d__ResolveType * SOAP_FMAC4 soap_in_d__ResolveType(struct soap *soap, const char *tag, struct d__ResolveType *a, const char *type)
{
	size_t soap_flag_wsa__EndpointReference = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct d__ResolveType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_d__ResolveType, sizeof(struct d__ResolveType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_d__ResolveType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsa__EndpointReference && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in__wsa__EndpointReference(soap, "wsa:EndpointReference", &a->wsa__EndpointReference, ""))
				{	soap_flag_wsa__EndpointReference--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			soap_check_result(soap, "wsa:EndpointReference");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct d__ResolveType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_d__ResolveType, 0, sizeof(struct d__ResolveType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_wsa__EndpointReference > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_d__ResolveType(struct soap *soap, const struct d__ResolveType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_d__ResolveType);
	if (soap_out_d__ResolveType(soap, tag?tag:"d:ResolveType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct d__ResolveType * SOAP_FMAC4 soap_get_d__ResolveType(struct soap *soap, struct d__ResolveType *p, const char *tag, const char *type)
{
	if ((p = soap_in_d__ResolveType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_d__ProbeMatchType(struct soap *soap, struct d__ProbeMatchType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__wsa__EndpointReference(soap, &a->wsa__EndpointReference);
	soap_default_d__QNameListType(soap, &a->Types);
	a->Scopes = NULL;
	soap_default_d__UriListType(soap, &a->XAddrs);
	soap_default_unsignedInt(soap, &a->MetadataVersion);
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_d__ProbeMatchType(struct soap *soap, const struct d__ProbeMatchType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__wsa__EndpointReference(soap, &a->wsa__EndpointReference);
	soap_serialize_d__QNameListType(soap, &a->Types);
	soap_serialize_PointerTod__ScopesType(soap, &a->Scopes);
	soap_serialize_d__UriListType(soap, &a->XAddrs);
	soap_embedded(soap, &a->MetadataVersion, SOAP_TYPE_unsignedInt);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_d__ProbeMatchType(struct soap *soap, const char *tag, int id, const struct d__ProbeMatchType *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_d__ProbeMatchType), type))
		return soap->error;
	if (soap_out__wsa__EndpointReference(soap, "wsa:EndpointReference", -1, &a->wsa__EndpointReference, ""))
		return soap->error;
	if (soap_out_d__QNameListType(soap, "d:Types", -1, &a->Types, ""))
		return soap->error;
	if (soap_out_PointerTod__ScopesType(soap, "d:Scopes", -1, &a->Scopes, ""))
		return soap->error;
	if (soap_out_d__UriListType(soap, "d:XAddrs", -1, &a->XAddrs, ""))
		return soap->error;
	if (soap_out_unsignedInt(soap, "d:MetadataVersion", -1, &a->MetadataVersion, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct d__ProbeMatchType * SOAP_FMAC4 soap_in_d__ProbeMatchType(struct soap *soap, const char *tag, struct d__ProbeMatchType *a, const char *type)
{
	size_t soap_flag_wsa__EndpointReference = 1;
	size_t soap_flag_Types = 1;
	size_t soap_flag_Scopes = 1;
	size_t soap_flag_XAddrs = 1;
	size_t soap_flag_MetadataVersion = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct d__ProbeMatchType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_d__ProbeMatchType, sizeof(struct d__ProbeMatchType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_d__ProbeMatchType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsa__EndpointReference && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in__wsa__EndpointReference(soap, "wsa:EndpointReference", &a->wsa__EndpointReference, ""))
				{	soap_flag_wsa__EndpointReference--;
					continue;
				}
			if (soap_flag_Types && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_d__QNameListType(soap, "d:Types", &a->Types, "d:QNameListType"))
				{	soap_flag_Types--;
					continue;
				}
			if (soap_flag_Scopes && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTod__ScopesType(soap, "d:Scopes", &a->Scopes, "d:ScopesType"))
				{	soap_flag_Scopes--;
					continue;
				}
			if (soap_flag_XAddrs && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_d__UriListType(soap, "d:XAddrs", &a->XAddrs, "d:UriListType"))
				{	soap_flag_XAddrs--;
					continue;
				}
			if (soap_flag_MetadataVersion && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, "d:MetadataVersion", &a->MetadataVersion, "xsd:unsignedInt"))
				{	soap_flag_MetadataVersion--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct d__ProbeMatchType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_d__ProbeMatchType, 0, sizeof(struct d__ProbeMatchType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_wsa__EndpointReference > 0 || soap_flag_MetadataVersion > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_d__ProbeMatchType(struct soap *soap, const struct d__ProbeMatchType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_d__ProbeMatchType);
	if (soap_out_d__ProbeMatchType(soap, tag?tag:"d:ProbeMatchType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct d__ProbeMatchType * SOAP_FMAC4 soap_get_d__ProbeMatchType(struct soap *soap, struct d__ProbeMatchType *p, const char *tag, const char *type)
{
	if ((p = soap_in_d__ProbeMatchType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_d__ProbeMatchesType(struct soap *soap, struct d__ProbeMatchesType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeProbeMatch = 0;
	a->ProbeMatch = NULL;
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_d__ProbeMatchesType(struct soap *soap, const struct d__ProbeMatchesType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->ProbeMatch)
	{	int i;
		for (i = 0; i < a->__sizeProbeMatch; i++)
		{
			soap_embedded(soap, a->ProbeMatch + i, SOAP_TYPE_d__ProbeMatchType);
			soap_serialize_d__ProbeMatchType(soap, a->ProbeMatch + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_d__ProbeMatchesType(struct soap *soap, const char *tag, int id, const struct d__ProbeMatchesType *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_d__ProbeMatchesType), type))
		return soap->error;
	soap_element_result(soap, "-sizeProbeMatch");
	if (a->ProbeMatch)
	{	int i;
		for (i = 0; i < a->__sizeProbeMatch; i++)
			if (soap_out_d__ProbeMatchType(soap, "d:ProbeMatch", -1, a->ProbeMatch + i, ""))
				return soap->error;
	}
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct d__ProbeMatchesType * SOAP_FMAC4 soap_in_d__ProbeMatchesType(struct soap *soap, const char *tag, struct d__ProbeMatchesType *a, const char *type)
{
	struct soap_blist *soap_blist_ProbeMatch = NULL;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct d__ProbeMatchesType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_d__ProbeMatchesType, sizeof(struct d__ProbeMatchesType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_d__ProbeMatchesType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "d:ProbeMatch", 1, NULL))
			{	if (a->ProbeMatch == NULL)
				{	if (soap_blist_ProbeMatch == NULL)
						soap_blist_ProbeMatch = soap_new_block(soap);
					a->ProbeMatch = (struct d__ProbeMatchType *)soap_push_block(soap, soap_blist_ProbeMatch, sizeof(struct d__ProbeMatchType));
					if (a->ProbeMatch == NULL)
						return NULL;
					soap_default_d__ProbeMatchType(soap, a->ProbeMatch);
				}
				soap_revert(soap);
				if (soap_in_d__ProbeMatchType(soap, "d:ProbeMatch", a->ProbeMatch, "d:ProbeMatchType"))
				{	a->__sizeProbeMatch++;
					a->ProbeMatch = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizeProbeMatch");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ProbeMatch)
			soap_pop_block(soap, soap_blist_ProbeMatch);
		if (a->__sizeProbeMatch)
			a->ProbeMatch = (struct d__ProbeMatchType *)soap_save_block(soap, soap_blist_ProbeMatch, NULL, 1);
		else
		{	a->ProbeMatch = NULL;
			if (soap_blist_ProbeMatch)
				soap_end_block(soap, soap_blist_ProbeMatch);
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct d__ProbeMatchesType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_d__ProbeMatchesType, 0, sizeof(struct d__ProbeMatchesType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_d__ProbeMatchesType(struct soap *soap, const struct d__ProbeMatchesType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_d__ProbeMatchesType);
	if (soap_out_d__ProbeMatchesType(soap, tag?tag:"d:ProbeMatchesType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct d__ProbeMatchesType * SOAP_FMAC4 soap_get_d__ProbeMatchesType(struct soap *soap, struct d__ProbeMatchesType *p, const char *tag, const char *type)
{
	if ((p = soap_in_d__ProbeMatchesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_d__ProbeType(struct soap *soap, struct d__ProbeType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_d__QNameListType(soap, &a->Types);
	a->Scopes = NULL;
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_d__ProbeType(struct soap *soap, const struct d__ProbeType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_d__QNameListType(soap, &a->Types);
	soap_serialize_PointerTod__ScopesType(soap, &a->Scopes);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_d__ProbeType(struct soap *soap, const char *tag, int id, const struct d__ProbeType *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_d__ProbeType), type))
		return soap->error;
	if (soap_out_d__QNameListType(soap, "d:Types", -1, &a->Types, ""))
		return soap->error;
	if (soap_out_PointerTod__ScopesType(soap, "d:Scopes", -1, &a->Scopes, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct d__ProbeType * SOAP_FMAC4 soap_in_d__ProbeType(struct soap *soap, const char *tag, struct d__ProbeType *a, const char *type)
{
	size_t soap_flag_Types = 1;
	size_t soap_flag_Scopes = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct d__ProbeType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_d__ProbeType, sizeof(struct d__ProbeType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_d__ProbeType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Types && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_d__QNameListType(soap, "d:Types", &a->Types, "d:QNameListType"))
				{	soap_flag_Types--;
					continue;
				}
			if (soap_flag_Scopes && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTod__ScopesType(soap, "d:Scopes", &a->Scopes, "d:ScopesType"))
				{	soap_flag_Scopes--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct d__ProbeType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_d__ProbeType, 0, sizeof(struct d__ProbeType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_d__ProbeType(struct soap *soap, const struct d__ProbeType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_d__ProbeType);
	if (soap_out_d__ProbeType(soap, tag?tag:"d:ProbeType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct d__ProbeType * SOAP_FMAC4 soap_get_d__ProbeType(struct soap *soap, struct d__ProbeType *p, const char *tag, const char *type)
{
	if ((p = soap_in_d__ProbeType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_d__ByeType(struct soap *soap, struct d__ByeType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__wsa__EndpointReference(soap, &a->wsa__EndpointReference);
	soap_default_d__QNameListType(soap, &a->Types);
	a->Scopes = NULL;
	soap_default_d__UriListType(soap, &a->XAddrs);
	a->MetadataVersion = NULL;
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_d__ByeType(struct soap *soap, const struct d__ByeType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__wsa__EndpointReference(soap, &a->wsa__EndpointReference);
	soap_serialize_d__QNameListType(soap, &a->Types);
	soap_serialize_PointerTod__ScopesType(soap, &a->Scopes);
	soap_serialize_d__UriListType(soap, &a->XAddrs);
	soap_serialize_PointerTounsignedInt(soap, &a->MetadataVersion);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_d__ByeType(struct soap *soap, const char *tag, int id, const struct d__ByeType *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_d__ByeType), type))
		return soap->error;
	if (soap_out__wsa__EndpointReference(soap, "wsa:EndpointReference", -1, &a->wsa__EndpointReference, ""))
		return soap->error;
	if (soap_out_d__QNameListType(soap, "d:Types", -1, &a->Types, ""))
		return soap->error;
	if (soap_out_PointerTod__ScopesType(soap, "d:Scopes", -1, &a->Scopes, ""))
		return soap->error;
	if (soap_out_d__UriListType(soap, "d:XAddrs", -1, &a->XAddrs, ""))
		return soap->error;
	if (soap_out_PointerTounsignedInt(soap, "d:MetadataVersion", -1, &a->MetadataVersion, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct d__ByeType * SOAP_FMAC4 soap_in_d__ByeType(struct soap *soap, const char *tag, struct d__ByeType *a, const char *type)
{
	size_t soap_flag_wsa__EndpointReference = 1;
	size_t soap_flag_Types = 1;
	size_t soap_flag_Scopes = 1;
	size_t soap_flag_XAddrs = 1;
	size_t soap_flag_MetadataVersion = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct d__ByeType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_d__ByeType, sizeof(struct d__ByeType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_d__ByeType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsa__EndpointReference && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in__wsa__EndpointReference(soap, "wsa:EndpointReference", &a->wsa__EndpointReference, ""))
				{	soap_flag_wsa__EndpointReference--;
					continue;
				}
			if (soap_flag_Types && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_d__QNameListType(soap, "d:Types", &a->Types, "d:QNameListType"))
				{	soap_flag_Types--;
					continue;
				}
			if (soap_flag_Scopes && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTod__ScopesType(soap, "d:Scopes", &a->Scopes, "d:ScopesType"))
				{	soap_flag_Scopes--;
					continue;
				}
			if (soap_flag_XAddrs && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_d__UriListType(soap, "d:XAddrs", &a->XAddrs, "d:UriListType"))
				{	soap_flag_XAddrs--;
					continue;
				}
			if (soap_flag_MetadataVersion && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTounsignedInt(soap, "d:MetadataVersion", &a->MetadataVersion, "xsd:unsignedInt"))
				{	soap_flag_MetadataVersion--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct d__ByeType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_d__ByeType, 0, sizeof(struct d__ByeType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_wsa__EndpointReference > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_d__ByeType(struct soap *soap, const struct d__ByeType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_d__ByeType);
	if (soap_out_d__ByeType(soap, tag?tag:"d:ByeType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct d__ByeType * SOAP_FMAC4 soap_get_d__ByeType(struct soap *soap, struct d__ByeType *p, const char *tag, const char *type)
{
	if ((p = soap_in_d__ByeType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_d__ScopesType(struct soap *soap, struct d__ScopesType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_d__UriListType(soap, &a->__item);
	soap_default_string(soap, &a->MatchBy);
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_d__ScopesType(struct soap *soap, const struct d__ScopesType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_d__UriListType(soap, &a->__item);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_d__ScopesType(struct soap *soap, const char *tag, int id, const struct d__ScopesType *a, const char *type)
{
	if (a->MatchBy)
		soap_set_attr(soap, "MatchBy", a->MatchBy, 1);
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	return soap_out_d__UriListType(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct d__ScopesType * SOAP_FMAC4 soap_in_d__ScopesType(struct soap *soap, const char *tag, struct d__ScopesType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct d__ScopesType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_d__ScopesType, sizeof(struct d__ScopesType), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default_d__ScopesType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "MatchBy", 0), &a->MatchBy, -1, -1))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (!soap_in_d__UriListType(soap, tag, &a->__item, "d:ScopesType"))
		return NULL;
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_d__ScopesType(struct soap *soap, const struct d__ScopesType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_d__ScopesType);
	if (soap_out_d__ScopesType(soap, tag?tag:"d:ScopesType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct d__ScopesType * SOAP_FMAC4 soap_get_d__ScopesType(struct soap *soap, struct d__ScopesType *p, const char *tag, const char *type)
{
	if ((p = soap_in_d__ScopesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_d__HelloType(struct soap *soap, struct d__HelloType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__wsa__EndpointReference(soap, &a->wsa__EndpointReference);
	soap_default_d__QNameListType(soap, &a->Types);
	a->Scopes = NULL;
	soap_default_d__UriListType(soap, &a->XAddrs);
	soap_default_unsignedInt(soap, &a->MetadataVersion);
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_d__HelloType(struct soap *soap, const struct d__HelloType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__wsa__EndpointReference(soap, &a->wsa__EndpointReference);
	soap_serialize_d__QNameListType(soap, &a->Types);
	soap_serialize_PointerTod__ScopesType(soap, &a->Scopes);
	soap_serialize_d__UriListType(soap, &a->XAddrs);
	soap_embedded(soap, &a->MetadataVersion, SOAP_TYPE_unsignedInt);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_d__HelloType(struct soap *soap, const char *tag, int id, const struct d__HelloType *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_d__HelloType), type))
		return soap->error;
	if (soap_out__wsa__EndpointReference(soap, "wsa:EndpointReference", -1, &a->wsa__EndpointReference, ""))
		return soap->error;
	if (soap_out_d__QNameListType(soap, "d:Types", -1, &a->Types, ""))
		return soap->error;
	if (soap_out_PointerTod__ScopesType(soap, "d:Scopes", -1, &a->Scopes, ""))
		return soap->error;
	if (soap_out_d__UriListType(soap, "d:XAddrs", -1, &a->XAddrs, ""))
		return soap->error;
	if (soap_out_unsignedInt(soap, "d:MetadataVersion", -1, &a->MetadataVersion, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct d__HelloType * SOAP_FMAC4 soap_in_d__HelloType(struct soap *soap, const char *tag, struct d__HelloType *a, const char *type)
{
	size_t soap_flag_wsa__EndpointReference = 1;
	size_t soap_flag_Types = 1;
	size_t soap_flag_Scopes = 1;
	size_t soap_flag_XAddrs = 1;
	size_t soap_flag_MetadataVersion = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct d__HelloType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_d__HelloType, sizeof(struct d__HelloType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_d__HelloType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsa__EndpointReference && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in__wsa__EndpointReference(soap, "wsa:EndpointReference", &a->wsa__EndpointReference, ""))
				{	soap_flag_wsa__EndpointReference--;
					continue;
				}
			if (soap_flag_Types && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_d__QNameListType(soap, "d:Types", &a->Types, "d:QNameListType"))
				{	soap_flag_Types--;
					continue;
				}
			if (soap_flag_Scopes && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTod__ScopesType(soap, "d:Scopes", &a->Scopes, "d:ScopesType"))
				{	soap_flag_Scopes--;
					continue;
				}
			if (soap_flag_XAddrs && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_d__UriListType(soap, "d:XAddrs", &a->XAddrs, "d:UriListType"))
				{	soap_flag_XAddrs--;
					continue;
				}
			if (soap_flag_MetadataVersion && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, "d:MetadataVersion", &a->MetadataVersion, "xsd:unsignedInt"))
				{	soap_flag_MetadataVersion--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct d__HelloType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_d__HelloType, 0, sizeof(struct d__HelloType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_wsa__EndpointReference > 0 || soap_flag_MetadataVersion > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_d__HelloType(struct soap *soap, const struct d__HelloType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_d__HelloType);
	if (soap_out_d__HelloType(soap, tag?tag:"d:HelloType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct d__HelloType * SOAP_FMAC4 soap_get_d__HelloType(struct soap *soap, struct d__HelloType *p, const char *tag, const char *type)
{
	if ((p = soap_in_d__HelloType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Dot11PSK(struct soap *soap, const char *tag, int id, const struct xsd__hexBinary *a, const char *type)
{
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_tt__Dot11PSK);
	if (id < 0)
		return soap->error;
	if (soap_element_begin_out(soap, tag, id, type))
		return soap->error;
	if (soap_puthex(soap, a->__ptr, a->__size))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct xsd__hexBinary * SOAP_FMAC4 soap_in_tt__Dot11PSK(struct soap *soap, const char *tag, struct xsd__hexBinary *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":hexBinary"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct xsd__hexBinary *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Dot11PSK, sizeof(struct xsd__hexBinary), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__Dot11PSK(soap, a);
	if (soap->body && !*soap->href)
	{
		a->__ptr = soap_gethex(soap, &a->__size);
		if ((!a->__ptr && soap->error) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct xsd__hexBinary *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Dot11PSK, 0, sizeof(struct xsd__hexBinary), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Dot11PSK(struct soap *soap, const struct xsd__hexBinary *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, (struct soap_array*)&a->__ptr, 1, tag, SOAP_TYPE_tt__Dot11PSK);
	if (soap_out_tt__Dot11PSK(soap, tag?tag:"tt:Dot11PSK", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct xsd__hexBinary * SOAP_FMAC4 soap_get_tt__Dot11PSK(struct soap *soap, struct xsd__hexBinary *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Dot11PSK(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Dot11SSIDType(struct soap *soap, const char *tag, int id, const struct xsd__hexBinary *a, const char *type)
{
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_tt__Dot11SSIDType);
	if (id < 0)
		return soap->error;
	if (soap_element_begin_out(soap, tag, id, type))
		return soap->error;
	if (soap_puthex(soap, a->__ptr, a->__size))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct xsd__hexBinary * SOAP_FMAC4 soap_in_tt__Dot11SSIDType(struct soap *soap, const char *tag, struct xsd__hexBinary *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":hexBinary"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct xsd__hexBinary *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Dot11SSIDType, sizeof(struct xsd__hexBinary), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__Dot11SSIDType(soap, a);
	if (soap->body && !*soap->href)
	{
		a->__ptr = soap_gethex(soap, &a->__size);
		if ((!a->__ptr && soap->error) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct xsd__hexBinary *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Dot11SSIDType, 0, sizeof(struct xsd__hexBinary), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Dot11SSIDType(struct soap *soap, const struct xsd__hexBinary *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, (struct soap_array*)&a->__ptr, 1, tag, SOAP_TYPE_tt__Dot11SSIDType);
	if (soap_out_tt__Dot11SSIDType(soap, tag?tag:"tt:Dot11SSIDType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct xsd__hexBinary * SOAP_FMAC4 soap_get_tt__Dot11SSIDType(struct soap *soap, struct xsd__hexBinary *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Dot11SSIDType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xsd__hexBinary(struct soap *soap, struct xsd__hexBinary *a)
{
	(void)soap; /* appease -Wall -Werror */
	a->__size = 0;
	a->__ptr = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__hexBinary(struct soap *soap, struct xsd__hexBinary const*a)
{
	if (a->__ptr)
		soap_array_reference(soap, a, (struct soap_array*)&a->__ptr, 1, SOAP_TYPE_xsd__hexBinary);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__hexBinary(struct soap *soap, const char *tag, int id, const struct xsd__hexBinary *a, const char *type)
{
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_xsd__hexBinary);
	if (id < 0)
		return soap->error;
	if (soap_element_begin_out(soap, tag, id, type))
		return soap->error;
	if (soap_puthex(soap, a->__ptr, a->__size))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct xsd__hexBinary * SOAP_FMAC4 soap_in_xsd__hexBinary(struct soap *soap, const char *tag, struct xsd__hexBinary *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":hexBinary"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct xsd__hexBinary *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__hexBinary, sizeof(struct xsd__hexBinary), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_xsd__hexBinary(soap, a);
	if (soap->body && !*soap->href)
	{
		a->__ptr = soap_gethex(soap, &a->__size);
		if ((!a->__ptr && soap->error) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct xsd__hexBinary *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xsd__hexBinary, 0, sizeof(struct xsd__hexBinary), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__hexBinary(struct soap *soap, const struct xsd__hexBinary *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, (struct soap_array*)&a->__ptr, 1, tag, SOAP_TYPE_xsd__hexBinary);
	if (soap_out_xsd__hexBinary(soap, tag?tag:"xsd:hexBinary", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct xsd__hexBinary * SOAP_FMAC4 soap_get_xsd__hexBinary(struct soap *soap, struct xsd__hexBinary *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__hexBinary(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsa5__ProblemActionType(struct soap *soap, struct wsa5__ProblemActionType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Action);
	soap_default_string(soap, &a->SoapAction);
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsa5__ProblemActionType(struct soap *soap, const struct wsa5__ProblemActionType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Action);
	soap_serialize_string(soap, &a->SoapAction);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa5__ProblemActionType(struct soap *soap, const char *tag, int id, const struct wsa5__ProblemActionType *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsa5__ProblemActionType), type))
		return soap->error;
	if (soap_out_string(soap, "wsa5:Action", -1, &a->Action, ""))
		return soap->error;
	if (soap_out_string(soap, "wsa5:SoapAction", -1, &a->SoapAction, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsa5__ProblemActionType * SOAP_FMAC4 soap_in_wsa5__ProblemActionType(struct soap *soap, const char *tag, struct wsa5__ProblemActionType *a, const char *type)
{
	size_t soap_flag_Action = 1;
	size_t soap_flag_SoapAction = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wsa5__ProblemActionType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa5__ProblemActionType, sizeof(struct wsa5__ProblemActionType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsa5__ProblemActionType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Action && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "wsa5:Action", &a->Action, "xsd:string"))
				{	soap_flag_Action--;
					continue;
				}
			if (soap_flag_SoapAction && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "wsa5:SoapAction", &a->SoapAction, "xsd:string"))
				{	soap_flag_SoapAction--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wsa5__ProblemActionType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsa5__ProblemActionType, 0, sizeof(struct wsa5__ProblemActionType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa5__ProblemActionType(struct soap *soap, const struct wsa5__ProblemActionType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wsa5__ProblemActionType);
	if (soap_out_wsa5__ProblemActionType(soap, tag?tag:"wsa5:ProblemActionType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__ProblemActionType * SOAP_FMAC4 soap_get_wsa5__ProblemActionType(struct soap *soap, struct wsa5__ProblemActionType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa5__ProblemActionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsa5__RelatesToType(struct soap *soap, struct wsa5__RelatesToType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default_wsa5__RelationshipTypeOpenEnum(soap, &a->RelationshipType);
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsa5__RelatesToType(struct soap *soap, const struct wsa5__RelatesToType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->__item);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa5__RelatesToType(struct soap *soap, const char *tag, int id, const struct wsa5__RelatesToType *a, const char *type)
{
	if (a->RelationshipType)
		soap_set_attr(soap, "RelationshipType", a->RelationshipType, 1);
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	return soap_out_string(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct wsa5__RelatesToType * SOAP_FMAC4 soap_in_wsa5__RelatesToType(struct soap *soap, const char *tag, struct wsa5__RelatesToType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct wsa5__RelatesToType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa5__RelatesToType, sizeof(struct wsa5__RelatesToType), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default_wsa5__RelatesToType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "RelationshipType", 0), &a->RelationshipType, -1, -1))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (!soap_in_string(soap, tag, &a->__item, "wsa5:RelatesToType"))
		return NULL;
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa5__RelatesToType(struct soap *soap, const struct wsa5__RelatesToType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wsa5__RelatesToType);
	if (soap_out_wsa5__RelatesToType(soap, tag?tag:"wsa5:RelatesToType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__RelatesToType * SOAP_FMAC4 soap_get_wsa5__RelatesToType(struct soap *soap, struct wsa5__RelatesToType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa5__RelatesToType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsa5__MetadataType(struct soap *soap, struct wsa5__MetadataType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsa5__MetadataType(struct soap *soap, const struct wsa5__MetadataType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa5__MetadataType(struct soap *soap, const char *tag, int id, const struct wsa5__MetadataType *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsa5__MetadataType), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsa5__MetadataType * SOAP_FMAC4 soap_in_wsa5__MetadataType(struct soap *soap, const char *tag, struct wsa5__MetadataType *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wsa5__MetadataType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa5__MetadataType, sizeof(struct wsa5__MetadataType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsa5__MetadataType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wsa5__MetadataType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsa5__MetadataType, 0, sizeof(struct wsa5__MetadataType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa5__MetadataType(struct soap *soap, const struct wsa5__MetadataType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wsa5__MetadataType);
	if (soap_out_wsa5__MetadataType(soap, tag?tag:"wsa5:MetadataType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__MetadataType * SOAP_FMAC4 soap_get_wsa5__MetadataType(struct soap *soap, struct wsa5__MetadataType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa5__MetadataType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsa5__ReferenceParametersType(struct soap *soap, struct wsa5__ReferenceParametersType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsa5__ReferenceParametersType(struct soap *soap, const struct wsa5__ReferenceParametersType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa5__ReferenceParametersType(struct soap *soap, const char *tag, int id, const struct wsa5__ReferenceParametersType *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsa5__ReferenceParametersType), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsa5__ReferenceParametersType * SOAP_FMAC4 soap_in_wsa5__ReferenceParametersType(struct soap *soap, const char *tag, struct wsa5__ReferenceParametersType *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wsa5__ReferenceParametersType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa5__ReferenceParametersType, sizeof(struct wsa5__ReferenceParametersType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsa5__ReferenceParametersType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wsa5__ReferenceParametersType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsa5__ReferenceParametersType, 0, sizeof(struct wsa5__ReferenceParametersType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa5__ReferenceParametersType(struct soap *soap, const struct wsa5__ReferenceParametersType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wsa5__ReferenceParametersType);
	if (soap_out_wsa5__ReferenceParametersType(soap, tag?tag:"wsa5:ReferenceParametersType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__ReferenceParametersType * SOAP_FMAC4 soap_get_wsa5__ReferenceParametersType(struct soap *soap, struct wsa5__ReferenceParametersType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa5__ReferenceParametersType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsa5__EndpointReferenceType(struct soap *soap, struct wsa5__EndpointReferenceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Address);
	a->ReferenceParameters = NULL;
	a->Metadata = NULL;
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsa5__EndpointReferenceType(struct soap *soap, const struct wsa5__EndpointReferenceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Address);
	soap_serialize_PointerTowsa5__ReferenceParametersType(soap, &a->ReferenceParameters);
	soap_serialize_PointerTowsa5__MetadataType(soap, &a->Metadata);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa5__EndpointReferenceType(struct soap *soap, const char *tag, int id, const struct wsa5__EndpointReferenceType *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsa5__EndpointReferenceType), type))
		return soap->error;
	if (a->Address)
	{	if (soap_out_string(soap, "wsa5:Address", -1, &a->Address, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "wsa5:Address"))
		return soap->error;
	if (soap_out_PointerTowsa5__ReferenceParametersType(soap, "wsa5:ReferenceParameters", -1, &a->ReferenceParameters, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__MetadataType(soap, "wsa5:Metadata", -1, &a->Metadata, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsa5__EndpointReferenceType * SOAP_FMAC4 soap_in_wsa5__EndpointReferenceType(struct soap *soap, const char *tag, struct wsa5__EndpointReferenceType *a, const char *type)
{
	size_t soap_flag_Address = 1;
	size_t soap_flag_ReferenceParameters = 1;
	size_t soap_flag_Metadata = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wsa5__EndpointReferenceType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa5__EndpointReferenceType, sizeof(struct wsa5__EndpointReferenceType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsa5__EndpointReferenceType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Address && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "wsa5:Address", &a->Address, "xsd:string"))
				{	soap_flag_Address--;
					continue;
				}
			if (soap_flag_ReferenceParameters && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsa5__ReferenceParametersType(soap, "wsa5:ReferenceParameters", &a->ReferenceParameters, "wsa5:ReferenceParametersType"))
				{	soap_flag_ReferenceParameters--;
					continue;
				}
			if (soap_flag_Metadata && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsa5__MetadataType(soap, "wsa5:Metadata", &a->Metadata, "wsa5:MetadataType"))
				{	soap_flag_Metadata--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wsa5__EndpointReferenceType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsa5__EndpointReferenceType, 0, sizeof(struct wsa5__EndpointReferenceType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Address > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa5__EndpointReferenceType(struct soap *soap, const struct wsa5__EndpointReferenceType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wsa5__EndpointReferenceType);
	if (soap_out_wsa5__EndpointReferenceType(soap, tag?tag:"wsa5:EndpointReferenceType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__EndpointReferenceType * SOAP_FMAC4 soap_get_wsa5__EndpointReferenceType(struct soap *soap, struct wsa5__EndpointReferenceType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa5__EndpointReferenceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__wsa__MessageID(soap, &a->wsa__MessageID);
	a->wsa__RelatesTo = NULL;
	a->wsa__From = NULL;
	a->wsa__ReplyTo = NULL;
	a->wsa__FaultTo = NULL;
	soap_default__wsa__To(soap, &a->wsa__To);
	soap_default__wsa__Action(soap, &a->wsa__Action);
	soap_default__wsa5__MessageID(soap, &a->wsa5__MessageID);
	a->wsa5__RelatesTo = NULL;
	a->wsa5__From = NULL;
	a->wsa5__ReplyTo = NULL;
	a->wsa5__FaultTo = NULL;
	soap_default__wsa5__To(soap, &a->wsa5__To);
	soap_default__wsa5__Action(soap, &a->wsa5__Action);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__wsa__MessageID(soap, &a->wsa__MessageID);
	soap_serialize_PointerTo_wsa__RelatesTo(soap, &a->wsa__RelatesTo);
	soap_serialize_PointerTo_wsa__From(soap, &a->wsa__From);
	soap_serialize_PointerTo_wsa__ReplyTo(soap, &a->wsa__ReplyTo);
	soap_serialize_PointerTo_wsa__FaultTo(soap, &a->wsa__FaultTo);
	soap_serialize__wsa__To(soap, &a->wsa__To);
	soap_serialize__wsa__Action(soap, &a->wsa__Action);
	soap_serialize__wsa5__MessageID(soap, &a->wsa5__MessageID);
	soap_serialize_PointerTo_wsa5__RelatesTo(soap, &a->wsa5__RelatesTo);
	soap_serialize_PointerTo_wsa5__From(soap, &a->wsa5__From);
	soap_serialize_PointerTo_wsa5__ReplyTo(soap, &a->wsa5__ReplyTo);
	soap_serialize_PointerTo_wsa5__FaultTo(soap, &a->wsa5__FaultTo);
	soap_serialize__wsa5__To(soap, &a->wsa5__To);
	soap_serialize__wsa5__Action(soap, &a->wsa5__Action);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Header), type))
		return soap->error;
	if (soap_out__wsa__MessageID(soap, "wsa:MessageID", -1, &a->wsa__MessageID, ""))
		return soap->error;
	if (soap_out_PointerTo_wsa__RelatesTo(soap, "wsa:RelatesTo", -1, &a->wsa__RelatesTo, ""))
		return soap->error;
	if (soap_out_PointerTo_wsa__From(soap, "wsa:From", -1, &a->wsa__From, ""))
		return soap->error;
	soap->mustUnderstand = 1;
	if (soap_out_PointerTo_wsa__ReplyTo(soap, "wsa:ReplyTo", -1, &a->wsa__ReplyTo, ""))
		return soap->error;
	soap->mustUnderstand = 1;
	if (soap_out_PointerTo_wsa__FaultTo(soap, "wsa:FaultTo", -1, &a->wsa__FaultTo, ""))
		return soap->error;
	soap->mustUnderstand = 1;
	if (soap_out__wsa__To(soap, "wsa:To", -1, &a->wsa__To, ""))
		return soap->error;
	soap->mustUnderstand = 1;
	if (soap_out__wsa__Action(soap, "wsa:Action", -1, &a->wsa__Action, ""))
		return soap->error;
	if (soap_out__wsa5__MessageID(soap, "wsa5:MessageID", -1, &a->wsa5__MessageID, ""))
		return soap->error;
	if (soap_out_PointerTo_wsa5__RelatesTo(soap, "wsa5:RelatesTo", -1, &a->wsa5__RelatesTo, ""))
		return soap->error;
	if (soap_out_PointerTo_wsa5__From(soap, "wsa5:From", -1, &a->wsa5__From, ""))
		return soap->error;
	soap->mustUnderstand = 1;
	if (soap_out_PointerTo_wsa5__ReplyTo(soap, "wsa5:ReplyTo", -1, &a->wsa5__ReplyTo, ""))
		return soap->error;
	soap->mustUnderstand = 1;
	if (soap_out_PointerTo_wsa5__FaultTo(soap, "wsa5:FaultTo", -1, &a->wsa5__FaultTo, ""))
		return soap->error;
	soap->mustUnderstand = 1;
	if (soap_out__wsa5__To(soap, "wsa5:To", -1, &a->wsa5__To, ""))
		return soap->error;
	soap->mustUnderstand = 1;
	if (soap_out__wsa5__Action(soap, "wsa5:Action", -1, &a->wsa5__Action, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{
	size_t soap_flag_wsa__MessageID = 1;
	size_t soap_flag_wsa__RelatesTo = 1;
	size_t soap_flag_wsa__From = 1;
	size_t soap_flag_wsa__ReplyTo = 1;
	size_t soap_flag_wsa__FaultTo = 1;
	size_t soap_flag_wsa__To = 1;
	size_t soap_flag_wsa__Action = 1;
	size_t soap_flag_wsa5__MessageID = 1;
	size_t soap_flag_wsa5__RelatesTo = 1;
	size_t soap_flag_wsa5__From = 1;
	size_t soap_flag_wsa5__ReplyTo = 1;
	size_t soap_flag_wsa5__FaultTo = 1;
	size_t soap_flag_wsa5__To = 1;
	size_t soap_flag_wsa5__Action = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Header *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Header(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsa__MessageID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__wsa__MessageID(soap, "wsa:MessageID", &a->wsa__MessageID, ""))
				{	soap_flag_wsa__MessageID--;
					continue;
				}
			if (soap_flag_wsa__RelatesTo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsa__RelatesTo(soap, "wsa:RelatesTo", &a->wsa__RelatesTo, ""))
				{	soap_flag_wsa__RelatesTo--;
					continue;
				}
			if (soap_flag_wsa__From && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsa__From(soap, "wsa:From", &a->wsa__From, ""))
				{	soap_flag_wsa__From--;
					continue;
				}
			if (soap_flag_wsa__ReplyTo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsa__ReplyTo(soap, "wsa:ReplyTo", &a->wsa__ReplyTo, ""))
				{	soap_flag_wsa__ReplyTo--;
					continue;
				}
			if (soap_flag_wsa__FaultTo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsa__FaultTo(soap, "wsa:FaultTo", &a->wsa__FaultTo, ""))
				{	soap_flag_wsa__FaultTo--;
					continue;
				}
			if (soap_flag_wsa__To && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__wsa__To(soap, "wsa:To", &a->wsa__To, ""))
				{	soap_flag_wsa__To--;
					continue;
				}
			if (soap_flag_wsa__Action && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__wsa__Action(soap, "wsa:Action", &a->wsa__Action, ""))
				{	soap_flag_wsa__Action--;
					continue;
				}
			if (soap_flag_wsa5__MessageID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__wsa5__MessageID(soap, "wsa5:MessageID", &a->wsa5__MessageID, ""))
				{	soap_flag_wsa5__MessageID--;
					continue;
				}
			if (soap_flag_wsa5__RelatesTo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsa5__RelatesTo(soap, "wsa5:RelatesTo", &a->wsa5__RelatesTo, ""))
				{	soap_flag_wsa5__RelatesTo--;
					continue;
				}
			if (soap_flag_wsa5__From && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsa5__From(soap, "wsa5:From", &a->wsa5__From, ""))
				{	soap_flag_wsa5__From--;
					continue;
				}
			if (soap_flag_wsa5__ReplyTo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsa5__ReplyTo(soap, "wsa5:ReplyTo", &a->wsa5__ReplyTo, ""))
				{	soap_flag_wsa5__ReplyTo--;
					continue;
				}
			if (soap_flag_wsa5__FaultTo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsa5__FaultTo(soap, "wsa5:FaultTo", &a->wsa5__FaultTo, ""))
				{	soap_flag_wsa5__FaultTo--;
					continue;
				}
			if (soap_flag_wsa5__To && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__wsa5__To(soap, "wsa5:To", &a->wsa5__To, ""))
				{	soap_flag_wsa5__To--;
					continue;
				}
			if (soap_flag_wsa5__Action && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__wsa5__Action(soap, "wsa5:Action", &a->wsa5__Action, ""))
				{	soap_flag_wsa5__Action--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Header, 0, sizeof(struct SOAP_ENV__Header), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Header);
	if (soap_out_SOAP_ENV__Header(soap, tag?tag:"SOAP-ENV:Header", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsa__Relationship(struct soap *soap, struct wsa__Relationship *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default__QName(soap, &a->RelationshipType);
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsa__Relationship(struct soap *soap, const struct wsa__Relationship *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->__item);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa__Relationship(struct soap *soap, const char *tag, int id, const struct wsa__Relationship *a, const char *type)
{
	if (a->RelationshipType)
		soap_set_attr(soap, "RelationshipType", soap_QName2s(soap, a->RelationshipType), 1);
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	return soap_out_string(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct wsa__Relationship * SOAP_FMAC4 soap_in_wsa__Relationship(struct soap *soap, const char *tag, struct wsa__Relationship *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct wsa__Relationship *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa__Relationship, sizeof(struct wsa__Relationship), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default_wsa__Relationship(soap, a);
	if (soap_s2QName(soap, soap_attr_value(soap, "RelationshipType", 0), &a->RelationshipType, -1, -1))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (!soap_in_string(soap, tag, &a->__item, "wsa:Relationship"))
		return NULL;
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa__Relationship(struct soap *soap, const struct wsa__Relationship *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wsa__Relationship);
	if (soap_out_wsa__Relationship(soap, tag?tag:"wsa:Relationship", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa__Relationship * SOAP_FMAC4 soap_get_wsa__Relationship(struct soap *soap, struct wsa__Relationship *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa__Relationship(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsa__ServiceNameType(struct soap *soap, struct wsa__ServiceNameType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->__item);
	soap_default_string(soap, &a->PortName);
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsa__ServiceNameType(struct soap *soap, const struct wsa__ServiceNameType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->__item);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa__ServiceNameType(struct soap *soap, const char *tag, int id, const struct wsa__ServiceNameType *a, const char *type)
{
	const char *soap_tmp___item = soap_QName2s(soap, a->__item);
	if (a->PortName)
		soap_set_attr(soap, "PortName", a->PortName, 1);
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	return soap_out__QName(soap, tag, id, (char*const*)&soap_tmp___item, "");
}

SOAP_FMAC3 struct wsa__ServiceNameType * SOAP_FMAC4 soap_in_wsa__ServiceNameType(struct soap *soap, const char *tag, struct wsa__ServiceNameType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct wsa__ServiceNameType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa__ServiceNameType, sizeof(struct wsa__ServiceNameType), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default_wsa__ServiceNameType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "PortName", 0), &a->PortName, -1, -1))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (!soap_in__QName(soap, tag, &a->__item, "wsa:ServiceNameType"))
		return NULL;
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa__ServiceNameType(struct soap *soap, const struct wsa__ServiceNameType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wsa__ServiceNameType);
	if (soap_out_wsa__ServiceNameType(soap, tag?tag:"wsa:ServiceNameType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa__ServiceNameType * SOAP_FMAC4 soap_get_wsa__ServiceNameType(struct soap *soap, struct wsa__ServiceNameType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa__ServiceNameType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsa__ReferenceParametersType(struct soap *soap, struct wsa__ReferenceParametersType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsa__ReferenceParametersType(struct soap *soap, const struct wsa__ReferenceParametersType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa__ReferenceParametersType(struct soap *soap, const char *tag, int id, const struct wsa__ReferenceParametersType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsa__ReferenceParametersType), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsa__ReferenceParametersType * SOAP_FMAC4 soap_in_wsa__ReferenceParametersType(struct soap *soap, const char *tag, struct wsa__ReferenceParametersType *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wsa__ReferenceParametersType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa__ReferenceParametersType, sizeof(struct wsa__ReferenceParametersType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsa__ReferenceParametersType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wsa__ReferenceParametersType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsa__ReferenceParametersType, 0, sizeof(struct wsa__ReferenceParametersType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa__ReferenceParametersType(struct soap *soap, const struct wsa__ReferenceParametersType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wsa__ReferenceParametersType);
	if (soap_out_wsa__ReferenceParametersType(soap, tag?tag:"wsa:ReferenceParametersType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa__ReferenceParametersType * SOAP_FMAC4 soap_get_wsa__ReferenceParametersType(struct soap *soap, struct wsa__ReferenceParametersType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa__ReferenceParametersType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsa__ReferencePropertiesType(struct soap *soap, struct wsa__ReferencePropertiesType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsa__ReferencePropertiesType(struct soap *soap, const struct wsa__ReferencePropertiesType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa__ReferencePropertiesType(struct soap *soap, const char *tag, int id, const struct wsa__ReferencePropertiesType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsa__ReferencePropertiesType), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsa__ReferencePropertiesType * SOAP_FMAC4 soap_in_wsa__ReferencePropertiesType(struct soap *soap, const char *tag, struct wsa__ReferencePropertiesType *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wsa__ReferencePropertiesType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa__ReferencePropertiesType, sizeof(struct wsa__ReferencePropertiesType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsa__ReferencePropertiesType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wsa__ReferencePropertiesType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsa__ReferencePropertiesType, 0, sizeof(struct wsa__ReferencePropertiesType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa__ReferencePropertiesType(struct soap *soap, const struct wsa__ReferencePropertiesType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wsa__ReferencePropertiesType);
	if (soap_out_wsa__ReferencePropertiesType(soap, tag?tag:"wsa:ReferencePropertiesType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa__ReferencePropertiesType * SOAP_FMAC4 soap_get_wsa__ReferencePropertiesType(struct soap *soap, struct wsa__ReferencePropertiesType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa__ReferencePropertiesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsa__EndpointReferenceType(struct soap *soap, struct wsa__EndpointReferenceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Address);
	a->ReferenceProperties = NULL;
	a->ReferenceParameters = NULL;
	a->PortType = NULL;
	a->ServiceName = NULL;
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsa__EndpointReferenceType(struct soap *soap, const struct wsa__EndpointReferenceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Address);
	soap_serialize_PointerTowsa__ReferencePropertiesType(soap, &a->ReferenceProperties);
	soap_serialize_PointerTowsa__ReferenceParametersType(soap, &a->ReferenceParameters);
	soap_serialize_PointerTo_QName(soap, &a->PortType);
	soap_serialize_PointerTowsa__ServiceNameType(soap, &a->ServiceName);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa__EndpointReferenceType(struct soap *soap, const char *tag, int id, const struct wsa__EndpointReferenceType *a, const char *type)
{
	const char *soap_tmp_PortType = a->PortType ? soap_QName2s(soap, *a->PortType) : NULL;
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsa__EndpointReferenceType), type))
		return soap->error;
	if (a->Address)
	{	if (soap_out_string(soap, "wsa:Address", -1, &a->Address, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "wsa:Address"))
		return soap->error;
	if (soap_out_PointerTowsa__ReferencePropertiesType(soap, "wsa:ReferenceProperties", -1, &a->ReferenceProperties, ""))
		return soap->error;
	if (soap_out_PointerTowsa__ReferenceParametersType(soap, "wsa:ReferenceParameters", -1, &a->ReferenceParameters, ""))
		return soap->error;
	if (soap_out__QName(soap, "wsa:PortType", -1, (char*const*)&soap_tmp_PortType, ""))
		return soap->error;
	if (soap_out_PointerTowsa__ServiceNameType(soap, "wsa:ServiceName", -1, &a->ServiceName, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsa__EndpointReferenceType * SOAP_FMAC4 soap_in_wsa__EndpointReferenceType(struct soap *soap, const char *tag, struct wsa__EndpointReferenceType *a, const char *type)
{
	size_t soap_flag_Address = 1;
	size_t soap_flag_ReferenceProperties = 1;
	size_t soap_flag_ReferenceParameters = 1;
	size_t soap_flag_PortType = 1;
	size_t soap_flag_ServiceName = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wsa__EndpointReferenceType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa__EndpointReferenceType, sizeof(struct wsa__EndpointReferenceType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsa__EndpointReferenceType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Address && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "wsa:Address", &a->Address, "xsd:string"))
				{	soap_flag_Address--;
					continue;
				}
			if (soap_flag_ReferenceProperties && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsa__ReferencePropertiesType(soap, "wsa:ReferenceProperties", &a->ReferenceProperties, "wsa:ReferencePropertiesType"))
				{	soap_flag_ReferenceProperties--;
					continue;
				}
			if (soap_flag_ReferenceParameters && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsa__ReferenceParametersType(soap, "wsa:ReferenceParameters", &a->ReferenceParameters, "wsa:ReferenceParametersType"))
				{	soap_flag_ReferenceParameters--;
					continue;
				}
			if (soap_flag_PortType && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_QName(soap, "wsa:PortType", &a->PortType, ""))
				{	soap_flag_PortType--;
					continue;
				}
			if (soap_flag_ServiceName && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsa__ServiceNameType(soap, "wsa:ServiceName", &a->ServiceName, "wsa:ServiceNameType"))
				{	soap_flag_ServiceName--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wsa__EndpointReferenceType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsa__EndpointReferenceType, 0, sizeof(struct wsa__EndpointReferenceType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Address > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa__EndpointReferenceType(struct soap *soap, const struct wsa__EndpointReferenceType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wsa__EndpointReferenceType);
	if (soap_out_wsa__EndpointReferenceType(soap, tag?tag:"wsa:EndpointReferenceType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa__EndpointReferenceType * SOAP_FMAC4 soap_get_wsa__EndpointReferenceType(struct soap *soap, struct wsa__EndpointReferenceType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa__EndpointReferenceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tt__union_EventStream(struct soap *soap, int choice, const union _tt__union_EventStream *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	switch (choice)
	{
	case SOAP_UNION__tt__union_EventStream_wsnt__NotificationMessage:
		soap_serialize_PointerTowsnt__NotificationMessageHolderType(soap, &a->wsnt__NotificationMessage);
		break;
	case SOAP_UNION__tt__union_EventStream_Extension:
		soap_serialize_PointerTott__EventStreamExtension(soap, &a->Extension);
		break;
	default:
		break;
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tt__union_EventStream(struct soap *soap, int choice, const union _tt__union_EventStream *a)
{
	switch (choice)
	{
	case SOAP_UNION__tt__union_EventStream_wsnt__NotificationMessage:
		return soap_out_PointerTowsnt__NotificationMessageHolderType(soap, "wsnt:NotificationMessage", -1, &a->wsnt__NotificationMessage, "");
	case SOAP_UNION__tt__union_EventStream_Extension:
		return soap_out_PointerTott__EventStreamExtension(soap, "tt:Extension", -1, &a->Extension, "");
	default:
		break;
	}
	return SOAP_OK;
}

SOAP_FMAC3 union _tt__union_EventStream * SOAP_FMAC4 soap_in__tt__union_EventStream(struct soap *soap, int *choice, union _tt__union_EventStream *a)
{	soap->error = SOAP_TAG_MISMATCH;
	a->wsnt__NotificationMessage = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTowsnt__NotificationMessageHolderType(soap, "wsnt:NotificationMessage", &a->wsnt__NotificationMessage, "wsnt:NotificationMessageHolderType"))
	{	*choice = SOAP_UNION__tt__union_EventStream_wsnt__NotificationMessage;
		return a;
	}
	a->Extension = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTott__EventStreamExtension(soap, "tt:Extension", &a->Extension, "tt:EventStreamExtension"))
	{	*choice = SOAP_UNION__tt__union_EventStream_Extension;
		return a;
	}
	*choice = 0;
	if (!soap->error)
		soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tt__union_PTZStream(struct soap *soap, int choice, const union _tt__union_PTZStream *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	switch (choice)
	{
	case SOAP_UNION__tt__union_PTZStream_PTZStatus:
		soap_serialize_PointerTott__PTZStatus(soap, &a->PTZStatus);
		break;
	case SOAP_UNION__tt__union_PTZStream_Extension:
		soap_serialize_PointerTott__PTZStreamExtension(soap, &a->Extension);
		break;
	default:
		break;
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tt__union_PTZStream(struct soap *soap, int choice, const union _tt__union_PTZStream *a)
{
	switch (choice)
	{
	case SOAP_UNION__tt__union_PTZStream_PTZStatus:
		return soap_out_PointerTott__PTZStatus(soap, "tt:PTZStatus", -1, &a->PTZStatus, "");
	case SOAP_UNION__tt__union_PTZStream_Extension:
		return soap_out_PointerTott__PTZStreamExtension(soap, "tt:Extension", -1, &a->Extension, "");
	default:
		break;
	}
	return SOAP_OK;
}

SOAP_FMAC3 union _tt__union_PTZStream * SOAP_FMAC4 soap_in__tt__union_PTZStream(struct soap *soap, int *choice, union _tt__union_PTZStream *a)
{	soap->error = SOAP_TAG_MISMATCH;
	a->PTZStatus = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTott__PTZStatus(soap, "tt:PTZStatus", &a->PTZStatus, "tt:PTZStatus"))
	{	*choice = SOAP_UNION__tt__union_PTZStream_PTZStatus;
		return a;
	}
	a->Extension = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTott__PTZStreamExtension(soap, "tt:Extension", &a->Extension, "tt:PTZStreamExtension"))
	{	*choice = SOAP_UNION__tt__union_PTZStream_Extension;
		return a;
	}
	*choice = 0;
	if (!soap->error)
		soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tt__union_VideoAnalyticsStream(struct soap *soap, int choice, const union _tt__union_VideoAnalyticsStream *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	switch (choice)
	{
	case SOAP_UNION__tt__union_VideoAnalyticsStream_Frame:
		soap_serialize_PointerTott__Frame(soap, &a->Frame);
		break;
	case SOAP_UNION__tt__union_VideoAnalyticsStream_Extension:
		soap_serialize_PointerTott__VideoAnalyticsStreamExtension(soap, &a->Extension);
		break;
	default:
		break;
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tt__union_VideoAnalyticsStream(struct soap *soap, int choice, const union _tt__union_VideoAnalyticsStream *a)
{
	switch (choice)
	{
	case SOAP_UNION__tt__union_VideoAnalyticsStream_Frame:
		return soap_out_PointerTott__Frame(soap, "tt:Frame", -1, &a->Frame, "");
	case SOAP_UNION__tt__union_VideoAnalyticsStream_Extension:
		return soap_out_PointerTott__VideoAnalyticsStreamExtension(soap, "tt:Extension", -1, &a->Extension, "");
	default:
		break;
	}
	return SOAP_OK;
}

SOAP_FMAC3 union _tt__union_VideoAnalyticsStream * SOAP_FMAC4 soap_in__tt__union_VideoAnalyticsStream(struct soap *soap, int *choice, union _tt__union_VideoAnalyticsStream *a)
{	soap->error = SOAP_TAG_MISMATCH;
	a->Frame = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTott__Frame(soap, "tt:Frame", &a->Frame, "tt:Frame"))
	{	*choice = SOAP_UNION__tt__union_VideoAnalyticsStream_Frame;
		return a;
	}
	a->Extension = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTott__VideoAnalyticsStreamExtension(soap, "tt:Extension", &a->Extension, "tt:VideoAnalyticsStreamExtension"))
	{	*choice = SOAP_UNION__tt__union_VideoAnalyticsStream_Extension;
		return a;
	}
	*choice = 0;
	if (!soap->error)
		soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tt__union_MetadataStream(struct soap *soap, int choice, const union _tt__union_MetadataStream *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	switch (choice)
	{
	case SOAP_UNION__tt__union_MetadataStream_VideoAnalytics:
		soap_serialize_PointerTott__VideoAnalyticsStream(soap, &a->VideoAnalytics);
		break;
	case SOAP_UNION__tt__union_MetadataStream_PTZ:
		soap_serialize_PointerTott__PTZStream(soap, &a->PTZ);
		break;
	case SOAP_UNION__tt__union_MetadataStream_Event:
		soap_serialize_PointerTott__EventStream(soap, &a->Event);
		break;
	case SOAP_UNION__tt__union_MetadataStream_Extension:
		soap_serialize_PointerTott__MetadataStreamExtension(soap, &a->Extension);
		break;
	default:
		break;
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tt__union_MetadataStream(struct soap *soap, int choice, const union _tt__union_MetadataStream *a)
{
	switch (choice)
	{
	case SOAP_UNION__tt__union_MetadataStream_VideoAnalytics:
		return soap_out_PointerTott__VideoAnalyticsStream(soap, "tt:VideoAnalytics", -1, &a->VideoAnalytics, "");
	case SOAP_UNION__tt__union_MetadataStream_PTZ:
		return soap_out_PointerTott__PTZStream(soap, "tt:PTZ", -1, &a->PTZ, "");
	case SOAP_UNION__tt__union_MetadataStream_Event:
		return soap_out_PointerTott__EventStream(soap, "tt:Event", -1, &a->Event, "");
	case SOAP_UNION__tt__union_MetadataStream_Extension:
		return soap_out_PointerTott__MetadataStreamExtension(soap, "tt:Extension", -1, &a->Extension, "");
	default:
		break;
	}
	return SOAP_OK;
}

SOAP_FMAC3 union _tt__union_MetadataStream * SOAP_FMAC4 soap_in__tt__union_MetadataStream(struct soap *soap, int *choice, union _tt__union_MetadataStream *a)
{	soap->error = SOAP_TAG_MISMATCH;
	a->VideoAnalytics = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTott__VideoAnalyticsStream(soap, "tt:VideoAnalytics", &a->VideoAnalytics, "tt:VideoAnalyticsStream"))
	{	*choice = SOAP_UNION__tt__union_MetadataStream_VideoAnalytics;
		return a;
	}
	a->PTZ = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTott__PTZStream(soap, "tt:PTZ", &a->PTZ, "tt:PTZStream"))
	{	*choice = SOAP_UNION__tt__union_MetadataStream_PTZ;
		return a;
	}
	a->Event = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTott__EventStream(soap, "tt:Event", &a->Event, "tt:EventStream"))
	{	*choice = SOAP_UNION__tt__union_MetadataStream_Event;
		return a;
	}
	a->Extension = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTott__MetadataStreamExtension(soap, "tt:Extension", &a->Extension, "tt:MetadataStreamExtension"))
	{	*choice = SOAP_UNION__tt__union_MetadataStream_Extension;
		return a;
	}
	*choice = 0;
	if (!soap->error)
		soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Reason))
		soap_serialize_SOAP_ENV__Reason(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Reason *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Reason);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Reason(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Reason **)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Reason(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Reason);
	if (soap_out_PointerToSOAP_ENV__Reason(soap, tag?tag:"SOAP-ENV:Reason", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Detail))
		soap_serialize_SOAP_ENV__Detail(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Detail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Detail);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Detail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Detail **)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Detail(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Detail);
	if (soap_out_PointerToSOAP_ENV__Detail(soap, tag?tag:"SOAP-ENV:Detail", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Code))
		soap_serialize_SOAP_ENV__Code(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Code);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Code(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Code **)soap_malloc(soap, sizeof(struct SOAP_ENV__Code *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Code);
	if (soap_out_PointerToSOAP_ENV__Code(soap, tag?tag:"SOAP-ENV:Code", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetSnapshotUriResponse(struct soap *soap, struct _trt__GetSnapshotUriResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetSnapshotUriResponse))
		soap_serialize__trt__GetSnapshotUriResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetSnapshotUriResponse(struct soap *soap, const char *tag, int id, struct _trt__GetSnapshotUriResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetSnapshotUriResponse);
	if (id < 0)
		return soap->error;
	return soap_out__trt__GetSnapshotUriResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__GetSnapshotUriResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__GetSnapshotUriResponse(struct soap *soap, const char *tag, struct _trt__GetSnapshotUriResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__GetSnapshotUriResponse **)soap_malloc(soap, sizeof(struct _trt__GetSnapshotUriResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__GetSnapshotUriResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__GetSnapshotUriResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetSnapshotUriResponse, sizeof(struct _trt__GetSnapshotUriResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetSnapshotUriResponse(struct soap *soap, struct _trt__GetSnapshotUriResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetSnapshotUriResponse);
	if (soap_out_PointerTo_trt__GetSnapshotUriResponse(soap, tag?tag:"trt:GetSnapshotUriResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetSnapshotUriResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__GetSnapshotUriResponse(struct soap *soap, struct _trt__GetSnapshotUriResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetSnapshotUriResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetSnapshotUri(struct soap *soap, struct _trt__GetSnapshotUri *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetSnapshotUri))
		soap_serialize__trt__GetSnapshotUri(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetSnapshotUri(struct soap *soap, const char *tag, int id, struct _trt__GetSnapshotUri *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetSnapshotUri);
	if (id < 0)
		return soap->error;
	return soap_out__trt__GetSnapshotUri(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__GetSnapshotUri ** SOAP_FMAC4 soap_in_PointerTo_trt__GetSnapshotUri(struct soap *soap, const char *tag, struct _trt__GetSnapshotUri **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__GetSnapshotUri **)soap_malloc(soap, sizeof(struct _trt__GetSnapshotUri *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__GetSnapshotUri(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__GetSnapshotUri **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetSnapshotUri, sizeof(struct _trt__GetSnapshotUri), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetSnapshotUri(struct soap *soap, struct _trt__GetSnapshotUri *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetSnapshotUri);
	if (soap_out_PointerTo_trt__GetSnapshotUri(soap, tag?tag:"trt:GetSnapshotUri", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetSnapshotUri ** SOAP_FMAC4 soap_get_PointerTo_trt__GetSnapshotUri(struct soap *soap, struct _trt__GetSnapshotUri **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetSnapshotUri(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__SetSynchronizationPointResponse(struct soap *soap, struct _trt__SetSynchronizationPointResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__SetSynchronizationPointResponse))
		soap_serialize__trt__SetSynchronizationPointResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__SetSynchronizationPointResponse(struct soap *soap, const char *tag, int id, struct _trt__SetSynchronizationPointResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__SetSynchronizationPointResponse);
	if (id < 0)
		return soap->error;
	return soap_out__trt__SetSynchronizationPointResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__SetSynchronizationPointResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__SetSynchronizationPointResponse(struct soap *soap, const char *tag, struct _trt__SetSynchronizationPointResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__SetSynchronizationPointResponse **)soap_malloc(soap, sizeof(struct _trt__SetSynchronizationPointResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__SetSynchronizationPointResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__SetSynchronizationPointResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__SetSynchronizationPointResponse, sizeof(struct _trt__SetSynchronizationPointResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__SetSynchronizationPointResponse(struct soap *soap, struct _trt__SetSynchronizationPointResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__SetSynchronizationPointResponse);
	if (soap_out_PointerTo_trt__SetSynchronizationPointResponse(soap, tag?tag:"trt:SetSynchronizationPointResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__SetSynchronizationPointResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__SetSynchronizationPointResponse(struct soap *soap, struct _trt__SetSynchronizationPointResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__SetSynchronizationPointResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__SetSynchronizationPoint(struct soap *soap, struct _trt__SetSynchronizationPoint *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__SetSynchronizationPoint))
		soap_serialize__trt__SetSynchronizationPoint(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__SetSynchronizationPoint(struct soap *soap, const char *tag, int id, struct _trt__SetSynchronizationPoint *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__SetSynchronizationPoint);
	if (id < 0)
		return soap->error;
	return soap_out__trt__SetSynchronizationPoint(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__SetSynchronizationPoint ** SOAP_FMAC4 soap_in_PointerTo_trt__SetSynchronizationPoint(struct soap *soap, const char *tag, struct _trt__SetSynchronizationPoint **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__SetSynchronizationPoint **)soap_malloc(soap, sizeof(struct _trt__SetSynchronizationPoint *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__SetSynchronizationPoint(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__SetSynchronizationPoint **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__SetSynchronizationPoint, sizeof(struct _trt__SetSynchronizationPoint), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__SetSynchronizationPoint(struct soap *soap, struct _trt__SetSynchronizationPoint *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__SetSynchronizationPoint);
	if (soap_out_PointerTo_trt__SetSynchronizationPoint(soap, tag?tag:"trt:SetSynchronizationPoint", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__SetSynchronizationPoint ** SOAP_FMAC4 soap_get_PointerTo_trt__SetSynchronizationPoint(struct soap *soap, struct _trt__SetSynchronizationPoint **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__SetSynchronizationPoint(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__StopMulticastStreamingResponse(struct soap *soap, struct _trt__StopMulticastStreamingResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__StopMulticastStreamingResponse))
		soap_serialize__trt__StopMulticastStreamingResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__StopMulticastStreamingResponse(struct soap *soap, const char *tag, int id, struct _trt__StopMulticastStreamingResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__StopMulticastStreamingResponse);
	if (id < 0)
		return soap->error;
	return soap_out__trt__StopMulticastStreamingResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__StopMulticastStreamingResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__StopMulticastStreamingResponse(struct soap *soap, const char *tag, struct _trt__StopMulticastStreamingResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__StopMulticastStreamingResponse **)soap_malloc(soap, sizeof(struct _trt__StopMulticastStreamingResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__StopMulticastStreamingResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__StopMulticastStreamingResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__StopMulticastStreamingResponse, sizeof(struct _trt__StopMulticastStreamingResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__StopMulticastStreamingResponse(struct soap *soap, struct _trt__StopMulticastStreamingResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__StopMulticastStreamingResponse);
	if (soap_out_PointerTo_trt__StopMulticastStreamingResponse(soap, tag?tag:"trt:StopMulticastStreamingResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__StopMulticastStreamingResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__StopMulticastStreamingResponse(struct soap *soap, struct _trt__StopMulticastStreamingResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__StopMulticastStreamingResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__StopMulticastStreaming(struct soap *soap, struct _trt__StopMulticastStreaming *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__StopMulticastStreaming))
		soap_serialize__trt__StopMulticastStreaming(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__StopMulticastStreaming(struct soap *soap, const char *tag, int id, struct _trt__StopMulticastStreaming *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__StopMulticastStreaming);
	if (id < 0)
		return soap->error;
	return soap_out__trt__StopMulticastStreaming(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__StopMulticastStreaming ** SOAP_FMAC4 soap_in_PointerTo_trt__StopMulticastStreaming(struct soap *soap, const char *tag, struct _trt__StopMulticastStreaming **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__StopMulticastStreaming **)soap_malloc(soap, sizeof(struct _trt__StopMulticastStreaming *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__StopMulticastStreaming(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__StopMulticastStreaming **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__StopMulticastStreaming, sizeof(struct _trt__StopMulticastStreaming), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__StopMulticastStreaming(struct soap *soap, struct _trt__StopMulticastStreaming *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__StopMulticastStreaming);
	if (soap_out_PointerTo_trt__StopMulticastStreaming(soap, tag?tag:"trt:StopMulticastStreaming", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__StopMulticastStreaming ** SOAP_FMAC4 soap_get_PointerTo_trt__StopMulticastStreaming(struct soap *soap, struct _trt__StopMulticastStreaming **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__StopMulticastStreaming(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__StartMulticastStreamingResponse(struct soap *soap, struct _trt__StartMulticastStreamingResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__StartMulticastStreamingResponse))
		soap_serialize__trt__StartMulticastStreamingResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__StartMulticastStreamingResponse(struct soap *soap, const char *tag, int id, struct _trt__StartMulticastStreamingResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__StartMulticastStreamingResponse);
	if (id < 0)
		return soap->error;
	return soap_out__trt__StartMulticastStreamingResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__StartMulticastStreamingResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__StartMulticastStreamingResponse(struct soap *soap, const char *tag, struct _trt__StartMulticastStreamingResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__StartMulticastStreamingResponse **)soap_malloc(soap, sizeof(struct _trt__StartMulticastStreamingResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__StartMulticastStreamingResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__StartMulticastStreamingResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__StartMulticastStreamingResponse, sizeof(struct _trt__StartMulticastStreamingResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__StartMulticastStreamingResponse(struct soap *soap, struct _trt__StartMulticastStreamingResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__StartMulticastStreamingResponse);
	if (soap_out_PointerTo_trt__StartMulticastStreamingResponse(soap, tag?tag:"trt:StartMulticastStreamingResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__StartMulticastStreamingResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__StartMulticastStreamingResponse(struct soap *soap, struct _trt__StartMulticastStreamingResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__StartMulticastStreamingResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__StartMulticastStreaming(struct soap *soap, struct _trt__StartMulticastStreaming *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__StartMulticastStreaming))
		soap_serialize__trt__StartMulticastStreaming(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__StartMulticastStreaming(struct soap *soap, const char *tag, int id, struct _trt__StartMulticastStreaming *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__StartMulticastStreaming);
	if (id < 0)
		return soap->error;
	return soap_out__trt__StartMulticastStreaming(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__StartMulticastStreaming ** SOAP_FMAC4 soap_in_PointerTo_trt__StartMulticastStreaming(struct soap *soap, const char *tag, struct _trt__StartMulticastStreaming **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__StartMulticastStreaming **)soap_malloc(soap, sizeof(struct _trt__StartMulticastStreaming *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__StartMulticastStreaming(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__StartMulticastStreaming **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__StartMulticastStreaming, sizeof(struct _trt__StartMulticastStreaming), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__StartMulticastStreaming(struct soap *soap, struct _trt__StartMulticastStreaming *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__StartMulticastStreaming);
	if (soap_out_PointerTo_trt__StartMulticastStreaming(soap, tag?tag:"trt:StartMulticastStreaming", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__StartMulticastStreaming ** SOAP_FMAC4 soap_get_PointerTo_trt__StartMulticastStreaming(struct soap *soap, struct _trt__StartMulticastStreaming **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__StartMulticastStreaming(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetStreamUriResponse(struct soap *soap, struct _trt__GetStreamUriResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetStreamUriResponse))
		soap_serialize__trt__GetStreamUriResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetStreamUriResponse(struct soap *soap, const char *tag, int id, struct _trt__GetStreamUriResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetStreamUriResponse);
	if (id < 0)
		return soap->error;
	return soap_out__trt__GetStreamUriResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__GetStreamUriResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__GetStreamUriResponse(struct soap *soap, const char *tag, struct _trt__GetStreamUriResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__GetStreamUriResponse **)soap_malloc(soap, sizeof(struct _trt__GetStreamUriResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__GetStreamUriResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__GetStreamUriResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetStreamUriResponse, sizeof(struct _trt__GetStreamUriResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetStreamUriResponse(struct soap *soap, struct _trt__GetStreamUriResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetStreamUriResponse);
	if (soap_out_PointerTo_trt__GetStreamUriResponse(soap, tag?tag:"trt:GetStreamUriResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetStreamUriResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__GetStreamUriResponse(struct soap *soap, struct _trt__GetStreamUriResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetStreamUriResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetStreamUri(struct soap *soap, struct _trt__GetStreamUri *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetStreamUri))
		soap_serialize__trt__GetStreamUri(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetStreamUri(struct soap *soap, const char *tag, int id, struct _trt__GetStreamUri *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetStreamUri);
	if (id < 0)
		return soap->error;
	return soap_out__trt__GetStreamUri(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__GetStreamUri ** SOAP_FMAC4 soap_in_PointerTo_trt__GetStreamUri(struct soap *soap, const char *tag, struct _trt__GetStreamUri **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__GetStreamUri **)soap_malloc(soap, sizeof(struct _trt__GetStreamUri *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__GetStreamUri(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__GetStreamUri **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetStreamUri, sizeof(struct _trt__GetStreamUri), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetStreamUri(struct soap *soap, struct _trt__GetStreamUri *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetStreamUri);
	if (soap_out_PointerTo_trt__GetStreamUri(soap, tag?tag:"trt:GetStreamUri", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetStreamUri ** SOAP_FMAC4 soap_get_PointerTo_trt__GetStreamUri(struct soap *soap, struct _trt__GetStreamUri **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetStreamUri(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse(struct soap *soap, struct _trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse))
		soap_serialize__trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse(struct soap *soap, const char *tag, int id, struct _trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse);
	if (id < 0)
		return soap->error;
	return soap_out__trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse(struct soap *soap, const char *tag, struct _trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse **)soap_malloc(soap, sizeof(struct _trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse, sizeof(struct _trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse(struct soap *soap, struct _trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse);
	if (soap_out_PointerTo_trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse(soap, tag?tag:"trt:GetGuaranteedNumberOfVideoEncoderInstancesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse(struct soap *soap, struct _trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetGuaranteedNumberOfVideoEncoderInstances(struct soap *soap, struct _trt__GetGuaranteedNumberOfVideoEncoderInstances *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetGuaranteedNumberOfVideoEncoderInstances))
		soap_serialize__trt__GetGuaranteedNumberOfVideoEncoderInstances(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetGuaranteedNumberOfVideoEncoderInstances(struct soap *soap, const char *tag, int id, struct _trt__GetGuaranteedNumberOfVideoEncoderInstances *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetGuaranteedNumberOfVideoEncoderInstances);
	if (id < 0)
		return soap->error;
	return soap_out__trt__GetGuaranteedNumberOfVideoEncoderInstances(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__GetGuaranteedNumberOfVideoEncoderInstances ** SOAP_FMAC4 soap_in_PointerTo_trt__GetGuaranteedNumberOfVideoEncoderInstances(struct soap *soap, const char *tag, struct _trt__GetGuaranteedNumberOfVideoEncoderInstances **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__GetGuaranteedNumberOfVideoEncoderInstances **)soap_malloc(soap, sizeof(struct _trt__GetGuaranteedNumberOfVideoEncoderInstances *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__GetGuaranteedNumberOfVideoEncoderInstances(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__GetGuaranteedNumberOfVideoEncoderInstances **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetGuaranteedNumberOfVideoEncoderInstances, sizeof(struct _trt__GetGuaranteedNumberOfVideoEncoderInstances), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetGuaranteedNumberOfVideoEncoderInstances(struct soap *soap, struct _trt__GetGuaranteedNumberOfVideoEncoderInstances *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetGuaranteedNumberOfVideoEncoderInstances);
	if (soap_out_PointerTo_trt__GetGuaranteedNumberOfVideoEncoderInstances(soap, tag?tag:"trt:GetGuaranteedNumberOfVideoEncoderInstances", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetGuaranteedNumberOfVideoEncoderInstances ** SOAP_FMAC4 soap_get_PointerTo_trt__GetGuaranteedNumberOfVideoEncoderInstances(struct soap *soap, struct _trt__GetGuaranteedNumberOfVideoEncoderInstances **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetGuaranteedNumberOfVideoEncoderInstances(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetAudioDecoderConfigurationOptionsResponse(struct soap *soap, struct _trt__GetAudioDecoderConfigurationOptionsResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetAudioDecoderConfigurationOptionsResponse))
		soap_serialize__trt__GetAudioDecoderConfigurationOptionsResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetAudioDecoderConfigurationOptionsResponse(struct soap *soap, const char *tag, int id, struct _trt__GetAudioDecoderConfigurationOptionsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetAudioDecoderConfigurationOptionsResponse);
	if (id < 0)
		return soap->error;
	return soap_out__trt__GetAudioDecoderConfigurationOptionsResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__GetAudioDecoderConfigurationOptionsResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__GetAudioDecoderConfigurationOptionsResponse(struct soap *soap, const char *tag, struct _trt__GetAudioDecoderConfigurationOptionsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__GetAudioDecoderConfigurationOptionsResponse **)soap_malloc(soap, sizeof(struct _trt__GetAudioDecoderConfigurationOptionsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__GetAudioDecoderConfigurationOptionsResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__GetAudioDecoderConfigurationOptionsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetAudioDecoderConfigurationOptionsResponse, sizeof(struct _trt__GetAudioDecoderConfigurationOptionsResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetAudioDecoderConfigurationOptionsResponse(struct soap *soap, struct _trt__GetAudioDecoderConfigurationOptionsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetAudioDecoderConfigurationOptionsResponse);
	if (soap_out_PointerTo_trt__GetAudioDecoderConfigurationOptionsResponse(soap, tag?tag:"trt:GetAudioDecoderConfigurationOptionsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetAudioDecoderConfigurationOptionsResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__GetAudioDecoderConfigurationOptionsResponse(struct soap *soap, struct _trt__GetAudioDecoderConfigurationOptionsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetAudioDecoderConfigurationOptionsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetAudioDecoderConfigurationOptions(struct soap *soap, struct _trt__GetAudioDecoderConfigurationOptions *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetAudioDecoderConfigurationOptions))
		soap_serialize__trt__GetAudioDecoderConfigurationOptions(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetAudioDecoderConfigurationOptions(struct soap *soap, const char *tag, int id, struct _trt__GetAudioDecoderConfigurationOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetAudioDecoderConfigurationOptions);
	if (id < 0)
		return soap->error;
	return soap_out__trt__GetAudioDecoderConfigurationOptions(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__GetAudioDecoderConfigurationOptions ** SOAP_FMAC4 soap_in_PointerTo_trt__GetAudioDecoderConfigurationOptions(struct soap *soap, const char *tag, struct _trt__GetAudioDecoderConfigurationOptions **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__GetAudioDecoderConfigurationOptions **)soap_malloc(soap, sizeof(struct _trt__GetAudioDecoderConfigurationOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__GetAudioDecoderConfigurationOptions(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__GetAudioDecoderConfigurationOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetAudioDecoderConfigurationOptions, sizeof(struct _trt__GetAudioDecoderConfigurationOptions), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetAudioDecoderConfigurationOptions(struct soap *soap, struct _trt__GetAudioDecoderConfigurationOptions *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetAudioDecoderConfigurationOptions);
	if (soap_out_PointerTo_trt__GetAudioDecoderConfigurationOptions(soap, tag?tag:"trt:GetAudioDecoderConfigurationOptions", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetAudioDecoderConfigurationOptions ** SOAP_FMAC4 soap_get_PointerTo_trt__GetAudioDecoderConfigurationOptions(struct soap *soap, struct _trt__GetAudioDecoderConfigurationOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetAudioDecoderConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetAudioOutputConfigurationOptionsResponse(struct soap *soap, struct _trt__GetAudioOutputConfigurationOptionsResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetAudioOutputConfigurationOptionsResponse))
		soap_serialize__trt__GetAudioOutputConfigurationOptionsResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetAudioOutputConfigurationOptionsResponse(struct soap *soap, const char *tag, int id, struct _trt__GetAudioOutputConfigurationOptionsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetAudioOutputConfigurationOptionsResponse);
	if (id < 0)
		return soap->error;
	return soap_out__trt__GetAudioOutputConfigurationOptionsResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__GetAudioOutputConfigurationOptionsResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__GetAudioOutputConfigurationOptionsResponse(struct soap *soap, const char *tag, struct _trt__GetAudioOutputConfigurationOptionsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__GetAudioOutputConfigurationOptionsResponse **)soap_malloc(soap, sizeof(struct _trt__GetAudioOutputConfigurationOptionsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__GetAudioOutputConfigurationOptionsResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__GetAudioOutputConfigurationOptionsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetAudioOutputConfigurationOptionsResponse, sizeof(struct _trt__GetAudioOutputConfigurationOptionsResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetAudioOutputConfigurationOptionsResponse(struct soap *soap, struct _trt__GetAudioOutputConfigurationOptionsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetAudioOutputConfigurationOptionsResponse);
	if (soap_out_PointerTo_trt__GetAudioOutputConfigurationOptionsResponse(soap, tag?tag:"trt:GetAudioOutputConfigurationOptionsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetAudioOutputConfigurationOptionsResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__GetAudioOutputConfigurationOptionsResponse(struct soap *soap, struct _trt__GetAudioOutputConfigurationOptionsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetAudioOutputConfigurationOptionsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetAudioOutputConfigurationOptions(struct soap *soap, struct _trt__GetAudioOutputConfigurationOptions *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetAudioOutputConfigurationOptions))
		soap_serialize__trt__GetAudioOutputConfigurationOptions(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetAudioOutputConfigurationOptions(struct soap *soap, const char *tag, int id, struct _trt__GetAudioOutputConfigurationOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetAudioOutputConfigurationOptions);
	if (id < 0)
		return soap->error;
	return soap_out__trt__GetAudioOutputConfigurationOptions(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__GetAudioOutputConfigurationOptions ** SOAP_FMAC4 soap_in_PointerTo_trt__GetAudioOutputConfigurationOptions(struct soap *soap, const char *tag, struct _trt__GetAudioOutputConfigurationOptions **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__GetAudioOutputConfigurationOptions **)soap_malloc(soap, sizeof(struct _trt__GetAudioOutputConfigurationOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__GetAudioOutputConfigurationOptions(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__GetAudioOutputConfigurationOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetAudioOutputConfigurationOptions, sizeof(struct _trt__GetAudioOutputConfigurationOptions), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetAudioOutputConfigurationOptions(struct soap *soap, struct _trt__GetAudioOutputConfigurationOptions *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetAudioOutputConfigurationOptions);
	if (soap_out_PointerTo_trt__GetAudioOutputConfigurationOptions(soap, tag?tag:"trt:GetAudioOutputConfigurationOptions", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetAudioOutputConfigurationOptions ** SOAP_FMAC4 soap_get_PointerTo_trt__GetAudioOutputConfigurationOptions(struct soap *soap, struct _trt__GetAudioOutputConfigurationOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetAudioOutputConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetMetadataConfigurationOptionsResponse(struct soap *soap, struct _trt__GetMetadataConfigurationOptionsResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetMetadataConfigurationOptionsResponse))
		soap_serialize__trt__GetMetadataConfigurationOptionsResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetMetadataConfigurationOptionsResponse(struct soap *soap, const char *tag, int id, struct _trt__GetMetadataConfigurationOptionsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetMetadataConfigurationOptionsResponse);
	if (id < 0)
		return soap->error;
	return soap_out__trt__GetMetadataConfigurationOptionsResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__GetMetadataConfigurationOptionsResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__GetMetadataConfigurationOptionsResponse(struct soap *soap, const char *tag, struct _trt__GetMetadataConfigurationOptionsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__GetMetadataConfigurationOptionsResponse **)soap_malloc(soap, sizeof(struct _trt__GetMetadataConfigurationOptionsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__GetMetadataConfigurationOptionsResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__GetMetadataConfigurationOptionsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetMetadataConfigurationOptionsResponse, sizeof(struct _trt__GetMetadataConfigurationOptionsResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetMetadataConfigurationOptionsResponse(struct soap *soap, struct _trt__GetMetadataConfigurationOptionsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetMetadataConfigurationOptionsResponse);
	if (soap_out_PointerTo_trt__GetMetadataConfigurationOptionsResponse(soap, tag?tag:"trt:GetMetadataConfigurationOptionsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetMetadataConfigurationOptionsResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__GetMetadataConfigurationOptionsResponse(struct soap *soap, struct _trt__GetMetadataConfigurationOptionsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetMetadataConfigurationOptionsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetMetadataConfigurationOptions(struct soap *soap, struct _trt__GetMetadataConfigurationOptions *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetMetadataConfigurationOptions))
		soap_serialize__trt__GetMetadataConfigurationOptions(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetMetadataConfigurationOptions(struct soap *soap, const char *tag, int id, struct _trt__GetMetadataConfigurationOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetMetadataConfigurationOptions);
	if (id < 0)
		return soap->error;
	return soap_out__trt__GetMetadataConfigurationOptions(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__GetMetadataConfigurationOptions ** SOAP_FMAC4 soap_in_PointerTo_trt__GetMetadataConfigurationOptions(struct soap *soap, const char *tag, struct _trt__GetMetadataConfigurationOptions **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__GetMetadataConfigurationOptions **)soap_malloc(soap, sizeof(struct _trt__GetMetadataConfigurationOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__GetMetadataConfigurationOptions(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__GetMetadataConfigurationOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetMetadataConfigurationOptions, sizeof(struct _trt__GetMetadataConfigurationOptions), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetMetadataConfigurationOptions(struct soap *soap, struct _trt__GetMetadataConfigurationOptions *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetMetadataConfigurationOptions);
	if (soap_out_PointerTo_trt__GetMetadataConfigurationOptions(soap, tag?tag:"trt:GetMetadataConfigurationOptions", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetMetadataConfigurationOptions ** SOAP_FMAC4 soap_get_PointerTo_trt__GetMetadataConfigurationOptions(struct soap *soap, struct _trt__GetMetadataConfigurationOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetMetadataConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetAudioEncoderConfigurationOptionsResponse(struct soap *soap, struct _trt__GetAudioEncoderConfigurationOptionsResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetAudioEncoderConfigurationOptionsResponse))
		soap_serialize__trt__GetAudioEncoderConfigurationOptionsResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetAudioEncoderConfigurationOptionsResponse(struct soap *soap, const char *tag, int id, struct _trt__GetAudioEncoderConfigurationOptionsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetAudioEncoderConfigurationOptionsResponse);
	if (id < 0)
		return soap->error;
	return soap_out__trt__GetAudioEncoderConfigurationOptionsResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__GetAudioEncoderConfigurationOptionsResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__GetAudioEncoderConfigurationOptionsResponse(struct soap *soap, const char *tag, struct _trt__GetAudioEncoderConfigurationOptionsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__GetAudioEncoderConfigurationOptionsResponse **)soap_malloc(soap, sizeof(struct _trt__GetAudioEncoderConfigurationOptionsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__GetAudioEncoderConfigurationOptionsResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__GetAudioEncoderConfigurationOptionsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetAudioEncoderConfigurationOptionsResponse, sizeof(struct _trt__GetAudioEncoderConfigurationOptionsResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetAudioEncoderConfigurationOptionsResponse(struct soap *soap, struct _trt__GetAudioEncoderConfigurationOptionsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetAudioEncoderConfigurationOptionsResponse);
	if (soap_out_PointerTo_trt__GetAudioEncoderConfigurationOptionsResponse(soap, tag?tag:"trt:GetAudioEncoderConfigurationOptionsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetAudioEncoderConfigurationOptionsResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__GetAudioEncoderConfigurationOptionsResponse(struct soap *soap, struct _trt__GetAudioEncoderConfigurationOptionsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetAudioEncoderConfigurationOptionsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetAudioEncoderConfigurationOptions(struct soap *soap, struct _trt__GetAudioEncoderConfigurationOptions *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetAudioEncoderConfigurationOptions))
		soap_serialize__trt__GetAudioEncoderConfigurationOptions(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetAudioEncoderConfigurationOptions(struct soap *soap, const char *tag, int id, struct _trt__GetAudioEncoderConfigurationOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetAudioEncoderConfigurationOptions);
	if (id < 0)
		return soap->error;
	return soap_out__trt__GetAudioEncoderConfigurationOptions(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__GetAudioEncoderConfigurationOptions ** SOAP_FMAC4 soap_in_PointerTo_trt__GetAudioEncoderConfigurationOptions(struct soap *soap, const char *tag, struct _trt__GetAudioEncoderConfigurationOptions **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__GetAudioEncoderConfigurationOptions **)soap_malloc(soap, sizeof(struct _trt__GetAudioEncoderConfigurationOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__GetAudioEncoderConfigurationOptions(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__GetAudioEncoderConfigurationOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetAudioEncoderConfigurationOptions, sizeof(struct _trt__GetAudioEncoderConfigurationOptions), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetAudioEncoderConfigurationOptions(struct soap *soap, struct _trt__GetAudioEncoderConfigurationOptions *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetAudioEncoderConfigurationOptions);
	if (soap_out_PointerTo_trt__GetAudioEncoderConfigurationOptions(soap, tag?tag:"trt:GetAudioEncoderConfigurationOptions", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetAudioEncoderConfigurationOptions ** SOAP_FMAC4 soap_get_PointerTo_trt__GetAudioEncoderConfigurationOptions(struct soap *soap, struct _trt__GetAudioEncoderConfigurationOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetAudioEncoderConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetAudioSourceConfigurationOptionsResponse(struct soap *soap, struct _trt__GetAudioSourceConfigurationOptionsResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetAudioSourceConfigurationOptionsResponse))
		soap_serialize__trt__GetAudioSourceConfigurationOptionsResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetAudioSourceConfigurationOptionsResponse(struct soap *soap, const char *tag, int id, struct _trt__GetAudioSourceConfigurationOptionsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetAudioSourceConfigurationOptionsResponse);
	if (id < 0)
		return soap->error;
	return soap_out__trt__GetAudioSourceConfigurationOptionsResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__GetAudioSourceConfigurationOptionsResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__GetAudioSourceConfigurationOptionsResponse(struct soap *soap, const char *tag, struct _trt__GetAudioSourceConfigurationOptionsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__GetAudioSourceConfigurationOptionsResponse **)soap_malloc(soap, sizeof(struct _trt__GetAudioSourceConfigurationOptionsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__GetAudioSourceConfigurationOptionsResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__GetAudioSourceConfigurationOptionsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetAudioSourceConfigurationOptionsResponse, sizeof(struct _trt__GetAudioSourceConfigurationOptionsResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetAudioSourceConfigurationOptionsResponse(struct soap *soap, struct _trt__GetAudioSourceConfigurationOptionsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetAudioSourceConfigurationOptionsResponse);
	if (soap_out_PointerTo_trt__GetAudioSourceConfigurationOptionsResponse(soap, tag?tag:"trt:GetAudioSourceConfigurationOptionsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetAudioSourceConfigurationOptionsResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__GetAudioSourceConfigurationOptionsResponse(struct soap *soap, struct _trt__GetAudioSourceConfigurationOptionsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetAudioSourceConfigurationOptionsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetAudioSourceConfigurationOptions(struct soap *soap, struct _trt__GetAudioSourceConfigurationOptions *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetAudioSourceConfigurationOptions))
		soap_serialize__trt__GetAudioSourceConfigurationOptions(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetAudioSourceConfigurationOptions(struct soap *soap, const char *tag, int id, struct _trt__GetAudioSourceConfigurationOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetAudioSourceConfigurationOptions);
	if (id < 0)
		return soap->error;
	return soap_out__trt__GetAudioSourceConfigurationOptions(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__GetAudioSourceConfigurationOptions ** SOAP_FMAC4 soap_in_PointerTo_trt__GetAudioSourceConfigurationOptions(struct soap *soap, const char *tag, struct _trt__GetAudioSourceConfigurationOptions **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__GetAudioSourceConfigurationOptions **)soap_malloc(soap, sizeof(struct _trt__GetAudioSourceConfigurationOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__GetAudioSourceConfigurationOptions(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__GetAudioSourceConfigurationOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetAudioSourceConfigurationOptions, sizeof(struct _trt__GetAudioSourceConfigurationOptions), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetAudioSourceConfigurationOptions(struct soap *soap, struct _trt__GetAudioSourceConfigurationOptions *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetAudioSourceConfigurationOptions);
	if (soap_out_PointerTo_trt__GetAudioSourceConfigurationOptions(soap, tag?tag:"trt:GetAudioSourceConfigurationOptions", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetAudioSourceConfigurationOptions ** SOAP_FMAC4 soap_get_PointerTo_trt__GetAudioSourceConfigurationOptions(struct soap *soap, struct _trt__GetAudioSourceConfigurationOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetAudioSourceConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetVideoEncoderConfigurationOptionsResponse(struct soap *soap, struct _trt__GetVideoEncoderConfigurationOptionsResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetVideoEncoderConfigurationOptionsResponse))
		soap_serialize__trt__GetVideoEncoderConfigurationOptionsResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetVideoEncoderConfigurationOptionsResponse(struct soap *soap, const char *tag, int id, struct _trt__GetVideoEncoderConfigurationOptionsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetVideoEncoderConfigurationOptionsResponse);
	if (id < 0)
		return soap->error;
	return soap_out__trt__GetVideoEncoderConfigurationOptionsResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__GetVideoEncoderConfigurationOptionsResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__GetVideoEncoderConfigurationOptionsResponse(struct soap *soap, const char *tag, struct _trt__GetVideoEncoderConfigurationOptionsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__GetVideoEncoderConfigurationOptionsResponse **)soap_malloc(soap, sizeof(struct _trt__GetVideoEncoderConfigurationOptionsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__GetVideoEncoderConfigurationOptionsResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__GetVideoEncoderConfigurationOptionsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetVideoEncoderConfigurationOptionsResponse, sizeof(struct _trt__GetVideoEncoderConfigurationOptionsResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetVideoEncoderConfigurationOptionsResponse(struct soap *soap, struct _trt__GetVideoEncoderConfigurationOptionsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetVideoEncoderConfigurationOptionsResponse);
	if (soap_out_PointerTo_trt__GetVideoEncoderConfigurationOptionsResponse(soap, tag?tag:"trt:GetVideoEncoderConfigurationOptionsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetVideoEncoderConfigurationOptionsResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__GetVideoEncoderConfigurationOptionsResponse(struct soap *soap, struct _trt__GetVideoEncoderConfigurationOptionsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetVideoEncoderConfigurationOptionsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetVideoEncoderConfigurationOptions(struct soap *soap, struct _trt__GetVideoEncoderConfigurationOptions *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetVideoEncoderConfigurationOptions))
		soap_serialize__trt__GetVideoEncoderConfigurationOptions(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetVideoEncoderConfigurationOptions(struct soap *soap, const char *tag, int id, struct _trt__GetVideoEncoderConfigurationOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetVideoEncoderConfigurationOptions);
	if (id < 0)
		return soap->error;
	return soap_out__trt__GetVideoEncoderConfigurationOptions(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__GetVideoEncoderConfigurationOptions ** SOAP_FMAC4 soap_in_PointerTo_trt__GetVideoEncoderConfigurationOptions(struct soap *soap, const char *tag, struct _trt__GetVideoEncoderConfigurationOptions **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__GetVideoEncoderConfigurationOptions **)soap_malloc(soap, sizeof(struct _trt__GetVideoEncoderConfigurationOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__GetVideoEncoderConfigurationOptions(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__GetVideoEncoderConfigurationOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetVideoEncoderConfigurationOptions, sizeof(struct _trt__GetVideoEncoderConfigurationOptions), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetVideoEncoderConfigurationOptions(struct soap *soap, struct _trt__GetVideoEncoderConfigurationOptions *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetVideoEncoderConfigurationOptions);
	if (soap_out_PointerTo_trt__GetVideoEncoderConfigurationOptions(soap, tag?tag:"trt:GetVideoEncoderConfigurationOptions", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetVideoEncoderConfigurationOptions ** SOAP_FMAC4 soap_get_PointerTo_trt__GetVideoEncoderConfigurationOptions(struct soap *soap, struct _trt__GetVideoEncoderConfigurationOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetVideoEncoderConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetVideoSourceConfigurationOptionsResponse(struct soap *soap, struct _trt__GetVideoSourceConfigurationOptionsResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetVideoSourceConfigurationOptionsResponse))
		soap_serialize__trt__GetVideoSourceConfigurationOptionsResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetVideoSourceConfigurationOptionsResponse(struct soap *soap, const char *tag, int id, struct _trt__GetVideoSourceConfigurationOptionsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetVideoSourceConfigurationOptionsResponse);
	if (id < 0)
		return soap->error;
	return soap_out__trt__GetVideoSourceConfigurationOptionsResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__GetVideoSourceConfigurationOptionsResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__GetVideoSourceConfigurationOptionsResponse(struct soap *soap, const char *tag, struct _trt__GetVideoSourceConfigurationOptionsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__GetVideoSourceConfigurationOptionsResponse **)soap_malloc(soap, sizeof(struct _trt__GetVideoSourceConfigurationOptionsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__GetVideoSourceConfigurationOptionsResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__GetVideoSourceConfigurationOptionsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetVideoSourceConfigurationOptionsResponse, sizeof(struct _trt__GetVideoSourceConfigurationOptionsResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetVideoSourceConfigurationOptionsResponse(struct soap *soap, struct _trt__GetVideoSourceConfigurationOptionsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetVideoSourceConfigurationOptionsResponse);
	if (soap_out_PointerTo_trt__GetVideoSourceConfigurationOptionsResponse(soap, tag?tag:"trt:GetVideoSourceConfigurationOptionsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetVideoSourceConfigurationOptionsResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__GetVideoSourceConfigurationOptionsResponse(struct soap *soap, struct _trt__GetVideoSourceConfigurationOptionsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetVideoSourceConfigurationOptionsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetVideoSourceConfigurationOptions(struct soap *soap, struct _trt__GetVideoSourceConfigurationOptions *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetVideoSourceConfigurationOptions))
		soap_serialize__trt__GetVideoSourceConfigurationOptions(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetVideoSourceConfigurationOptions(struct soap *soap, const char *tag, int id, struct _trt__GetVideoSourceConfigurationOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetVideoSourceConfigurationOptions);
	if (id < 0)
		return soap->error;
	return soap_out__trt__GetVideoSourceConfigurationOptions(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__GetVideoSourceConfigurationOptions ** SOAP_FMAC4 soap_in_PointerTo_trt__GetVideoSourceConfigurationOptions(struct soap *soap, const char *tag, struct _trt__GetVideoSourceConfigurationOptions **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__GetVideoSourceConfigurationOptions **)soap_malloc(soap, sizeof(struct _trt__GetVideoSourceConfigurationOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__GetVideoSourceConfigurationOptions(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__GetVideoSourceConfigurationOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetVideoSourceConfigurationOptions, sizeof(struct _trt__GetVideoSourceConfigurationOptions), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetVideoSourceConfigurationOptions(struct soap *soap, struct _trt__GetVideoSourceConfigurationOptions *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetVideoSourceConfigurationOptions);
	if (soap_out_PointerTo_trt__GetVideoSourceConfigurationOptions(soap, tag?tag:"trt:GetVideoSourceConfigurationOptions", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetVideoSourceConfigurationOptions ** SOAP_FMAC4 soap_get_PointerTo_trt__GetVideoSourceConfigurationOptions(struct soap *soap, struct _trt__GetVideoSourceConfigurationOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetVideoSourceConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__SetAudioDecoderConfigurationResponse(struct soap *soap, struct _trt__SetAudioDecoderConfigurationResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__SetAudioDecoderConfigurationResponse))
		soap_serialize__trt__SetAudioDecoderConfigurationResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__SetAudioDecoderConfigurationResponse(struct soap *soap, const char *tag, int id, struct _trt__SetAudioDecoderConfigurationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__SetAudioDecoderConfigurationResponse);
	if (id < 0)
		return soap->error;
	return soap_out__trt__SetAudioDecoderConfigurationResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__SetAudioDecoderConfigurationResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__SetAudioDecoderConfigurationResponse(struct soap *soap, const char *tag, struct _trt__SetAudioDecoderConfigurationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__SetAudioDecoderConfigurationResponse **)soap_malloc(soap, sizeof(struct _trt__SetAudioDecoderConfigurationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__SetAudioDecoderConfigurationResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__SetAudioDecoderConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__SetAudioDecoderConfigurationResponse, sizeof(struct _trt__SetAudioDecoderConfigurationResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__SetAudioDecoderConfigurationResponse(struct soap *soap, struct _trt__SetAudioDecoderConfigurationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__SetAudioDecoderConfigurationResponse);
	if (soap_out_PointerTo_trt__SetAudioDecoderConfigurationResponse(soap, tag?tag:"trt:SetAudioDecoderConfigurationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__SetAudioDecoderConfigurationResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__SetAudioDecoderConfigurationResponse(struct soap *soap, struct _trt__SetAudioDecoderConfigurationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__SetAudioDecoderConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__SetAudioDecoderConfiguration(struct soap *soap, struct _trt__SetAudioDecoderConfiguration *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__SetAudioDecoderConfiguration))
		soap_serialize__trt__SetAudioDecoderConfiguration(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__SetAudioDecoderConfiguration(struct soap *soap, const char *tag, int id, struct _trt__SetAudioDecoderConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__SetAudioDecoderConfiguration);
	if (id < 0)
		return soap->error;
	return soap_out__trt__SetAudioDecoderConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__SetAudioDecoderConfiguration ** SOAP_FMAC4 soap_in_PointerTo_trt__SetAudioDecoderConfiguration(struct soap *soap, const char *tag, struct _trt__SetAudioDecoderConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__SetAudioDecoderConfiguration **)soap_malloc(soap, sizeof(struct _trt__SetAudioDecoderConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__SetAudioDecoderConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__SetAudioDecoderConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__SetAudioDecoderConfiguration, sizeof(struct _trt__SetAudioDecoderConfiguration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__SetAudioDecoderConfiguration(struct soap *soap, struct _trt__SetAudioDecoderConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__SetAudioDecoderConfiguration);
	if (soap_out_PointerTo_trt__SetAudioDecoderConfiguration(soap, tag?tag:"trt:SetAudioDecoderConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__SetAudioDecoderConfiguration ** SOAP_FMAC4 soap_get_PointerTo_trt__SetAudioDecoderConfiguration(struct soap *soap, struct _trt__SetAudioDecoderConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__SetAudioDecoderConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__SetAudioOutputConfigurationResponse(struct soap *soap, struct _trt__SetAudioOutputConfigurationResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__SetAudioOutputConfigurationResponse))
		soap_serialize__trt__SetAudioOutputConfigurationResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__SetAudioOutputConfigurationResponse(struct soap *soap, const char *tag, int id, struct _trt__SetAudioOutputConfigurationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__SetAudioOutputConfigurationResponse);
	if (id < 0)
		return soap->error;
	return soap_out__trt__SetAudioOutputConfigurationResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__SetAudioOutputConfigurationResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__SetAudioOutputConfigurationResponse(struct soap *soap, const char *tag, struct _trt__SetAudioOutputConfigurationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__SetAudioOutputConfigurationResponse **)soap_malloc(soap, sizeof(struct _trt__SetAudioOutputConfigurationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__SetAudioOutputConfigurationResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__SetAudioOutputConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__SetAudioOutputConfigurationResponse, sizeof(struct _trt__SetAudioOutputConfigurationResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__SetAudioOutputConfigurationResponse(struct soap *soap, struct _trt__SetAudioOutputConfigurationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__SetAudioOutputConfigurationResponse);
	if (soap_out_PointerTo_trt__SetAudioOutputConfigurationResponse(soap, tag?tag:"trt:SetAudioOutputConfigurationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__SetAudioOutputConfigurationResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__SetAudioOutputConfigurationResponse(struct soap *soap, struct _trt__SetAudioOutputConfigurationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__SetAudioOutputConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__SetAudioOutputConfiguration(struct soap *soap, struct _trt__SetAudioOutputConfiguration *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__SetAudioOutputConfiguration))
		soap_serialize__trt__SetAudioOutputConfiguration(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__SetAudioOutputConfiguration(struct soap *soap, const char *tag, int id, struct _trt__SetAudioOutputConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__SetAudioOutputConfiguration);
	if (id < 0)
		return soap->error;
	return soap_out__trt__SetAudioOutputConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__SetAudioOutputConfiguration ** SOAP_FMAC4 soap_in_PointerTo_trt__SetAudioOutputConfiguration(struct soap *soap, const char *tag, struct _trt__SetAudioOutputConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__SetAudioOutputConfiguration **)soap_malloc(soap, sizeof(struct _trt__SetAudioOutputConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__SetAudioOutputConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__SetAudioOutputConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__SetAudioOutputConfiguration, sizeof(struct _trt__SetAudioOutputConfiguration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__SetAudioOutputConfiguration(struct soap *soap, struct _trt__SetAudioOutputConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__SetAudioOutputConfiguration);
	if (soap_out_PointerTo_trt__SetAudioOutputConfiguration(soap, tag?tag:"trt:SetAudioOutputConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__SetAudioOutputConfiguration ** SOAP_FMAC4 soap_get_PointerTo_trt__SetAudioOutputConfiguration(struct soap *soap, struct _trt__SetAudioOutputConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__SetAudioOutputConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__SetMetadataConfigurationResponse(struct soap *soap, struct _trt__SetMetadataConfigurationResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__SetMetadataConfigurationResponse))
		soap_serialize__trt__SetMetadataConfigurationResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__SetMetadataConfigurationResponse(struct soap *soap, const char *tag, int id, struct _trt__SetMetadataConfigurationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__SetMetadataConfigurationResponse);
	if (id < 0)
		return soap->error;
	return soap_out__trt__SetMetadataConfigurationResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__SetMetadataConfigurationResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__SetMetadataConfigurationResponse(struct soap *soap, const char *tag, struct _trt__SetMetadataConfigurationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__SetMetadataConfigurationResponse **)soap_malloc(soap, sizeof(struct _trt__SetMetadataConfigurationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__SetMetadataConfigurationResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__SetMetadataConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__SetMetadataConfigurationResponse, sizeof(struct _trt__SetMetadataConfigurationResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__SetMetadataConfigurationResponse(struct soap *soap, struct _trt__SetMetadataConfigurationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__SetMetadataConfigurationResponse);
	if (soap_out_PointerTo_trt__SetMetadataConfigurationResponse(soap, tag?tag:"trt:SetMetadataConfigurationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__SetMetadataConfigurationResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__SetMetadataConfigurationResponse(struct soap *soap, struct _trt__SetMetadataConfigurationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__SetMetadataConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__SetMetadataConfiguration(struct soap *soap, struct _trt__SetMetadataConfiguration *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__SetMetadataConfiguration))
		soap_serialize__trt__SetMetadataConfiguration(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__SetMetadataConfiguration(struct soap *soap, const char *tag, int id, struct _trt__SetMetadataConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__SetMetadataConfiguration);
	if (id < 0)
		return soap->error;
	return soap_out__trt__SetMetadataConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__SetMetadataConfiguration ** SOAP_FMAC4 soap_in_PointerTo_trt__SetMetadataConfiguration(struct soap *soap, const char *tag, struct _trt__SetMetadataConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__SetMetadataConfiguration **)soap_malloc(soap, sizeof(struct _trt__SetMetadataConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__SetMetadataConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__SetMetadataConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__SetMetadataConfiguration, sizeof(struct _trt__SetMetadataConfiguration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__SetMetadataConfiguration(struct soap *soap, struct _trt__SetMetadataConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__SetMetadataConfiguration);
	if (soap_out_PointerTo_trt__SetMetadataConfiguration(soap, tag?tag:"trt:SetMetadataConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__SetMetadataConfiguration ** SOAP_FMAC4 soap_get_PointerTo_trt__SetMetadataConfiguration(struct soap *soap, struct _trt__SetMetadataConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__SetMetadataConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__SetVideoAnalyticsConfigurationResponse(struct soap *soap, struct _trt__SetVideoAnalyticsConfigurationResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__SetVideoAnalyticsConfigurationResponse))
		soap_serialize__trt__SetVideoAnalyticsConfigurationResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__SetVideoAnalyticsConfigurationResponse(struct soap *soap, const char *tag, int id, struct _trt__SetVideoAnalyticsConfigurationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__SetVideoAnalyticsConfigurationResponse);
	if (id < 0)
		return soap->error;
	return soap_out__trt__SetVideoAnalyticsConfigurationResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__SetVideoAnalyticsConfigurationResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__SetVideoAnalyticsConfigurationResponse(struct soap *soap, const char *tag, struct _trt__SetVideoAnalyticsConfigurationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__SetVideoAnalyticsConfigurationResponse **)soap_malloc(soap, sizeof(struct _trt__SetVideoAnalyticsConfigurationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__SetVideoAnalyticsConfigurationResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__SetVideoAnalyticsConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__SetVideoAnalyticsConfigurationResponse, sizeof(struct _trt__SetVideoAnalyticsConfigurationResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__SetVideoAnalyticsConfigurationResponse(struct soap *soap, struct _trt__SetVideoAnalyticsConfigurationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__SetVideoAnalyticsConfigurationResponse);
	if (soap_out_PointerTo_trt__SetVideoAnalyticsConfigurationResponse(soap, tag?tag:"trt:SetVideoAnalyticsConfigurationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__SetVideoAnalyticsConfigurationResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__SetVideoAnalyticsConfigurationResponse(struct soap *soap, struct _trt__SetVideoAnalyticsConfigurationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__SetVideoAnalyticsConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__SetVideoAnalyticsConfiguration(struct soap *soap, struct _trt__SetVideoAnalyticsConfiguration *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__SetVideoAnalyticsConfiguration))
		soap_serialize__trt__SetVideoAnalyticsConfiguration(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__SetVideoAnalyticsConfiguration(struct soap *soap, const char *tag, int id, struct _trt__SetVideoAnalyticsConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__SetVideoAnalyticsConfiguration);
	if (id < 0)
		return soap->error;
	return soap_out__trt__SetVideoAnalyticsConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__SetVideoAnalyticsConfiguration ** SOAP_FMAC4 soap_in_PointerTo_trt__SetVideoAnalyticsConfiguration(struct soap *soap, const char *tag, struct _trt__SetVideoAnalyticsConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__SetVideoAnalyticsConfiguration **)soap_malloc(soap, sizeof(struct _trt__SetVideoAnalyticsConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__SetVideoAnalyticsConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__SetVideoAnalyticsConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__SetVideoAnalyticsConfiguration, sizeof(struct _trt__SetVideoAnalyticsConfiguration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__SetVideoAnalyticsConfiguration(struct soap *soap, struct _trt__SetVideoAnalyticsConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__SetVideoAnalyticsConfiguration);
	if (soap_out_PointerTo_trt__SetVideoAnalyticsConfiguration(soap, tag?tag:"trt:SetVideoAnalyticsConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__SetVideoAnalyticsConfiguration ** SOAP_FMAC4 soap_get_PointerTo_trt__SetVideoAnalyticsConfiguration(struct soap *soap, struct _trt__SetVideoAnalyticsConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__SetVideoAnalyticsConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__SetAudioEncoderConfigurationResponse(struct soap *soap, struct _trt__SetAudioEncoderConfigurationResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__SetAudioEncoderConfigurationResponse))
		soap_serialize__trt__SetAudioEncoderConfigurationResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__SetAudioEncoderConfigurationResponse(struct soap *soap, const char *tag, int id, struct _trt__SetAudioEncoderConfigurationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__SetAudioEncoderConfigurationResponse);
	if (id < 0)
		return soap->error;
	return soap_out__trt__SetAudioEncoderConfigurationResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__SetAudioEncoderConfigurationResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__SetAudioEncoderConfigurationResponse(struct soap *soap, const char *tag, struct _trt__SetAudioEncoderConfigurationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__SetAudioEncoderConfigurationResponse **)soap_malloc(soap, sizeof(struct _trt__SetAudioEncoderConfigurationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__SetAudioEncoderConfigurationResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__SetAudioEncoderConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__SetAudioEncoderConfigurationResponse, sizeof(struct _trt__SetAudioEncoderConfigurationResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__SetAudioEncoderConfigurationResponse(struct soap *soap, struct _trt__SetAudioEncoderConfigurationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__SetAudioEncoderConfigurationResponse);
	if (soap_out_PointerTo_trt__SetAudioEncoderConfigurationResponse(soap, tag?tag:"trt:SetAudioEncoderConfigurationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__SetAudioEncoderConfigurationResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__SetAudioEncoderConfigurationResponse(struct soap *soap, struct _trt__SetAudioEncoderConfigurationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__SetAudioEncoderConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__SetAudioEncoderConfiguration(struct soap *soap, struct _trt__SetAudioEncoderConfiguration *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__SetAudioEncoderConfiguration))
		soap_serialize__trt__SetAudioEncoderConfiguration(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__SetAudioEncoderConfiguration(struct soap *soap, const char *tag, int id, struct _trt__SetAudioEncoderConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__SetAudioEncoderConfiguration);
	if (id < 0)
		return soap->error;
	return soap_out__trt__SetAudioEncoderConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__SetAudioEncoderConfiguration ** SOAP_FMAC4 soap_in_PointerTo_trt__SetAudioEncoderConfiguration(struct soap *soap, const char *tag, struct _trt__SetAudioEncoderConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__SetAudioEncoderConfiguration **)soap_malloc(soap, sizeof(struct _trt__SetAudioEncoderConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__SetAudioEncoderConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__SetAudioEncoderConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__SetAudioEncoderConfiguration, sizeof(struct _trt__SetAudioEncoderConfiguration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__SetAudioEncoderConfiguration(struct soap *soap, struct _trt__SetAudioEncoderConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__SetAudioEncoderConfiguration);
	if (soap_out_PointerTo_trt__SetAudioEncoderConfiguration(soap, tag?tag:"trt:SetAudioEncoderConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__SetAudioEncoderConfiguration ** SOAP_FMAC4 soap_get_PointerTo_trt__SetAudioEncoderConfiguration(struct soap *soap, struct _trt__SetAudioEncoderConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__SetAudioEncoderConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__SetAudioSourceConfigurationResponse(struct soap *soap, struct _trt__SetAudioSourceConfigurationResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__SetAudioSourceConfigurationResponse))
		soap_serialize__trt__SetAudioSourceConfigurationResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__SetAudioSourceConfigurationResponse(struct soap *soap, const char *tag, int id, struct _trt__SetAudioSourceConfigurationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__SetAudioSourceConfigurationResponse);
	if (id < 0)
		return soap->error;
	return soap_out__trt__SetAudioSourceConfigurationResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__SetAudioSourceConfigurationResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__SetAudioSourceConfigurationResponse(struct soap *soap, const char *tag, struct _trt__SetAudioSourceConfigurationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__SetAudioSourceConfigurationResponse **)soap_malloc(soap, sizeof(struct _trt__SetAudioSourceConfigurationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__SetAudioSourceConfigurationResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__SetAudioSourceConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__SetAudioSourceConfigurationResponse, sizeof(struct _trt__SetAudioSourceConfigurationResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__SetAudioSourceConfigurationResponse(struct soap *soap, struct _trt__SetAudioSourceConfigurationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__SetAudioSourceConfigurationResponse);
	if (soap_out_PointerTo_trt__SetAudioSourceConfigurationResponse(soap, tag?tag:"trt:SetAudioSourceConfigurationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__SetAudioSourceConfigurationResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__SetAudioSourceConfigurationResponse(struct soap *soap, struct _trt__SetAudioSourceConfigurationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__SetAudioSourceConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__SetAudioSourceConfiguration(struct soap *soap, struct _trt__SetAudioSourceConfiguration *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__SetAudioSourceConfiguration))
		soap_serialize__trt__SetAudioSourceConfiguration(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__SetAudioSourceConfiguration(struct soap *soap, const char *tag, int id, struct _trt__SetAudioSourceConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__SetAudioSourceConfiguration);
	if (id < 0)
		return soap->error;
	return soap_out__trt__SetAudioSourceConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__SetAudioSourceConfiguration ** SOAP_FMAC4 soap_in_PointerTo_trt__SetAudioSourceConfiguration(struct soap *soap, const char *tag, struct _trt__SetAudioSourceConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__SetAudioSourceConfiguration **)soap_malloc(soap, sizeof(struct _trt__SetAudioSourceConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__SetAudioSourceConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__SetAudioSourceConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__SetAudioSourceConfiguration, sizeof(struct _trt__SetAudioSourceConfiguration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__SetAudioSourceConfiguration(struct soap *soap, struct _trt__SetAudioSourceConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__SetAudioSourceConfiguration);
	if (soap_out_PointerTo_trt__SetAudioSourceConfiguration(soap, tag?tag:"trt:SetAudioSourceConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__SetAudioSourceConfiguration ** SOAP_FMAC4 soap_get_PointerTo_trt__SetAudioSourceConfiguration(struct soap *soap, struct _trt__SetAudioSourceConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__SetAudioSourceConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__SetVideoEncoderConfigurationResponse(struct soap *soap, struct _trt__SetVideoEncoderConfigurationResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__SetVideoEncoderConfigurationResponse))
		soap_serialize__trt__SetVideoEncoderConfigurationResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__SetVideoEncoderConfigurationResponse(struct soap *soap, const char *tag, int id, struct _trt__SetVideoEncoderConfigurationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__SetVideoEncoderConfigurationResponse);
	if (id < 0)
		return soap->error;
	return soap_out__trt__SetVideoEncoderConfigurationResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__SetVideoEncoderConfigurationResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__SetVideoEncoderConfigurationResponse(struct soap *soap, const char *tag, struct _trt__SetVideoEncoderConfigurationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__SetVideoEncoderConfigurationResponse **)soap_malloc(soap, sizeof(struct _trt__SetVideoEncoderConfigurationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__SetVideoEncoderConfigurationResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__SetVideoEncoderConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__SetVideoEncoderConfigurationResponse, sizeof(struct _trt__SetVideoEncoderConfigurationResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__SetVideoEncoderConfigurationResponse(struct soap *soap, struct _trt__SetVideoEncoderConfigurationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__SetVideoEncoderConfigurationResponse);
	if (soap_out_PointerTo_trt__SetVideoEncoderConfigurationResponse(soap, tag?tag:"trt:SetVideoEncoderConfigurationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__SetVideoEncoderConfigurationResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__SetVideoEncoderConfigurationResponse(struct soap *soap, struct _trt__SetVideoEncoderConfigurationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__SetVideoEncoderConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__SetVideoEncoderConfiguration(struct soap *soap, struct _trt__SetVideoEncoderConfiguration *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__SetVideoEncoderConfiguration))
		soap_serialize__trt__SetVideoEncoderConfiguration(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__SetVideoEncoderConfiguration(struct soap *soap, const char *tag, int id, struct _trt__SetVideoEncoderConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__SetVideoEncoderConfiguration);
	if (id < 0)
		return soap->error;
	return soap_out__trt__SetVideoEncoderConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__SetVideoEncoderConfiguration ** SOAP_FMAC4 soap_in_PointerTo_trt__SetVideoEncoderConfiguration(struct soap *soap, const char *tag, struct _trt__SetVideoEncoderConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__SetVideoEncoderConfiguration **)soap_malloc(soap, sizeof(struct _trt__SetVideoEncoderConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__SetVideoEncoderConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__SetVideoEncoderConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__SetVideoEncoderConfiguration, sizeof(struct _trt__SetVideoEncoderConfiguration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__SetVideoEncoderConfiguration(struct soap *soap, struct _trt__SetVideoEncoderConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__SetVideoEncoderConfiguration);
	if (soap_out_PointerTo_trt__SetVideoEncoderConfiguration(soap, tag?tag:"trt:SetVideoEncoderConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__SetVideoEncoderConfiguration ** SOAP_FMAC4 soap_get_PointerTo_trt__SetVideoEncoderConfiguration(struct soap *soap, struct _trt__SetVideoEncoderConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__SetVideoEncoderConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__SetVideoSourceConfigurationResponse(struct soap *soap, struct _trt__SetVideoSourceConfigurationResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__SetVideoSourceConfigurationResponse))
		soap_serialize__trt__SetVideoSourceConfigurationResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__SetVideoSourceConfigurationResponse(struct soap *soap, const char *tag, int id, struct _trt__SetVideoSourceConfigurationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__SetVideoSourceConfigurationResponse);
	if (id < 0)
		return soap->error;
	return soap_out__trt__SetVideoSourceConfigurationResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__SetVideoSourceConfigurationResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__SetVideoSourceConfigurationResponse(struct soap *soap, const char *tag, struct _trt__SetVideoSourceConfigurationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__SetVideoSourceConfigurationResponse **)soap_malloc(soap, sizeof(struct _trt__SetVideoSourceConfigurationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__SetVideoSourceConfigurationResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__SetVideoSourceConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__SetVideoSourceConfigurationResponse, sizeof(struct _trt__SetVideoSourceConfigurationResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__SetVideoSourceConfigurationResponse(struct soap *soap, struct _trt__SetVideoSourceConfigurationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__SetVideoSourceConfigurationResponse);
	if (soap_out_PointerTo_trt__SetVideoSourceConfigurationResponse(soap, tag?tag:"trt:SetVideoSourceConfigurationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__SetVideoSourceConfigurationResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__SetVideoSourceConfigurationResponse(struct soap *soap, struct _trt__SetVideoSourceConfigurationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__SetVideoSourceConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__SetVideoSourceConfiguration(struct soap *soap, struct _trt__SetVideoSourceConfiguration *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__SetVideoSourceConfiguration))
		soap_serialize__trt__SetVideoSourceConfiguration(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__SetVideoSourceConfiguration(struct soap *soap, const char *tag, int id, struct _trt__SetVideoSourceConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__SetVideoSourceConfiguration);
	if (id < 0)
		return soap->error;
	return soap_out__trt__SetVideoSourceConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__SetVideoSourceConfiguration ** SOAP_FMAC4 soap_in_PointerTo_trt__SetVideoSourceConfiguration(struct soap *soap, const char *tag, struct _trt__SetVideoSourceConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__SetVideoSourceConfiguration **)soap_malloc(soap, sizeof(struct _trt__SetVideoSourceConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__SetVideoSourceConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__SetVideoSourceConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__SetVideoSourceConfiguration, sizeof(struct _trt__SetVideoSourceConfiguration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__SetVideoSourceConfiguration(struct soap *soap, struct _trt__SetVideoSourceConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__SetVideoSourceConfiguration);
	if (soap_out_PointerTo_trt__SetVideoSourceConfiguration(soap, tag?tag:"trt:SetVideoSourceConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__SetVideoSourceConfiguration ** SOAP_FMAC4 soap_get_PointerTo_trt__SetVideoSourceConfiguration(struct soap *soap, struct _trt__SetVideoSourceConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__SetVideoSourceConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetCompatibleAudioDecoderConfigurationsResponse(struct soap *soap, struct _trt__GetCompatibleAudioDecoderConfigurationsResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetCompatibleAudioDecoderConfigurationsResponse))
		soap_serialize__trt__GetCompatibleAudioDecoderConfigurationsResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetCompatibleAudioDecoderConfigurationsResponse(struct soap *soap, const char *tag, int id, struct _trt__GetCompatibleAudioDecoderConfigurationsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetCompatibleAudioDecoderConfigurationsResponse);
	if (id < 0)
		return soap->error;
	return soap_out__trt__GetCompatibleAudioDecoderConfigurationsResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__GetCompatibleAudioDecoderConfigurationsResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__GetCompatibleAudioDecoderConfigurationsResponse(struct soap *soap, const char *tag, struct _trt__GetCompatibleAudioDecoderConfigurationsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__GetCompatibleAudioDecoderConfigurationsResponse **)soap_malloc(soap, sizeof(struct _trt__GetCompatibleAudioDecoderConfigurationsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__GetCompatibleAudioDecoderConfigurationsResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__GetCompatibleAudioDecoderConfigurationsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetCompatibleAudioDecoderConfigurationsResponse, sizeof(struct _trt__GetCompatibleAudioDecoderConfigurationsResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetCompatibleAudioDecoderConfigurationsResponse(struct soap *soap, struct _trt__GetCompatibleAudioDecoderConfigurationsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetCompatibleAudioDecoderConfigurationsResponse);
	if (soap_out_PointerTo_trt__GetCompatibleAudioDecoderConfigurationsResponse(soap, tag?tag:"trt:GetCompatibleAudioDecoderConfigurationsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetCompatibleAudioDecoderConfigurationsResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__GetCompatibleAudioDecoderConfigurationsResponse(struct soap *soap, struct _trt__GetCompatibleAudioDecoderConfigurationsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetCompatibleAudioDecoderConfigurationsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetCompatibleAudioDecoderConfigurations(struct soap *soap, struct _trt__GetCompatibleAudioDecoderConfigurations *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetCompatibleAudioDecoderConfigurations))
		soap_serialize__trt__GetCompatibleAudioDecoderConfigurations(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetCompatibleAudioDecoderConfigurations(struct soap *soap, const char *tag, int id, struct _trt__GetCompatibleAudioDecoderConfigurations *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetCompatibleAudioDecoderConfigurations);
	if (id < 0)
		return soap->error;
	return soap_out__trt__GetCompatibleAudioDecoderConfigurations(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__GetCompatibleAudioDecoderConfigurations ** SOAP_FMAC4 soap_in_PointerTo_trt__GetCompatibleAudioDecoderConfigurations(struct soap *soap, const char *tag, struct _trt__GetCompatibleAudioDecoderConfigurations **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__GetCompatibleAudioDecoderConfigurations **)soap_malloc(soap, sizeof(struct _trt__GetCompatibleAudioDecoderConfigurations *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__GetCompatibleAudioDecoderConfigurations(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__GetCompatibleAudioDecoderConfigurations **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetCompatibleAudioDecoderConfigurations, sizeof(struct _trt__GetCompatibleAudioDecoderConfigurations), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetCompatibleAudioDecoderConfigurations(struct soap *soap, struct _trt__GetCompatibleAudioDecoderConfigurations *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetCompatibleAudioDecoderConfigurations);
	if (soap_out_PointerTo_trt__GetCompatibleAudioDecoderConfigurations(soap, tag?tag:"trt:GetCompatibleAudioDecoderConfigurations", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetCompatibleAudioDecoderConfigurations ** SOAP_FMAC4 soap_get_PointerTo_trt__GetCompatibleAudioDecoderConfigurations(struct soap *soap, struct _trt__GetCompatibleAudioDecoderConfigurations **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetCompatibleAudioDecoderConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetCompatibleAudioOutputConfigurationsResponse(struct soap *soap, struct _trt__GetCompatibleAudioOutputConfigurationsResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetCompatibleAudioOutputConfigurationsResponse))
		soap_serialize__trt__GetCompatibleAudioOutputConfigurationsResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetCompatibleAudioOutputConfigurationsResponse(struct soap *soap, const char *tag, int id, struct _trt__GetCompatibleAudioOutputConfigurationsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetCompatibleAudioOutputConfigurationsResponse);
	if (id < 0)
		return soap->error;
	return soap_out__trt__GetCompatibleAudioOutputConfigurationsResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__GetCompatibleAudioOutputConfigurationsResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__GetCompatibleAudioOutputConfigurationsResponse(struct soap *soap, const char *tag, struct _trt__GetCompatibleAudioOutputConfigurationsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__GetCompatibleAudioOutputConfigurationsResponse **)soap_malloc(soap, sizeof(struct _trt__GetCompatibleAudioOutputConfigurationsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__GetCompatibleAudioOutputConfigurationsResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__GetCompatibleAudioOutputConfigurationsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetCompatibleAudioOutputConfigurationsResponse, sizeof(struct _trt__GetCompatibleAudioOutputConfigurationsResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetCompatibleAudioOutputConfigurationsResponse(struct soap *soap, struct _trt__GetCompatibleAudioOutputConfigurationsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetCompatibleAudioOutputConfigurationsResponse);
	if (soap_out_PointerTo_trt__GetCompatibleAudioOutputConfigurationsResponse(soap, tag?tag:"trt:GetCompatibleAudioOutputConfigurationsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetCompatibleAudioOutputConfigurationsResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__GetCompatibleAudioOutputConfigurationsResponse(struct soap *soap, struct _trt__GetCompatibleAudioOutputConfigurationsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetCompatibleAudioOutputConfigurationsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetCompatibleAudioOutputConfigurations(struct soap *soap, struct _trt__GetCompatibleAudioOutputConfigurations *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetCompatibleAudioOutputConfigurations))
		soap_serialize__trt__GetCompatibleAudioOutputConfigurations(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetCompatibleAudioOutputConfigurations(struct soap *soap, const char *tag, int id, struct _trt__GetCompatibleAudioOutputConfigurations *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetCompatibleAudioOutputConfigurations);
	if (id < 0)
		return soap->error;
	return soap_out__trt__GetCompatibleAudioOutputConfigurations(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__GetCompatibleAudioOutputConfigurations ** SOAP_FMAC4 soap_in_PointerTo_trt__GetCompatibleAudioOutputConfigurations(struct soap *soap, const char *tag, struct _trt__GetCompatibleAudioOutputConfigurations **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__GetCompatibleAudioOutputConfigurations **)soap_malloc(soap, sizeof(struct _trt__GetCompatibleAudioOutputConfigurations *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__GetCompatibleAudioOutputConfigurations(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__GetCompatibleAudioOutputConfigurations **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetCompatibleAudioOutputConfigurations, sizeof(struct _trt__GetCompatibleAudioOutputConfigurations), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetCompatibleAudioOutputConfigurations(struct soap *soap, struct _trt__GetCompatibleAudioOutputConfigurations *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetCompatibleAudioOutputConfigurations);
	if (soap_out_PointerTo_trt__GetCompatibleAudioOutputConfigurations(soap, tag?tag:"trt:GetCompatibleAudioOutputConfigurations", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetCompatibleAudioOutputConfigurations ** SOAP_FMAC4 soap_get_PointerTo_trt__GetCompatibleAudioOutputConfigurations(struct soap *soap, struct _trt__GetCompatibleAudioOutputConfigurations **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetCompatibleAudioOutputConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetCompatibleMetadataConfigurationsResponse(struct soap *soap, struct _trt__GetCompatibleMetadataConfigurationsResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetCompatibleMetadataConfigurationsResponse))
		soap_serialize__trt__GetCompatibleMetadataConfigurationsResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetCompatibleMetadataConfigurationsResponse(struct soap *soap, const char *tag, int id, struct _trt__GetCompatibleMetadataConfigurationsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetCompatibleMetadataConfigurationsResponse);
	if (id < 0)
		return soap->error;
	return soap_out__trt__GetCompatibleMetadataConfigurationsResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__GetCompatibleMetadataConfigurationsResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__GetCompatibleMetadataConfigurationsResponse(struct soap *soap, const char *tag, struct _trt__GetCompatibleMetadataConfigurationsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__GetCompatibleMetadataConfigurationsResponse **)soap_malloc(soap, sizeof(struct _trt__GetCompatibleMetadataConfigurationsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__GetCompatibleMetadataConfigurationsResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__GetCompatibleMetadataConfigurationsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetCompatibleMetadataConfigurationsResponse, sizeof(struct _trt__GetCompatibleMetadataConfigurationsResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetCompatibleMetadataConfigurationsResponse(struct soap *soap, struct _trt__GetCompatibleMetadataConfigurationsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetCompatibleMetadataConfigurationsResponse);
	if (soap_out_PointerTo_trt__GetCompatibleMetadataConfigurationsResponse(soap, tag?tag:"trt:GetCompatibleMetadataConfigurationsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetCompatibleMetadataConfigurationsResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__GetCompatibleMetadataConfigurationsResponse(struct soap *soap, struct _trt__GetCompatibleMetadataConfigurationsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetCompatibleMetadataConfigurationsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetCompatibleMetadataConfigurations(struct soap *soap, struct _trt__GetCompatibleMetadataConfigurations *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetCompatibleMetadataConfigurations))
		soap_serialize__trt__GetCompatibleMetadataConfigurations(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetCompatibleMetadataConfigurations(struct soap *soap, const char *tag, int id, struct _trt__GetCompatibleMetadataConfigurations *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetCompatibleMetadataConfigurations);
	if (id < 0)
		return soap->error;
	return soap_out__trt__GetCompatibleMetadataConfigurations(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__GetCompatibleMetadataConfigurations ** SOAP_FMAC4 soap_in_PointerTo_trt__GetCompatibleMetadataConfigurations(struct soap *soap, const char *tag, struct _trt__GetCompatibleMetadataConfigurations **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__GetCompatibleMetadataConfigurations **)soap_malloc(soap, sizeof(struct _trt__GetCompatibleMetadataConfigurations *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__GetCompatibleMetadataConfigurations(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__GetCompatibleMetadataConfigurations **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetCompatibleMetadataConfigurations, sizeof(struct _trt__GetCompatibleMetadataConfigurations), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetCompatibleMetadataConfigurations(struct soap *soap, struct _trt__GetCompatibleMetadataConfigurations *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetCompatibleMetadataConfigurations);
	if (soap_out_PointerTo_trt__GetCompatibleMetadataConfigurations(soap, tag?tag:"trt:GetCompatibleMetadataConfigurations", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetCompatibleMetadataConfigurations ** SOAP_FMAC4 soap_get_PointerTo_trt__GetCompatibleMetadataConfigurations(struct soap *soap, struct _trt__GetCompatibleMetadataConfigurations **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetCompatibleMetadataConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetCompatibleVideoAnalyticsConfigurationsResponse(struct soap *soap, struct _trt__GetCompatibleVideoAnalyticsConfigurationsResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetCompatibleVideoAnalyticsConfigurationsResponse))
		soap_serialize__trt__GetCompatibleVideoAnalyticsConfigurationsResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetCompatibleVideoAnalyticsConfigurationsResponse(struct soap *soap, const char *tag, int id, struct _trt__GetCompatibleVideoAnalyticsConfigurationsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetCompatibleVideoAnalyticsConfigurationsResponse);
	if (id < 0)
		return soap->error;
	return soap_out__trt__GetCompatibleVideoAnalyticsConfigurationsResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__GetCompatibleVideoAnalyticsConfigurationsResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__GetCompatibleVideoAnalyticsConfigurationsResponse(struct soap *soap, const char *tag, struct _trt__GetCompatibleVideoAnalyticsConfigurationsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__GetCompatibleVideoAnalyticsConfigurationsResponse **)soap_malloc(soap, sizeof(struct _trt__GetCompatibleVideoAnalyticsConfigurationsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__GetCompatibleVideoAnalyticsConfigurationsResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__GetCompatibleVideoAnalyticsConfigurationsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetCompatibleVideoAnalyticsConfigurationsResponse, sizeof(struct _trt__GetCompatibleVideoAnalyticsConfigurationsResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetCompatibleVideoAnalyticsConfigurationsResponse(struct soap *soap, struct _trt__GetCompatibleVideoAnalyticsConfigurationsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetCompatibleVideoAnalyticsConfigurationsResponse);
	if (soap_out_PointerTo_trt__GetCompatibleVideoAnalyticsConfigurationsResponse(soap, tag?tag:"trt:GetCompatibleVideoAnalyticsConfigurationsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetCompatibleVideoAnalyticsConfigurationsResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__GetCompatibleVideoAnalyticsConfigurationsResponse(struct soap *soap, struct _trt__GetCompatibleVideoAnalyticsConfigurationsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetCompatibleVideoAnalyticsConfigurationsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetCompatibleVideoAnalyticsConfigurations(struct soap *soap, struct _trt__GetCompatibleVideoAnalyticsConfigurations *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetCompatibleVideoAnalyticsConfigurations))
		soap_serialize__trt__GetCompatibleVideoAnalyticsConfigurations(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetCompatibleVideoAnalyticsConfigurations(struct soap *soap, const char *tag, int id, struct _trt__GetCompatibleVideoAnalyticsConfigurations *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetCompatibleVideoAnalyticsConfigurations);
	if (id < 0)
		return soap->error;
	return soap_out__trt__GetCompatibleVideoAnalyticsConfigurations(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__GetCompatibleVideoAnalyticsConfigurations ** SOAP_FMAC4 soap_in_PointerTo_trt__GetCompatibleVideoAnalyticsConfigurations(struct soap *soap, const char *tag, struct _trt__GetCompatibleVideoAnalyticsConfigurations **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__GetCompatibleVideoAnalyticsConfigurations **)soap_malloc(soap, sizeof(struct _trt__GetCompatibleVideoAnalyticsConfigurations *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__GetCompatibleVideoAnalyticsConfigurations(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__GetCompatibleVideoAnalyticsConfigurations **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetCompatibleVideoAnalyticsConfigurations, sizeof(struct _trt__GetCompatibleVideoAnalyticsConfigurations), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetCompatibleVideoAnalyticsConfigurations(struct soap *soap, struct _trt__GetCompatibleVideoAnalyticsConfigurations *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetCompatibleVideoAnalyticsConfigurations);
	if (soap_out_PointerTo_trt__GetCompatibleVideoAnalyticsConfigurations(soap, tag?tag:"trt:GetCompatibleVideoAnalyticsConfigurations", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetCompatibleVideoAnalyticsConfigurations ** SOAP_FMAC4 soap_get_PointerTo_trt__GetCompatibleVideoAnalyticsConfigurations(struct soap *soap, struct _trt__GetCompatibleVideoAnalyticsConfigurations **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetCompatibleVideoAnalyticsConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetCompatibleAudioSourceConfigurationsResponse(struct soap *soap, struct _trt__GetCompatibleAudioSourceConfigurationsResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetCompatibleAudioSourceConfigurationsResponse))
		soap_serialize__trt__GetCompatibleAudioSourceConfigurationsResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetCompatibleAudioSourceConfigurationsResponse(struct soap *soap, const char *tag, int id, struct _trt__GetCompatibleAudioSourceConfigurationsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetCompatibleAudioSourceConfigurationsResponse);
	if (id < 0)
		return soap->error;
	return soap_out__trt__GetCompatibleAudioSourceConfigurationsResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__GetCompatibleAudioSourceConfigurationsResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__GetCompatibleAudioSourceConfigurationsResponse(struct soap *soap, const char *tag, struct _trt__GetCompatibleAudioSourceConfigurationsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__GetCompatibleAudioSourceConfigurationsResponse **)soap_malloc(soap, sizeof(struct _trt__GetCompatibleAudioSourceConfigurationsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__GetCompatibleAudioSourceConfigurationsResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__GetCompatibleAudioSourceConfigurationsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetCompatibleAudioSourceConfigurationsResponse, sizeof(struct _trt__GetCompatibleAudioSourceConfigurationsResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetCompatibleAudioSourceConfigurationsResponse(struct soap *soap, struct _trt__GetCompatibleAudioSourceConfigurationsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetCompatibleAudioSourceConfigurationsResponse);
	if (soap_out_PointerTo_trt__GetCompatibleAudioSourceConfigurationsResponse(soap, tag?tag:"trt:GetCompatibleAudioSourceConfigurationsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetCompatibleAudioSourceConfigurationsResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__GetCompatibleAudioSourceConfigurationsResponse(struct soap *soap, struct _trt__GetCompatibleAudioSourceConfigurationsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetCompatibleAudioSourceConfigurationsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetCompatibleAudioSourceConfigurations(struct soap *soap, struct _trt__GetCompatibleAudioSourceConfigurations *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetCompatibleAudioSourceConfigurations))
		soap_serialize__trt__GetCompatibleAudioSourceConfigurations(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetCompatibleAudioSourceConfigurations(struct soap *soap, const char *tag, int id, struct _trt__GetCompatibleAudioSourceConfigurations *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetCompatibleAudioSourceConfigurations);
	if (id < 0)
		return soap->error;
	return soap_out__trt__GetCompatibleAudioSourceConfigurations(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__GetCompatibleAudioSourceConfigurations ** SOAP_FMAC4 soap_in_PointerTo_trt__GetCompatibleAudioSourceConfigurations(struct soap *soap, const char *tag, struct _trt__GetCompatibleAudioSourceConfigurations **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__GetCompatibleAudioSourceConfigurations **)soap_malloc(soap, sizeof(struct _trt__GetCompatibleAudioSourceConfigurations *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__GetCompatibleAudioSourceConfigurations(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__GetCompatibleAudioSourceConfigurations **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetCompatibleAudioSourceConfigurations, sizeof(struct _trt__GetCompatibleAudioSourceConfigurations), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetCompatibleAudioSourceConfigurations(struct soap *soap, struct _trt__GetCompatibleAudioSourceConfigurations *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetCompatibleAudioSourceConfigurations);
	if (soap_out_PointerTo_trt__GetCompatibleAudioSourceConfigurations(soap, tag?tag:"trt:GetCompatibleAudioSourceConfigurations", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetCompatibleAudioSourceConfigurations ** SOAP_FMAC4 soap_get_PointerTo_trt__GetCompatibleAudioSourceConfigurations(struct soap *soap, struct _trt__GetCompatibleAudioSourceConfigurations **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetCompatibleAudioSourceConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetCompatibleAudioEncoderConfigurationsResponse(struct soap *soap, struct _trt__GetCompatibleAudioEncoderConfigurationsResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetCompatibleAudioEncoderConfigurationsResponse))
		soap_serialize__trt__GetCompatibleAudioEncoderConfigurationsResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetCompatibleAudioEncoderConfigurationsResponse(struct soap *soap, const char *tag, int id, struct _trt__GetCompatibleAudioEncoderConfigurationsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetCompatibleAudioEncoderConfigurationsResponse);
	if (id < 0)
		return soap->error;
	return soap_out__trt__GetCompatibleAudioEncoderConfigurationsResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__GetCompatibleAudioEncoderConfigurationsResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__GetCompatibleAudioEncoderConfigurationsResponse(struct soap *soap, const char *tag, struct _trt__GetCompatibleAudioEncoderConfigurationsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__GetCompatibleAudioEncoderConfigurationsResponse **)soap_malloc(soap, sizeof(struct _trt__GetCompatibleAudioEncoderConfigurationsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__GetCompatibleAudioEncoderConfigurationsResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__GetCompatibleAudioEncoderConfigurationsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetCompatibleAudioEncoderConfigurationsResponse, sizeof(struct _trt__GetCompatibleAudioEncoderConfigurationsResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetCompatibleAudioEncoderConfigurationsResponse(struct soap *soap, struct _trt__GetCompatibleAudioEncoderConfigurationsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetCompatibleAudioEncoderConfigurationsResponse);
	if (soap_out_PointerTo_trt__GetCompatibleAudioEncoderConfigurationsResponse(soap, tag?tag:"trt:GetCompatibleAudioEncoderConfigurationsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetCompatibleAudioEncoderConfigurationsResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__GetCompatibleAudioEncoderConfigurationsResponse(struct soap *soap, struct _trt__GetCompatibleAudioEncoderConfigurationsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetCompatibleAudioEncoderConfigurationsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetCompatibleAudioEncoderConfigurations(struct soap *soap, struct _trt__GetCompatibleAudioEncoderConfigurations *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetCompatibleAudioEncoderConfigurations))
		soap_serialize__trt__GetCompatibleAudioEncoderConfigurations(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetCompatibleAudioEncoderConfigurations(struct soap *soap, const char *tag, int id, struct _trt__GetCompatibleAudioEncoderConfigurations *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetCompatibleAudioEncoderConfigurations);
	if (id < 0)
		return soap->error;
	return soap_out__trt__GetCompatibleAudioEncoderConfigurations(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__GetCompatibleAudioEncoderConfigurations ** SOAP_FMAC4 soap_in_PointerTo_trt__GetCompatibleAudioEncoderConfigurations(struct soap *soap, const char *tag, struct _trt__GetCompatibleAudioEncoderConfigurations **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__GetCompatibleAudioEncoderConfigurations **)soap_malloc(soap, sizeof(struct _trt__GetCompatibleAudioEncoderConfigurations *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__GetCompatibleAudioEncoderConfigurations(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__GetCompatibleAudioEncoderConfigurations **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetCompatibleAudioEncoderConfigurations, sizeof(struct _trt__GetCompatibleAudioEncoderConfigurations), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetCompatibleAudioEncoderConfigurations(struct soap *soap, struct _trt__GetCompatibleAudioEncoderConfigurations *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetCompatibleAudioEncoderConfigurations);
	if (soap_out_PointerTo_trt__GetCompatibleAudioEncoderConfigurations(soap, tag?tag:"trt:GetCompatibleAudioEncoderConfigurations", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetCompatibleAudioEncoderConfigurations ** SOAP_FMAC4 soap_get_PointerTo_trt__GetCompatibleAudioEncoderConfigurations(struct soap *soap, struct _trt__GetCompatibleAudioEncoderConfigurations **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetCompatibleAudioEncoderConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetCompatibleVideoSourceConfigurationsResponse(struct soap *soap, struct _trt__GetCompatibleVideoSourceConfigurationsResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetCompatibleVideoSourceConfigurationsResponse))
		soap_serialize__trt__GetCompatibleVideoSourceConfigurationsResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetCompatibleVideoSourceConfigurationsResponse(struct soap *soap, const char *tag, int id, struct _trt__GetCompatibleVideoSourceConfigurationsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetCompatibleVideoSourceConfigurationsResponse);
	if (id < 0)
		return soap->error;
	return soap_out__trt__GetCompatibleVideoSourceConfigurationsResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__GetCompatibleVideoSourceConfigurationsResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__GetCompatibleVideoSourceConfigurationsResponse(struct soap *soap, const char *tag, struct _trt__GetCompatibleVideoSourceConfigurationsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__GetCompatibleVideoSourceConfigurationsResponse **)soap_malloc(soap, sizeof(struct _trt__GetCompatibleVideoSourceConfigurationsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__GetCompatibleVideoSourceConfigurationsResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__GetCompatibleVideoSourceConfigurationsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetCompatibleVideoSourceConfigurationsResponse, sizeof(struct _trt__GetCompatibleVideoSourceConfigurationsResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetCompatibleVideoSourceConfigurationsResponse(struct soap *soap, struct _trt__GetCompatibleVideoSourceConfigurationsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetCompatibleVideoSourceConfigurationsResponse);
	if (soap_out_PointerTo_trt__GetCompatibleVideoSourceConfigurationsResponse(soap, tag?tag:"trt:GetCompatibleVideoSourceConfigurationsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetCompatibleVideoSourceConfigurationsResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__GetCompatibleVideoSourceConfigurationsResponse(struct soap *soap, struct _trt__GetCompatibleVideoSourceConfigurationsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetCompatibleVideoSourceConfigurationsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetCompatibleVideoSourceConfigurations(struct soap *soap, struct _trt__GetCompatibleVideoSourceConfigurations *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetCompatibleVideoSourceConfigurations))
		soap_serialize__trt__GetCompatibleVideoSourceConfigurations(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetCompatibleVideoSourceConfigurations(struct soap *soap, const char *tag, int id, struct _trt__GetCompatibleVideoSourceConfigurations *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetCompatibleVideoSourceConfigurations);
	if (id < 0)
		return soap->error;
	return soap_out__trt__GetCompatibleVideoSourceConfigurations(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__GetCompatibleVideoSourceConfigurations ** SOAP_FMAC4 soap_in_PointerTo_trt__GetCompatibleVideoSourceConfigurations(struct soap *soap, const char *tag, struct _trt__GetCompatibleVideoSourceConfigurations **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__GetCompatibleVideoSourceConfigurations **)soap_malloc(soap, sizeof(struct _trt__GetCompatibleVideoSourceConfigurations *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__GetCompatibleVideoSourceConfigurations(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__GetCompatibleVideoSourceConfigurations **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetCompatibleVideoSourceConfigurations, sizeof(struct _trt__GetCompatibleVideoSourceConfigurations), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetCompatibleVideoSourceConfigurations(struct soap *soap, struct _trt__GetCompatibleVideoSourceConfigurations *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetCompatibleVideoSourceConfigurations);
	if (soap_out_PointerTo_trt__GetCompatibleVideoSourceConfigurations(soap, tag?tag:"trt:GetCompatibleVideoSourceConfigurations", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetCompatibleVideoSourceConfigurations ** SOAP_FMAC4 soap_get_PointerTo_trt__GetCompatibleVideoSourceConfigurations(struct soap *soap, struct _trt__GetCompatibleVideoSourceConfigurations **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetCompatibleVideoSourceConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetCompatibleVideoEncoderConfigurationsResponse(struct soap *soap, struct _trt__GetCompatibleVideoEncoderConfigurationsResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetCompatibleVideoEncoderConfigurationsResponse))
		soap_serialize__trt__GetCompatibleVideoEncoderConfigurationsResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetCompatibleVideoEncoderConfigurationsResponse(struct soap *soap, const char *tag, int id, struct _trt__GetCompatibleVideoEncoderConfigurationsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetCompatibleVideoEncoderConfigurationsResponse);
	if (id < 0)
		return soap->error;
	return soap_out__trt__GetCompatibleVideoEncoderConfigurationsResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__GetCompatibleVideoEncoderConfigurationsResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__GetCompatibleVideoEncoderConfigurationsResponse(struct soap *soap, const char *tag, struct _trt__GetCompatibleVideoEncoderConfigurationsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__GetCompatibleVideoEncoderConfigurationsResponse **)soap_malloc(soap, sizeof(struct _trt__GetCompatibleVideoEncoderConfigurationsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__GetCompatibleVideoEncoderConfigurationsResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__GetCompatibleVideoEncoderConfigurationsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetCompatibleVideoEncoderConfigurationsResponse, sizeof(struct _trt__GetCompatibleVideoEncoderConfigurationsResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetCompatibleVideoEncoderConfigurationsResponse(struct soap *soap, struct _trt__GetCompatibleVideoEncoderConfigurationsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetCompatibleVideoEncoderConfigurationsResponse);
	if (soap_out_PointerTo_trt__GetCompatibleVideoEncoderConfigurationsResponse(soap, tag?tag:"trt:GetCompatibleVideoEncoderConfigurationsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetCompatibleVideoEncoderConfigurationsResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__GetCompatibleVideoEncoderConfigurationsResponse(struct soap *soap, struct _trt__GetCompatibleVideoEncoderConfigurationsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetCompatibleVideoEncoderConfigurationsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetCompatibleVideoEncoderConfigurations(struct soap *soap, struct _trt__GetCompatibleVideoEncoderConfigurations *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetCompatibleVideoEncoderConfigurations))
		soap_serialize__trt__GetCompatibleVideoEncoderConfigurations(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetCompatibleVideoEncoderConfigurations(struct soap *soap, const char *tag, int id, struct _trt__GetCompatibleVideoEncoderConfigurations *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetCompatibleVideoEncoderConfigurations);
	if (id < 0)
		return soap->error;
	return soap_out__trt__GetCompatibleVideoEncoderConfigurations(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__GetCompatibleVideoEncoderConfigurations ** SOAP_FMAC4 soap_in_PointerTo_trt__GetCompatibleVideoEncoderConfigurations(struct soap *soap, const char *tag, struct _trt__GetCompatibleVideoEncoderConfigurations **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__GetCompatibleVideoEncoderConfigurations **)soap_malloc(soap, sizeof(struct _trt__GetCompatibleVideoEncoderConfigurations *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__GetCompatibleVideoEncoderConfigurations(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__GetCompatibleVideoEncoderConfigurations **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetCompatibleVideoEncoderConfigurations, sizeof(struct _trt__GetCompatibleVideoEncoderConfigurations), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetCompatibleVideoEncoderConfigurations(struct soap *soap, struct _trt__GetCompatibleVideoEncoderConfigurations *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetCompatibleVideoEncoderConfigurations);
	if (soap_out_PointerTo_trt__GetCompatibleVideoEncoderConfigurations(soap, tag?tag:"trt:GetCompatibleVideoEncoderConfigurations", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetCompatibleVideoEncoderConfigurations ** SOAP_FMAC4 soap_get_PointerTo_trt__GetCompatibleVideoEncoderConfigurations(struct soap *soap, struct _trt__GetCompatibleVideoEncoderConfigurations **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetCompatibleVideoEncoderConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetAudioDecoderConfigurationResponse(struct soap *soap, struct _trt__GetAudioDecoderConfigurationResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetAudioDecoderConfigurationResponse))
		soap_serialize__trt__GetAudioDecoderConfigurationResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetAudioDecoderConfigurationResponse(struct soap *soap, const char *tag, int id, struct _trt__GetAudioDecoderConfigurationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetAudioDecoderConfigurationResponse);
	if (id < 0)
		return soap->error;
	return soap_out__trt__GetAudioDecoderConfigurationResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__GetAudioDecoderConfigurationResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__GetAudioDecoderConfigurationResponse(struct soap *soap, const char *tag, struct _trt__GetAudioDecoderConfigurationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__GetAudioDecoderConfigurationResponse **)soap_malloc(soap, sizeof(struct _trt__GetAudioDecoderConfigurationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__GetAudioDecoderConfigurationResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__GetAudioDecoderConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetAudioDecoderConfigurationResponse, sizeof(struct _trt__GetAudioDecoderConfigurationResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetAudioDecoderConfigurationResponse(struct soap *soap, struct _trt__GetAudioDecoderConfigurationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetAudioDecoderConfigurationResponse);
	if (soap_out_PointerTo_trt__GetAudioDecoderConfigurationResponse(soap, tag?tag:"trt:GetAudioDecoderConfigurationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetAudioDecoderConfigurationResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__GetAudioDecoderConfigurationResponse(struct soap *soap, struct _trt__GetAudioDecoderConfigurationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetAudioDecoderConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetAudioDecoderConfiguration(struct soap *soap, struct _trt__GetAudioDecoderConfiguration *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetAudioDecoderConfiguration))
		soap_serialize__trt__GetAudioDecoderConfiguration(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetAudioDecoderConfiguration(struct soap *soap, const char *tag, int id, struct _trt__GetAudioDecoderConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetAudioDecoderConfiguration);
	if (id < 0)
		return soap->error;
	return soap_out__trt__GetAudioDecoderConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__GetAudioDecoderConfiguration ** SOAP_FMAC4 soap_in_PointerTo_trt__GetAudioDecoderConfiguration(struct soap *soap, const char *tag, struct _trt__GetAudioDecoderConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__GetAudioDecoderConfiguration **)soap_malloc(soap, sizeof(struct _trt__GetAudioDecoderConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__GetAudioDecoderConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__GetAudioDecoderConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetAudioDecoderConfiguration, sizeof(struct _trt__GetAudioDecoderConfiguration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetAudioDecoderConfiguration(struct soap *soap, struct _trt__GetAudioDecoderConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetAudioDecoderConfiguration);
	if (soap_out_PointerTo_trt__GetAudioDecoderConfiguration(soap, tag?tag:"trt:GetAudioDecoderConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetAudioDecoderConfiguration ** SOAP_FMAC4 soap_get_PointerTo_trt__GetAudioDecoderConfiguration(struct soap *soap, struct _trt__GetAudioDecoderConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetAudioDecoderConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetAudioOutputConfigurationResponse(struct soap *soap, struct _trt__GetAudioOutputConfigurationResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetAudioOutputConfigurationResponse))
		soap_serialize__trt__GetAudioOutputConfigurationResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetAudioOutputConfigurationResponse(struct soap *soap, const char *tag, int id, struct _trt__GetAudioOutputConfigurationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetAudioOutputConfigurationResponse);
	if (id < 0)
		return soap->error;
	return soap_out__trt__GetAudioOutputConfigurationResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__GetAudioOutputConfigurationResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__GetAudioOutputConfigurationResponse(struct soap *soap, const char *tag, struct _trt__GetAudioOutputConfigurationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__GetAudioOutputConfigurationResponse **)soap_malloc(soap, sizeof(struct _trt__GetAudioOutputConfigurationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__GetAudioOutputConfigurationResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__GetAudioOutputConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetAudioOutputConfigurationResponse, sizeof(struct _trt__GetAudioOutputConfigurationResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetAudioOutputConfigurationResponse(struct soap *soap, struct _trt__GetAudioOutputConfigurationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetAudioOutputConfigurationResponse);
	if (soap_out_PointerTo_trt__GetAudioOutputConfigurationResponse(soap, tag?tag:"trt:GetAudioOutputConfigurationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetAudioOutputConfigurationResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__GetAudioOutputConfigurationResponse(struct soap *soap, struct _trt__GetAudioOutputConfigurationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetAudioOutputConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetAudioOutputConfiguration(struct soap *soap, struct _trt__GetAudioOutputConfiguration *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetAudioOutputConfiguration))
		soap_serialize__trt__GetAudioOutputConfiguration(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetAudioOutputConfiguration(struct soap *soap, const char *tag, int id, struct _trt__GetAudioOutputConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetAudioOutputConfiguration);
	if (id < 0)
		return soap->error;
	return soap_out__trt__GetAudioOutputConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__GetAudioOutputConfiguration ** SOAP_FMAC4 soap_in_PointerTo_trt__GetAudioOutputConfiguration(struct soap *soap, const char *tag, struct _trt__GetAudioOutputConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__GetAudioOutputConfiguration **)soap_malloc(soap, sizeof(struct _trt__GetAudioOutputConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__GetAudioOutputConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__GetAudioOutputConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetAudioOutputConfiguration, sizeof(struct _trt__GetAudioOutputConfiguration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetAudioOutputConfiguration(struct soap *soap, struct _trt__GetAudioOutputConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetAudioOutputConfiguration);
	if (soap_out_PointerTo_trt__GetAudioOutputConfiguration(soap, tag?tag:"trt:GetAudioOutputConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetAudioOutputConfiguration ** SOAP_FMAC4 soap_get_PointerTo_trt__GetAudioOutputConfiguration(struct soap *soap, struct _trt__GetAudioOutputConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetAudioOutputConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetMetadataConfigurationResponse(struct soap *soap, struct _trt__GetMetadataConfigurationResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetMetadataConfigurationResponse))
		soap_serialize__trt__GetMetadataConfigurationResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetMetadataConfigurationResponse(struct soap *soap, const char *tag, int id, struct _trt__GetMetadataConfigurationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetMetadataConfigurationResponse);
	if (id < 0)
		return soap->error;
	return soap_out__trt__GetMetadataConfigurationResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__GetMetadataConfigurationResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__GetMetadataConfigurationResponse(struct soap *soap, const char *tag, struct _trt__GetMetadataConfigurationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__GetMetadataConfigurationResponse **)soap_malloc(soap, sizeof(struct _trt__GetMetadataConfigurationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__GetMetadataConfigurationResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__GetMetadataConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetMetadataConfigurationResponse, sizeof(struct _trt__GetMetadataConfigurationResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetMetadataConfigurationResponse(struct soap *soap, struct _trt__GetMetadataConfigurationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetMetadataConfigurationResponse);
	if (soap_out_PointerTo_trt__GetMetadataConfigurationResponse(soap, tag?tag:"trt:GetMetadataConfigurationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetMetadataConfigurationResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__GetMetadataConfigurationResponse(struct soap *soap, struct _trt__GetMetadataConfigurationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetMetadataConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetMetadataConfiguration(struct soap *soap, struct _trt__GetMetadataConfiguration *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetMetadataConfiguration))
		soap_serialize__trt__GetMetadataConfiguration(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetMetadataConfiguration(struct soap *soap, const char *tag, int id, struct _trt__GetMetadataConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetMetadataConfiguration);
	if (id < 0)
		return soap->error;
	return soap_out__trt__GetMetadataConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__GetMetadataConfiguration ** SOAP_FMAC4 soap_in_PointerTo_trt__GetMetadataConfiguration(struct soap *soap, const char *tag, struct _trt__GetMetadataConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__GetMetadataConfiguration **)soap_malloc(soap, sizeof(struct _trt__GetMetadataConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__GetMetadataConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__GetMetadataConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetMetadataConfiguration, sizeof(struct _trt__GetMetadataConfiguration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetMetadataConfiguration(struct soap *soap, struct _trt__GetMetadataConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetMetadataConfiguration);
	if (soap_out_PointerTo_trt__GetMetadataConfiguration(soap, tag?tag:"trt:GetMetadataConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetMetadataConfiguration ** SOAP_FMAC4 soap_get_PointerTo_trt__GetMetadataConfiguration(struct soap *soap, struct _trt__GetMetadataConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetMetadataConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetVideoAnalyticsConfigurationResponse(struct soap *soap, struct _trt__GetVideoAnalyticsConfigurationResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetVideoAnalyticsConfigurationResponse))
		soap_serialize__trt__GetVideoAnalyticsConfigurationResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetVideoAnalyticsConfigurationResponse(struct soap *soap, const char *tag, int id, struct _trt__GetVideoAnalyticsConfigurationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetVideoAnalyticsConfigurationResponse);
	if (id < 0)
		return soap->error;
	return soap_out__trt__GetVideoAnalyticsConfigurationResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__GetVideoAnalyticsConfigurationResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__GetVideoAnalyticsConfigurationResponse(struct soap *soap, const char *tag, struct _trt__GetVideoAnalyticsConfigurationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__GetVideoAnalyticsConfigurationResponse **)soap_malloc(soap, sizeof(struct _trt__GetVideoAnalyticsConfigurationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__GetVideoAnalyticsConfigurationResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__GetVideoAnalyticsConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetVideoAnalyticsConfigurationResponse, sizeof(struct _trt__GetVideoAnalyticsConfigurationResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetVideoAnalyticsConfigurationResponse(struct soap *soap, struct _trt__GetVideoAnalyticsConfigurationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetVideoAnalyticsConfigurationResponse);
	if (soap_out_PointerTo_trt__GetVideoAnalyticsConfigurationResponse(soap, tag?tag:"trt:GetVideoAnalyticsConfigurationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetVideoAnalyticsConfigurationResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__GetVideoAnalyticsConfigurationResponse(struct soap *soap, struct _trt__GetVideoAnalyticsConfigurationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetVideoAnalyticsConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetVideoAnalyticsConfiguration(struct soap *soap, struct _trt__GetVideoAnalyticsConfiguration *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetVideoAnalyticsConfiguration))
		soap_serialize__trt__GetVideoAnalyticsConfiguration(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetVideoAnalyticsConfiguration(struct soap *soap, const char *tag, int id, struct _trt__GetVideoAnalyticsConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetVideoAnalyticsConfiguration);
	if (id < 0)
		return soap->error;
	return soap_out__trt__GetVideoAnalyticsConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__GetVideoAnalyticsConfiguration ** SOAP_FMAC4 soap_in_PointerTo_trt__GetVideoAnalyticsConfiguration(struct soap *soap, const char *tag, struct _trt__GetVideoAnalyticsConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__GetVideoAnalyticsConfiguration **)soap_malloc(soap, sizeof(struct _trt__GetVideoAnalyticsConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__GetVideoAnalyticsConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__GetVideoAnalyticsConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetVideoAnalyticsConfiguration, sizeof(struct _trt__GetVideoAnalyticsConfiguration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetVideoAnalyticsConfiguration(struct soap *soap, struct _trt__GetVideoAnalyticsConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetVideoAnalyticsConfiguration);
	if (soap_out_PointerTo_trt__GetVideoAnalyticsConfiguration(soap, tag?tag:"trt:GetVideoAnalyticsConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetVideoAnalyticsConfiguration ** SOAP_FMAC4 soap_get_PointerTo_trt__GetVideoAnalyticsConfiguration(struct soap *soap, struct _trt__GetVideoAnalyticsConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetVideoAnalyticsConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetAudioEncoderConfigurationResponse(struct soap *soap, struct _trt__GetAudioEncoderConfigurationResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetAudioEncoderConfigurationResponse))
		soap_serialize__trt__GetAudioEncoderConfigurationResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetAudioEncoderConfigurationResponse(struct soap *soap, const char *tag, int id, struct _trt__GetAudioEncoderConfigurationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetAudioEncoderConfigurationResponse);
	if (id < 0)
		return soap->error;
	return soap_out__trt__GetAudioEncoderConfigurationResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__GetAudioEncoderConfigurationResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__GetAudioEncoderConfigurationResponse(struct soap *soap, const char *tag, struct _trt__GetAudioEncoderConfigurationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__GetAudioEncoderConfigurationResponse **)soap_malloc(soap, sizeof(struct _trt__GetAudioEncoderConfigurationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__GetAudioEncoderConfigurationResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__GetAudioEncoderConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetAudioEncoderConfigurationResponse, sizeof(struct _trt__GetAudioEncoderConfigurationResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetAudioEncoderConfigurationResponse(struct soap *soap, struct _trt__GetAudioEncoderConfigurationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetAudioEncoderConfigurationResponse);
	if (soap_out_PointerTo_trt__GetAudioEncoderConfigurationResponse(soap, tag?tag:"trt:GetAudioEncoderConfigurationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetAudioEncoderConfigurationResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__GetAudioEncoderConfigurationResponse(struct soap *soap, struct _trt__GetAudioEncoderConfigurationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetAudioEncoderConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetAudioEncoderConfiguration(struct soap *soap, struct _trt__GetAudioEncoderConfiguration *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetAudioEncoderConfiguration))
		soap_serialize__trt__GetAudioEncoderConfiguration(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetAudioEncoderConfiguration(struct soap *soap, const char *tag, int id, struct _trt__GetAudioEncoderConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetAudioEncoderConfiguration);
	if (id < 0)
		return soap->error;
	return soap_out__trt__GetAudioEncoderConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__GetAudioEncoderConfiguration ** SOAP_FMAC4 soap_in_PointerTo_trt__GetAudioEncoderConfiguration(struct soap *soap, const char *tag, struct _trt__GetAudioEncoderConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__GetAudioEncoderConfiguration **)soap_malloc(soap, sizeof(struct _trt__GetAudioEncoderConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__GetAudioEncoderConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__GetAudioEncoderConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetAudioEncoderConfiguration, sizeof(struct _trt__GetAudioEncoderConfiguration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetAudioEncoderConfiguration(struct soap *soap, struct _trt__GetAudioEncoderConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetAudioEncoderConfiguration);
	if (soap_out_PointerTo_trt__GetAudioEncoderConfiguration(soap, tag?tag:"trt:GetAudioEncoderConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetAudioEncoderConfiguration ** SOAP_FMAC4 soap_get_PointerTo_trt__GetAudioEncoderConfiguration(struct soap *soap, struct _trt__GetAudioEncoderConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetAudioEncoderConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetAudioSourceConfigurationResponse(struct soap *soap, struct _trt__GetAudioSourceConfigurationResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetAudioSourceConfigurationResponse))
		soap_serialize__trt__GetAudioSourceConfigurationResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetAudioSourceConfigurationResponse(struct soap *soap, const char *tag, int id, struct _trt__GetAudioSourceConfigurationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetAudioSourceConfigurationResponse);
	if (id < 0)
		return soap->error;
	return soap_out__trt__GetAudioSourceConfigurationResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__GetAudioSourceConfigurationResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__GetAudioSourceConfigurationResponse(struct soap *soap, const char *tag, struct _trt__GetAudioSourceConfigurationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__GetAudioSourceConfigurationResponse **)soap_malloc(soap, sizeof(struct _trt__GetAudioSourceConfigurationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__GetAudioSourceConfigurationResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__GetAudioSourceConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetAudioSourceConfigurationResponse, sizeof(struct _trt__GetAudioSourceConfigurationResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetAudioSourceConfigurationResponse(struct soap *soap, struct _trt__GetAudioSourceConfigurationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetAudioSourceConfigurationResponse);
	if (soap_out_PointerTo_trt__GetAudioSourceConfigurationResponse(soap, tag?tag:"trt:GetAudioSourceConfigurationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetAudioSourceConfigurationResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__GetAudioSourceConfigurationResponse(struct soap *soap, struct _trt__GetAudioSourceConfigurationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetAudioSourceConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetAudioSourceConfiguration(struct soap *soap, struct _trt__GetAudioSourceConfiguration *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetAudioSourceConfiguration))
		soap_serialize__trt__GetAudioSourceConfiguration(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetAudioSourceConfiguration(struct soap *soap, const char *tag, int id, struct _trt__GetAudioSourceConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetAudioSourceConfiguration);
	if (id < 0)
		return soap->error;
	return soap_out__trt__GetAudioSourceConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__GetAudioSourceConfiguration ** SOAP_FMAC4 soap_in_PointerTo_trt__GetAudioSourceConfiguration(struct soap *soap, const char *tag, struct _trt__GetAudioSourceConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__GetAudioSourceConfiguration **)soap_malloc(soap, sizeof(struct _trt__GetAudioSourceConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__GetAudioSourceConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__GetAudioSourceConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetAudioSourceConfiguration, sizeof(struct _trt__GetAudioSourceConfiguration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetAudioSourceConfiguration(struct soap *soap, struct _trt__GetAudioSourceConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetAudioSourceConfiguration);
	if (soap_out_PointerTo_trt__GetAudioSourceConfiguration(soap, tag?tag:"trt:GetAudioSourceConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetAudioSourceConfiguration ** SOAP_FMAC4 soap_get_PointerTo_trt__GetAudioSourceConfiguration(struct soap *soap, struct _trt__GetAudioSourceConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetAudioSourceConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetVideoEncoderConfigurationResponse(struct soap *soap, struct _trt__GetVideoEncoderConfigurationResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetVideoEncoderConfigurationResponse))
		soap_serialize__trt__GetVideoEncoderConfigurationResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetVideoEncoderConfigurationResponse(struct soap *soap, const char *tag, int id, struct _trt__GetVideoEncoderConfigurationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetVideoEncoderConfigurationResponse);
	if (id < 0)
		return soap->error;
	return soap_out__trt__GetVideoEncoderConfigurationResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__GetVideoEncoderConfigurationResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__GetVideoEncoderConfigurationResponse(struct soap *soap, const char *tag, struct _trt__GetVideoEncoderConfigurationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__GetVideoEncoderConfigurationResponse **)soap_malloc(soap, sizeof(struct _trt__GetVideoEncoderConfigurationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__GetVideoEncoderConfigurationResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__GetVideoEncoderConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetVideoEncoderConfigurationResponse, sizeof(struct _trt__GetVideoEncoderConfigurationResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetVideoEncoderConfigurationResponse(struct soap *soap, struct _trt__GetVideoEncoderConfigurationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetVideoEncoderConfigurationResponse);
	if (soap_out_PointerTo_trt__GetVideoEncoderConfigurationResponse(soap, tag?tag:"trt:GetVideoEncoderConfigurationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetVideoEncoderConfigurationResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__GetVideoEncoderConfigurationResponse(struct soap *soap, struct _trt__GetVideoEncoderConfigurationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetVideoEncoderConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetVideoEncoderConfiguration(struct soap *soap, struct _trt__GetVideoEncoderConfiguration *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetVideoEncoderConfiguration))
		soap_serialize__trt__GetVideoEncoderConfiguration(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetVideoEncoderConfiguration(struct soap *soap, const char *tag, int id, struct _trt__GetVideoEncoderConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetVideoEncoderConfiguration);
	if (id < 0)
		return soap->error;
	return soap_out__trt__GetVideoEncoderConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__GetVideoEncoderConfiguration ** SOAP_FMAC4 soap_in_PointerTo_trt__GetVideoEncoderConfiguration(struct soap *soap, const char *tag, struct _trt__GetVideoEncoderConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__GetVideoEncoderConfiguration **)soap_malloc(soap, sizeof(struct _trt__GetVideoEncoderConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__GetVideoEncoderConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__GetVideoEncoderConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetVideoEncoderConfiguration, sizeof(struct _trt__GetVideoEncoderConfiguration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetVideoEncoderConfiguration(struct soap *soap, struct _trt__GetVideoEncoderConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetVideoEncoderConfiguration);
	if (soap_out_PointerTo_trt__GetVideoEncoderConfiguration(soap, tag?tag:"trt:GetVideoEncoderConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetVideoEncoderConfiguration ** SOAP_FMAC4 soap_get_PointerTo_trt__GetVideoEncoderConfiguration(struct soap *soap, struct _trt__GetVideoEncoderConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetVideoEncoderConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetVideoSourceConfigurationResponse(struct soap *soap, struct _trt__GetVideoSourceConfigurationResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetVideoSourceConfigurationResponse))
		soap_serialize__trt__GetVideoSourceConfigurationResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetVideoSourceConfigurationResponse(struct soap *soap, const char *tag, int id, struct _trt__GetVideoSourceConfigurationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetVideoSourceConfigurationResponse);
	if (id < 0)
		return soap->error;
	return soap_out__trt__GetVideoSourceConfigurationResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__GetVideoSourceConfigurationResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__GetVideoSourceConfigurationResponse(struct soap *soap, const char *tag, struct _trt__GetVideoSourceConfigurationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__GetVideoSourceConfigurationResponse **)soap_malloc(soap, sizeof(struct _trt__GetVideoSourceConfigurationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__GetVideoSourceConfigurationResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__GetVideoSourceConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetVideoSourceConfigurationResponse, sizeof(struct _trt__GetVideoSourceConfigurationResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetVideoSourceConfigurationResponse(struct soap *soap, struct _trt__GetVideoSourceConfigurationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetVideoSourceConfigurationResponse);
	if (soap_out_PointerTo_trt__GetVideoSourceConfigurationResponse(soap, tag?tag:"trt:GetVideoSourceConfigurationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetVideoSourceConfigurationResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__GetVideoSourceConfigurationResponse(struct soap *soap, struct _trt__GetVideoSourceConfigurationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetVideoSourceConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetVideoSourceConfiguration(struct soap *soap, struct _trt__GetVideoSourceConfiguration *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetVideoSourceConfiguration))
		soap_serialize__trt__GetVideoSourceConfiguration(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetVideoSourceConfiguration(struct soap *soap, const char *tag, int id, struct _trt__GetVideoSourceConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetVideoSourceConfiguration);
	if (id < 0)
		return soap->error;
	return soap_out__trt__GetVideoSourceConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__GetVideoSourceConfiguration ** SOAP_FMAC4 soap_in_PointerTo_trt__GetVideoSourceConfiguration(struct soap *soap, const char *tag, struct _trt__GetVideoSourceConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__GetVideoSourceConfiguration **)soap_malloc(soap, sizeof(struct _trt__GetVideoSourceConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__GetVideoSourceConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__GetVideoSourceConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetVideoSourceConfiguration, sizeof(struct _trt__GetVideoSourceConfiguration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetVideoSourceConfiguration(struct soap *soap, struct _trt__GetVideoSourceConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetVideoSourceConfiguration);
	if (soap_out_PointerTo_trt__GetVideoSourceConfiguration(soap, tag?tag:"trt:GetVideoSourceConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetVideoSourceConfiguration ** SOAP_FMAC4 soap_get_PointerTo_trt__GetVideoSourceConfiguration(struct soap *soap, struct _trt__GetVideoSourceConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetVideoSourceConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetAudioDecoderConfigurationsResponse(struct soap *soap, struct _trt__GetAudioDecoderConfigurationsResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetAudioDecoderConfigurationsResponse))
		soap_serialize__trt__GetAudioDecoderConfigurationsResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetAudioDecoderConfigurationsResponse(struct soap *soap, const char *tag, int id, struct _trt__GetAudioDecoderConfigurationsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetAudioDecoderConfigurationsResponse);
	if (id < 0)
		return soap->error;
	return soap_out__trt__GetAudioDecoderConfigurationsResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__GetAudioDecoderConfigurationsResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__GetAudioDecoderConfigurationsResponse(struct soap *soap, const char *tag, struct _trt__GetAudioDecoderConfigurationsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__GetAudioDecoderConfigurationsResponse **)soap_malloc(soap, sizeof(struct _trt__GetAudioDecoderConfigurationsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__GetAudioDecoderConfigurationsResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__GetAudioDecoderConfigurationsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetAudioDecoderConfigurationsResponse, sizeof(struct _trt__GetAudioDecoderConfigurationsResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetAudioDecoderConfigurationsResponse(struct soap *soap, struct _trt__GetAudioDecoderConfigurationsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetAudioDecoderConfigurationsResponse);
	if (soap_out_PointerTo_trt__GetAudioDecoderConfigurationsResponse(soap, tag?tag:"trt:GetAudioDecoderConfigurationsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetAudioDecoderConfigurationsResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__GetAudioDecoderConfigurationsResponse(struct soap *soap, struct _trt__GetAudioDecoderConfigurationsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetAudioDecoderConfigurationsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetAudioDecoderConfigurations(struct soap *soap, struct _trt__GetAudioDecoderConfigurations *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetAudioDecoderConfigurations))
		soap_serialize__trt__GetAudioDecoderConfigurations(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetAudioDecoderConfigurations(struct soap *soap, const char *tag, int id, struct _trt__GetAudioDecoderConfigurations *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetAudioDecoderConfigurations);
	if (id < 0)
		return soap->error;
	return soap_out__trt__GetAudioDecoderConfigurations(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__GetAudioDecoderConfigurations ** SOAP_FMAC4 soap_in_PointerTo_trt__GetAudioDecoderConfigurations(struct soap *soap, const char *tag, struct _trt__GetAudioDecoderConfigurations **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__GetAudioDecoderConfigurations **)soap_malloc(soap, sizeof(struct _trt__GetAudioDecoderConfigurations *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__GetAudioDecoderConfigurations(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__GetAudioDecoderConfigurations **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetAudioDecoderConfigurations, sizeof(struct _trt__GetAudioDecoderConfigurations), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetAudioDecoderConfigurations(struct soap *soap, struct _trt__GetAudioDecoderConfigurations *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetAudioDecoderConfigurations);
	if (soap_out_PointerTo_trt__GetAudioDecoderConfigurations(soap, tag?tag:"trt:GetAudioDecoderConfigurations", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetAudioDecoderConfigurations ** SOAP_FMAC4 soap_get_PointerTo_trt__GetAudioDecoderConfigurations(struct soap *soap, struct _trt__GetAudioDecoderConfigurations **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetAudioDecoderConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetAudioOutputConfigurationsResponse(struct soap *soap, struct _trt__GetAudioOutputConfigurationsResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetAudioOutputConfigurationsResponse))
		soap_serialize__trt__GetAudioOutputConfigurationsResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetAudioOutputConfigurationsResponse(struct soap *soap, const char *tag, int id, struct _trt__GetAudioOutputConfigurationsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetAudioOutputConfigurationsResponse);
	if (id < 0)
		return soap->error;
	return soap_out__trt__GetAudioOutputConfigurationsResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__GetAudioOutputConfigurationsResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__GetAudioOutputConfigurationsResponse(struct soap *soap, const char *tag, struct _trt__GetAudioOutputConfigurationsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__GetAudioOutputConfigurationsResponse **)soap_malloc(soap, sizeof(struct _trt__GetAudioOutputConfigurationsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__GetAudioOutputConfigurationsResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__GetAudioOutputConfigurationsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetAudioOutputConfigurationsResponse, sizeof(struct _trt__GetAudioOutputConfigurationsResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetAudioOutputConfigurationsResponse(struct soap *soap, struct _trt__GetAudioOutputConfigurationsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetAudioOutputConfigurationsResponse);
	if (soap_out_PointerTo_trt__GetAudioOutputConfigurationsResponse(soap, tag?tag:"trt:GetAudioOutputConfigurationsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetAudioOutputConfigurationsResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__GetAudioOutputConfigurationsResponse(struct soap *soap, struct _trt__GetAudioOutputConfigurationsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetAudioOutputConfigurationsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetAudioOutputConfigurations(struct soap *soap, struct _trt__GetAudioOutputConfigurations *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetAudioOutputConfigurations))
		soap_serialize__trt__GetAudioOutputConfigurations(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetAudioOutputConfigurations(struct soap *soap, const char *tag, int id, struct _trt__GetAudioOutputConfigurations *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetAudioOutputConfigurations);
	if (id < 0)
		return soap->error;
	return soap_out__trt__GetAudioOutputConfigurations(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__GetAudioOutputConfigurations ** SOAP_FMAC4 soap_in_PointerTo_trt__GetAudioOutputConfigurations(struct soap *soap, const char *tag, struct _trt__GetAudioOutputConfigurations **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__GetAudioOutputConfigurations **)soap_malloc(soap, sizeof(struct _trt__GetAudioOutputConfigurations *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__GetAudioOutputConfigurations(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__GetAudioOutputConfigurations **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetAudioOutputConfigurations, sizeof(struct _trt__GetAudioOutputConfigurations), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetAudioOutputConfigurations(struct soap *soap, struct _trt__GetAudioOutputConfigurations *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetAudioOutputConfigurations);
	if (soap_out_PointerTo_trt__GetAudioOutputConfigurations(soap, tag?tag:"trt:GetAudioOutputConfigurations", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetAudioOutputConfigurations ** SOAP_FMAC4 soap_get_PointerTo_trt__GetAudioOutputConfigurations(struct soap *soap, struct _trt__GetAudioOutputConfigurations **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetAudioOutputConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetMetadataConfigurationsResponse(struct soap *soap, struct _trt__GetMetadataConfigurationsResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetMetadataConfigurationsResponse))
		soap_serialize__trt__GetMetadataConfigurationsResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetMetadataConfigurationsResponse(struct soap *soap, const char *tag, int id, struct _trt__GetMetadataConfigurationsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetMetadataConfigurationsResponse);
	if (id < 0)
		return soap->error;
	return soap_out__trt__GetMetadataConfigurationsResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__GetMetadataConfigurationsResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__GetMetadataConfigurationsResponse(struct soap *soap, const char *tag, struct _trt__GetMetadataConfigurationsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__GetMetadataConfigurationsResponse **)soap_malloc(soap, sizeof(struct _trt__GetMetadataConfigurationsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__GetMetadataConfigurationsResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__GetMetadataConfigurationsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetMetadataConfigurationsResponse, sizeof(struct _trt__GetMetadataConfigurationsResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetMetadataConfigurationsResponse(struct soap *soap, struct _trt__GetMetadataConfigurationsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetMetadataConfigurationsResponse);
	if (soap_out_PointerTo_trt__GetMetadataConfigurationsResponse(soap, tag?tag:"trt:GetMetadataConfigurationsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetMetadataConfigurationsResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__GetMetadataConfigurationsResponse(struct soap *soap, struct _trt__GetMetadataConfigurationsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetMetadataConfigurationsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetMetadataConfigurations(struct soap *soap, struct _trt__GetMetadataConfigurations *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetMetadataConfigurations))
		soap_serialize__trt__GetMetadataConfigurations(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetMetadataConfigurations(struct soap *soap, const char *tag, int id, struct _trt__GetMetadataConfigurations *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetMetadataConfigurations);
	if (id < 0)
		return soap->error;
	return soap_out__trt__GetMetadataConfigurations(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__GetMetadataConfigurations ** SOAP_FMAC4 soap_in_PointerTo_trt__GetMetadataConfigurations(struct soap *soap, const char *tag, struct _trt__GetMetadataConfigurations **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__GetMetadataConfigurations **)soap_malloc(soap, sizeof(struct _trt__GetMetadataConfigurations *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__GetMetadataConfigurations(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__GetMetadataConfigurations **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetMetadataConfigurations, sizeof(struct _trt__GetMetadataConfigurations), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetMetadataConfigurations(struct soap *soap, struct _trt__GetMetadataConfigurations *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetMetadataConfigurations);
	if (soap_out_PointerTo_trt__GetMetadataConfigurations(soap, tag?tag:"trt:GetMetadataConfigurations", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetMetadataConfigurations ** SOAP_FMAC4 soap_get_PointerTo_trt__GetMetadataConfigurations(struct soap *soap, struct _trt__GetMetadataConfigurations **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetMetadataConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetVideoAnalyticsConfigurationsResponse(struct soap *soap, struct _trt__GetVideoAnalyticsConfigurationsResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetVideoAnalyticsConfigurationsResponse))
		soap_serialize__trt__GetVideoAnalyticsConfigurationsResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetVideoAnalyticsConfigurationsResponse(struct soap *soap, const char *tag, int id, struct _trt__GetVideoAnalyticsConfigurationsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetVideoAnalyticsConfigurationsResponse);
	if (id < 0)
		return soap->error;
	return soap_out__trt__GetVideoAnalyticsConfigurationsResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__GetVideoAnalyticsConfigurationsResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__GetVideoAnalyticsConfigurationsResponse(struct soap *soap, const char *tag, struct _trt__GetVideoAnalyticsConfigurationsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__GetVideoAnalyticsConfigurationsResponse **)soap_malloc(soap, sizeof(struct _trt__GetVideoAnalyticsConfigurationsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__GetVideoAnalyticsConfigurationsResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__GetVideoAnalyticsConfigurationsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetVideoAnalyticsConfigurationsResponse, sizeof(struct _trt__GetVideoAnalyticsConfigurationsResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetVideoAnalyticsConfigurationsResponse(struct soap *soap, struct _trt__GetVideoAnalyticsConfigurationsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetVideoAnalyticsConfigurationsResponse);
	if (soap_out_PointerTo_trt__GetVideoAnalyticsConfigurationsResponse(soap, tag?tag:"trt:GetVideoAnalyticsConfigurationsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetVideoAnalyticsConfigurationsResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__GetVideoAnalyticsConfigurationsResponse(struct soap *soap, struct _trt__GetVideoAnalyticsConfigurationsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetVideoAnalyticsConfigurationsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetVideoAnalyticsConfigurations(struct soap *soap, struct _trt__GetVideoAnalyticsConfigurations *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetVideoAnalyticsConfigurations))
		soap_serialize__trt__GetVideoAnalyticsConfigurations(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetVideoAnalyticsConfigurations(struct soap *soap, const char *tag, int id, struct _trt__GetVideoAnalyticsConfigurations *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetVideoAnalyticsConfigurations);
	if (id < 0)
		return soap->error;
	return soap_out__trt__GetVideoAnalyticsConfigurations(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__GetVideoAnalyticsConfigurations ** SOAP_FMAC4 soap_in_PointerTo_trt__GetVideoAnalyticsConfigurations(struct soap *soap, const char *tag, struct _trt__GetVideoAnalyticsConfigurations **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__GetVideoAnalyticsConfigurations **)soap_malloc(soap, sizeof(struct _trt__GetVideoAnalyticsConfigurations *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__GetVideoAnalyticsConfigurations(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__GetVideoAnalyticsConfigurations **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetVideoAnalyticsConfigurations, sizeof(struct _trt__GetVideoAnalyticsConfigurations), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetVideoAnalyticsConfigurations(struct soap *soap, struct _trt__GetVideoAnalyticsConfigurations *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetVideoAnalyticsConfigurations);
	if (soap_out_PointerTo_trt__GetVideoAnalyticsConfigurations(soap, tag?tag:"trt:GetVideoAnalyticsConfigurations", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetVideoAnalyticsConfigurations ** SOAP_FMAC4 soap_get_PointerTo_trt__GetVideoAnalyticsConfigurations(struct soap *soap, struct _trt__GetVideoAnalyticsConfigurations **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetVideoAnalyticsConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetAudioEncoderConfigurationsResponse(struct soap *soap, struct _trt__GetAudioEncoderConfigurationsResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetAudioEncoderConfigurationsResponse))
		soap_serialize__trt__GetAudioEncoderConfigurationsResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetAudioEncoderConfigurationsResponse(struct soap *soap, const char *tag, int id, struct _trt__GetAudioEncoderConfigurationsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetAudioEncoderConfigurationsResponse);
	if (id < 0)
		return soap->error;
	return soap_out__trt__GetAudioEncoderConfigurationsResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__GetAudioEncoderConfigurationsResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__GetAudioEncoderConfigurationsResponse(struct soap *soap, const char *tag, struct _trt__GetAudioEncoderConfigurationsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__GetAudioEncoderConfigurationsResponse **)soap_malloc(soap, sizeof(struct _trt__GetAudioEncoderConfigurationsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__GetAudioEncoderConfigurationsResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__GetAudioEncoderConfigurationsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetAudioEncoderConfigurationsResponse, sizeof(struct _trt__GetAudioEncoderConfigurationsResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetAudioEncoderConfigurationsResponse(struct soap *soap, struct _trt__GetAudioEncoderConfigurationsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetAudioEncoderConfigurationsResponse);
	if (soap_out_PointerTo_trt__GetAudioEncoderConfigurationsResponse(soap, tag?tag:"trt:GetAudioEncoderConfigurationsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetAudioEncoderConfigurationsResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__GetAudioEncoderConfigurationsResponse(struct soap *soap, struct _trt__GetAudioEncoderConfigurationsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetAudioEncoderConfigurationsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetAudioEncoderConfigurations(struct soap *soap, struct _trt__GetAudioEncoderConfigurations *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetAudioEncoderConfigurations))
		soap_serialize__trt__GetAudioEncoderConfigurations(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetAudioEncoderConfigurations(struct soap *soap, const char *tag, int id, struct _trt__GetAudioEncoderConfigurations *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetAudioEncoderConfigurations);
	if (id < 0)
		return soap->error;
	return soap_out__trt__GetAudioEncoderConfigurations(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__GetAudioEncoderConfigurations ** SOAP_FMAC4 soap_in_PointerTo_trt__GetAudioEncoderConfigurations(struct soap *soap, const char *tag, struct _trt__GetAudioEncoderConfigurations **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__GetAudioEncoderConfigurations **)soap_malloc(soap, sizeof(struct _trt__GetAudioEncoderConfigurations *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__GetAudioEncoderConfigurations(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__GetAudioEncoderConfigurations **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetAudioEncoderConfigurations, sizeof(struct _trt__GetAudioEncoderConfigurations), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetAudioEncoderConfigurations(struct soap *soap, struct _trt__GetAudioEncoderConfigurations *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetAudioEncoderConfigurations);
	if (soap_out_PointerTo_trt__GetAudioEncoderConfigurations(soap, tag?tag:"trt:GetAudioEncoderConfigurations", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetAudioEncoderConfigurations ** SOAP_FMAC4 soap_get_PointerTo_trt__GetAudioEncoderConfigurations(struct soap *soap, struct _trt__GetAudioEncoderConfigurations **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetAudioEncoderConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetAudioSourceConfigurationsResponse(struct soap *soap, struct _trt__GetAudioSourceConfigurationsResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetAudioSourceConfigurationsResponse))
		soap_serialize__trt__GetAudioSourceConfigurationsResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetAudioSourceConfigurationsResponse(struct soap *soap, const char *tag, int id, struct _trt__GetAudioSourceConfigurationsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetAudioSourceConfigurationsResponse);
	if (id < 0)
		return soap->error;
	return soap_out__trt__GetAudioSourceConfigurationsResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__GetAudioSourceConfigurationsResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__GetAudioSourceConfigurationsResponse(struct soap *soap, const char *tag, struct _trt__GetAudioSourceConfigurationsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__GetAudioSourceConfigurationsResponse **)soap_malloc(soap, sizeof(struct _trt__GetAudioSourceConfigurationsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__GetAudioSourceConfigurationsResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__GetAudioSourceConfigurationsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetAudioSourceConfigurationsResponse, sizeof(struct _trt__GetAudioSourceConfigurationsResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetAudioSourceConfigurationsResponse(struct soap *soap, struct _trt__GetAudioSourceConfigurationsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetAudioSourceConfigurationsResponse);
	if (soap_out_PointerTo_trt__GetAudioSourceConfigurationsResponse(soap, tag?tag:"trt:GetAudioSourceConfigurationsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetAudioSourceConfigurationsResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__GetAudioSourceConfigurationsResponse(struct soap *soap, struct _trt__GetAudioSourceConfigurationsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetAudioSourceConfigurationsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetAudioSourceConfigurations(struct soap *soap, struct _trt__GetAudioSourceConfigurations *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetAudioSourceConfigurations))
		soap_serialize__trt__GetAudioSourceConfigurations(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetAudioSourceConfigurations(struct soap *soap, const char *tag, int id, struct _trt__GetAudioSourceConfigurations *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetAudioSourceConfigurations);
	if (id < 0)
		return soap->error;
	return soap_out__trt__GetAudioSourceConfigurations(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__GetAudioSourceConfigurations ** SOAP_FMAC4 soap_in_PointerTo_trt__GetAudioSourceConfigurations(struct soap *soap, const char *tag, struct _trt__GetAudioSourceConfigurations **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__GetAudioSourceConfigurations **)soap_malloc(soap, sizeof(struct _trt__GetAudioSourceConfigurations *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__GetAudioSourceConfigurations(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__GetAudioSourceConfigurations **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetAudioSourceConfigurations, sizeof(struct _trt__GetAudioSourceConfigurations), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetAudioSourceConfigurations(struct soap *soap, struct _trt__GetAudioSourceConfigurations *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetAudioSourceConfigurations);
	if (soap_out_PointerTo_trt__GetAudioSourceConfigurations(soap, tag?tag:"trt:GetAudioSourceConfigurations", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetAudioSourceConfigurations ** SOAP_FMAC4 soap_get_PointerTo_trt__GetAudioSourceConfigurations(struct soap *soap, struct _trt__GetAudioSourceConfigurations **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetAudioSourceConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetVideoEncoderConfigurationsResponse(struct soap *soap, struct _trt__GetVideoEncoderConfigurationsResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetVideoEncoderConfigurationsResponse))
		soap_serialize__trt__GetVideoEncoderConfigurationsResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetVideoEncoderConfigurationsResponse(struct soap *soap, const char *tag, int id, struct _trt__GetVideoEncoderConfigurationsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetVideoEncoderConfigurationsResponse);
	if (id < 0)
		return soap->error;
	return soap_out__trt__GetVideoEncoderConfigurationsResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__GetVideoEncoderConfigurationsResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__GetVideoEncoderConfigurationsResponse(struct soap *soap, const char *tag, struct _trt__GetVideoEncoderConfigurationsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__GetVideoEncoderConfigurationsResponse **)soap_malloc(soap, sizeof(struct _trt__GetVideoEncoderConfigurationsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__GetVideoEncoderConfigurationsResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__GetVideoEncoderConfigurationsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetVideoEncoderConfigurationsResponse, sizeof(struct _trt__GetVideoEncoderConfigurationsResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetVideoEncoderConfigurationsResponse(struct soap *soap, struct _trt__GetVideoEncoderConfigurationsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetVideoEncoderConfigurationsResponse);
	if (soap_out_PointerTo_trt__GetVideoEncoderConfigurationsResponse(soap, tag?tag:"trt:GetVideoEncoderConfigurationsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetVideoEncoderConfigurationsResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__GetVideoEncoderConfigurationsResponse(struct soap *soap, struct _trt__GetVideoEncoderConfigurationsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetVideoEncoderConfigurationsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetVideoEncoderConfigurations(struct soap *soap, struct _trt__GetVideoEncoderConfigurations *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetVideoEncoderConfigurations))
		soap_serialize__trt__GetVideoEncoderConfigurations(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetVideoEncoderConfigurations(struct soap *soap, const char *tag, int id, struct _trt__GetVideoEncoderConfigurations *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetVideoEncoderConfigurations);
	if (id < 0)
		return soap->error;
	return soap_out__trt__GetVideoEncoderConfigurations(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__GetVideoEncoderConfigurations ** SOAP_FMAC4 soap_in_PointerTo_trt__GetVideoEncoderConfigurations(struct soap *soap, const char *tag, struct _trt__GetVideoEncoderConfigurations **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__GetVideoEncoderConfigurations **)soap_malloc(soap, sizeof(struct _trt__GetVideoEncoderConfigurations *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__GetVideoEncoderConfigurations(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__GetVideoEncoderConfigurations **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetVideoEncoderConfigurations, sizeof(struct _trt__GetVideoEncoderConfigurations), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetVideoEncoderConfigurations(struct soap *soap, struct _trt__GetVideoEncoderConfigurations *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetVideoEncoderConfigurations);
	if (soap_out_PointerTo_trt__GetVideoEncoderConfigurations(soap, tag?tag:"trt:GetVideoEncoderConfigurations", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetVideoEncoderConfigurations ** SOAP_FMAC4 soap_get_PointerTo_trt__GetVideoEncoderConfigurations(struct soap *soap, struct _trt__GetVideoEncoderConfigurations **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetVideoEncoderConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetVideoSourceConfigurationsResponse(struct soap *soap, struct _trt__GetVideoSourceConfigurationsResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetVideoSourceConfigurationsResponse))
		soap_serialize__trt__GetVideoSourceConfigurationsResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetVideoSourceConfigurationsResponse(struct soap *soap, const char *tag, int id, struct _trt__GetVideoSourceConfigurationsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetVideoSourceConfigurationsResponse);
	if (id < 0)
		return soap->error;
	return soap_out__trt__GetVideoSourceConfigurationsResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__GetVideoSourceConfigurationsResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__GetVideoSourceConfigurationsResponse(struct soap *soap, const char *tag, struct _trt__GetVideoSourceConfigurationsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__GetVideoSourceConfigurationsResponse **)soap_malloc(soap, sizeof(struct _trt__GetVideoSourceConfigurationsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__GetVideoSourceConfigurationsResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__GetVideoSourceConfigurationsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetVideoSourceConfigurationsResponse, sizeof(struct _trt__GetVideoSourceConfigurationsResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetVideoSourceConfigurationsResponse(struct soap *soap, struct _trt__GetVideoSourceConfigurationsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetVideoSourceConfigurationsResponse);
	if (soap_out_PointerTo_trt__GetVideoSourceConfigurationsResponse(soap, tag?tag:"trt:GetVideoSourceConfigurationsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetVideoSourceConfigurationsResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__GetVideoSourceConfigurationsResponse(struct soap *soap, struct _trt__GetVideoSourceConfigurationsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetVideoSourceConfigurationsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetVideoSourceConfigurations(struct soap *soap, struct _trt__GetVideoSourceConfigurations *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetVideoSourceConfigurations))
		soap_serialize__trt__GetVideoSourceConfigurations(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetVideoSourceConfigurations(struct soap *soap, const char *tag, int id, struct _trt__GetVideoSourceConfigurations *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetVideoSourceConfigurations);
	if (id < 0)
		return soap->error;
	return soap_out__trt__GetVideoSourceConfigurations(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__GetVideoSourceConfigurations ** SOAP_FMAC4 soap_in_PointerTo_trt__GetVideoSourceConfigurations(struct soap *soap, const char *tag, struct _trt__GetVideoSourceConfigurations **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__GetVideoSourceConfigurations **)soap_malloc(soap, sizeof(struct _trt__GetVideoSourceConfigurations *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__GetVideoSourceConfigurations(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__GetVideoSourceConfigurations **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetVideoSourceConfigurations, sizeof(struct _trt__GetVideoSourceConfigurations), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetVideoSourceConfigurations(struct soap *soap, struct _trt__GetVideoSourceConfigurations *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetVideoSourceConfigurations);
	if (soap_out_PointerTo_trt__GetVideoSourceConfigurations(soap, tag?tag:"trt:GetVideoSourceConfigurations", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetVideoSourceConfigurations ** SOAP_FMAC4 soap_get_PointerTo_trt__GetVideoSourceConfigurations(struct soap *soap, struct _trt__GetVideoSourceConfigurations **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetVideoSourceConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__DeleteProfileResponse(struct soap *soap, struct _trt__DeleteProfileResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__DeleteProfileResponse))
		soap_serialize__trt__DeleteProfileResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__DeleteProfileResponse(struct soap *soap, const char *tag, int id, struct _trt__DeleteProfileResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__DeleteProfileResponse);
	if (id < 0)
		return soap->error;
	return soap_out__trt__DeleteProfileResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__DeleteProfileResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__DeleteProfileResponse(struct soap *soap, const char *tag, struct _trt__DeleteProfileResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__DeleteProfileResponse **)soap_malloc(soap, sizeof(struct _trt__DeleteProfileResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__DeleteProfileResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__DeleteProfileResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__DeleteProfileResponse, sizeof(struct _trt__DeleteProfileResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__DeleteProfileResponse(struct soap *soap, struct _trt__DeleteProfileResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__DeleteProfileResponse);
	if (soap_out_PointerTo_trt__DeleteProfileResponse(soap, tag?tag:"trt:DeleteProfileResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__DeleteProfileResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__DeleteProfileResponse(struct soap *soap, struct _trt__DeleteProfileResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__DeleteProfileResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__DeleteProfile(struct soap *soap, struct _trt__DeleteProfile *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__DeleteProfile))
		soap_serialize__trt__DeleteProfile(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__DeleteProfile(struct soap *soap, const char *tag, int id, struct _trt__DeleteProfile *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__DeleteProfile);
	if (id < 0)
		return soap->error;
	return soap_out__trt__DeleteProfile(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__DeleteProfile ** SOAP_FMAC4 soap_in_PointerTo_trt__DeleteProfile(struct soap *soap, const char *tag, struct _trt__DeleteProfile **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__DeleteProfile **)soap_malloc(soap, sizeof(struct _trt__DeleteProfile *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__DeleteProfile(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__DeleteProfile **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__DeleteProfile, sizeof(struct _trt__DeleteProfile), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__DeleteProfile(struct soap *soap, struct _trt__DeleteProfile *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__DeleteProfile);
	if (soap_out_PointerTo_trt__DeleteProfile(soap, tag?tag:"trt:DeleteProfile", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__DeleteProfile ** SOAP_FMAC4 soap_get_PointerTo_trt__DeleteProfile(struct soap *soap, struct _trt__DeleteProfile **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__DeleteProfile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__RemoveAudioDecoderConfigurationResponse(struct soap *soap, struct _trt__RemoveAudioDecoderConfigurationResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__RemoveAudioDecoderConfigurationResponse))
		soap_serialize__trt__RemoveAudioDecoderConfigurationResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__RemoveAudioDecoderConfigurationResponse(struct soap *soap, const char *tag, int id, struct _trt__RemoveAudioDecoderConfigurationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__RemoveAudioDecoderConfigurationResponse);
	if (id < 0)
		return soap->error;
	return soap_out__trt__RemoveAudioDecoderConfigurationResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__RemoveAudioDecoderConfigurationResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__RemoveAudioDecoderConfigurationResponse(struct soap *soap, const char *tag, struct _trt__RemoveAudioDecoderConfigurationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__RemoveAudioDecoderConfigurationResponse **)soap_malloc(soap, sizeof(struct _trt__RemoveAudioDecoderConfigurationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__RemoveAudioDecoderConfigurationResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__RemoveAudioDecoderConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__RemoveAudioDecoderConfigurationResponse, sizeof(struct _trt__RemoveAudioDecoderConfigurationResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__RemoveAudioDecoderConfigurationResponse(struct soap *soap, struct _trt__RemoveAudioDecoderConfigurationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__RemoveAudioDecoderConfigurationResponse);
	if (soap_out_PointerTo_trt__RemoveAudioDecoderConfigurationResponse(soap, tag?tag:"trt:RemoveAudioDecoderConfigurationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__RemoveAudioDecoderConfigurationResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__RemoveAudioDecoderConfigurationResponse(struct soap *soap, struct _trt__RemoveAudioDecoderConfigurationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__RemoveAudioDecoderConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__RemoveAudioDecoderConfiguration(struct soap *soap, struct _trt__RemoveAudioDecoderConfiguration *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__RemoveAudioDecoderConfiguration))
		soap_serialize__trt__RemoveAudioDecoderConfiguration(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__RemoveAudioDecoderConfiguration(struct soap *soap, const char *tag, int id, struct _trt__RemoveAudioDecoderConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__RemoveAudioDecoderConfiguration);
	if (id < 0)
		return soap->error;
	return soap_out__trt__RemoveAudioDecoderConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__RemoveAudioDecoderConfiguration ** SOAP_FMAC4 soap_in_PointerTo_trt__RemoveAudioDecoderConfiguration(struct soap *soap, const char *tag, struct _trt__RemoveAudioDecoderConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__RemoveAudioDecoderConfiguration **)soap_malloc(soap, sizeof(struct _trt__RemoveAudioDecoderConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__RemoveAudioDecoderConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__RemoveAudioDecoderConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__RemoveAudioDecoderConfiguration, sizeof(struct _trt__RemoveAudioDecoderConfiguration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__RemoveAudioDecoderConfiguration(struct soap *soap, struct _trt__RemoveAudioDecoderConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__RemoveAudioDecoderConfiguration);
	if (soap_out_PointerTo_trt__RemoveAudioDecoderConfiguration(soap, tag?tag:"trt:RemoveAudioDecoderConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__RemoveAudioDecoderConfiguration ** SOAP_FMAC4 soap_get_PointerTo_trt__RemoveAudioDecoderConfiguration(struct soap *soap, struct _trt__RemoveAudioDecoderConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__RemoveAudioDecoderConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__RemoveAudioOutputConfigurationResponse(struct soap *soap, struct _trt__RemoveAudioOutputConfigurationResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__RemoveAudioOutputConfigurationResponse))
		soap_serialize__trt__RemoveAudioOutputConfigurationResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__RemoveAudioOutputConfigurationResponse(struct soap *soap, const char *tag, int id, struct _trt__RemoveAudioOutputConfigurationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__RemoveAudioOutputConfigurationResponse);
	if (id < 0)
		return soap->error;
	return soap_out__trt__RemoveAudioOutputConfigurationResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__RemoveAudioOutputConfigurationResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__RemoveAudioOutputConfigurationResponse(struct soap *soap, const char *tag, struct _trt__RemoveAudioOutputConfigurationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__RemoveAudioOutputConfigurationResponse **)soap_malloc(soap, sizeof(struct _trt__RemoveAudioOutputConfigurationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__RemoveAudioOutputConfigurationResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__RemoveAudioOutputConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__RemoveAudioOutputConfigurationResponse, sizeof(struct _trt__RemoveAudioOutputConfigurationResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__RemoveAudioOutputConfigurationResponse(struct soap *soap, struct _trt__RemoveAudioOutputConfigurationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__RemoveAudioOutputConfigurationResponse);
	if (soap_out_PointerTo_trt__RemoveAudioOutputConfigurationResponse(soap, tag?tag:"trt:RemoveAudioOutputConfigurationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__RemoveAudioOutputConfigurationResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__RemoveAudioOutputConfigurationResponse(struct soap *soap, struct _trt__RemoveAudioOutputConfigurationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__RemoveAudioOutputConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__RemoveAudioOutputConfiguration(struct soap *soap, struct _trt__RemoveAudioOutputConfiguration *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__RemoveAudioOutputConfiguration))
		soap_serialize__trt__RemoveAudioOutputConfiguration(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__RemoveAudioOutputConfiguration(struct soap *soap, const char *tag, int id, struct _trt__RemoveAudioOutputConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__RemoveAudioOutputConfiguration);
	if (id < 0)
		return soap->error;
	return soap_out__trt__RemoveAudioOutputConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__RemoveAudioOutputConfiguration ** SOAP_FMAC4 soap_in_PointerTo_trt__RemoveAudioOutputConfiguration(struct soap *soap, const char *tag, struct _trt__RemoveAudioOutputConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__RemoveAudioOutputConfiguration **)soap_malloc(soap, sizeof(struct _trt__RemoveAudioOutputConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__RemoveAudioOutputConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__RemoveAudioOutputConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__RemoveAudioOutputConfiguration, sizeof(struct _trt__RemoveAudioOutputConfiguration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__RemoveAudioOutputConfiguration(struct soap *soap, struct _trt__RemoveAudioOutputConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__RemoveAudioOutputConfiguration);
	if (soap_out_PointerTo_trt__RemoveAudioOutputConfiguration(soap, tag?tag:"trt:RemoveAudioOutputConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__RemoveAudioOutputConfiguration ** SOAP_FMAC4 soap_get_PointerTo_trt__RemoveAudioOutputConfiguration(struct soap *soap, struct _trt__RemoveAudioOutputConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__RemoveAudioOutputConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__RemoveMetadataConfigurationResponse(struct soap *soap, struct _trt__RemoveMetadataConfigurationResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__RemoveMetadataConfigurationResponse))
		soap_serialize__trt__RemoveMetadataConfigurationResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__RemoveMetadataConfigurationResponse(struct soap *soap, const char *tag, int id, struct _trt__RemoveMetadataConfigurationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__RemoveMetadataConfigurationResponse);
	if (id < 0)
		return soap->error;
	return soap_out__trt__RemoveMetadataConfigurationResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__RemoveMetadataConfigurationResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__RemoveMetadataConfigurationResponse(struct soap *soap, const char *tag, struct _trt__RemoveMetadataConfigurationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__RemoveMetadataConfigurationResponse **)soap_malloc(soap, sizeof(struct _trt__RemoveMetadataConfigurationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__RemoveMetadataConfigurationResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__RemoveMetadataConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__RemoveMetadataConfigurationResponse, sizeof(struct _trt__RemoveMetadataConfigurationResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__RemoveMetadataConfigurationResponse(struct soap *soap, struct _trt__RemoveMetadataConfigurationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__RemoveMetadataConfigurationResponse);
	if (soap_out_PointerTo_trt__RemoveMetadataConfigurationResponse(soap, tag?tag:"trt:RemoveMetadataConfigurationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__RemoveMetadataConfigurationResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__RemoveMetadataConfigurationResponse(struct soap *soap, struct _trt__RemoveMetadataConfigurationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__RemoveMetadataConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__RemoveMetadataConfiguration(struct soap *soap, struct _trt__RemoveMetadataConfiguration *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__RemoveMetadataConfiguration))
		soap_serialize__trt__RemoveMetadataConfiguration(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__RemoveMetadataConfiguration(struct soap *soap, const char *tag, int id, struct _trt__RemoveMetadataConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__RemoveMetadataConfiguration);
	if (id < 0)
		return soap->error;
	return soap_out__trt__RemoveMetadataConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__RemoveMetadataConfiguration ** SOAP_FMAC4 soap_in_PointerTo_trt__RemoveMetadataConfiguration(struct soap *soap, const char *tag, struct _trt__RemoveMetadataConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__RemoveMetadataConfiguration **)soap_malloc(soap, sizeof(struct _trt__RemoveMetadataConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__RemoveMetadataConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__RemoveMetadataConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__RemoveMetadataConfiguration, sizeof(struct _trt__RemoveMetadataConfiguration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__RemoveMetadataConfiguration(struct soap *soap, struct _trt__RemoveMetadataConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__RemoveMetadataConfiguration);
	if (soap_out_PointerTo_trt__RemoveMetadataConfiguration(soap, tag?tag:"trt:RemoveMetadataConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__RemoveMetadataConfiguration ** SOAP_FMAC4 soap_get_PointerTo_trt__RemoveMetadataConfiguration(struct soap *soap, struct _trt__RemoveMetadataConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__RemoveMetadataConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__RemoveVideoAnalyticsConfigurationResponse(struct soap *soap, struct _trt__RemoveVideoAnalyticsConfigurationResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__RemoveVideoAnalyticsConfigurationResponse))
		soap_serialize__trt__RemoveVideoAnalyticsConfigurationResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__RemoveVideoAnalyticsConfigurationResponse(struct soap *soap, const char *tag, int id, struct _trt__RemoveVideoAnalyticsConfigurationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__RemoveVideoAnalyticsConfigurationResponse);
	if (id < 0)
		return soap->error;
	return soap_out__trt__RemoveVideoAnalyticsConfigurationResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__RemoveVideoAnalyticsConfigurationResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__RemoveVideoAnalyticsConfigurationResponse(struct soap *soap, const char *tag, struct _trt__RemoveVideoAnalyticsConfigurationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__RemoveVideoAnalyticsConfigurationResponse **)soap_malloc(soap, sizeof(struct _trt__RemoveVideoAnalyticsConfigurationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__RemoveVideoAnalyticsConfigurationResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__RemoveVideoAnalyticsConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__RemoveVideoAnalyticsConfigurationResponse, sizeof(struct _trt__RemoveVideoAnalyticsConfigurationResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__RemoveVideoAnalyticsConfigurationResponse(struct soap *soap, struct _trt__RemoveVideoAnalyticsConfigurationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__RemoveVideoAnalyticsConfigurationResponse);
	if (soap_out_PointerTo_trt__RemoveVideoAnalyticsConfigurationResponse(soap, tag?tag:"trt:RemoveVideoAnalyticsConfigurationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__RemoveVideoAnalyticsConfigurationResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__RemoveVideoAnalyticsConfigurationResponse(struct soap *soap, struct _trt__RemoveVideoAnalyticsConfigurationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__RemoveVideoAnalyticsConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__RemoveVideoAnalyticsConfiguration(struct soap *soap, struct _trt__RemoveVideoAnalyticsConfiguration *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__RemoveVideoAnalyticsConfiguration))
		soap_serialize__trt__RemoveVideoAnalyticsConfiguration(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__RemoveVideoAnalyticsConfiguration(struct soap *soap, const char *tag, int id, struct _trt__RemoveVideoAnalyticsConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__RemoveVideoAnalyticsConfiguration);
	if (id < 0)
		return soap->error;
	return soap_out__trt__RemoveVideoAnalyticsConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__RemoveVideoAnalyticsConfiguration ** SOAP_FMAC4 soap_in_PointerTo_trt__RemoveVideoAnalyticsConfiguration(struct soap *soap, const char *tag, struct _trt__RemoveVideoAnalyticsConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__RemoveVideoAnalyticsConfiguration **)soap_malloc(soap, sizeof(struct _trt__RemoveVideoAnalyticsConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__RemoveVideoAnalyticsConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__RemoveVideoAnalyticsConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__RemoveVideoAnalyticsConfiguration, sizeof(struct _trt__RemoveVideoAnalyticsConfiguration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__RemoveVideoAnalyticsConfiguration(struct soap *soap, struct _trt__RemoveVideoAnalyticsConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__RemoveVideoAnalyticsConfiguration);
	if (soap_out_PointerTo_trt__RemoveVideoAnalyticsConfiguration(soap, tag?tag:"trt:RemoveVideoAnalyticsConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__RemoveVideoAnalyticsConfiguration ** SOAP_FMAC4 soap_get_PointerTo_trt__RemoveVideoAnalyticsConfiguration(struct soap *soap, struct _trt__RemoveVideoAnalyticsConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__RemoveVideoAnalyticsConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__RemovePTZConfigurationResponse(struct soap *soap, struct _trt__RemovePTZConfigurationResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__RemovePTZConfigurationResponse))
		soap_serialize__trt__RemovePTZConfigurationResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__RemovePTZConfigurationResponse(struct soap *soap, const char *tag, int id, struct _trt__RemovePTZConfigurationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__RemovePTZConfigurationResponse);
	if (id < 0)
		return soap->error;
	return soap_out__trt__RemovePTZConfigurationResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__RemovePTZConfigurationResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__RemovePTZConfigurationResponse(struct soap *soap, const char *tag, struct _trt__RemovePTZConfigurationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__RemovePTZConfigurationResponse **)soap_malloc(soap, sizeof(struct _trt__RemovePTZConfigurationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__RemovePTZConfigurationResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__RemovePTZConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__RemovePTZConfigurationResponse, sizeof(struct _trt__RemovePTZConfigurationResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__RemovePTZConfigurationResponse(struct soap *soap, struct _trt__RemovePTZConfigurationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__RemovePTZConfigurationResponse);
	if (soap_out_PointerTo_trt__RemovePTZConfigurationResponse(soap, tag?tag:"trt:RemovePTZConfigurationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__RemovePTZConfigurationResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__RemovePTZConfigurationResponse(struct soap *soap, struct _trt__RemovePTZConfigurationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__RemovePTZConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__RemovePTZConfiguration(struct soap *soap, struct _trt__RemovePTZConfiguration *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__RemovePTZConfiguration))
		soap_serialize__trt__RemovePTZConfiguration(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__RemovePTZConfiguration(struct soap *soap, const char *tag, int id, struct _trt__RemovePTZConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__RemovePTZConfiguration);
	if (id < 0)
		return soap->error;
	return soap_out__trt__RemovePTZConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__RemovePTZConfiguration ** SOAP_FMAC4 soap_in_PointerTo_trt__RemovePTZConfiguration(struct soap *soap, const char *tag, struct _trt__RemovePTZConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__RemovePTZConfiguration **)soap_malloc(soap, sizeof(struct _trt__RemovePTZConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__RemovePTZConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__RemovePTZConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__RemovePTZConfiguration, sizeof(struct _trt__RemovePTZConfiguration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__RemovePTZConfiguration(struct soap *soap, struct _trt__RemovePTZConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__RemovePTZConfiguration);
	if (soap_out_PointerTo_trt__RemovePTZConfiguration(soap, tag?tag:"trt:RemovePTZConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__RemovePTZConfiguration ** SOAP_FMAC4 soap_get_PointerTo_trt__RemovePTZConfiguration(struct soap *soap, struct _trt__RemovePTZConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__RemovePTZConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__RemoveAudioSourceConfigurationResponse(struct soap *soap, struct _trt__RemoveAudioSourceConfigurationResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__RemoveAudioSourceConfigurationResponse))
		soap_serialize__trt__RemoveAudioSourceConfigurationResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__RemoveAudioSourceConfigurationResponse(struct soap *soap, const char *tag, int id, struct _trt__RemoveAudioSourceConfigurationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__RemoveAudioSourceConfigurationResponse);
	if (id < 0)
		return soap->error;
	return soap_out__trt__RemoveAudioSourceConfigurationResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__RemoveAudioSourceConfigurationResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__RemoveAudioSourceConfigurationResponse(struct soap *soap, const char *tag, struct _trt__RemoveAudioSourceConfigurationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__RemoveAudioSourceConfigurationResponse **)soap_malloc(soap, sizeof(struct _trt__RemoveAudioSourceConfigurationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__RemoveAudioSourceConfigurationResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__RemoveAudioSourceConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__RemoveAudioSourceConfigurationResponse, sizeof(struct _trt__RemoveAudioSourceConfigurationResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__RemoveAudioSourceConfigurationResponse(struct soap *soap, struct _trt__RemoveAudioSourceConfigurationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__RemoveAudioSourceConfigurationResponse);
	if (soap_out_PointerTo_trt__RemoveAudioSourceConfigurationResponse(soap, tag?tag:"trt:RemoveAudioSourceConfigurationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__RemoveAudioSourceConfigurationResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__RemoveAudioSourceConfigurationResponse(struct soap *soap, struct _trt__RemoveAudioSourceConfigurationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__RemoveAudioSourceConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__RemoveAudioSourceConfiguration(struct soap *soap, struct _trt__RemoveAudioSourceConfiguration *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__RemoveAudioSourceConfiguration))
		soap_serialize__trt__RemoveAudioSourceConfiguration(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__RemoveAudioSourceConfiguration(struct soap *soap, const char *tag, int id, struct _trt__RemoveAudioSourceConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__RemoveAudioSourceConfiguration);
	if (id < 0)
		return soap->error;
	return soap_out__trt__RemoveAudioSourceConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__RemoveAudioSourceConfiguration ** SOAP_FMAC4 soap_in_PointerTo_trt__RemoveAudioSourceConfiguration(struct soap *soap, const char *tag, struct _trt__RemoveAudioSourceConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__RemoveAudioSourceConfiguration **)soap_malloc(soap, sizeof(struct _trt__RemoveAudioSourceConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__RemoveAudioSourceConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__RemoveAudioSourceConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__RemoveAudioSourceConfiguration, sizeof(struct _trt__RemoveAudioSourceConfiguration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__RemoveAudioSourceConfiguration(struct soap *soap, struct _trt__RemoveAudioSourceConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__RemoveAudioSourceConfiguration);
	if (soap_out_PointerTo_trt__RemoveAudioSourceConfiguration(soap, tag?tag:"trt:RemoveAudioSourceConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__RemoveAudioSourceConfiguration ** SOAP_FMAC4 soap_get_PointerTo_trt__RemoveAudioSourceConfiguration(struct soap *soap, struct _trt__RemoveAudioSourceConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__RemoveAudioSourceConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__RemoveAudioEncoderConfigurationResponse(struct soap *soap, struct _trt__RemoveAudioEncoderConfigurationResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__RemoveAudioEncoderConfigurationResponse))
		soap_serialize__trt__RemoveAudioEncoderConfigurationResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__RemoveAudioEncoderConfigurationResponse(struct soap *soap, const char *tag, int id, struct _trt__RemoveAudioEncoderConfigurationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__RemoveAudioEncoderConfigurationResponse);
	if (id < 0)
		return soap->error;
	return soap_out__trt__RemoveAudioEncoderConfigurationResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__RemoveAudioEncoderConfigurationResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__RemoveAudioEncoderConfigurationResponse(struct soap *soap, const char *tag, struct _trt__RemoveAudioEncoderConfigurationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__RemoveAudioEncoderConfigurationResponse **)soap_malloc(soap, sizeof(struct _trt__RemoveAudioEncoderConfigurationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__RemoveAudioEncoderConfigurationResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__RemoveAudioEncoderConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__RemoveAudioEncoderConfigurationResponse, sizeof(struct _trt__RemoveAudioEncoderConfigurationResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__RemoveAudioEncoderConfigurationResponse(struct soap *soap, struct _trt__RemoveAudioEncoderConfigurationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__RemoveAudioEncoderConfigurationResponse);
	if (soap_out_PointerTo_trt__RemoveAudioEncoderConfigurationResponse(soap, tag?tag:"trt:RemoveAudioEncoderConfigurationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__RemoveAudioEncoderConfigurationResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__RemoveAudioEncoderConfigurationResponse(struct soap *soap, struct _trt__RemoveAudioEncoderConfigurationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__RemoveAudioEncoderConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__RemoveAudioEncoderConfiguration(struct soap *soap, struct _trt__RemoveAudioEncoderConfiguration *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__RemoveAudioEncoderConfiguration))
		soap_serialize__trt__RemoveAudioEncoderConfiguration(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__RemoveAudioEncoderConfiguration(struct soap *soap, const char *tag, int id, struct _trt__RemoveAudioEncoderConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__RemoveAudioEncoderConfiguration);
	if (id < 0)
		return soap->error;
	return soap_out__trt__RemoveAudioEncoderConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__RemoveAudioEncoderConfiguration ** SOAP_FMAC4 soap_in_PointerTo_trt__RemoveAudioEncoderConfiguration(struct soap *soap, const char *tag, struct _trt__RemoveAudioEncoderConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__RemoveAudioEncoderConfiguration **)soap_malloc(soap, sizeof(struct _trt__RemoveAudioEncoderConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__RemoveAudioEncoderConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__RemoveAudioEncoderConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__RemoveAudioEncoderConfiguration, sizeof(struct _trt__RemoveAudioEncoderConfiguration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__RemoveAudioEncoderConfiguration(struct soap *soap, struct _trt__RemoveAudioEncoderConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__RemoveAudioEncoderConfiguration);
	if (soap_out_PointerTo_trt__RemoveAudioEncoderConfiguration(soap, tag?tag:"trt:RemoveAudioEncoderConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__RemoveAudioEncoderConfiguration ** SOAP_FMAC4 soap_get_PointerTo_trt__RemoveAudioEncoderConfiguration(struct soap *soap, struct _trt__RemoveAudioEncoderConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__RemoveAudioEncoderConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__RemoveVideoSourceConfigurationResponse(struct soap *soap, struct _trt__RemoveVideoSourceConfigurationResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__RemoveVideoSourceConfigurationResponse))
		soap_serialize__trt__RemoveVideoSourceConfigurationResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__RemoveVideoSourceConfigurationResponse(struct soap *soap, const char *tag, int id, struct _trt__RemoveVideoSourceConfigurationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__RemoveVideoSourceConfigurationResponse);
	if (id < 0)
		return soap->error;
	return soap_out__trt__RemoveVideoSourceConfigurationResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__RemoveVideoSourceConfigurationResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__RemoveVideoSourceConfigurationResponse(struct soap *soap, const char *tag, struct _trt__RemoveVideoSourceConfigurationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__RemoveVideoSourceConfigurationResponse **)soap_malloc(soap, sizeof(struct _trt__RemoveVideoSourceConfigurationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__RemoveVideoSourceConfigurationResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__RemoveVideoSourceConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__RemoveVideoSourceConfigurationResponse, sizeof(struct _trt__RemoveVideoSourceConfigurationResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__RemoveVideoSourceConfigurationResponse(struct soap *soap, struct _trt__RemoveVideoSourceConfigurationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__RemoveVideoSourceConfigurationResponse);
	if (soap_out_PointerTo_trt__RemoveVideoSourceConfigurationResponse(soap, tag?tag:"trt:RemoveVideoSourceConfigurationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__RemoveVideoSourceConfigurationResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__RemoveVideoSourceConfigurationResponse(struct soap *soap, struct _trt__RemoveVideoSourceConfigurationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__RemoveVideoSourceConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__RemoveVideoSourceConfiguration(struct soap *soap, struct _trt__RemoveVideoSourceConfiguration *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__RemoveVideoSourceConfiguration))
		soap_serialize__trt__RemoveVideoSourceConfiguration(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__RemoveVideoSourceConfiguration(struct soap *soap, const char *tag, int id, struct _trt__RemoveVideoSourceConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__RemoveVideoSourceConfiguration);
	if (id < 0)
		return soap->error;
	return soap_out__trt__RemoveVideoSourceConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__RemoveVideoSourceConfiguration ** SOAP_FMAC4 soap_in_PointerTo_trt__RemoveVideoSourceConfiguration(struct soap *soap, const char *tag, struct _trt__RemoveVideoSourceConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__RemoveVideoSourceConfiguration **)soap_malloc(soap, sizeof(struct _trt__RemoveVideoSourceConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__RemoveVideoSourceConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__RemoveVideoSourceConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__RemoveVideoSourceConfiguration, sizeof(struct _trt__RemoveVideoSourceConfiguration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__RemoveVideoSourceConfiguration(struct soap *soap, struct _trt__RemoveVideoSourceConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__RemoveVideoSourceConfiguration);
	if (soap_out_PointerTo_trt__RemoveVideoSourceConfiguration(soap, tag?tag:"trt:RemoveVideoSourceConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__RemoveVideoSourceConfiguration ** SOAP_FMAC4 soap_get_PointerTo_trt__RemoveVideoSourceConfiguration(struct soap *soap, struct _trt__RemoveVideoSourceConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__RemoveVideoSourceConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__RemoveVideoEncoderConfigurationResponse(struct soap *soap, struct _trt__RemoveVideoEncoderConfigurationResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__RemoveVideoEncoderConfigurationResponse))
		soap_serialize__trt__RemoveVideoEncoderConfigurationResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__RemoveVideoEncoderConfigurationResponse(struct soap *soap, const char *tag, int id, struct _trt__RemoveVideoEncoderConfigurationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__RemoveVideoEncoderConfigurationResponse);
	if (id < 0)
		return soap->error;
	return soap_out__trt__RemoveVideoEncoderConfigurationResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__RemoveVideoEncoderConfigurationResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__RemoveVideoEncoderConfigurationResponse(struct soap *soap, const char *tag, struct _trt__RemoveVideoEncoderConfigurationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__RemoveVideoEncoderConfigurationResponse **)soap_malloc(soap, sizeof(struct _trt__RemoveVideoEncoderConfigurationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__RemoveVideoEncoderConfigurationResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__RemoveVideoEncoderConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__RemoveVideoEncoderConfigurationResponse, sizeof(struct _trt__RemoveVideoEncoderConfigurationResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__RemoveVideoEncoderConfigurationResponse(struct soap *soap, struct _trt__RemoveVideoEncoderConfigurationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__RemoveVideoEncoderConfigurationResponse);
	if (soap_out_PointerTo_trt__RemoveVideoEncoderConfigurationResponse(soap, tag?tag:"trt:RemoveVideoEncoderConfigurationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__RemoveVideoEncoderConfigurationResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__RemoveVideoEncoderConfigurationResponse(struct soap *soap, struct _trt__RemoveVideoEncoderConfigurationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__RemoveVideoEncoderConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__RemoveVideoEncoderConfiguration(struct soap *soap, struct _trt__RemoveVideoEncoderConfiguration *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__RemoveVideoEncoderConfiguration))
		soap_serialize__trt__RemoveVideoEncoderConfiguration(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__RemoveVideoEncoderConfiguration(struct soap *soap, const char *tag, int id, struct _trt__RemoveVideoEncoderConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__RemoveVideoEncoderConfiguration);
	if (id < 0)
		return soap->error;
	return soap_out__trt__RemoveVideoEncoderConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__RemoveVideoEncoderConfiguration ** SOAP_FMAC4 soap_in_PointerTo_trt__RemoveVideoEncoderConfiguration(struct soap *soap, const char *tag, struct _trt__RemoveVideoEncoderConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__RemoveVideoEncoderConfiguration **)soap_malloc(soap, sizeof(struct _trt__RemoveVideoEncoderConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__RemoveVideoEncoderConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__RemoveVideoEncoderConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__RemoveVideoEncoderConfiguration, sizeof(struct _trt__RemoveVideoEncoderConfiguration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__RemoveVideoEncoderConfiguration(struct soap *soap, struct _trt__RemoveVideoEncoderConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__RemoveVideoEncoderConfiguration);
	if (soap_out_PointerTo_trt__RemoveVideoEncoderConfiguration(soap, tag?tag:"trt:RemoveVideoEncoderConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__RemoveVideoEncoderConfiguration ** SOAP_FMAC4 soap_get_PointerTo_trt__RemoveVideoEncoderConfiguration(struct soap *soap, struct _trt__RemoveVideoEncoderConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__RemoveVideoEncoderConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__AddAudioDecoderConfigurationResponse(struct soap *soap, struct _trt__AddAudioDecoderConfigurationResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__AddAudioDecoderConfigurationResponse))
		soap_serialize__trt__AddAudioDecoderConfigurationResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__AddAudioDecoderConfigurationResponse(struct soap *soap, const char *tag, int id, struct _trt__AddAudioDecoderConfigurationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__AddAudioDecoderConfigurationResponse);
	if (id < 0)
		return soap->error;
	return soap_out__trt__AddAudioDecoderConfigurationResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__AddAudioDecoderConfigurationResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__AddAudioDecoderConfigurationResponse(struct soap *soap, const char *tag, struct _trt__AddAudioDecoderConfigurationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__AddAudioDecoderConfigurationResponse **)soap_malloc(soap, sizeof(struct _trt__AddAudioDecoderConfigurationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__AddAudioDecoderConfigurationResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__AddAudioDecoderConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__AddAudioDecoderConfigurationResponse, sizeof(struct _trt__AddAudioDecoderConfigurationResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__AddAudioDecoderConfigurationResponse(struct soap *soap, struct _trt__AddAudioDecoderConfigurationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__AddAudioDecoderConfigurationResponse);
	if (soap_out_PointerTo_trt__AddAudioDecoderConfigurationResponse(soap, tag?tag:"trt:AddAudioDecoderConfigurationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__AddAudioDecoderConfigurationResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__AddAudioDecoderConfigurationResponse(struct soap *soap, struct _trt__AddAudioDecoderConfigurationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__AddAudioDecoderConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__AddAudioDecoderConfiguration(struct soap *soap, struct _trt__AddAudioDecoderConfiguration *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__AddAudioDecoderConfiguration))
		soap_serialize__trt__AddAudioDecoderConfiguration(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__AddAudioDecoderConfiguration(struct soap *soap, const char *tag, int id, struct _trt__AddAudioDecoderConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__AddAudioDecoderConfiguration);
	if (id < 0)
		return soap->error;
	return soap_out__trt__AddAudioDecoderConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__AddAudioDecoderConfiguration ** SOAP_FMAC4 soap_in_PointerTo_trt__AddAudioDecoderConfiguration(struct soap *soap, const char *tag, struct _trt__AddAudioDecoderConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__AddAudioDecoderConfiguration **)soap_malloc(soap, sizeof(struct _trt__AddAudioDecoderConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__AddAudioDecoderConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__AddAudioDecoderConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__AddAudioDecoderConfiguration, sizeof(struct _trt__AddAudioDecoderConfiguration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__AddAudioDecoderConfiguration(struct soap *soap, struct _trt__AddAudioDecoderConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__AddAudioDecoderConfiguration);
	if (soap_out_PointerTo_trt__AddAudioDecoderConfiguration(soap, tag?tag:"trt:AddAudioDecoderConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__AddAudioDecoderConfiguration ** SOAP_FMAC4 soap_get_PointerTo_trt__AddAudioDecoderConfiguration(struct soap *soap, struct _trt__AddAudioDecoderConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__AddAudioDecoderConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__AddAudioOutputConfigurationResponse(struct soap *soap, struct _trt__AddAudioOutputConfigurationResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__AddAudioOutputConfigurationResponse))
		soap_serialize__trt__AddAudioOutputConfigurationResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__AddAudioOutputConfigurationResponse(struct soap *soap, const char *tag, int id, struct _trt__AddAudioOutputConfigurationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__AddAudioOutputConfigurationResponse);
	if (id < 0)
		return soap->error;
	return soap_out__trt__AddAudioOutputConfigurationResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__AddAudioOutputConfigurationResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__AddAudioOutputConfigurationResponse(struct soap *soap, const char *tag, struct _trt__AddAudioOutputConfigurationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__AddAudioOutputConfigurationResponse **)soap_malloc(soap, sizeof(struct _trt__AddAudioOutputConfigurationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__AddAudioOutputConfigurationResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__AddAudioOutputConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__AddAudioOutputConfigurationResponse, sizeof(struct _trt__AddAudioOutputConfigurationResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__AddAudioOutputConfigurationResponse(struct soap *soap, struct _trt__AddAudioOutputConfigurationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__AddAudioOutputConfigurationResponse);
	if (soap_out_PointerTo_trt__AddAudioOutputConfigurationResponse(soap, tag?tag:"trt:AddAudioOutputConfigurationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__AddAudioOutputConfigurationResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__AddAudioOutputConfigurationResponse(struct soap *soap, struct _trt__AddAudioOutputConfigurationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__AddAudioOutputConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__AddAudioOutputConfiguration(struct soap *soap, struct _trt__AddAudioOutputConfiguration *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__AddAudioOutputConfiguration))
		soap_serialize__trt__AddAudioOutputConfiguration(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__AddAudioOutputConfiguration(struct soap *soap, const char *tag, int id, struct _trt__AddAudioOutputConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__AddAudioOutputConfiguration);
	if (id < 0)
		return soap->error;
	return soap_out__trt__AddAudioOutputConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__AddAudioOutputConfiguration ** SOAP_FMAC4 soap_in_PointerTo_trt__AddAudioOutputConfiguration(struct soap *soap, const char *tag, struct _trt__AddAudioOutputConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__AddAudioOutputConfiguration **)soap_malloc(soap, sizeof(struct _trt__AddAudioOutputConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__AddAudioOutputConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__AddAudioOutputConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__AddAudioOutputConfiguration, sizeof(struct _trt__AddAudioOutputConfiguration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__AddAudioOutputConfiguration(struct soap *soap, struct _trt__AddAudioOutputConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__AddAudioOutputConfiguration);
	if (soap_out_PointerTo_trt__AddAudioOutputConfiguration(soap, tag?tag:"trt:AddAudioOutputConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__AddAudioOutputConfiguration ** SOAP_FMAC4 soap_get_PointerTo_trt__AddAudioOutputConfiguration(struct soap *soap, struct _trt__AddAudioOutputConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__AddAudioOutputConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__AddMetadataConfigurationResponse(struct soap *soap, struct _trt__AddMetadataConfigurationResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__AddMetadataConfigurationResponse))
		soap_serialize__trt__AddMetadataConfigurationResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__AddMetadataConfigurationResponse(struct soap *soap, const char *tag, int id, struct _trt__AddMetadataConfigurationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__AddMetadataConfigurationResponse);
	if (id < 0)
		return soap->error;
	return soap_out__trt__AddMetadataConfigurationResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__AddMetadataConfigurationResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__AddMetadataConfigurationResponse(struct soap *soap, const char *tag, struct _trt__AddMetadataConfigurationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__AddMetadataConfigurationResponse **)soap_malloc(soap, sizeof(struct _trt__AddMetadataConfigurationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__AddMetadataConfigurationResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__AddMetadataConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__AddMetadataConfigurationResponse, sizeof(struct _trt__AddMetadataConfigurationResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__AddMetadataConfigurationResponse(struct soap *soap, struct _trt__AddMetadataConfigurationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__AddMetadataConfigurationResponse);
	if (soap_out_PointerTo_trt__AddMetadataConfigurationResponse(soap, tag?tag:"trt:AddMetadataConfigurationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__AddMetadataConfigurationResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__AddMetadataConfigurationResponse(struct soap *soap, struct _trt__AddMetadataConfigurationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__AddMetadataConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__AddMetadataConfiguration(struct soap *soap, struct _trt__AddMetadataConfiguration *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__AddMetadataConfiguration))
		soap_serialize__trt__AddMetadataConfiguration(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__AddMetadataConfiguration(struct soap *soap, const char *tag, int id, struct _trt__AddMetadataConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__AddMetadataConfiguration);
	if (id < 0)
		return soap->error;
	return soap_out__trt__AddMetadataConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__AddMetadataConfiguration ** SOAP_FMAC4 soap_in_PointerTo_trt__AddMetadataConfiguration(struct soap *soap, const char *tag, struct _trt__AddMetadataConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__AddMetadataConfiguration **)soap_malloc(soap, sizeof(struct _trt__AddMetadataConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__AddMetadataConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__AddMetadataConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__AddMetadataConfiguration, sizeof(struct _trt__AddMetadataConfiguration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__AddMetadataConfiguration(struct soap *soap, struct _trt__AddMetadataConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__AddMetadataConfiguration);
	if (soap_out_PointerTo_trt__AddMetadataConfiguration(soap, tag?tag:"trt:AddMetadataConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__AddMetadataConfiguration ** SOAP_FMAC4 soap_get_PointerTo_trt__AddMetadataConfiguration(struct soap *soap, struct _trt__AddMetadataConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__AddMetadataConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__AddVideoAnalyticsConfigurationResponse(struct soap *soap, struct _trt__AddVideoAnalyticsConfigurationResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__AddVideoAnalyticsConfigurationResponse))
		soap_serialize__trt__AddVideoAnalyticsConfigurationResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__AddVideoAnalyticsConfigurationResponse(struct soap *soap, const char *tag, int id, struct _trt__AddVideoAnalyticsConfigurationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__AddVideoAnalyticsConfigurationResponse);
	if (id < 0)
		return soap->error;
	return soap_out__trt__AddVideoAnalyticsConfigurationResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__AddVideoAnalyticsConfigurationResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__AddVideoAnalyticsConfigurationResponse(struct soap *soap, const char *tag, struct _trt__AddVideoAnalyticsConfigurationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__AddVideoAnalyticsConfigurationResponse **)soap_malloc(soap, sizeof(struct _trt__AddVideoAnalyticsConfigurationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__AddVideoAnalyticsConfigurationResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__AddVideoAnalyticsConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__AddVideoAnalyticsConfigurationResponse, sizeof(struct _trt__AddVideoAnalyticsConfigurationResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__AddVideoAnalyticsConfigurationResponse(struct soap *soap, struct _trt__AddVideoAnalyticsConfigurationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__AddVideoAnalyticsConfigurationResponse);
	if (soap_out_PointerTo_trt__AddVideoAnalyticsConfigurationResponse(soap, tag?tag:"trt:AddVideoAnalyticsConfigurationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__AddVideoAnalyticsConfigurationResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__AddVideoAnalyticsConfigurationResponse(struct soap *soap, struct _trt__AddVideoAnalyticsConfigurationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__AddVideoAnalyticsConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__AddVideoAnalyticsConfiguration(struct soap *soap, struct _trt__AddVideoAnalyticsConfiguration *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__AddVideoAnalyticsConfiguration))
		soap_serialize__trt__AddVideoAnalyticsConfiguration(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__AddVideoAnalyticsConfiguration(struct soap *soap, const char *tag, int id, struct _trt__AddVideoAnalyticsConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__AddVideoAnalyticsConfiguration);
	if (id < 0)
		return soap->error;
	return soap_out__trt__AddVideoAnalyticsConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__AddVideoAnalyticsConfiguration ** SOAP_FMAC4 soap_in_PointerTo_trt__AddVideoAnalyticsConfiguration(struct soap *soap, const char *tag, struct _trt__AddVideoAnalyticsConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__AddVideoAnalyticsConfiguration **)soap_malloc(soap, sizeof(struct _trt__AddVideoAnalyticsConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__AddVideoAnalyticsConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__AddVideoAnalyticsConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__AddVideoAnalyticsConfiguration, sizeof(struct _trt__AddVideoAnalyticsConfiguration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__AddVideoAnalyticsConfiguration(struct soap *soap, struct _trt__AddVideoAnalyticsConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__AddVideoAnalyticsConfiguration);
	if (soap_out_PointerTo_trt__AddVideoAnalyticsConfiguration(soap, tag?tag:"trt:AddVideoAnalyticsConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__AddVideoAnalyticsConfiguration ** SOAP_FMAC4 soap_get_PointerTo_trt__AddVideoAnalyticsConfiguration(struct soap *soap, struct _trt__AddVideoAnalyticsConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__AddVideoAnalyticsConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__AddPTZConfigurationResponse(struct soap *soap, struct _trt__AddPTZConfigurationResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__AddPTZConfigurationResponse))
		soap_serialize__trt__AddPTZConfigurationResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__AddPTZConfigurationResponse(struct soap *soap, const char *tag, int id, struct _trt__AddPTZConfigurationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__AddPTZConfigurationResponse);
	if (id < 0)
		return soap->error;
	return soap_out__trt__AddPTZConfigurationResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__AddPTZConfigurationResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__AddPTZConfigurationResponse(struct soap *soap, const char *tag, struct _trt__AddPTZConfigurationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__AddPTZConfigurationResponse **)soap_malloc(soap, sizeof(struct _trt__AddPTZConfigurationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__AddPTZConfigurationResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__AddPTZConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__AddPTZConfigurationResponse, sizeof(struct _trt__AddPTZConfigurationResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__AddPTZConfigurationResponse(struct soap *soap, struct _trt__AddPTZConfigurationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__AddPTZConfigurationResponse);
	if (soap_out_PointerTo_trt__AddPTZConfigurationResponse(soap, tag?tag:"trt:AddPTZConfigurationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__AddPTZConfigurationResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__AddPTZConfigurationResponse(struct soap *soap, struct _trt__AddPTZConfigurationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__AddPTZConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__AddPTZConfiguration(struct soap *soap, struct _trt__AddPTZConfiguration *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__AddPTZConfiguration))
		soap_serialize__trt__AddPTZConfiguration(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__AddPTZConfiguration(struct soap *soap, const char *tag, int id, struct _trt__AddPTZConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__AddPTZConfiguration);
	if (id < 0)
		return soap->error;
	return soap_out__trt__AddPTZConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__AddPTZConfiguration ** SOAP_FMAC4 soap_in_PointerTo_trt__AddPTZConfiguration(struct soap *soap, const char *tag, struct _trt__AddPTZConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__AddPTZConfiguration **)soap_malloc(soap, sizeof(struct _trt__AddPTZConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__AddPTZConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__AddPTZConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__AddPTZConfiguration, sizeof(struct _trt__AddPTZConfiguration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__AddPTZConfiguration(struct soap *soap, struct _trt__AddPTZConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__AddPTZConfiguration);
	if (soap_out_PointerTo_trt__AddPTZConfiguration(soap, tag?tag:"trt:AddPTZConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__AddPTZConfiguration ** SOAP_FMAC4 soap_get_PointerTo_trt__AddPTZConfiguration(struct soap *soap, struct _trt__AddPTZConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__AddPTZConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__AddAudioSourceConfigurationResponse(struct soap *soap, struct _trt__AddAudioSourceConfigurationResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__AddAudioSourceConfigurationResponse))
		soap_serialize__trt__AddAudioSourceConfigurationResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__AddAudioSourceConfigurationResponse(struct soap *soap, const char *tag, int id, struct _trt__AddAudioSourceConfigurationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__AddAudioSourceConfigurationResponse);
	if (id < 0)
		return soap->error;
	return soap_out__trt__AddAudioSourceConfigurationResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__AddAudioSourceConfigurationResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__AddAudioSourceConfigurationResponse(struct soap *soap, const char *tag, struct _trt__AddAudioSourceConfigurationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__AddAudioSourceConfigurationResponse **)soap_malloc(soap, sizeof(struct _trt__AddAudioSourceConfigurationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__AddAudioSourceConfigurationResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__AddAudioSourceConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__AddAudioSourceConfigurationResponse, sizeof(struct _trt__AddAudioSourceConfigurationResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__AddAudioSourceConfigurationResponse(struct soap *soap, struct _trt__AddAudioSourceConfigurationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__AddAudioSourceConfigurationResponse);
	if (soap_out_PointerTo_trt__AddAudioSourceConfigurationResponse(soap, tag?tag:"trt:AddAudioSourceConfigurationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__AddAudioSourceConfigurationResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__AddAudioSourceConfigurationResponse(struct soap *soap, struct _trt__AddAudioSourceConfigurationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__AddAudioSourceConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__AddAudioSourceConfiguration(struct soap *soap, struct _trt__AddAudioSourceConfiguration *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__AddAudioSourceConfiguration))
		soap_serialize__trt__AddAudioSourceConfiguration(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__AddAudioSourceConfiguration(struct soap *soap, const char *tag, int id, struct _trt__AddAudioSourceConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__AddAudioSourceConfiguration);
	if (id < 0)
		return soap->error;
	return soap_out__trt__AddAudioSourceConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__AddAudioSourceConfiguration ** SOAP_FMAC4 soap_in_PointerTo_trt__AddAudioSourceConfiguration(struct soap *soap, const char *tag, struct _trt__AddAudioSourceConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__AddAudioSourceConfiguration **)soap_malloc(soap, sizeof(struct _trt__AddAudioSourceConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__AddAudioSourceConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__AddAudioSourceConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__AddAudioSourceConfiguration, sizeof(struct _trt__AddAudioSourceConfiguration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__AddAudioSourceConfiguration(struct soap *soap, struct _trt__AddAudioSourceConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__AddAudioSourceConfiguration);
	if (soap_out_PointerTo_trt__AddAudioSourceConfiguration(soap, tag?tag:"trt:AddAudioSourceConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__AddAudioSourceConfiguration ** SOAP_FMAC4 soap_get_PointerTo_trt__AddAudioSourceConfiguration(struct soap *soap, struct _trt__AddAudioSourceConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__AddAudioSourceConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__AddAudioEncoderConfigurationResponse(struct soap *soap, struct _trt__AddAudioEncoderConfigurationResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__AddAudioEncoderConfigurationResponse))
		soap_serialize__trt__AddAudioEncoderConfigurationResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__AddAudioEncoderConfigurationResponse(struct soap *soap, const char *tag, int id, struct _trt__AddAudioEncoderConfigurationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__AddAudioEncoderConfigurationResponse);
	if (id < 0)
		return soap->error;
	return soap_out__trt__AddAudioEncoderConfigurationResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__AddAudioEncoderConfigurationResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__AddAudioEncoderConfigurationResponse(struct soap *soap, const char *tag, struct _trt__AddAudioEncoderConfigurationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__AddAudioEncoderConfigurationResponse **)soap_malloc(soap, sizeof(struct _trt__AddAudioEncoderConfigurationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__AddAudioEncoderConfigurationResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__AddAudioEncoderConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__AddAudioEncoderConfigurationResponse, sizeof(struct _trt__AddAudioEncoderConfigurationResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__AddAudioEncoderConfigurationResponse(struct soap *soap, struct _trt__AddAudioEncoderConfigurationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__AddAudioEncoderConfigurationResponse);
	if (soap_out_PointerTo_trt__AddAudioEncoderConfigurationResponse(soap, tag?tag:"trt:AddAudioEncoderConfigurationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__AddAudioEncoderConfigurationResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__AddAudioEncoderConfigurationResponse(struct soap *soap, struct _trt__AddAudioEncoderConfigurationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__AddAudioEncoderConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__AddAudioEncoderConfiguration(struct soap *soap, struct _trt__AddAudioEncoderConfiguration *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__AddAudioEncoderConfiguration))
		soap_serialize__trt__AddAudioEncoderConfiguration(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__AddAudioEncoderConfiguration(struct soap *soap, const char *tag, int id, struct _trt__AddAudioEncoderConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__AddAudioEncoderConfiguration);
	if (id < 0)
		return soap->error;
	return soap_out__trt__AddAudioEncoderConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__AddAudioEncoderConfiguration ** SOAP_FMAC4 soap_in_PointerTo_trt__AddAudioEncoderConfiguration(struct soap *soap, const char *tag, struct _trt__AddAudioEncoderConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__AddAudioEncoderConfiguration **)soap_malloc(soap, sizeof(struct _trt__AddAudioEncoderConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__AddAudioEncoderConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__AddAudioEncoderConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__AddAudioEncoderConfiguration, sizeof(struct _trt__AddAudioEncoderConfiguration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__AddAudioEncoderConfiguration(struct soap *soap, struct _trt__AddAudioEncoderConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__AddAudioEncoderConfiguration);
	if (soap_out_PointerTo_trt__AddAudioEncoderConfiguration(soap, tag?tag:"trt:AddAudioEncoderConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__AddAudioEncoderConfiguration ** SOAP_FMAC4 soap_get_PointerTo_trt__AddAudioEncoderConfiguration(struct soap *soap, struct _trt__AddAudioEncoderConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__AddAudioEncoderConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__AddVideoSourceConfigurationResponse(struct soap *soap, struct _trt__AddVideoSourceConfigurationResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__AddVideoSourceConfigurationResponse))
		soap_serialize__trt__AddVideoSourceConfigurationResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__AddVideoSourceConfigurationResponse(struct soap *soap, const char *tag, int id, struct _trt__AddVideoSourceConfigurationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__AddVideoSourceConfigurationResponse);
	if (id < 0)
		return soap->error;
	return soap_out__trt__AddVideoSourceConfigurationResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__AddVideoSourceConfigurationResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__AddVideoSourceConfigurationResponse(struct soap *soap, const char *tag, struct _trt__AddVideoSourceConfigurationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__AddVideoSourceConfigurationResponse **)soap_malloc(soap, sizeof(struct _trt__AddVideoSourceConfigurationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__AddVideoSourceConfigurationResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__AddVideoSourceConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__AddVideoSourceConfigurationResponse, sizeof(struct _trt__AddVideoSourceConfigurationResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__AddVideoSourceConfigurationResponse(struct soap *soap, struct _trt__AddVideoSourceConfigurationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__AddVideoSourceConfigurationResponse);
	if (soap_out_PointerTo_trt__AddVideoSourceConfigurationResponse(soap, tag?tag:"trt:AddVideoSourceConfigurationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__AddVideoSourceConfigurationResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__AddVideoSourceConfigurationResponse(struct soap *soap, struct _trt__AddVideoSourceConfigurationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__AddVideoSourceConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__AddVideoSourceConfiguration(struct soap *soap, struct _trt__AddVideoSourceConfiguration *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__AddVideoSourceConfiguration))
		soap_serialize__trt__AddVideoSourceConfiguration(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__AddVideoSourceConfiguration(struct soap *soap, const char *tag, int id, struct _trt__AddVideoSourceConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__AddVideoSourceConfiguration);
	if (id < 0)
		return soap->error;
	return soap_out__trt__AddVideoSourceConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__AddVideoSourceConfiguration ** SOAP_FMAC4 soap_in_PointerTo_trt__AddVideoSourceConfiguration(struct soap *soap, const char *tag, struct _trt__AddVideoSourceConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__AddVideoSourceConfiguration **)soap_malloc(soap, sizeof(struct _trt__AddVideoSourceConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__AddVideoSourceConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__AddVideoSourceConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__AddVideoSourceConfiguration, sizeof(struct _trt__AddVideoSourceConfiguration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__AddVideoSourceConfiguration(struct soap *soap, struct _trt__AddVideoSourceConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__AddVideoSourceConfiguration);
	if (soap_out_PointerTo_trt__AddVideoSourceConfiguration(soap, tag?tag:"trt:AddVideoSourceConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__AddVideoSourceConfiguration ** SOAP_FMAC4 soap_get_PointerTo_trt__AddVideoSourceConfiguration(struct soap *soap, struct _trt__AddVideoSourceConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__AddVideoSourceConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__AddVideoEncoderConfigurationResponse(struct soap *soap, struct _trt__AddVideoEncoderConfigurationResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__AddVideoEncoderConfigurationResponse))
		soap_serialize__trt__AddVideoEncoderConfigurationResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__AddVideoEncoderConfigurationResponse(struct soap *soap, const char *tag, int id, struct _trt__AddVideoEncoderConfigurationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__AddVideoEncoderConfigurationResponse);
	if (id < 0)
		return soap->error;
	return soap_out__trt__AddVideoEncoderConfigurationResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__AddVideoEncoderConfigurationResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__AddVideoEncoderConfigurationResponse(struct soap *soap, const char *tag, struct _trt__AddVideoEncoderConfigurationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__AddVideoEncoderConfigurationResponse **)soap_malloc(soap, sizeof(struct _trt__AddVideoEncoderConfigurationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__AddVideoEncoderConfigurationResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__AddVideoEncoderConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__AddVideoEncoderConfigurationResponse, sizeof(struct _trt__AddVideoEncoderConfigurationResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__AddVideoEncoderConfigurationResponse(struct soap *soap, struct _trt__AddVideoEncoderConfigurationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__AddVideoEncoderConfigurationResponse);
	if (soap_out_PointerTo_trt__AddVideoEncoderConfigurationResponse(soap, tag?tag:"trt:AddVideoEncoderConfigurationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__AddVideoEncoderConfigurationResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__AddVideoEncoderConfigurationResponse(struct soap *soap, struct _trt__AddVideoEncoderConfigurationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__AddVideoEncoderConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__AddVideoEncoderConfiguration(struct soap *soap, struct _trt__AddVideoEncoderConfiguration *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__AddVideoEncoderConfiguration))
		soap_serialize__trt__AddVideoEncoderConfiguration(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__AddVideoEncoderConfiguration(struct soap *soap, const char *tag, int id, struct _trt__AddVideoEncoderConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__AddVideoEncoderConfiguration);
	if (id < 0)
		return soap->error;
	return soap_out__trt__AddVideoEncoderConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__AddVideoEncoderConfiguration ** SOAP_FMAC4 soap_in_PointerTo_trt__AddVideoEncoderConfiguration(struct soap *soap, const char *tag, struct _trt__AddVideoEncoderConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__AddVideoEncoderConfiguration **)soap_malloc(soap, sizeof(struct _trt__AddVideoEncoderConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__AddVideoEncoderConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__AddVideoEncoderConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__AddVideoEncoderConfiguration, sizeof(struct _trt__AddVideoEncoderConfiguration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__AddVideoEncoderConfiguration(struct soap *soap, struct _trt__AddVideoEncoderConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__AddVideoEncoderConfiguration);
	if (soap_out_PointerTo_trt__AddVideoEncoderConfiguration(soap, tag?tag:"trt:AddVideoEncoderConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__AddVideoEncoderConfiguration ** SOAP_FMAC4 soap_get_PointerTo_trt__AddVideoEncoderConfiguration(struct soap *soap, struct _trt__AddVideoEncoderConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__AddVideoEncoderConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetProfilesResponse(struct soap *soap, struct _trt__GetProfilesResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetProfilesResponse))
		soap_serialize__trt__GetProfilesResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetProfilesResponse(struct soap *soap, const char *tag, int id, struct _trt__GetProfilesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetProfilesResponse);
	if (id < 0)
		return soap->error;
	return soap_out__trt__GetProfilesResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__GetProfilesResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__GetProfilesResponse(struct soap *soap, const char *tag, struct _trt__GetProfilesResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__GetProfilesResponse **)soap_malloc(soap, sizeof(struct _trt__GetProfilesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__GetProfilesResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__GetProfilesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetProfilesResponse, sizeof(struct _trt__GetProfilesResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetProfilesResponse(struct soap *soap, struct _trt__GetProfilesResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetProfilesResponse);
	if (soap_out_PointerTo_trt__GetProfilesResponse(soap, tag?tag:"trt:GetProfilesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetProfilesResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__GetProfilesResponse(struct soap *soap, struct _trt__GetProfilesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetProfilesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetProfiles(struct soap *soap, struct _trt__GetProfiles *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetProfiles))
		soap_serialize__trt__GetProfiles(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetProfiles(struct soap *soap, const char *tag, int id, struct _trt__GetProfiles *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetProfiles);
	if (id < 0)
		return soap->error;
	return soap_out__trt__GetProfiles(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__GetProfiles ** SOAP_FMAC4 soap_in_PointerTo_trt__GetProfiles(struct soap *soap, const char *tag, struct _trt__GetProfiles **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__GetProfiles **)soap_malloc(soap, sizeof(struct _trt__GetProfiles *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__GetProfiles(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__GetProfiles **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetProfiles, sizeof(struct _trt__GetProfiles), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetProfiles(struct soap *soap, struct _trt__GetProfiles *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetProfiles);
	if (soap_out_PointerTo_trt__GetProfiles(soap, tag?tag:"trt:GetProfiles", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetProfiles ** SOAP_FMAC4 soap_get_PointerTo_trt__GetProfiles(struct soap *soap, struct _trt__GetProfiles **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetProfiles(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetProfileResponse(struct soap *soap, struct _trt__GetProfileResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetProfileResponse))
		soap_serialize__trt__GetProfileResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetProfileResponse(struct soap *soap, const char *tag, int id, struct _trt__GetProfileResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetProfileResponse);
	if (id < 0)
		return soap->error;
	return soap_out__trt__GetProfileResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__GetProfileResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__GetProfileResponse(struct soap *soap, const char *tag, struct _trt__GetProfileResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__GetProfileResponse **)soap_malloc(soap, sizeof(struct _trt__GetProfileResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__GetProfileResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__GetProfileResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetProfileResponse, sizeof(struct _trt__GetProfileResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetProfileResponse(struct soap *soap, struct _trt__GetProfileResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetProfileResponse);
	if (soap_out_PointerTo_trt__GetProfileResponse(soap, tag?tag:"trt:GetProfileResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetProfileResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__GetProfileResponse(struct soap *soap, struct _trt__GetProfileResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetProfileResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetProfile(struct soap *soap, struct _trt__GetProfile *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetProfile))
		soap_serialize__trt__GetProfile(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetProfile(struct soap *soap, const char *tag, int id, struct _trt__GetProfile *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetProfile);
	if (id < 0)
		return soap->error;
	return soap_out__trt__GetProfile(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__GetProfile ** SOAP_FMAC4 soap_in_PointerTo_trt__GetProfile(struct soap *soap, const char *tag, struct _trt__GetProfile **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__GetProfile **)soap_malloc(soap, sizeof(struct _trt__GetProfile *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__GetProfile(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__GetProfile **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetProfile, sizeof(struct _trt__GetProfile), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetProfile(struct soap *soap, struct _trt__GetProfile *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetProfile);
	if (soap_out_PointerTo_trt__GetProfile(soap, tag?tag:"trt:GetProfile", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetProfile ** SOAP_FMAC4 soap_get_PointerTo_trt__GetProfile(struct soap *soap, struct _trt__GetProfile **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetProfile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__CreateProfileResponse(struct soap *soap, struct _trt__CreateProfileResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__CreateProfileResponse))
		soap_serialize__trt__CreateProfileResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__CreateProfileResponse(struct soap *soap, const char *tag, int id, struct _trt__CreateProfileResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__CreateProfileResponse);
	if (id < 0)
		return soap->error;
	return soap_out__trt__CreateProfileResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__CreateProfileResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__CreateProfileResponse(struct soap *soap, const char *tag, struct _trt__CreateProfileResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__CreateProfileResponse **)soap_malloc(soap, sizeof(struct _trt__CreateProfileResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__CreateProfileResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__CreateProfileResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__CreateProfileResponse, sizeof(struct _trt__CreateProfileResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__CreateProfileResponse(struct soap *soap, struct _trt__CreateProfileResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__CreateProfileResponse);
	if (soap_out_PointerTo_trt__CreateProfileResponse(soap, tag?tag:"trt:CreateProfileResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__CreateProfileResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__CreateProfileResponse(struct soap *soap, struct _trt__CreateProfileResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__CreateProfileResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__CreateProfile(struct soap *soap, struct _trt__CreateProfile *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__CreateProfile))
		soap_serialize__trt__CreateProfile(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__CreateProfile(struct soap *soap, const char *tag, int id, struct _trt__CreateProfile *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__CreateProfile);
	if (id < 0)
		return soap->error;
	return soap_out__trt__CreateProfile(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__CreateProfile ** SOAP_FMAC4 soap_in_PointerTo_trt__CreateProfile(struct soap *soap, const char *tag, struct _trt__CreateProfile **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__CreateProfile **)soap_malloc(soap, sizeof(struct _trt__CreateProfile *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__CreateProfile(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__CreateProfile **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__CreateProfile, sizeof(struct _trt__CreateProfile), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__CreateProfile(struct soap *soap, struct _trt__CreateProfile *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__CreateProfile);
	if (soap_out_PointerTo_trt__CreateProfile(soap, tag?tag:"trt:CreateProfile", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__CreateProfile ** SOAP_FMAC4 soap_get_PointerTo_trt__CreateProfile(struct soap *soap, struct _trt__CreateProfile **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__CreateProfile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetAudioOutputsResponse(struct soap *soap, struct _trt__GetAudioOutputsResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetAudioOutputsResponse))
		soap_serialize__trt__GetAudioOutputsResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetAudioOutputsResponse(struct soap *soap, const char *tag, int id, struct _trt__GetAudioOutputsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetAudioOutputsResponse);
	if (id < 0)
		return soap->error;
	return soap_out__trt__GetAudioOutputsResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__GetAudioOutputsResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__GetAudioOutputsResponse(struct soap *soap, const char *tag, struct _trt__GetAudioOutputsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__GetAudioOutputsResponse **)soap_malloc(soap, sizeof(struct _trt__GetAudioOutputsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__GetAudioOutputsResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__GetAudioOutputsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetAudioOutputsResponse, sizeof(struct _trt__GetAudioOutputsResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetAudioOutputsResponse(struct soap *soap, struct _trt__GetAudioOutputsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetAudioOutputsResponse);
	if (soap_out_PointerTo_trt__GetAudioOutputsResponse(soap, tag?tag:"trt:GetAudioOutputsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetAudioOutputsResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__GetAudioOutputsResponse(struct soap *soap, struct _trt__GetAudioOutputsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetAudioOutputsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetAudioOutputs(struct soap *soap, struct _trt__GetAudioOutputs *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetAudioOutputs))
		soap_serialize__trt__GetAudioOutputs(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetAudioOutputs(struct soap *soap, const char *tag, int id, struct _trt__GetAudioOutputs *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetAudioOutputs);
	if (id < 0)
		return soap->error;
	return soap_out__trt__GetAudioOutputs(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__GetAudioOutputs ** SOAP_FMAC4 soap_in_PointerTo_trt__GetAudioOutputs(struct soap *soap, const char *tag, struct _trt__GetAudioOutputs **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__GetAudioOutputs **)soap_malloc(soap, sizeof(struct _trt__GetAudioOutputs *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__GetAudioOutputs(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__GetAudioOutputs **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetAudioOutputs, sizeof(struct _trt__GetAudioOutputs), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetAudioOutputs(struct soap *soap, struct _trt__GetAudioOutputs *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetAudioOutputs);
	if (soap_out_PointerTo_trt__GetAudioOutputs(soap, tag?tag:"trt:GetAudioOutputs", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetAudioOutputs ** SOAP_FMAC4 soap_get_PointerTo_trt__GetAudioOutputs(struct soap *soap, struct _trt__GetAudioOutputs **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetAudioOutputs(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetAudioSourcesResponse(struct soap *soap, struct _trt__GetAudioSourcesResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetAudioSourcesResponse))
		soap_serialize__trt__GetAudioSourcesResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetAudioSourcesResponse(struct soap *soap, const char *tag, int id, struct _trt__GetAudioSourcesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetAudioSourcesResponse);
	if (id < 0)
		return soap->error;
	return soap_out__trt__GetAudioSourcesResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__GetAudioSourcesResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__GetAudioSourcesResponse(struct soap *soap, const char *tag, struct _trt__GetAudioSourcesResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__GetAudioSourcesResponse **)soap_malloc(soap, sizeof(struct _trt__GetAudioSourcesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__GetAudioSourcesResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__GetAudioSourcesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetAudioSourcesResponse, sizeof(struct _trt__GetAudioSourcesResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetAudioSourcesResponse(struct soap *soap, struct _trt__GetAudioSourcesResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetAudioSourcesResponse);
	if (soap_out_PointerTo_trt__GetAudioSourcesResponse(soap, tag?tag:"trt:GetAudioSourcesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetAudioSourcesResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__GetAudioSourcesResponse(struct soap *soap, struct _trt__GetAudioSourcesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetAudioSourcesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetAudioSources(struct soap *soap, struct _trt__GetAudioSources *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetAudioSources))
		soap_serialize__trt__GetAudioSources(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetAudioSources(struct soap *soap, const char *tag, int id, struct _trt__GetAudioSources *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetAudioSources);
	if (id < 0)
		return soap->error;
	return soap_out__trt__GetAudioSources(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__GetAudioSources ** SOAP_FMAC4 soap_in_PointerTo_trt__GetAudioSources(struct soap *soap, const char *tag, struct _trt__GetAudioSources **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__GetAudioSources **)soap_malloc(soap, sizeof(struct _trt__GetAudioSources *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__GetAudioSources(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__GetAudioSources **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetAudioSources, sizeof(struct _trt__GetAudioSources), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetAudioSources(struct soap *soap, struct _trt__GetAudioSources *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetAudioSources);
	if (soap_out_PointerTo_trt__GetAudioSources(soap, tag?tag:"trt:GetAudioSources", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetAudioSources ** SOAP_FMAC4 soap_get_PointerTo_trt__GetAudioSources(struct soap *soap, struct _trt__GetAudioSources **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetAudioSources(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetVideoSourcesResponse(struct soap *soap, struct _trt__GetVideoSourcesResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetVideoSourcesResponse))
		soap_serialize__trt__GetVideoSourcesResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetVideoSourcesResponse(struct soap *soap, const char *tag, int id, struct _trt__GetVideoSourcesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetVideoSourcesResponse);
	if (id < 0)
		return soap->error;
	return soap_out__trt__GetVideoSourcesResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__GetVideoSourcesResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__GetVideoSourcesResponse(struct soap *soap, const char *tag, struct _trt__GetVideoSourcesResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__GetVideoSourcesResponse **)soap_malloc(soap, sizeof(struct _trt__GetVideoSourcesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__GetVideoSourcesResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__GetVideoSourcesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetVideoSourcesResponse, sizeof(struct _trt__GetVideoSourcesResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetVideoSourcesResponse(struct soap *soap, struct _trt__GetVideoSourcesResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetVideoSourcesResponse);
	if (soap_out_PointerTo_trt__GetVideoSourcesResponse(soap, tag?tag:"trt:GetVideoSourcesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetVideoSourcesResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__GetVideoSourcesResponse(struct soap *soap, struct _trt__GetVideoSourcesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetVideoSourcesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetVideoSources(struct soap *soap, struct _trt__GetVideoSources *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetVideoSources))
		soap_serialize__trt__GetVideoSources(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetVideoSources(struct soap *soap, const char *tag, int id, struct _trt__GetVideoSources *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetVideoSources);
	if (id < 0)
		return soap->error;
	return soap_out__trt__GetVideoSources(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__GetVideoSources ** SOAP_FMAC4 soap_in_PointerTo_trt__GetVideoSources(struct soap *soap, const char *tag, struct _trt__GetVideoSources **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__GetVideoSources **)soap_malloc(soap, sizeof(struct _trt__GetVideoSources *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__GetVideoSources(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__GetVideoSources **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetVideoSources, sizeof(struct _trt__GetVideoSources), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetVideoSources(struct soap *soap, struct _trt__GetVideoSources *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetVideoSources);
	if (soap_out_PointerTo_trt__GetVideoSources(soap, tag?tag:"trt:GetVideoSources", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetVideoSources ** SOAP_FMAC4 soap_get_PointerTo_trt__GetVideoSources(struct soap *soap, struct _trt__GetVideoSources **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetVideoSources(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetServiceCapabilitiesResponse(struct soap *soap, struct _trt__GetServiceCapabilitiesResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetServiceCapabilitiesResponse))
		soap_serialize__trt__GetServiceCapabilitiesResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetServiceCapabilitiesResponse(struct soap *soap, const char *tag, int id, struct _trt__GetServiceCapabilitiesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetServiceCapabilitiesResponse);
	if (id < 0)
		return soap->error;
	return soap_out__trt__GetServiceCapabilitiesResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__GetServiceCapabilitiesResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__GetServiceCapabilitiesResponse(struct soap *soap, const char *tag, struct _trt__GetServiceCapabilitiesResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__GetServiceCapabilitiesResponse **)soap_malloc(soap, sizeof(struct _trt__GetServiceCapabilitiesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__GetServiceCapabilitiesResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__GetServiceCapabilitiesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetServiceCapabilitiesResponse, sizeof(struct _trt__GetServiceCapabilitiesResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetServiceCapabilitiesResponse(struct soap *soap, struct _trt__GetServiceCapabilitiesResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetServiceCapabilitiesResponse);
	if (soap_out_PointerTo_trt__GetServiceCapabilitiesResponse(soap, tag?tag:"trt:GetServiceCapabilitiesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetServiceCapabilitiesResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__GetServiceCapabilitiesResponse(struct soap *soap, struct _trt__GetServiceCapabilitiesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetServiceCapabilitiesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetServiceCapabilities(struct soap *soap, struct _trt__GetServiceCapabilities *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetServiceCapabilities))
		soap_serialize__trt__GetServiceCapabilities(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetServiceCapabilities(struct soap *soap, const char *tag, int id, struct _trt__GetServiceCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetServiceCapabilities);
	if (id < 0)
		return soap->error;
	return soap_out__trt__GetServiceCapabilities(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__GetServiceCapabilities ** SOAP_FMAC4 soap_in_PointerTo_trt__GetServiceCapabilities(struct soap *soap, const char *tag, struct _trt__GetServiceCapabilities **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__GetServiceCapabilities **)soap_malloc(soap, sizeof(struct _trt__GetServiceCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__GetServiceCapabilities(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__GetServiceCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetServiceCapabilities, sizeof(struct _trt__GetServiceCapabilities), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetServiceCapabilities(struct soap *soap, struct _trt__GetServiceCapabilities *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetServiceCapabilities);
	if (soap_out_PointerTo_trt__GetServiceCapabilities(soap, tag?tag:"trt:GetServiceCapabilities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetServiceCapabilities ** SOAP_FMAC4 soap_get_PointerTo_trt__GetServiceCapabilities(struct soap *soap, struct _trt__GetServiceCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetServiceCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tptz__StopResponse(struct soap *soap, struct _tptz__StopResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tptz__StopResponse))
		soap_serialize__tptz__StopResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tptz__StopResponse(struct soap *soap, const char *tag, int id, struct _tptz__StopResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tptz__StopResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tptz__StopResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tptz__StopResponse ** SOAP_FMAC4 soap_in_PointerTo_tptz__StopResponse(struct soap *soap, const char *tag, struct _tptz__StopResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tptz__StopResponse **)soap_malloc(soap, sizeof(struct _tptz__StopResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tptz__StopResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tptz__StopResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__StopResponse, sizeof(struct _tptz__StopResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tptz__StopResponse(struct soap *soap, struct _tptz__StopResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tptz__StopResponse);
	if (soap_out_PointerTo_tptz__StopResponse(soap, tag?tag:"tptz:StopResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__StopResponse ** SOAP_FMAC4 soap_get_PointerTo_tptz__StopResponse(struct soap *soap, struct _tptz__StopResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tptz__StopResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tptz__Stop(struct soap *soap, struct _tptz__Stop *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tptz__Stop))
		soap_serialize__tptz__Stop(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tptz__Stop(struct soap *soap, const char *tag, int id, struct _tptz__Stop *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tptz__Stop);
	if (id < 0)
		return soap->error;
	return soap_out__tptz__Stop(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tptz__Stop ** SOAP_FMAC4 soap_in_PointerTo_tptz__Stop(struct soap *soap, const char *tag, struct _tptz__Stop **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tptz__Stop **)soap_malloc(soap, sizeof(struct _tptz__Stop *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tptz__Stop(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tptz__Stop **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__Stop, sizeof(struct _tptz__Stop), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tptz__Stop(struct soap *soap, struct _tptz__Stop *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tptz__Stop);
	if (soap_out_PointerTo_tptz__Stop(soap, tag?tag:"tptz:Stop", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__Stop ** SOAP_FMAC4 soap_get_PointerTo_tptz__Stop(struct soap *soap, struct _tptz__Stop **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tptz__Stop(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tptz__AbsoluteMoveResponse(struct soap *soap, struct _tptz__AbsoluteMoveResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tptz__AbsoluteMoveResponse))
		soap_serialize__tptz__AbsoluteMoveResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tptz__AbsoluteMoveResponse(struct soap *soap, const char *tag, int id, struct _tptz__AbsoluteMoveResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tptz__AbsoluteMoveResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tptz__AbsoluteMoveResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tptz__AbsoluteMoveResponse ** SOAP_FMAC4 soap_in_PointerTo_tptz__AbsoluteMoveResponse(struct soap *soap, const char *tag, struct _tptz__AbsoluteMoveResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tptz__AbsoluteMoveResponse **)soap_malloc(soap, sizeof(struct _tptz__AbsoluteMoveResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tptz__AbsoluteMoveResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tptz__AbsoluteMoveResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__AbsoluteMoveResponse, sizeof(struct _tptz__AbsoluteMoveResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tptz__AbsoluteMoveResponse(struct soap *soap, struct _tptz__AbsoluteMoveResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tptz__AbsoluteMoveResponse);
	if (soap_out_PointerTo_tptz__AbsoluteMoveResponse(soap, tag?tag:"tptz:AbsoluteMoveResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__AbsoluteMoveResponse ** SOAP_FMAC4 soap_get_PointerTo_tptz__AbsoluteMoveResponse(struct soap *soap, struct _tptz__AbsoluteMoveResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tptz__AbsoluteMoveResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tptz__AbsoluteMove(struct soap *soap, struct _tptz__AbsoluteMove *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tptz__AbsoluteMove))
		soap_serialize__tptz__AbsoluteMove(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tptz__AbsoluteMove(struct soap *soap, const char *tag, int id, struct _tptz__AbsoluteMove *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tptz__AbsoluteMove);
	if (id < 0)
		return soap->error;
	return soap_out__tptz__AbsoluteMove(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tptz__AbsoluteMove ** SOAP_FMAC4 soap_in_PointerTo_tptz__AbsoluteMove(struct soap *soap, const char *tag, struct _tptz__AbsoluteMove **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tptz__AbsoluteMove **)soap_malloc(soap, sizeof(struct _tptz__AbsoluteMove *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tptz__AbsoluteMove(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tptz__AbsoluteMove **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__AbsoluteMove, sizeof(struct _tptz__AbsoluteMove), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tptz__AbsoluteMove(struct soap *soap, struct _tptz__AbsoluteMove *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tptz__AbsoluteMove);
	if (soap_out_PointerTo_tptz__AbsoluteMove(soap, tag?tag:"tptz:AbsoluteMove", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__AbsoluteMove ** SOAP_FMAC4 soap_get_PointerTo_tptz__AbsoluteMove(struct soap *soap, struct _tptz__AbsoluteMove **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tptz__AbsoluteMove(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tptz__SendAuxiliaryCommandResponse(struct soap *soap, struct _tptz__SendAuxiliaryCommandResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tptz__SendAuxiliaryCommandResponse))
		soap_serialize__tptz__SendAuxiliaryCommandResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tptz__SendAuxiliaryCommandResponse(struct soap *soap, const char *tag, int id, struct _tptz__SendAuxiliaryCommandResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tptz__SendAuxiliaryCommandResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tptz__SendAuxiliaryCommandResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tptz__SendAuxiliaryCommandResponse ** SOAP_FMAC4 soap_in_PointerTo_tptz__SendAuxiliaryCommandResponse(struct soap *soap, const char *tag, struct _tptz__SendAuxiliaryCommandResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tptz__SendAuxiliaryCommandResponse **)soap_malloc(soap, sizeof(struct _tptz__SendAuxiliaryCommandResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tptz__SendAuxiliaryCommandResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tptz__SendAuxiliaryCommandResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__SendAuxiliaryCommandResponse, sizeof(struct _tptz__SendAuxiliaryCommandResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tptz__SendAuxiliaryCommandResponse(struct soap *soap, struct _tptz__SendAuxiliaryCommandResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tptz__SendAuxiliaryCommandResponse);
	if (soap_out_PointerTo_tptz__SendAuxiliaryCommandResponse(soap, tag?tag:"tptz:SendAuxiliaryCommandResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__SendAuxiliaryCommandResponse ** SOAP_FMAC4 soap_get_PointerTo_tptz__SendAuxiliaryCommandResponse(struct soap *soap, struct _tptz__SendAuxiliaryCommandResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tptz__SendAuxiliaryCommandResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tptz__SendAuxiliaryCommand(struct soap *soap, struct _tptz__SendAuxiliaryCommand *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tptz__SendAuxiliaryCommand))
		soap_serialize__tptz__SendAuxiliaryCommand(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tptz__SendAuxiliaryCommand(struct soap *soap, const char *tag, int id, struct _tptz__SendAuxiliaryCommand *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tptz__SendAuxiliaryCommand);
	if (id < 0)
		return soap->error;
	return soap_out__tptz__SendAuxiliaryCommand(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tptz__SendAuxiliaryCommand ** SOAP_FMAC4 soap_in_PointerTo_tptz__SendAuxiliaryCommand(struct soap *soap, const char *tag, struct _tptz__SendAuxiliaryCommand **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tptz__SendAuxiliaryCommand **)soap_malloc(soap, sizeof(struct _tptz__SendAuxiliaryCommand *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tptz__SendAuxiliaryCommand(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tptz__SendAuxiliaryCommand **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__SendAuxiliaryCommand, sizeof(struct _tptz__SendAuxiliaryCommand), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tptz__SendAuxiliaryCommand(struct soap *soap, struct _tptz__SendAuxiliaryCommand *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tptz__SendAuxiliaryCommand);
	if (soap_out_PointerTo_tptz__SendAuxiliaryCommand(soap, tag?tag:"tptz:SendAuxiliaryCommand", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__SendAuxiliaryCommand ** SOAP_FMAC4 soap_get_PointerTo_tptz__SendAuxiliaryCommand(struct soap *soap, struct _tptz__SendAuxiliaryCommand **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tptz__SendAuxiliaryCommand(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tptz__RelativeMoveResponse(struct soap *soap, struct _tptz__RelativeMoveResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tptz__RelativeMoveResponse))
		soap_serialize__tptz__RelativeMoveResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tptz__RelativeMoveResponse(struct soap *soap, const char *tag, int id, struct _tptz__RelativeMoveResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tptz__RelativeMoveResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tptz__RelativeMoveResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tptz__RelativeMoveResponse ** SOAP_FMAC4 soap_in_PointerTo_tptz__RelativeMoveResponse(struct soap *soap, const char *tag, struct _tptz__RelativeMoveResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tptz__RelativeMoveResponse **)soap_malloc(soap, sizeof(struct _tptz__RelativeMoveResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tptz__RelativeMoveResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tptz__RelativeMoveResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__RelativeMoveResponse, sizeof(struct _tptz__RelativeMoveResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tptz__RelativeMoveResponse(struct soap *soap, struct _tptz__RelativeMoveResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tptz__RelativeMoveResponse);
	if (soap_out_PointerTo_tptz__RelativeMoveResponse(soap, tag?tag:"tptz:RelativeMoveResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__RelativeMoveResponse ** SOAP_FMAC4 soap_get_PointerTo_tptz__RelativeMoveResponse(struct soap *soap, struct _tptz__RelativeMoveResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tptz__RelativeMoveResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tptz__RelativeMove(struct soap *soap, struct _tptz__RelativeMove *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tptz__RelativeMove))
		soap_serialize__tptz__RelativeMove(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tptz__RelativeMove(struct soap *soap, const char *tag, int id, struct _tptz__RelativeMove *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tptz__RelativeMove);
	if (id < 0)
		return soap->error;
	return soap_out__tptz__RelativeMove(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tptz__RelativeMove ** SOAP_FMAC4 soap_in_PointerTo_tptz__RelativeMove(struct soap *soap, const char *tag, struct _tptz__RelativeMove **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tptz__RelativeMove **)soap_malloc(soap, sizeof(struct _tptz__RelativeMove *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tptz__RelativeMove(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tptz__RelativeMove **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__RelativeMove, sizeof(struct _tptz__RelativeMove), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tptz__RelativeMove(struct soap *soap, struct _tptz__RelativeMove *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tptz__RelativeMove);
	if (soap_out_PointerTo_tptz__RelativeMove(soap, tag?tag:"tptz:RelativeMove", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__RelativeMove ** SOAP_FMAC4 soap_get_PointerTo_tptz__RelativeMove(struct soap *soap, struct _tptz__RelativeMove **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tptz__RelativeMove(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tptz__ContinuousMoveResponse(struct soap *soap, struct _tptz__ContinuousMoveResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tptz__ContinuousMoveResponse))
		soap_serialize__tptz__ContinuousMoveResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tptz__ContinuousMoveResponse(struct soap *soap, const char *tag, int id, struct _tptz__ContinuousMoveResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tptz__ContinuousMoveResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tptz__ContinuousMoveResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tptz__ContinuousMoveResponse ** SOAP_FMAC4 soap_in_PointerTo_tptz__ContinuousMoveResponse(struct soap *soap, const char *tag, struct _tptz__ContinuousMoveResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tptz__ContinuousMoveResponse **)soap_malloc(soap, sizeof(struct _tptz__ContinuousMoveResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tptz__ContinuousMoveResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tptz__ContinuousMoveResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__ContinuousMoveResponse, sizeof(struct _tptz__ContinuousMoveResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tptz__ContinuousMoveResponse(struct soap *soap, struct _tptz__ContinuousMoveResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tptz__ContinuousMoveResponse);
	if (soap_out_PointerTo_tptz__ContinuousMoveResponse(soap, tag?tag:"tptz:ContinuousMoveResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__ContinuousMoveResponse ** SOAP_FMAC4 soap_get_PointerTo_tptz__ContinuousMoveResponse(struct soap *soap, struct _tptz__ContinuousMoveResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tptz__ContinuousMoveResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tptz__ContinuousMove(struct soap *soap, struct _tptz__ContinuousMove *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tptz__ContinuousMove))
		soap_serialize__tptz__ContinuousMove(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tptz__ContinuousMove(struct soap *soap, const char *tag, int id, struct _tptz__ContinuousMove *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tptz__ContinuousMove);
	if (id < 0)
		return soap->error;
	return soap_out__tptz__ContinuousMove(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tptz__ContinuousMove ** SOAP_FMAC4 soap_in_PointerTo_tptz__ContinuousMove(struct soap *soap, const char *tag, struct _tptz__ContinuousMove **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tptz__ContinuousMove **)soap_malloc(soap, sizeof(struct _tptz__ContinuousMove *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tptz__ContinuousMove(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tptz__ContinuousMove **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__ContinuousMove, sizeof(struct _tptz__ContinuousMove), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tptz__ContinuousMove(struct soap *soap, struct _tptz__ContinuousMove *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tptz__ContinuousMove);
	if (soap_out_PointerTo_tptz__ContinuousMove(soap, tag?tag:"tptz:ContinuousMove", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__ContinuousMove ** SOAP_FMAC4 soap_get_PointerTo_tptz__ContinuousMove(struct soap *soap, struct _tptz__ContinuousMove **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tptz__ContinuousMove(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tptz__SetHomePositionResponse(struct soap *soap, struct _tptz__SetHomePositionResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tptz__SetHomePositionResponse))
		soap_serialize__tptz__SetHomePositionResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tptz__SetHomePositionResponse(struct soap *soap, const char *tag, int id, struct _tptz__SetHomePositionResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tptz__SetHomePositionResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tptz__SetHomePositionResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tptz__SetHomePositionResponse ** SOAP_FMAC4 soap_in_PointerTo_tptz__SetHomePositionResponse(struct soap *soap, const char *tag, struct _tptz__SetHomePositionResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tptz__SetHomePositionResponse **)soap_malloc(soap, sizeof(struct _tptz__SetHomePositionResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tptz__SetHomePositionResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tptz__SetHomePositionResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__SetHomePositionResponse, sizeof(struct _tptz__SetHomePositionResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tptz__SetHomePositionResponse(struct soap *soap, struct _tptz__SetHomePositionResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tptz__SetHomePositionResponse);
	if (soap_out_PointerTo_tptz__SetHomePositionResponse(soap, tag?tag:"tptz:SetHomePositionResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__SetHomePositionResponse ** SOAP_FMAC4 soap_get_PointerTo_tptz__SetHomePositionResponse(struct soap *soap, struct _tptz__SetHomePositionResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tptz__SetHomePositionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tptz__SetHomePosition(struct soap *soap, struct _tptz__SetHomePosition *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tptz__SetHomePosition))
		soap_serialize__tptz__SetHomePosition(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tptz__SetHomePosition(struct soap *soap, const char *tag, int id, struct _tptz__SetHomePosition *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tptz__SetHomePosition);
	if (id < 0)
		return soap->error;
	return soap_out__tptz__SetHomePosition(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tptz__SetHomePosition ** SOAP_FMAC4 soap_in_PointerTo_tptz__SetHomePosition(struct soap *soap, const char *tag, struct _tptz__SetHomePosition **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tptz__SetHomePosition **)soap_malloc(soap, sizeof(struct _tptz__SetHomePosition *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tptz__SetHomePosition(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tptz__SetHomePosition **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__SetHomePosition, sizeof(struct _tptz__SetHomePosition), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tptz__SetHomePosition(struct soap *soap, struct _tptz__SetHomePosition *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tptz__SetHomePosition);
	if (soap_out_PointerTo_tptz__SetHomePosition(soap, tag?tag:"tptz:SetHomePosition", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__SetHomePosition ** SOAP_FMAC4 soap_get_PointerTo_tptz__SetHomePosition(struct soap *soap, struct _tptz__SetHomePosition **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tptz__SetHomePosition(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tptz__GotoHomePositionResponse(struct soap *soap, struct _tptz__GotoHomePositionResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tptz__GotoHomePositionResponse))
		soap_serialize__tptz__GotoHomePositionResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tptz__GotoHomePositionResponse(struct soap *soap, const char *tag, int id, struct _tptz__GotoHomePositionResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tptz__GotoHomePositionResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tptz__GotoHomePositionResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tptz__GotoHomePositionResponse ** SOAP_FMAC4 soap_in_PointerTo_tptz__GotoHomePositionResponse(struct soap *soap, const char *tag, struct _tptz__GotoHomePositionResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tptz__GotoHomePositionResponse **)soap_malloc(soap, sizeof(struct _tptz__GotoHomePositionResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tptz__GotoHomePositionResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tptz__GotoHomePositionResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__GotoHomePositionResponse, sizeof(struct _tptz__GotoHomePositionResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tptz__GotoHomePositionResponse(struct soap *soap, struct _tptz__GotoHomePositionResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tptz__GotoHomePositionResponse);
	if (soap_out_PointerTo_tptz__GotoHomePositionResponse(soap, tag?tag:"tptz:GotoHomePositionResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__GotoHomePositionResponse ** SOAP_FMAC4 soap_get_PointerTo_tptz__GotoHomePositionResponse(struct soap *soap, struct _tptz__GotoHomePositionResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tptz__GotoHomePositionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tptz__GotoHomePosition(struct soap *soap, struct _tptz__GotoHomePosition *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tptz__GotoHomePosition))
		soap_serialize__tptz__GotoHomePosition(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tptz__GotoHomePosition(struct soap *soap, const char *tag, int id, struct _tptz__GotoHomePosition *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tptz__GotoHomePosition);
	if (id < 0)
		return soap->error;
	return soap_out__tptz__GotoHomePosition(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tptz__GotoHomePosition ** SOAP_FMAC4 soap_in_PointerTo_tptz__GotoHomePosition(struct soap *soap, const char *tag, struct _tptz__GotoHomePosition **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tptz__GotoHomePosition **)soap_malloc(soap, sizeof(struct _tptz__GotoHomePosition *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tptz__GotoHomePosition(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tptz__GotoHomePosition **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__GotoHomePosition, sizeof(struct _tptz__GotoHomePosition), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tptz__GotoHomePosition(struct soap *soap, struct _tptz__GotoHomePosition *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tptz__GotoHomePosition);
	if (soap_out_PointerTo_tptz__GotoHomePosition(soap, tag?tag:"tptz:GotoHomePosition", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__GotoHomePosition ** SOAP_FMAC4 soap_get_PointerTo_tptz__GotoHomePosition(struct soap *soap, struct _tptz__GotoHomePosition **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tptz__GotoHomePosition(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tptz__GetConfigurationOptionsResponse(struct soap *soap, struct _tptz__GetConfigurationOptionsResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tptz__GetConfigurationOptionsResponse))
		soap_serialize__tptz__GetConfigurationOptionsResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tptz__GetConfigurationOptionsResponse(struct soap *soap, const char *tag, int id, struct _tptz__GetConfigurationOptionsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tptz__GetConfigurationOptionsResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tptz__GetConfigurationOptionsResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tptz__GetConfigurationOptionsResponse ** SOAP_FMAC4 soap_in_PointerTo_tptz__GetConfigurationOptionsResponse(struct soap *soap, const char *tag, struct _tptz__GetConfigurationOptionsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tptz__GetConfigurationOptionsResponse **)soap_malloc(soap, sizeof(struct _tptz__GetConfigurationOptionsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tptz__GetConfigurationOptionsResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tptz__GetConfigurationOptionsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__GetConfigurationOptionsResponse, sizeof(struct _tptz__GetConfigurationOptionsResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tptz__GetConfigurationOptionsResponse(struct soap *soap, struct _tptz__GetConfigurationOptionsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tptz__GetConfigurationOptionsResponse);
	if (soap_out_PointerTo_tptz__GetConfigurationOptionsResponse(soap, tag?tag:"tptz:GetConfigurationOptionsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__GetConfigurationOptionsResponse ** SOAP_FMAC4 soap_get_PointerTo_tptz__GetConfigurationOptionsResponse(struct soap *soap, struct _tptz__GetConfigurationOptionsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tptz__GetConfigurationOptionsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tptz__GetConfigurationOptions(struct soap *soap, struct _tptz__GetConfigurationOptions *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tptz__GetConfigurationOptions))
		soap_serialize__tptz__GetConfigurationOptions(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tptz__GetConfigurationOptions(struct soap *soap, const char *tag, int id, struct _tptz__GetConfigurationOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tptz__GetConfigurationOptions);
	if (id < 0)
		return soap->error;
	return soap_out__tptz__GetConfigurationOptions(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tptz__GetConfigurationOptions ** SOAP_FMAC4 soap_in_PointerTo_tptz__GetConfigurationOptions(struct soap *soap, const char *tag, struct _tptz__GetConfigurationOptions **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tptz__GetConfigurationOptions **)soap_malloc(soap, sizeof(struct _tptz__GetConfigurationOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tptz__GetConfigurationOptions(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tptz__GetConfigurationOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__GetConfigurationOptions, sizeof(struct _tptz__GetConfigurationOptions), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tptz__GetConfigurationOptions(struct soap *soap, struct _tptz__GetConfigurationOptions *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tptz__GetConfigurationOptions);
	if (soap_out_PointerTo_tptz__GetConfigurationOptions(soap, tag?tag:"tptz:GetConfigurationOptions", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__GetConfigurationOptions ** SOAP_FMAC4 soap_get_PointerTo_tptz__GetConfigurationOptions(struct soap *soap, struct _tptz__GetConfigurationOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tptz__GetConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tptz__SetConfigurationResponse(struct soap *soap, struct _tptz__SetConfigurationResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tptz__SetConfigurationResponse))
		soap_serialize__tptz__SetConfigurationResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tptz__SetConfigurationResponse(struct soap *soap, const char *tag, int id, struct _tptz__SetConfigurationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tptz__SetConfigurationResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tptz__SetConfigurationResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tptz__SetConfigurationResponse ** SOAP_FMAC4 soap_in_PointerTo_tptz__SetConfigurationResponse(struct soap *soap, const char *tag, struct _tptz__SetConfigurationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tptz__SetConfigurationResponse **)soap_malloc(soap, sizeof(struct _tptz__SetConfigurationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tptz__SetConfigurationResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tptz__SetConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__SetConfigurationResponse, sizeof(struct _tptz__SetConfigurationResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tptz__SetConfigurationResponse(struct soap *soap, struct _tptz__SetConfigurationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tptz__SetConfigurationResponse);
	if (soap_out_PointerTo_tptz__SetConfigurationResponse(soap, tag?tag:"tptz:SetConfigurationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__SetConfigurationResponse ** SOAP_FMAC4 soap_get_PointerTo_tptz__SetConfigurationResponse(struct soap *soap, struct _tptz__SetConfigurationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tptz__SetConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tptz__SetConfiguration(struct soap *soap, struct _tptz__SetConfiguration *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tptz__SetConfiguration))
		soap_serialize__tptz__SetConfiguration(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tptz__SetConfiguration(struct soap *soap, const char *tag, int id, struct _tptz__SetConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tptz__SetConfiguration);
	if (id < 0)
		return soap->error;
	return soap_out__tptz__SetConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tptz__SetConfiguration ** SOAP_FMAC4 soap_in_PointerTo_tptz__SetConfiguration(struct soap *soap, const char *tag, struct _tptz__SetConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tptz__SetConfiguration **)soap_malloc(soap, sizeof(struct _tptz__SetConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tptz__SetConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tptz__SetConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__SetConfiguration, sizeof(struct _tptz__SetConfiguration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tptz__SetConfiguration(struct soap *soap, struct _tptz__SetConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tptz__SetConfiguration);
	if (soap_out_PointerTo_tptz__SetConfiguration(soap, tag?tag:"tptz:SetConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__SetConfiguration ** SOAP_FMAC4 soap_get_PointerTo_tptz__SetConfiguration(struct soap *soap, struct _tptz__SetConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tptz__SetConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tptz__GetNodeResponse(struct soap *soap, struct _tptz__GetNodeResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tptz__GetNodeResponse))
		soap_serialize__tptz__GetNodeResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tptz__GetNodeResponse(struct soap *soap, const char *tag, int id, struct _tptz__GetNodeResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tptz__GetNodeResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tptz__GetNodeResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tptz__GetNodeResponse ** SOAP_FMAC4 soap_in_PointerTo_tptz__GetNodeResponse(struct soap *soap, const char *tag, struct _tptz__GetNodeResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tptz__GetNodeResponse **)soap_malloc(soap, sizeof(struct _tptz__GetNodeResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tptz__GetNodeResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tptz__GetNodeResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__GetNodeResponse, sizeof(struct _tptz__GetNodeResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tptz__GetNodeResponse(struct soap *soap, struct _tptz__GetNodeResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tptz__GetNodeResponse);
	if (soap_out_PointerTo_tptz__GetNodeResponse(soap, tag?tag:"tptz:GetNodeResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__GetNodeResponse ** SOAP_FMAC4 soap_get_PointerTo_tptz__GetNodeResponse(struct soap *soap, struct _tptz__GetNodeResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tptz__GetNodeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tptz__GetNode(struct soap *soap, struct _tptz__GetNode *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tptz__GetNode))
		soap_serialize__tptz__GetNode(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tptz__GetNode(struct soap *soap, const char *tag, int id, struct _tptz__GetNode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tptz__GetNode);
	if (id < 0)
		return soap->error;
	return soap_out__tptz__GetNode(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tptz__GetNode ** SOAP_FMAC4 soap_in_PointerTo_tptz__GetNode(struct soap *soap, const char *tag, struct _tptz__GetNode **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tptz__GetNode **)soap_malloc(soap, sizeof(struct _tptz__GetNode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tptz__GetNode(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tptz__GetNode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__GetNode, sizeof(struct _tptz__GetNode), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tptz__GetNode(struct soap *soap, struct _tptz__GetNode *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tptz__GetNode);
	if (soap_out_PointerTo_tptz__GetNode(soap, tag?tag:"tptz:GetNode", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__GetNode ** SOAP_FMAC4 soap_get_PointerTo_tptz__GetNode(struct soap *soap, struct _tptz__GetNode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tptz__GetNode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tptz__GetNodesResponse(struct soap *soap, struct _tptz__GetNodesResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tptz__GetNodesResponse))
		soap_serialize__tptz__GetNodesResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tptz__GetNodesResponse(struct soap *soap, const char *tag, int id, struct _tptz__GetNodesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tptz__GetNodesResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tptz__GetNodesResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tptz__GetNodesResponse ** SOAP_FMAC4 soap_in_PointerTo_tptz__GetNodesResponse(struct soap *soap, const char *tag, struct _tptz__GetNodesResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tptz__GetNodesResponse **)soap_malloc(soap, sizeof(struct _tptz__GetNodesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tptz__GetNodesResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tptz__GetNodesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__GetNodesResponse, sizeof(struct _tptz__GetNodesResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tptz__GetNodesResponse(struct soap *soap, struct _tptz__GetNodesResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tptz__GetNodesResponse);
	if (soap_out_PointerTo_tptz__GetNodesResponse(soap, tag?tag:"tptz:GetNodesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__GetNodesResponse ** SOAP_FMAC4 soap_get_PointerTo_tptz__GetNodesResponse(struct soap *soap, struct _tptz__GetNodesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tptz__GetNodesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tptz__GetNodes(struct soap *soap, struct _tptz__GetNodes *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tptz__GetNodes))
		soap_serialize__tptz__GetNodes(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tptz__GetNodes(struct soap *soap, const char *tag, int id, struct _tptz__GetNodes *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tptz__GetNodes);
	if (id < 0)
		return soap->error;
	return soap_out__tptz__GetNodes(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tptz__GetNodes ** SOAP_FMAC4 soap_in_PointerTo_tptz__GetNodes(struct soap *soap, const char *tag, struct _tptz__GetNodes **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tptz__GetNodes **)soap_malloc(soap, sizeof(struct _tptz__GetNodes *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tptz__GetNodes(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tptz__GetNodes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__GetNodes, sizeof(struct _tptz__GetNodes), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tptz__GetNodes(struct soap *soap, struct _tptz__GetNodes *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tptz__GetNodes);
	if (soap_out_PointerTo_tptz__GetNodes(soap, tag?tag:"tptz:GetNodes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__GetNodes ** SOAP_FMAC4 soap_get_PointerTo_tptz__GetNodes(struct soap *soap, struct _tptz__GetNodes **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tptz__GetNodes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tptz__GetConfigurationResponse(struct soap *soap, struct _tptz__GetConfigurationResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tptz__GetConfigurationResponse))
		soap_serialize__tptz__GetConfigurationResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tptz__GetConfigurationResponse(struct soap *soap, const char *tag, int id, struct _tptz__GetConfigurationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tptz__GetConfigurationResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tptz__GetConfigurationResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tptz__GetConfigurationResponse ** SOAP_FMAC4 soap_in_PointerTo_tptz__GetConfigurationResponse(struct soap *soap, const char *tag, struct _tptz__GetConfigurationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tptz__GetConfigurationResponse **)soap_malloc(soap, sizeof(struct _tptz__GetConfigurationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tptz__GetConfigurationResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tptz__GetConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__GetConfigurationResponse, sizeof(struct _tptz__GetConfigurationResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tptz__GetConfigurationResponse(struct soap *soap, struct _tptz__GetConfigurationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tptz__GetConfigurationResponse);
	if (soap_out_PointerTo_tptz__GetConfigurationResponse(soap, tag?tag:"tptz:GetConfigurationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__GetConfigurationResponse ** SOAP_FMAC4 soap_get_PointerTo_tptz__GetConfigurationResponse(struct soap *soap, struct _tptz__GetConfigurationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tptz__GetConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tptz__GetConfiguration(struct soap *soap, struct _tptz__GetConfiguration *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tptz__GetConfiguration))
		soap_serialize__tptz__GetConfiguration(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tptz__GetConfiguration(struct soap *soap, const char *tag, int id, struct _tptz__GetConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tptz__GetConfiguration);
	if (id < 0)
		return soap->error;
	return soap_out__tptz__GetConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tptz__GetConfiguration ** SOAP_FMAC4 soap_in_PointerTo_tptz__GetConfiguration(struct soap *soap, const char *tag, struct _tptz__GetConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tptz__GetConfiguration **)soap_malloc(soap, sizeof(struct _tptz__GetConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tptz__GetConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tptz__GetConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__GetConfiguration, sizeof(struct _tptz__GetConfiguration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tptz__GetConfiguration(struct soap *soap, struct _tptz__GetConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tptz__GetConfiguration);
	if (soap_out_PointerTo_tptz__GetConfiguration(soap, tag?tag:"tptz:GetConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__GetConfiguration ** SOAP_FMAC4 soap_get_PointerTo_tptz__GetConfiguration(struct soap *soap, struct _tptz__GetConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tptz__GetConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tptz__GetStatusResponse(struct soap *soap, struct _tptz__GetStatusResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tptz__GetStatusResponse))
		soap_serialize__tptz__GetStatusResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tptz__GetStatusResponse(struct soap *soap, const char *tag, int id, struct _tptz__GetStatusResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tptz__GetStatusResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tptz__GetStatusResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tptz__GetStatusResponse ** SOAP_FMAC4 soap_in_PointerTo_tptz__GetStatusResponse(struct soap *soap, const char *tag, struct _tptz__GetStatusResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tptz__GetStatusResponse **)soap_malloc(soap, sizeof(struct _tptz__GetStatusResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tptz__GetStatusResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tptz__GetStatusResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__GetStatusResponse, sizeof(struct _tptz__GetStatusResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tptz__GetStatusResponse(struct soap *soap, struct _tptz__GetStatusResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tptz__GetStatusResponse);
	if (soap_out_PointerTo_tptz__GetStatusResponse(soap, tag?tag:"tptz:GetStatusResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__GetStatusResponse ** SOAP_FMAC4 soap_get_PointerTo_tptz__GetStatusResponse(struct soap *soap, struct _tptz__GetStatusResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tptz__GetStatusResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tptz__GetStatus(struct soap *soap, struct _tptz__GetStatus *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tptz__GetStatus))
		soap_serialize__tptz__GetStatus(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tptz__GetStatus(struct soap *soap, const char *tag, int id, struct _tptz__GetStatus *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tptz__GetStatus);
	if (id < 0)
		return soap->error;
	return soap_out__tptz__GetStatus(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tptz__GetStatus ** SOAP_FMAC4 soap_in_PointerTo_tptz__GetStatus(struct soap *soap, const char *tag, struct _tptz__GetStatus **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tptz__GetStatus **)soap_malloc(soap, sizeof(struct _tptz__GetStatus *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tptz__GetStatus(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tptz__GetStatus **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__GetStatus, sizeof(struct _tptz__GetStatus), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tptz__GetStatus(struct soap *soap, struct _tptz__GetStatus *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tptz__GetStatus);
	if (soap_out_PointerTo_tptz__GetStatus(soap, tag?tag:"tptz:GetStatus", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__GetStatus ** SOAP_FMAC4 soap_get_PointerTo_tptz__GetStatus(struct soap *soap, struct _tptz__GetStatus **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tptz__GetStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tptz__GotoPresetResponse(struct soap *soap, struct _tptz__GotoPresetResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tptz__GotoPresetResponse))
		soap_serialize__tptz__GotoPresetResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tptz__GotoPresetResponse(struct soap *soap, const char *tag, int id, struct _tptz__GotoPresetResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tptz__GotoPresetResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tptz__GotoPresetResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tptz__GotoPresetResponse ** SOAP_FMAC4 soap_in_PointerTo_tptz__GotoPresetResponse(struct soap *soap, const char *tag, struct _tptz__GotoPresetResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tptz__GotoPresetResponse **)soap_malloc(soap, sizeof(struct _tptz__GotoPresetResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tptz__GotoPresetResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tptz__GotoPresetResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__GotoPresetResponse, sizeof(struct _tptz__GotoPresetResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tptz__GotoPresetResponse(struct soap *soap, struct _tptz__GotoPresetResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tptz__GotoPresetResponse);
	if (soap_out_PointerTo_tptz__GotoPresetResponse(soap, tag?tag:"tptz:GotoPresetResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__GotoPresetResponse ** SOAP_FMAC4 soap_get_PointerTo_tptz__GotoPresetResponse(struct soap *soap, struct _tptz__GotoPresetResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tptz__GotoPresetResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tptz__GotoPreset(struct soap *soap, struct _tptz__GotoPreset *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tptz__GotoPreset))
		soap_serialize__tptz__GotoPreset(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tptz__GotoPreset(struct soap *soap, const char *tag, int id, struct _tptz__GotoPreset *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tptz__GotoPreset);
	if (id < 0)
		return soap->error;
	return soap_out__tptz__GotoPreset(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tptz__GotoPreset ** SOAP_FMAC4 soap_in_PointerTo_tptz__GotoPreset(struct soap *soap, const char *tag, struct _tptz__GotoPreset **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tptz__GotoPreset **)soap_malloc(soap, sizeof(struct _tptz__GotoPreset *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tptz__GotoPreset(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tptz__GotoPreset **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__GotoPreset, sizeof(struct _tptz__GotoPreset), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tptz__GotoPreset(struct soap *soap, struct _tptz__GotoPreset *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tptz__GotoPreset);
	if (soap_out_PointerTo_tptz__GotoPreset(soap, tag?tag:"tptz:GotoPreset", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__GotoPreset ** SOAP_FMAC4 soap_get_PointerTo_tptz__GotoPreset(struct soap *soap, struct _tptz__GotoPreset **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tptz__GotoPreset(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tptz__RemovePresetResponse(struct soap *soap, struct _tptz__RemovePresetResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tptz__RemovePresetResponse))
		soap_serialize__tptz__RemovePresetResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tptz__RemovePresetResponse(struct soap *soap, const char *tag, int id, struct _tptz__RemovePresetResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tptz__RemovePresetResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tptz__RemovePresetResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tptz__RemovePresetResponse ** SOAP_FMAC4 soap_in_PointerTo_tptz__RemovePresetResponse(struct soap *soap, const char *tag, struct _tptz__RemovePresetResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tptz__RemovePresetResponse **)soap_malloc(soap, sizeof(struct _tptz__RemovePresetResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tptz__RemovePresetResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tptz__RemovePresetResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__RemovePresetResponse, sizeof(struct _tptz__RemovePresetResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tptz__RemovePresetResponse(struct soap *soap, struct _tptz__RemovePresetResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tptz__RemovePresetResponse);
	if (soap_out_PointerTo_tptz__RemovePresetResponse(soap, tag?tag:"tptz:RemovePresetResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__RemovePresetResponse ** SOAP_FMAC4 soap_get_PointerTo_tptz__RemovePresetResponse(struct soap *soap, struct _tptz__RemovePresetResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tptz__RemovePresetResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tptz__RemovePreset(struct soap *soap, struct _tptz__RemovePreset *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tptz__RemovePreset))
		soap_serialize__tptz__RemovePreset(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tptz__RemovePreset(struct soap *soap, const char *tag, int id, struct _tptz__RemovePreset *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tptz__RemovePreset);
	if (id < 0)
		return soap->error;
	return soap_out__tptz__RemovePreset(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tptz__RemovePreset ** SOAP_FMAC4 soap_in_PointerTo_tptz__RemovePreset(struct soap *soap, const char *tag, struct _tptz__RemovePreset **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tptz__RemovePreset **)soap_malloc(soap, sizeof(struct _tptz__RemovePreset *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tptz__RemovePreset(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tptz__RemovePreset **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__RemovePreset, sizeof(struct _tptz__RemovePreset), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tptz__RemovePreset(struct soap *soap, struct _tptz__RemovePreset *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tptz__RemovePreset);
	if (soap_out_PointerTo_tptz__RemovePreset(soap, tag?tag:"tptz:RemovePreset", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__RemovePreset ** SOAP_FMAC4 soap_get_PointerTo_tptz__RemovePreset(struct soap *soap, struct _tptz__RemovePreset **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tptz__RemovePreset(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tptz__SetPresetResponse(struct soap *soap, struct _tptz__SetPresetResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tptz__SetPresetResponse))
		soap_serialize__tptz__SetPresetResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tptz__SetPresetResponse(struct soap *soap, const char *tag, int id, struct _tptz__SetPresetResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tptz__SetPresetResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tptz__SetPresetResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tptz__SetPresetResponse ** SOAP_FMAC4 soap_in_PointerTo_tptz__SetPresetResponse(struct soap *soap, const char *tag, struct _tptz__SetPresetResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tptz__SetPresetResponse **)soap_malloc(soap, sizeof(struct _tptz__SetPresetResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tptz__SetPresetResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tptz__SetPresetResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__SetPresetResponse, sizeof(struct _tptz__SetPresetResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tptz__SetPresetResponse(struct soap *soap, struct _tptz__SetPresetResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tptz__SetPresetResponse);
	if (soap_out_PointerTo_tptz__SetPresetResponse(soap, tag?tag:"tptz:SetPresetResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__SetPresetResponse ** SOAP_FMAC4 soap_get_PointerTo_tptz__SetPresetResponse(struct soap *soap, struct _tptz__SetPresetResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tptz__SetPresetResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tptz__SetPreset(struct soap *soap, struct _tptz__SetPreset *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tptz__SetPreset))
		soap_serialize__tptz__SetPreset(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tptz__SetPreset(struct soap *soap, const char *tag, int id, struct _tptz__SetPreset *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tptz__SetPreset);
	if (id < 0)
		return soap->error;
	return soap_out__tptz__SetPreset(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tptz__SetPreset ** SOAP_FMAC4 soap_in_PointerTo_tptz__SetPreset(struct soap *soap, const char *tag, struct _tptz__SetPreset **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tptz__SetPreset **)soap_malloc(soap, sizeof(struct _tptz__SetPreset *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tptz__SetPreset(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tptz__SetPreset **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__SetPreset, sizeof(struct _tptz__SetPreset), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tptz__SetPreset(struct soap *soap, struct _tptz__SetPreset *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tptz__SetPreset);
	if (soap_out_PointerTo_tptz__SetPreset(soap, tag?tag:"tptz:SetPreset", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__SetPreset ** SOAP_FMAC4 soap_get_PointerTo_tptz__SetPreset(struct soap *soap, struct _tptz__SetPreset **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tptz__SetPreset(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tptz__GetPresetsResponse(struct soap *soap, struct _tptz__GetPresetsResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tptz__GetPresetsResponse))
		soap_serialize__tptz__GetPresetsResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tptz__GetPresetsResponse(struct soap *soap, const char *tag, int id, struct _tptz__GetPresetsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tptz__GetPresetsResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tptz__GetPresetsResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tptz__GetPresetsResponse ** SOAP_FMAC4 soap_in_PointerTo_tptz__GetPresetsResponse(struct soap *soap, const char *tag, struct _tptz__GetPresetsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tptz__GetPresetsResponse **)soap_malloc(soap, sizeof(struct _tptz__GetPresetsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tptz__GetPresetsResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tptz__GetPresetsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__GetPresetsResponse, sizeof(struct _tptz__GetPresetsResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tptz__GetPresetsResponse(struct soap *soap, struct _tptz__GetPresetsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tptz__GetPresetsResponse);
	if (soap_out_PointerTo_tptz__GetPresetsResponse(soap, tag?tag:"tptz:GetPresetsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__GetPresetsResponse ** SOAP_FMAC4 soap_get_PointerTo_tptz__GetPresetsResponse(struct soap *soap, struct _tptz__GetPresetsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tptz__GetPresetsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tptz__GetPresets(struct soap *soap, struct _tptz__GetPresets *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tptz__GetPresets))
		soap_serialize__tptz__GetPresets(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tptz__GetPresets(struct soap *soap, const char *tag, int id, struct _tptz__GetPresets *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tptz__GetPresets);
	if (id < 0)
		return soap->error;
	return soap_out__tptz__GetPresets(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tptz__GetPresets ** SOAP_FMAC4 soap_in_PointerTo_tptz__GetPresets(struct soap *soap, const char *tag, struct _tptz__GetPresets **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tptz__GetPresets **)soap_malloc(soap, sizeof(struct _tptz__GetPresets *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tptz__GetPresets(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tptz__GetPresets **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__GetPresets, sizeof(struct _tptz__GetPresets), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tptz__GetPresets(struct soap *soap, struct _tptz__GetPresets *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tptz__GetPresets);
	if (soap_out_PointerTo_tptz__GetPresets(soap, tag?tag:"tptz:GetPresets", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__GetPresets ** SOAP_FMAC4 soap_get_PointerTo_tptz__GetPresets(struct soap *soap, struct _tptz__GetPresets **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tptz__GetPresets(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tptz__GetConfigurationsResponse(struct soap *soap, struct _tptz__GetConfigurationsResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tptz__GetConfigurationsResponse))
		soap_serialize__tptz__GetConfigurationsResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tptz__GetConfigurationsResponse(struct soap *soap, const char *tag, int id, struct _tptz__GetConfigurationsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tptz__GetConfigurationsResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tptz__GetConfigurationsResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tptz__GetConfigurationsResponse ** SOAP_FMAC4 soap_in_PointerTo_tptz__GetConfigurationsResponse(struct soap *soap, const char *tag, struct _tptz__GetConfigurationsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tptz__GetConfigurationsResponse **)soap_malloc(soap, sizeof(struct _tptz__GetConfigurationsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tptz__GetConfigurationsResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tptz__GetConfigurationsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__GetConfigurationsResponse, sizeof(struct _tptz__GetConfigurationsResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tptz__GetConfigurationsResponse(struct soap *soap, struct _tptz__GetConfigurationsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tptz__GetConfigurationsResponse);
	if (soap_out_PointerTo_tptz__GetConfigurationsResponse(soap, tag?tag:"tptz:GetConfigurationsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__GetConfigurationsResponse ** SOAP_FMAC4 soap_get_PointerTo_tptz__GetConfigurationsResponse(struct soap *soap, struct _tptz__GetConfigurationsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tptz__GetConfigurationsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tptz__GetConfigurations(struct soap *soap, struct _tptz__GetConfigurations *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tptz__GetConfigurations))
		soap_serialize__tptz__GetConfigurations(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tptz__GetConfigurations(struct soap *soap, const char *tag, int id, struct _tptz__GetConfigurations *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tptz__GetConfigurations);
	if (id < 0)
		return soap->error;
	return soap_out__tptz__GetConfigurations(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tptz__GetConfigurations ** SOAP_FMAC4 soap_in_PointerTo_tptz__GetConfigurations(struct soap *soap, const char *tag, struct _tptz__GetConfigurations **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tptz__GetConfigurations **)soap_malloc(soap, sizeof(struct _tptz__GetConfigurations *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tptz__GetConfigurations(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tptz__GetConfigurations **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__GetConfigurations, sizeof(struct _tptz__GetConfigurations), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tptz__GetConfigurations(struct soap *soap, struct _tptz__GetConfigurations *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tptz__GetConfigurations);
	if (soap_out_PointerTo_tptz__GetConfigurations(soap, tag?tag:"tptz:GetConfigurations", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__GetConfigurations ** SOAP_FMAC4 soap_get_PointerTo_tptz__GetConfigurations(struct soap *soap, struct _tptz__GetConfigurations **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tptz__GetConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tptz__GetServiceCapabilitiesResponse(struct soap *soap, struct _tptz__GetServiceCapabilitiesResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tptz__GetServiceCapabilitiesResponse))
		soap_serialize__tptz__GetServiceCapabilitiesResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tptz__GetServiceCapabilitiesResponse(struct soap *soap, const char *tag, int id, struct _tptz__GetServiceCapabilitiesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tptz__GetServiceCapabilitiesResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tptz__GetServiceCapabilitiesResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tptz__GetServiceCapabilitiesResponse ** SOAP_FMAC4 soap_in_PointerTo_tptz__GetServiceCapabilitiesResponse(struct soap *soap, const char *tag, struct _tptz__GetServiceCapabilitiesResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tptz__GetServiceCapabilitiesResponse **)soap_malloc(soap, sizeof(struct _tptz__GetServiceCapabilitiesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tptz__GetServiceCapabilitiesResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tptz__GetServiceCapabilitiesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__GetServiceCapabilitiesResponse, sizeof(struct _tptz__GetServiceCapabilitiesResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tptz__GetServiceCapabilitiesResponse(struct soap *soap, struct _tptz__GetServiceCapabilitiesResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tptz__GetServiceCapabilitiesResponse);
	if (soap_out_PointerTo_tptz__GetServiceCapabilitiesResponse(soap, tag?tag:"tptz:GetServiceCapabilitiesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__GetServiceCapabilitiesResponse ** SOAP_FMAC4 soap_get_PointerTo_tptz__GetServiceCapabilitiesResponse(struct soap *soap, struct _tptz__GetServiceCapabilitiesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tptz__GetServiceCapabilitiesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tptz__GetServiceCapabilities(struct soap *soap, struct _tptz__GetServiceCapabilities *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tptz__GetServiceCapabilities))
		soap_serialize__tptz__GetServiceCapabilities(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tptz__GetServiceCapabilities(struct soap *soap, const char *tag, int id, struct _tptz__GetServiceCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tptz__GetServiceCapabilities);
	if (id < 0)
		return soap->error;
	return soap_out__tptz__GetServiceCapabilities(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tptz__GetServiceCapabilities ** SOAP_FMAC4 soap_in_PointerTo_tptz__GetServiceCapabilities(struct soap *soap, const char *tag, struct _tptz__GetServiceCapabilities **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tptz__GetServiceCapabilities **)soap_malloc(soap, sizeof(struct _tptz__GetServiceCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tptz__GetServiceCapabilities(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tptz__GetServiceCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__GetServiceCapabilities, sizeof(struct _tptz__GetServiceCapabilities), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tptz__GetServiceCapabilities(struct soap *soap, struct _tptz__GetServiceCapabilities *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tptz__GetServiceCapabilities);
	if (soap_out_PointerTo_tptz__GetServiceCapabilities(soap, tag?tag:"tptz:GetServiceCapabilities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__GetServiceCapabilities ** SOAP_FMAC4 soap_get_PointerTo_tptz__GetServiceCapabilities(struct soap *soap, struct _tptz__GetServiceCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tptz__GetServiceCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_timg__GetMoveOptionsResponse(struct soap *soap, struct _timg__GetMoveOptionsResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__timg__GetMoveOptionsResponse))
		soap_serialize__timg__GetMoveOptionsResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_timg__GetMoveOptionsResponse(struct soap *soap, const char *tag, int id, struct _timg__GetMoveOptionsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__timg__GetMoveOptionsResponse);
	if (id < 0)
		return soap->error;
	return soap_out__timg__GetMoveOptionsResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _timg__GetMoveOptionsResponse ** SOAP_FMAC4 soap_in_PointerTo_timg__GetMoveOptionsResponse(struct soap *soap, const char *tag, struct _timg__GetMoveOptionsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _timg__GetMoveOptionsResponse **)soap_malloc(soap, sizeof(struct _timg__GetMoveOptionsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__timg__GetMoveOptionsResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _timg__GetMoveOptionsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__timg__GetMoveOptionsResponse, sizeof(struct _timg__GetMoveOptionsResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_timg__GetMoveOptionsResponse(struct soap *soap, struct _timg__GetMoveOptionsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_timg__GetMoveOptionsResponse);
	if (soap_out_PointerTo_timg__GetMoveOptionsResponse(soap, tag?tag:"timg:GetMoveOptionsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _timg__GetMoveOptionsResponse ** SOAP_FMAC4 soap_get_PointerTo_timg__GetMoveOptionsResponse(struct soap *soap, struct _timg__GetMoveOptionsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_timg__GetMoveOptionsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_timg__GetMoveOptions(struct soap *soap, struct _timg__GetMoveOptions *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__timg__GetMoveOptions))
		soap_serialize__timg__GetMoveOptions(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_timg__GetMoveOptions(struct soap *soap, const char *tag, int id, struct _timg__GetMoveOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__timg__GetMoveOptions);
	if (id < 0)
		return soap->error;
	return soap_out__timg__GetMoveOptions(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _timg__GetMoveOptions ** SOAP_FMAC4 soap_in_PointerTo_timg__GetMoveOptions(struct soap *soap, const char *tag, struct _timg__GetMoveOptions **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _timg__GetMoveOptions **)soap_malloc(soap, sizeof(struct _timg__GetMoveOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__timg__GetMoveOptions(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _timg__GetMoveOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__timg__GetMoveOptions, sizeof(struct _timg__GetMoveOptions), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_timg__GetMoveOptions(struct soap *soap, struct _timg__GetMoveOptions *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_timg__GetMoveOptions);
	if (soap_out_PointerTo_timg__GetMoveOptions(soap, tag?tag:"timg:GetMoveOptions", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _timg__GetMoveOptions ** SOAP_FMAC4 soap_get_PointerTo_timg__GetMoveOptions(struct soap *soap, struct _timg__GetMoveOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_timg__GetMoveOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_timg__GetStatusResponse(struct soap *soap, struct _timg__GetStatusResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__timg__GetStatusResponse))
		soap_serialize__timg__GetStatusResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_timg__GetStatusResponse(struct soap *soap, const char *tag, int id, struct _timg__GetStatusResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__timg__GetStatusResponse);
	if (id < 0)
		return soap->error;
	return soap_out__timg__GetStatusResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _timg__GetStatusResponse ** SOAP_FMAC4 soap_in_PointerTo_timg__GetStatusResponse(struct soap *soap, const char *tag, struct _timg__GetStatusResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _timg__GetStatusResponse **)soap_malloc(soap, sizeof(struct _timg__GetStatusResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__timg__GetStatusResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _timg__GetStatusResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__timg__GetStatusResponse, sizeof(struct _timg__GetStatusResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_timg__GetStatusResponse(struct soap *soap, struct _timg__GetStatusResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_timg__GetStatusResponse);
	if (soap_out_PointerTo_timg__GetStatusResponse(soap, tag?tag:"timg:GetStatusResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _timg__GetStatusResponse ** SOAP_FMAC4 soap_get_PointerTo_timg__GetStatusResponse(struct soap *soap, struct _timg__GetStatusResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_timg__GetStatusResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_timg__GetStatus(struct soap *soap, struct _timg__GetStatus *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__timg__GetStatus))
		soap_serialize__timg__GetStatus(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_timg__GetStatus(struct soap *soap, const char *tag, int id, struct _timg__GetStatus *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__timg__GetStatus);
	if (id < 0)
		return soap->error;
	return soap_out__timg__GetStatus(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _timg__GetStatus ** SOAP_FMAC4 soap_in_PointerTo_timg__GetStatus(struct soap *soap, const char *tag, struct _timg__GetStatus **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _timg__GetStatus **)soap_malloc(soap, sizeof(struct _timg__GetStatus *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__timg__GetStatus(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _timg__GetStatus **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__timg__GetStatus, sizeof(struct _timg__GetStatus), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_timg__GetStatus(struct soap *soap, struct _timg__GetStatus *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_timg__GetStatus);
	if (soap_out_PointerTo_timg__GetStatus(soap, tag?tag:"timg:GetStatus", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _timg__GetStatus ** SOAP_FMAC4 soap_get_PointerTo_timg__GetStatus(struct soap *soap, struct _timg__GetStatus **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_timg__GetStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_timg__StopResponse(struct soap *soap, struct _timg__StopResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__timg__StopResponse))
		soap_serialize__timg__StopResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_timg__StopResponse(struct soap *soap, const char *tag, int id, struct _timg__StopResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__timg__StopResponse);
	if (id < 0)
		return soap->error;
	return soap_out__timg__StopResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _timg__StopResponse ** SOAP_FMAC4 soap_in_PointerTo_timg__StopResponse(struct soap *soap, const char *tag, struct _timg__StopResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _timg__StopResponse **)soap_malloc(soap, sizeof(struct _timg__StopResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__timg__StopResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _timg__StopResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__timg__StopResponse, sizeof(struct _timg__StopResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_timg__StopResponse(struct soap *soap, struct _timg__StopResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_timg__StopResponse);
	if (soap_out_PointerTo_timg__StopResponse(soap, tag?tag:"timg:StopResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _timg__StopResponse ** SOAP_FMAC4 soap_get_PointerTo_timg__StopResponse(struct soap *soap, struct _timg__StopResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_timg__StopResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_timg__Stop(struct soap *soap, struct _timg__Stop *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__timg__Stop))
		soap_serialize__timg__Stop(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_timg__Stop(struct soap *soap, const char *tag, int id, struct _timg__Stop *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__timg__Stop);
	if (id < 0)
		return soap->error;
	return soap_out__timg__Stop(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _timg__Stop ** SOAP_FMAC4 soap_in_PointerTo_timg__Stop(struct soap *soap, const char *tag, struct _timg__Stop **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _timg__Stop **)soap_malloc(soap, sizeof(struct _timg__Stop *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__timg__Stop(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _timg__Stop **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__timg__Stop, sizeof(struct _timg__Stop), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_timg__Stop(struct soap *soap, struct _timg__Stop *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_timg__Stop);
	if (soap_out_PointerTo_timg__Stop(soap, tag?tag:"timg:Stop", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _timg__Stop ** SOAP_FMAC4 soap_get_PointerTo_timg__Stop(struct soap *soap, struct _timg__Stop **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_timg__Stop(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_timg__MoveResponse(struct soap *soap, struct _timg__MoveResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__timg__MoveResponse))
		soap_serialize__timg__MoveResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_timg__MoveResponse(struct soap *soap, const char *tag, int id, struct _timg__MoveResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__timg__MoveResponse);
	if (id < 0)
		return soap->error;
	return soap_out__timg__MoveResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _timg__MoveResponse ** SOAP_FMAC4 soap_in_PointerTo_timg__MoveResponse(struct soap *soap, const char *tag, struct _timg__MoveResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _timg__MoveResponse **)soap_malloc(soap, sizeof(struct _timg__MoveResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__timg__MoveResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _timg__MoveResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__timg__MoveResponse, sizeof(struct _timg__MoveResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_timg__MoveResponse(struct soap *soap, struct _timg__MoveResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_timg__MoveResponse);
	if (soap_out_PointerTo_timg__MoveResponse(soap, tag?tag:"timg:MoveResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _timg__MoveResponse ** SOAP_FMAC4 soap_get_PointerTo_timg__MoveResponse(struct soap *soap, struct _timg__MoveResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_timg__MoveResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_timg__Move(struct soap *soap, struct _timg__Move *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__timg__Move))
		soap_serialize__timg__Move(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_timg__Move(struct soap *soap, const char *tag, int id, struct _timg__Move *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__timg__Move);
	if (id < 0)
		return soap->error;
	return soap_out__timg__Move(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _timg__Move ** SOAP_FMAC4 soap_in_PointerTo_timg__Move(struct soap *soap, const char *tag, struct _timg__Move **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _timg__Move **)soap_malloc(soap, sizeof(struct _timg__Move *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__timg__Move(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _timg__Move **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__timg__Move, sizeof(struct _timg__Move), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_timg__Move(struct soap *soap, struct _timg__Move *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_timg__Move);
	if (soap_out_PointerTo_timg__Move(soap, tag?tag:"timg:Move", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _timg__Move ** SOAP_FMAC4 soap_get_PointerTo_timg__Move(struct soap *soap, struct _timg__Move **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_timg__Move(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_timg__GetOptionsResponse(struct soap *soap, struct _timg__GetOptionsResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__timg__GetOptionsResponse))
		soap_serialize__timg__GetOptionsResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_timg__GetOptionsResponse(struct soap *soap, const char *tag, int id, struct _timg__GetOptionsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__timg__GetOptionsResponse);
	if (id < 0)
		return soap->error;
	return soap_out__timg__GetOptionsResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _timg__GetOptionsResponse ** SOAP_FMAC4 soap_in_PointerTo_timg__GetOptionsResponse(struct soap *soap, const char *tag, struct _timg__GetOptionsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _timg__GetOptionsResponse **)soap_malloc(soap, sizeof(struct _timg__GetOptionsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__timg__GetOptionsResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _timg__GetOptionsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__timg__GetOptionsResponse, sizeof(struct _timg__GetOptionsResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_timg__GetOptionsResponse(struct soap *soap, struct _timg__GetOptionsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_timg__GetOptionsResponse);
	if (soap_out_PointerTo_timg__GetOptionsResponse(soap, tag?tag:"timg:GetOptionsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _timg__GetOptionsResponse ** SOAP_FMAC4 soap_get_PointerTo_timg__GetOptionsResponse(struct soap *soap, struct _timg__GetOptionsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_timg__GetOptionsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_timg__GetOptions(struct soap *soap, struct _timg__GetOptions *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__timg__GetOptions))
		soap_serialize__timg__GetOptions(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_timg__GetOptions(struct soap *soap, const char *tag, int id, struct _timg__GetOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__timg__GetOptions);
	if (id < 0)
		return soap->error;
	return soap_out__timg__GetOptions(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _timg__GetOptions ** SOAP_FMAC4 soap_in_PointerTo_timg__GetOptions(struct soap *soap, const char *tag, struct _timg__GetOptions **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _timg__GetOptions **)soap_malloc(soap, sizeof(struct _timg__GetOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__timg__GetOptions(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _timg__GetOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__timg__GetOptions, sizeof(struct _timg__GetOptions), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_timg__GetOptions(struct soap *soap, struct _timg__GetOptions *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_timg__GetOptions);
	if (soap_out_PointerTo_timg__GetOptions(soap, tag?tag:"timg:GetOptions", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _timg__GetOptions ** SOAP_FMAC4 soap_get_PointerTo_timg__GetOptions(struct soap *soap, struct _timg__GetOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_timg__GetOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_timg__SetImagingSettingsResponse(struct soap *soap, struct _timg__SetImagingSettingsResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__timg__SetImagingSettingsResponse))
		soap_serialize__timg__SetImagingSettingsResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_timg__SetImagingSettingsResponse(struct soap *soap, const char *tag, int id, struct _timg__SetImagingSettingsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__timg__SetImagingSettingsResponse);
	if (id < 0)
		return soap->error;
	return soap_out__timg__SetImagingSettingsResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _timg__SetImagingSettingsResponse ** SOAP_FMAC4 soap_in_PointerTo_timg__SetImagingSettingsResponse(struct soap *soap, const char *tag, struct _timg__SetImagingSettingsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _timg__SetImagingSettingsResponse **)soap_malloc(soap, sizeof(struct _timg__SetImagingSettingsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__timg__SetImagingSettingsResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _timg__SetImagingSettingsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__timg__SetImagingSettingsResponse, sizeof(struct _timg__SetImagingSettingsResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_timg__SetImagingSettingsResponse(struct soap *soap, struct _timg__SetImagingSettingsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_timg__SetImagingSettingsResponse);
	if (soap_out_PointerTo_timg__SetImagingSettingsResponse(soap, tag?tag:"timg:SetImagingSettingsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _timg__SetImagingSettingsResponse ** SOAP_FMAC4 soap_get_PointerTo_timg__SetImagingSettingsResponse(struct soap *soap, struct _timg__SetImagingSettingsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_timg__SetImagingSettingsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_timg__SetImagingSettings(struct soap *soap, struct _timg__SetImagingSettings *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__timg__SetImagingSettings))
		soap_serialize__timg__SetImagingSettings(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_timg__SetImagingSettings(struct soap *soap, const char *tag, int id, struct _timg__SetImagingSettings *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__timg__SetImagingSettings);
	if (id < 0)
		return soap->error;
	return soap_out__timg__SetImagingSettings(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _timg__SetImagingSettings ** SOAP_FMAC4 soap_in_PointerTo_timg__SetImagingSettings(struct soap *soap, const char *tag, struct _timg__SetImagingSettings **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _timg__SetImagingSettings **)soap_malloc(soap, sizeof(struct _timg__SetImagingSettings *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__timg__SetImagingSettings(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _timg__SetImagingSettings **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__timg__SetImagingSettings, sizeof(struct _timg__SetImagingSettings), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_timg__SetImagingSettings(struct soap *soap, struct _timg__SetImagingSettings *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_timg__SetImagingSettings);
	if (soap_out_PointerTo_timg__SetImagingSettings(soap, tag?tag:"timg:SetImagingSettings", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _timg__SetImagingSettings ** SOAP_FMAC4 soap_get_PointerTo_timg__SetImagingSettings(struct soap *soap, struct _timg__SetImagingSettings **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_timg__SetImagingSettings(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_timg__GetImagingSettingsResponse(struct soap *soap, struct _timg__GetImagingSettingsResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__timg__GetImagingSettingsResponse))
		soap_serialize__timg__GetImagingSettingsResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_timg__GetImagingSettingsResponse(struct soap *soap, const char *tag, int id, struct _timg__GetImagingSettingsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__timg__GetImagingSettingsResponse);
	if (id < 0)
		return soap->error;
	return soap_out__timg__GetImagingSettingsResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _timg__GetImagingSettingsResponse ** SOAP_FMAC4 soap_in_PointerTo_timg__GetImagingSettingsResponse(struct soap *soap, const char *tag, struct _timg__GetImagingSettingsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _timg__GetImagingSettingsResponse **)soap_malloc(soap, sizeof(struct _timg__GetImagingSettingsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__timg__GetImagingSettingsResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _timg__GetImagingSettingsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__timg__GetImagingSettingsResponse, sizeof(struct _timg__GetImagingSettingsResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_timg__GetImagingSettingsResponse(struct soap *soap, struct _timg__GetImagingSettingsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_timg__GetImagingSettingsResponse);
	if (soap_out_PointerTo_timg__GetImagingSettingsResponse(soap, tag?tag:"timg:GetImagingSettingsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _timg__GetImagingSettingsResponse ** SOAP_FMAC4 soap_get_PointerTo_timg__GetImagingSettingsResponse(struct soap *soap, struct _timg__GetImagingSettingsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_timg__GetImagingSettingsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_timg__GetImagingSettings(struct soap *soap, struct _timg__GetImagingSettings *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__timg__GetImagingSettings))
		soap_serialize__timg__GetImagingSettings(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_timg__GetImagingSettings(struct soap *soap, const char *tag, int id, struct _timg__GetImagingSettings *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__timg__GetImagingSettings);
	if (id < 0)
		return soap->error;
	return soap_out__timg__GetImagingSettings(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _timg__GetImagingSettings ** SOAP_FMAC4 soap_in_PointerTo_timg__GetImagingSettings(struct soap *soap, const char *tag, struct _timg__GetImagingSettings **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _timg__GetImagingSettings **)soap_malloc(soap, sizeof(struct _timg__GetImagingSettings *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__timg__GetImagingSettings(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _timg__GetImagingSettings **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__timg__GetImagingSettings, sizeof(struct _timg__GetImagingSettings), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_timg__GetImagingSettings(struct soap *soap, struct _timg__GetImagingSettings *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_timg__GetImagingSettings);
	if (soap_out_PointerTo_timg__GetImagingSettings(soap, tag?tag:"timg:GetImagingSettings", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _timg__GetImagingSettings ** SOAP_FMAC4 soap_get_PointerTo_timg__GetImagingSettings(struct soap *soap, struct _timg__GetImagingSettings **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_timg__GetImagingSettings(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_timg__GetServiceCapabilitiesResponse(struct soap *soap, struct _timg__GetServiceCapabilitiesResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__timg__GetServiceCapabilitiesResponse))
		soap_serialize__timg__GetServiceCapabilitiesResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_timg__GetServiceCapabilitiesResponse(struct soap *soap, const char *tag, int id, struct _timg__GetServiceCapabilitiesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__timg__GetServiceCapabilitiesResponse);
	if (id < 0)
		return soap->error;
	return soap_out__timg__GetServiceCapabilitiesResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _timg__GetServiceCapabilitiesResponse ** SOAP_FMAC4 soap_in_PointerTo_timg__GetServiceCapabilitiesResponse(struct soap *soap, const char *tag, struct _timg__GetServiceCapabilitiesResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _timg__GetServiceCapabilitiesResponse **)soap_malloc(soap, sizeof(struct _timg__GetServiceCapabilitiesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__timg__GetServiceCapabilitiesResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _timg__GetServiceCapabilitiesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__timg__GetServiceCapabilitiesResponse, sizeof(struct _timg__GetServiceCapabilitiesResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_timg__GetServiceCapabilitiesResponse(struct soap *soap, struct _timg__GetServiceCapabilitiesResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_timg__GetServiceCapabilitiesResponse);
	if (soap_out_PointerTo_timg__GetServiceCapabilitiesResponse(soap, tag?tag:"timg:GetServiceCapabilitiesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _timg__GetServiceCapabilitiesResponse ** SOAP_FMAC4 soap_get_PointerTo_timg__GetServiceCapabilitiesResponse(struct soap *soap, struct _timg__GetServiceCapabilitiesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_timg__GetServiceCapabilitiesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_timg__GetServiceCapabilities(struct soap *soap, struct _timg__GetServiceCapabilities *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__timg__GetServiceCapabilities))
		soap_serialize__timg__GetServiceCapabilities(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_timg__GetServiceCapabilities(struct soap *soap, const char *tag, int id, struct _timg__GetServiceCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__timg__GetServiceCapabilities);
	if (id < 0)
		return soap->error;
	return soap_out__timg__GetServiceCapabilities(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _timg__GetServiceCapabilities ** SOAP_FMAC4 soap_in_PointerTo_timg__GetServiceCapabilities(struct soap *soap, const char *tag, struct _timg__GetServiceCapabilities **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _timg__GetServiceCapabilities **)soap_malloc(soap, sizeof(struct _timg__GetServiceCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__timg__GetServiceCapabilities(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _timg__GetServiceCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__timg__GetServiceCapabilities, sizeof(struct _timg__GetServiceCapabilities), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_timg__GetServiceCapabilities(struct soap *soap, struct _timg__GetServiceCapabilities *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_timg__GetServiceCapabilities);
	if (soap_out_PointerTo_timg__GetServiceCapabilities(soap, tag?tag:"timg:GetServiceCapabilities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _timg__GetServiceCapabilities ** SOAP_FMAC4 soap_get_PointerTo_timg__GetServiceCapabilities(struct soap *soap, struct _timg__GetServiceCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_timg__GetServiceCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__StartSystemRestoreResponse(struct soap *soap, struct _tds__StartSystemRestoreResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__StartSystemRestoreResponse))
		soap_serialize__tds__StartSystemRestoreResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__StartSystemRestoreResponse(struct soap *soap, const char *tag, int id, struct _tds__StartSystemRestoreResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__StartSystemRestoreResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tds__StartSystemRestoreResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__StartSystemRestoreResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__StartSystemRestoreResponse(struct soap *soap, const char *tag, struct _tds__StartSystemRestoreResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__StartSystemRestoreResponse **)soap_malloc(soap, sizeof(struct _tds__StartSystemRestoreResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__StartSystemRestoreResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__StartSystemRestoreResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__StartSystemRestoreResponse, sizeof(struct _tds__StartSystemRestoreResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__StartSystemRestoreResponse(struct soap *soap, struct _tds__StartSystemRestoreResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__StartSystemRestoreResponse);
	if (soap_out_PointerTo_tds__StartSystemRestoreResponse(soap, tag?tag:"tds:StartSystemRestoreResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__StartSystemRestoreResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__StartSystemRestoreResponse(struct soap *soap, struct _tds__StartSystemRestoreResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__StartSystemRestoreResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__StartSystemRestore(struct soap *soap, struct _tds__StartSystemRestore *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__StartSystemRestore))
		soap_serialize__tds__StartSystemRestore(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__StartSystemRestore(struct soap *soap, const char *tag, int id, struct _tds__StartSystemRestore *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__StartSystemRestore);
	if (id < 0)
		return soap->error;
	return soap_out__tds__StartSystemRestore(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__StartSystemRestore ** SOAP_FMAC4 soap_in_PointerTo_tds__StartSystemRestore(struct soap *soap, const char *tag, struct _tds__StartSystemRestore **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__StartSystemRestore **)soap_malloc(soap, sizeof(struct _tds__StartSystemRestore *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__StartSystemRestore(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__StartSystemRestore **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__StartSystemRestore, sizeof(struct _tds__StartSystemRestore), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__StartSystemRestore(struct soap *soap, struct _tds__StartSystemRestore *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__StartSystemRestore);
	if (soap_out_PointerTo_tds__StartSystemRestore(soap, tag?tag:"tds:StartSystemRestore", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__StartSystemRestore ** SOAP_FMAC4 soap_get_PointerTo_tds__StartSystemRestore(struct soap *soap, struct _tds__StartSystemRestore **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__StartSystemRestore(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__StartFirmwareUpgradeResponse(struct soap *soap, struct _tds__StartFirmwareUpgradeResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__StartFirmwareUpgradeResponse))
		soap_serialize__tds__StartFirmwareUpgradeResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__StartFirmwareUpgradeResponse(struct soap *soap, const char *tag, int id, struct _tds__StartFirmwareUpgradeResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__StartFirmwareUpgradeResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tds__StartFirmwareUpgradeResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__StartFirmwareUpgradeResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__StartFirmwareUpgradeResponse(struct soap *soap, const char *tag, struct _tds__StartFirmwareUpgradeResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__StartFirmwareUpgradeResponse **)soap_malloc(soap, sizeof(struct _tds__StartFirmwareUpgradeResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__StartFirmwareUpgradeResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__StartFirmwareUpgradeResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__StartFirmwareUpgradeResponse, sizeof(struct _tds__StartFirmwareUpgradeResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__StartFirmwareUpgradeResponse(struct soap *soap, struct _tds__StartFirmwareUpgradeResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__StartFirmwareUpgradeResponse);
	if (soap_out_PointerTo_tds__StartFirmwareUpgradeResponse(soap, tag?tag:"tds:StartFirmwareUpgradeResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__StartFirmwareUpgradeResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__StartFirmwareUpgradeResponse(struct soap *soap, struct _tds__StartFirmwareUpgradeResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__StartFirmwareUpgradeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__StartFirmwareUpgrade(struct soap *soap, struct _tds__StartFirmwareUpgrade *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__StartFirmwareUpgrade))
		soap_serialize__tds__StartFirmwareUpgrade(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__StartFirmwareUpgrade(struct soap *soap, const char *tag, int id, struct _tds__StartFirmwareUpgrade *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__StartFirmwareUpgrade);
	if (id < 0)
		return soap->error;
	return soap_out__tds__StartFirmwareUpgrade(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__StartFirmwareUpgrade ** SOAP_FMAC4 soap_in_PointerTo_tds__StartFirmwareUpgrade(struct soap *soap, const char *tag, struct _tds__StartFirmwareUpgrade **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__StartFirmwareUpgrade **)soap_malloc(soap, sizeof(struct _tds__StartFirmwareUpgrade *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__StartFirmwareUpgrade(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__StartFirmwareUpgrade **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__StartFirmwareUpgrade, sizeof(struct _tds__StartFirmwareUpgrade), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__StartFirmwareUpgrade(struct soap *soap, struct _tds__StartFirmwareUpgrade *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__StartFirmwareUpgrade);
	if (soap_out_PointerTo_tds__StartFirmwareUpgrade(soap, tag?tag:"tds:StartFirmwareUpgrade", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__StartFirmwareUpgrade ** SOAP_FMAC4 soap_get_PointerTo_tds__StartFirmwareUpgrade(struct soap *soap, struct _tds__StartFirmwareUpgrade **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__StartFirmwareUpgrade(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetSystemUrisResponse(struct soap *soap, struct _tds__GetSystemUrisResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetSystemUrisResponse))
		soap_serialize__tds__GetSystemUrisResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetSystemUrisResponse(struct soap *soap, const char *tag, int id, struct _tds__GetSystemUrisResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetSystemUrisResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tds__GetSystemUrisResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__GetSystemUrisResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__GetSystemUrisResponse(struct soap *soap, const char *tag, struct _tds__GetSystemUrisResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__GetSystemUrisResponse **)soap_malloc(soap, sizeof(struct _tds__GetSystemUrisResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__GetSystemUrisResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__GetSystemUrisResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetSystemUrisResponse, sizeof(struct _tds__GetSystemUrisResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetSystemUrisResponse(struct soap *soap, struct _tds__GetSystemUrisResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetSystemUrisResponse);
	if (soap_out_PointerTo_tds__GetSystemUrisResponse(soap, tag?tag:"tds:GetSystemUrisResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetSystemUrisResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__GetSystemUrisResponse(struct soap *soap, struct _tds__GetSystemUrisResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetSystemUrisResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetSystemUris(struct soap *soap, struct _tds__GetSystemUris *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetSystemUris))
		soap_serialize__tds__GetSystemUris(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetSystemUris(struct soap *soap, const char *tag, int id, struct _tds__GetSystemUris *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetSystemUris);
	if (id < 0)
		return soap->error;
	return soap_out__tds__GetSystemUris(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__GetSystemUris ** SOAP_FMAC4 soap_in_PointerTo_tds__GetSystemUris(struct soap *soap, const char *tag, struct _tds__GetSystemUris **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__GetSystemUris **)soap_malloc(soap, sizeof(struct _tds__GetSystemUris *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__GetSystemUris(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__GetSystemUris **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetSystemUris, sizeof(struct _tds__GetSystemUris), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetSystemUris(struct soap *soap, struct _tds__GetSystemUris *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetSystemUris);
	if (soap_out_PointerTo_tds__GetSystemUris(soap, tag?tag:"tds:GetSystemUris", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetSystemUris ** SOAP_FMAC4 soap_get_PointerTo_tds__GetSystemUris(struct soap *soap, struct _tds__GetSystemUris **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetSystemUris(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__ScanAvailableDot11NetworksResponse(struct soap *soap, struct _tds__ScanAvailableDot11NetworksResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__ScanAvailableDot11NetworksResponse))
		soap_serialize__tds__ScanAvailableDot11NetworksResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__ScanAvailableDot11NetworksResponse(struct soap *soap, const char *tag, int id, struct _tds__ScanAvailableDot11NetworksResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__ScanAvailableDot11NetworksResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tds__ScanAvailableDot11NetworksResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__ScanAvailableDot11NetworksResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__ScanAvailableDot11NetworksResponse(struct soap *soap, const char *tag, struct _tds__ScanAvailableDot11NetworksResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__ScanAvailableDot11NetworksResponse **)soap_malloc(soap, sizeof(struct _tds__ScanAvailableDot11NetworksResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__ScanAvailableDot11NetworksResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__ScanAvailableDot11NetworksResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__ScanAvailableDot11NetworksResponse, sizeof(struct _tds__ScanAvailableDot11NetworksResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__ScanAvailableDot11NetworksResponse(struct soap *soap, struct _tds__ScanAvailableDot11NetworksResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__ScanAvailableDot11NetworksResponse);
	if (soap_out_PointerTo_tds__ScanAvailableDot11NetworksResponse(soap, tag?tag:"tds:ScanAvailableDot11NetworksResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__ScanAvailableDot11NetworksResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__ScanAvailableDot11NetworksResponse(struct soap *soap, struct _tds__ScanAvailableDot11NetworksResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__ScanAvailableDot11NetworksResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__ScanAvailableDot11Networks(struct soap *soap, struct _tds__ScanAvailableDot11Networks *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__ScanAvailableDot11Networks))
		soap_serialize__tds__ScanAvailableDot11Networks(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__ScanAvailableDot11Networks(struct soap *soap, const char *tag, int id, struct _tds__ScanAvailableDot11Networks *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__ScanAvailableDot11Networks);
	if (id < 0)
		return soap->error;
	return soap_out__tds__ScanAvailableDot11Networks(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__ScanAvailableDot11Networks ** SOAP_FMAC4 soap_in_PointerTo_tds__ScanAvailableDot11Networks(struct soap *soap, const char *tag, struct _tds__ScanAvailableDot11Networks **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__ScanAvailableDot11Networks **)soap_malloc(soap, sizeof(struct _tds__ScanAvailableDot11Networks *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__ScanAvailableDot11Networks(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__ScanAvailableDot11Networks **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__ScanAvailableDot11Networks, sizeof(struct _tds__ScanAvailableDot11Networks), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__ScanAvailableDot11Networks(struct soap *soap, struct _tds__ScanAvailableDot11Networks *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__ScanAvailableDot11Networks);
	if (soap_out_PointerTo_tds__ScanAvailableDot11Networks(soap, tag?tag:"tds:ScanAvailableDot11Networks", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__ScanAvailableDot11Networks ** SOAP_FMAC4 soap_get_PointerTo_tds__ScanAvailableDot11Networks(struct soap *soap, struct _tds__ScanAvailableDot11Networks **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__ScanAvailableDot11Networks(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetDot11StatusResponse(struct soap *soap, struct _tds__GetDot11StatusResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetDot11StatusResponse))
		soap_serialize__tds__GetDot11StatusResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetDot11StatusResponse(struct soap *soap, const char *tag, int id, struct _tds__GetDot11StatusResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetDot11StatusResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tds__GetDot11StatusResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__GetDot11StatusResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__GetDot11StatusResponse(struct soap *soap, const char *tag, struct _tds__GetDot11StatusResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__GetDot11StatusResponse **)soap_malloc(soap, sizeof(struct _tds__GetDot11StatusResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__GetDot11StatusResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__GetDot11StatusResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetDot11StatusResponse, sizeof(struct _tds__GetDot11StatusResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetDot11StatusResponse(struct soap *soap, struct _tds__GetDot11StatusResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetDot11StatusResponse);
	if (soap_out_PointerTo_tds__GetDot11StatusResponse(soap, tag?tag:"tds:GetDot11StatusResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetDot11StatusResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__GetDot11StatusResponse(struct soap *soap, struct _tds__GetDot11StatusResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetDot11StatusResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetDot11Status(struct soap *soap, struct _tds__GetDot11Status *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetDot11Status))
		soap_serialize__tds__GetDot11Status(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetDot11Status(struct soap *soap, const char *tag, int id, struct _tds__GetDot11Status *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetDot11Status);
	if (id < 0)
		return soap->error;
	return soap_out__tds__GetDot11Status(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__GetDot11Status ** SOAP_FMAC4 soap_in_PointerTo_tds__GetDot11Status(struct soap *soap, const char *tag, struct _tds__GetDot11Status **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__GetDot11Status **)soap_malloc(soap, sizeof(struct _tds__GetDot11Status *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__GetDot11Status(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__GetDot11Status **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetDot11Status, sizeof(struct _tds__GetDot11Status), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetDot11Status(struct soap *soap, struct _tds__GetDot11Status *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetDot11Status);
	if (soap_out_PointerTo_tds__GetDot11Status(soap, tag?tag:"tds:GetDot11Status", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetDot11Status ** SOAP_FMAC4 soap_get_PointerTo_tds__GetDot11Status(struct soap *soap, struct _tds__GetDot11Status **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetDot11Status(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetDot11CapabilitiesResponse(struct soap *soap, struct _tds__GetDot11CapabilitiesResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetDot11CapabilitiesResponse))
		soap_serialize__tds__GetDot11CapabilitiesResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetDot11CapabilitiesResponse(struct soap *soap, const char *tag, int id, struct _tds__GetDot11CapabilitiesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetDot11CapabilitiesResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tds__GetDot11CapabilitiesResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__GetDot11CapabilitiesResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__GetDot11CapabilitiesResponse(struct soap *soap, const char *tag, struct _tds__GetDot11CapabilitiesResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__GetDot11CapabilitiesResponse **)soap_malloc(soap, sizeof(struct _tds__GetDot11CapabilitiesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__GetDot11CapabilitiesResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__GetDot11CapabilitiesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetDot11CapabilitiesResponse, sizeof(struct _tds__GetDot11CapabilitiesResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetDot11CapabilitiesResponse(struct soap *soap, struct _tds__GetDot11CapabilitiesResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetDot11CapabilitiesResponse);
	if (soap_out_PointerTo_tds__GetDot11CapabilitiesResponse(soap, tag?tag:"tds:GetDot11CapabilitiesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetDot11CapabilitiesResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__GetDot11CapabilitiesResponse(struct soap *soap, struct _tds__GetDot11CapabilitiesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetDot11CapabilitiesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetDot11Capabilities(struct soap *soap, struct _tds__GetDot11Capabilities *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetDot11Capabilities))
		soap_serialize__tds__GetDot11Capabilities(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetDot11Capabilities(struct soap *soap, const char *tag, int id, struct _tds__GetDot11Capabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetDot11Capabilities);
	if (id < 0)
		return soap->error;
	return soap_out__tds__GetDot11Capabilities(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__GetDot11Capabilities ** SOAP_FMAC4 soap_in_PointerTo_tds__GetDot11Capabilities(struct soap *soap, const char *tag, struct _tds__GetDot11Capabilities **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__GetDot11Capabilities **)soap_malloc(soap, sizeof(struct _tds__GetDot11Capabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__GetDot11Capabilities(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__GetDot11Capabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetDot11Capabilities, sizeof(struct _tds__GetDot11Capabilities), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetDot11Capabilities(struct soap *soap, struct _tds__GetDot11Capabilities *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetDot11Capabilities);
	if (soap_out_PointerTo_tds__GetDot11Capabilities(soap, tag?tag:"tds:GetDot11Capabilities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetDot11Capabilities ** SOAP_FMAC4 soap_get_PointerTo_tds__GetDot11Capabilities(struct soap *soap, struct _tds__GetDot11Capabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetDot11Capabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__DeleteDot1XConfigurationResponse(struct soap *soap, struct _tds__DeleteDot1XConfigurationResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__DeleteDot1XConfigurationResponse))
		soap_serialize__tds__DeleteDot1XConfigurationResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__DeleteDot1XConfigurationResponse(struct soap *soap, const char *tag, int id, struct _tds__DeleteDot1XConfigurationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__DeleteDot1XConfigurationResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tds__DeleteDot1XConfigurationResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__DeleteDot1XConfigurationResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__DeleteDot1XConfigurationResponse(struct soap *soap, const char *tag, struct _tds__DeleteDot1XConfigurationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__DeleteDot1XConfigurationResponse **)soap_malloc(soap, sizeof(struct _tds__DeleteDot1XConfigurationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__DeleteDot1XConfigurationResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__DeleteDot1XConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__DeleteDot1XConfigurationResponse, sizeof(struct _tds__DeleteDot1XConfigurationResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__DeleteDot1XConfigurationResponse(struct soap *soap, struct _tds__DeleteDot1XConfigurationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__DeleteDot1XConfigurationResponse);
	if (soap_out_PointerTo_tds__DeleteDot1XConfigurationResponse(soap, tag?tag:"tds:DeleteDot1XConfigurationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__DeleteDot1XConfigurationResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__DeleteDot1XConfigurationResponse(struct soap *soap, struct _tds__DeleteDot1XConfigurationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__DeleteDot1XConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__DeleteDot1XConfiguration(struct soap *soap, struct _tds__DeleteDot1XConfiguration *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__DeleteDot1XConfiguration))
		soap_serialize__tds__DeleteDot1XConfiguration(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__DeleteDot1XConfiguration(struct soap *soap, const char *tag, int id, struct _tds__DeleteDot1XConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__DeleteDot1XConfiguration);
	if (id < 0)
		return soap->error;
	return soap_out__tds__DeleteDot1XConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__DeleteDot1XConfiguration ** SOAP_FMAC4 soap_in_PointerTo_tds__DeleteDot1XConfiguration(struct soap *soap, const char *tag, struct _tds__DeleteDot1XConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__DeleteDot1XConfiguration **)soap_malloc(soap, sizeof(struct _tds__DeleteDot1XConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__DeleteDot1XConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__DeleteDot1XConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__DeleteDot1XConfiguration, sizeof(struct _tds__DeleteDot1XConfiguration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__DeleteDot1XConfiguration(struct soap *soap, struct _tds__DeleteDot1XConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__DeleteDot1XConfiguration);
	if (soap_out_PointerTo_tds__DeleteDot1XConfiguration(soap, tag?tag:"tds:DeleteDot1XConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__DeleteDot1XConfiguration ** SOAP_FMAC4 soap_get_PointerTo_tds__DeleteDot1XConfiguration(struct soap *soap, struct _tds__DeleteDot1XConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__DeleteDot1XConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetDot1XConfigurationsResponse(struct soap *soap, struct _tds__GetDot1XConfigurationsResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetDot1XConfigurationsResponse))
		soap_serialize__tds__GetDot1XConfigurationsResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetDot1XConfigurationsResponse(struct soap *soap, const char *tag, int id, struct _tds__GetDot1XConfigurationsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetDot1XConfigurationsResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tds__GetDot1XConfigurationsResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__GetDot1XConfigurationsResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__GetDot1XConfigurationsResponse(struct soap *soap, const char *tag, struct _tds__GetDot1XConfigurationsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__GetDot1XConfigurationsResponse **)soap_malloc(soap, sizeof(struct _tds__GetDot1XConfigurationsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__GetDot1XConfigurationsResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__GetDot1XConfigurationsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetDot1XConfigurationsResponse, sizeof(struct _tds__GetDot1XConfigurationsResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetDot1XConfigurationsResponse(struct soap *soap, struct _tds__GetDot1XConfigurationsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetDot1XConfigurationsResponse);
	if (soap_out_PointerTo_tds__GetDot1XConfigurationsResponse(soap, tag?tag:"tds:GetDot1XConfigurationsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetDot1XConfigurationsResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__GetDot1XConfigurationsResponse(struct soap *soap, struct _tds__GetDot1XConfigurationsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetDot1XConfigurationsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetDot1XConfigurations(struct soap *soap, struct _tds__GetDot1XConfigurations *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetDot1XConfigurations))
		soap_serialize__tds__GetDot1XConfigurations(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetDot1XConfigurations(struct soap *soap, const char *tag, int id, struct _tds__GetDot1XConfigurations *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetDot1XConfigurations);
	if (id < 0)
		return soap->error;
	return soap_out__tds__GetDot1XConfigurations(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__GetDot1XConfigurations ** SOAP_FMAC4 soap_in_PointerTo_tds__GetDot1XConfigurations(struct soap *soap, const char *tag, struct _tds__GetDot1XConfigurations **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__GetDot1XConfigurations **)soap_malloc(soap, sizeof(struct _tds__GetDot1XConfigurations *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__GetDot1XConfigurations(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__GetDot1XConfigurations **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetDot1XConfigurations, sizeof(struct _tds__GetDot1XConfigurations), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetDot1XConfigurations(struct soap *soap, struct _tds__GetDot1XConfigurations *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetDot1XConfigurations);
	if (soap_out_PointerTo_tds__GetDot1XConfigurations(soap, tag?tag:"tds:GetDot1XConfigurations", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetDot1XConfigurations ** SOAP_FMAC4 soap_get_PointerTo_tds__GetDot1XConfigurations(struct soap *soap, struct _tds__GetDot1XConfigurations **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetDot1XConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetDot1XConfigurationResponse(struct soap *soap, struct _tds__GetDot1XConfigurationResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetDot1XConfigurationResponse))
		soap_serialize__tds__GetDot1XConfigurationResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetDot1XConfigurationResponse(struct soap *soap, const char *tag, int id, struct _tds__GetDot1XConfigurationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetDot1XConfigurationResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tds__GetDot1XConfigurationResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__GetDot1XConfigurationResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__GetDot1XConfigurationResponse(struct soap *soap, const char *tag, struct _tds__GetDot1XConfigurationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__GetDot1XConfigurationResponse **)soap_malloc(soap, sizeof(struct _tds__GetDot1XConfigurationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__GetDot1XConfigurationResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__GetDot1XConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetDot1XConfigurationResponse, sizeof(struct _tds__GetDot1XConfigurationResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetDot1XConfigurationResponse(struct soap *soap, struct _tds__GetDot1XConfigurationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetDot1XConfigurationResponse);
	if (soap_out_PointerTo_tds__GetDot1XConfigurationResponse(soap, tag?tag:"tds:GetDot1XConfigurationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetDot1XConfigurationResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__GetDot1XConfigurationResponse(struct soap *soap, struct _tds__GetDot1XConfigurationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetDot1XConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetDot1XConfiguration(struct soap *soap, struct _tds__GetDot1XConfiguration *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetDot1XConfiguration))
		soap_serialize__tds__GetDot1XConfiguration(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetDot1XConfiguration(struct soap *soap, const char *tag, int id, struct _tds__GetDot1XConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetDot1XConfiguration);
	if (id < 0)
		return soap->error;
	return soap_out__tds__GetDot1XConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__GetDot1XConfiguration ** SOAP_FMAC4 soap_in_PointerTo_tds__GetDot1XConfiguration(struct soap *soap, const char *tag, struct _tds__GetDot1XConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__GetDot1XConfiguration **)soap_malloc(soap, sizeof(struct _tds__GetDot1XConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__GetDot1XConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__GetDot1XConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetDot1XConfiguration, sizeof(struct _tds__GetDot1XConfiguration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetDot1XConfiguration(struct soap *soap, struct _tds__GetDot1XConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetDot1XConfiguration);
	if (soap_out_PointerTo_tds__GetDot1XConfiguration(soap, tag?tag:"tds:GetDot1XConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetDot1XConfiguration ** SOAP_FMAC4 soap_get_PointerTo_tds__GetDot1XConfiguration(struct soap *soap, struct _tds__GetDot1XConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetDot1XConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetDot1XConfigurationResponse(struct soap *soap, struct _tds__SetDot1XConfigurationResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetDot1XConfigurationResponse))
		soap_serialize__tds__SetDot1XConfigurationResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetDot1XConfigurationResponse(struct soap *soap, const char *tag, int id, struct _tds__SetDot1XConfigurationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetDot1XConfigurationResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tds__SetDot1XConfigurationResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__SetDot1XConfigurationResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__SetDot1XConfigurationResponse(struct soap *soap, const char *tag, struct _tds__SetDot1XConfigurationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__SetDot1XConfigurationResponse **)soap_malloc(soap, sizeof(struct _tds__SetDot1XConfigurationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__SetDot1XConfigurationResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__SetDot1XConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetDot1XConfigurationResponse, sizeof(struct _tds__SetDot1XConfigurationResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetDot1XConfigurationResponse(struct soap *soap, struct _tds__SetDot1XConfigurationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__SetDot1XConfigurationResponse);
	if (soap_out_PointerTo_tds__SetDot1XConfigurationResponse(soap, tag?tag:"tds:SetDot1XConfigurationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetDot1XConfigurationResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__SetDot1XConfigurationResponse(struct soap *soap, struct _tds__SetDot1XConfigurationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetDot1XConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetDot1XConfiguration(struct soap *soap, struct _tds__SetDot1XConfiguration *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetDot1XConfiguration))
		soap_serialize__tds__SetDot1XConfiguration(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetDot1XConfiguration(struct soap *soap, const char *tag, int id, struct _tds__SetDot1XConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetDot1XConfiguration);
	if (id < 0)
		return soap->error;
	return soap_out__tds__SetDot1XConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__SetDot1XConfiguration ** SOAP_FMAC4 soap_in_PointerTo_tds__SetDot1XConfiguration(struct soap *soap, const char *tag, struct _tds__SetDot1XConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__SetDot1XConfiguration **)soap_malloc(soap, sizeof(struct _tds__SetDot1XConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__SetDot1XConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__SetDot1XConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetDot1XConfiguration, sizeof(struct _tds__SetDot1XConfiguration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetDot1XConfiguration(struct soap *soap, struct _tds__SetDot1XConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__SetDot1XConfiguration);
	if (soap_out_PointerTo_tds__SetDot1XConfiguration(soap, tag?tag:"tds:SetDot1XConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetDot1XConfiguration ** SOAP_FMAC4 soap_get_PointerTo_tds__SetDot1XConfiguration(struct soap *soap, struct _tds__SetDot1XConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetDot1XConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__CreateDot1XConfigurationResponse(struct soap *soap, struct _tds__CreateDot1XConfigurationResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__CreateDot1XConfigurationResponse))
		soap_serialize__tds__CreateDot1XConfigurationResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__CreateDot1XConfigurationResponse(struct soap *soap, const char *tag, int id, struct _tds__CreateDot1XConfigurationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__CreateDot1XConfigurationResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tds__CreateDot1XConfigurationResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__CreateDot1XConfigurationResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__CreateDot1XConfigurationResponse(struct soap *soap, const char *tag, struct _tds__CreateDot1XConfigurationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__CreateDot1XConfigurationResponse **)soap_malloc(soap, sizeof(struct _tds__CreateDot1XConfigurationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__CreateDot1XConfigurationResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__CreateDot1XConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__CreateDot1XConfigurationResponse, sizeof(struct _tds__CreateDot1XConfigurationResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__CreateDot1XConfigurationResponse(struct soap *soap, struct _tds__CreateDot1XConfigurationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__CreateDot1XConfigurationResponse);
	if (soap_out_PointerTo_tds__CreateDot1XConfigurationResponse(soap, tag?tag:"tds:CreateDot1XConfigurationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__CreateDot1XConfigurationResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__CreateDot1XConfigurationResponse(struct soap *soap, struct _tds__CreateDot1XConfigurationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__CreateDot1XConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__CreateDot1XConfiguration(struct soap *soap, struct _tds__CreateDot1XConfiguration *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__CreateDot1XConfiguration))
		soap_serialize__tds__CreateDot1XConfiguration(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__CreateDot1XConfiguration(struct soap *soap, const char *tag, int id, struct _tds__CreateDot1XConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__CreateDot1XConfiguration);
	if (id < 0)
		return soap->error;
	return soap_out__tds__CreateDot1XConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__CreateDot1XConfiguration ** SOAP_FMAC4 soap_in_PointerTo_tds__CreateDot1XConfiguration(struct soap *soap, const char *tag, struct _tds__CreateDot1XConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__CreateDot1XConfiguration **)soap_malloc(soap, sizeof(struct _tds__CreateDot1XConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__CreateDot1XConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__CreateDot1XConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__CreateDot1XConfiguration, sizeof(struct _tds__CreateDot1XConfiguration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__CreateDot1XConfiguration(struct soap *soap, struct _tds__CreateDot1XConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__CreateDot1XConfiguration);
	if (soap_out_PointerTo_tds__CreateDot1XConfiguration(soap, tag?tag:"tds:CreateDot1XConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__CreateDot1XConfiguration ** SOAP_FMAC4 soap_get_PointerTo_tds__CreateDot1XConfiguration(struct soap *soap, struct _tds__CreateDot1XConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__CreateDot1XConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__LoadCACertificatesResponse(struct soap *soap, struct _tds__LoadCACertificatesResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__LoadCACertificatesResponse))
		soap_serialize__tds__LoadCACertificatesResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__LoadCACertificatesResponse(struct soap *soap, const char *tag, int id, struct _tds__LoadCACertificatesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__LoadCACertificatesResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tds__LoadCACertificatesResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__LoadCACertificatesResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__LoadCACertificatesResponse(struct soap *soap, const char *tag, struct _tds__LoadCACertificatesResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__LoadCACertificatesResponse **)soap_malloc(soap, sizeof(struct _tds__LoadCACertificatesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__LoadCACertificatesResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__LoadCACertificatesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__LoadCACertificatesResponse, sizeof(struct _tds__LoadCACertificatesResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__LoadCACertificatesResponse(struct soap *soap, struct _tds__LoadCACertificatesResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__LoadCACertificatesResponse);
	if (soap_out_PointerTo_tds__LoadCACertificatesResponse(soap, tag?tag:"tds:LoadCACertificatesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__LoadCACertificatesResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__LoadCACertificatesResponse(struct soap *soap, struct _tds__LoadCACertificatesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__LoadCACertificatesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__LoadCACertificates(struct soap *soap, struct _tds__LoadCACertificates *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__LoadCACertificates))
		soap_serialize__tds__LoadCACertificates(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__LoadCACertificates(struct soap *soap, const char *tag, int id, struct _tds__LoadCACertificates *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__LoadCACertificates);
	if (id < 0)
		return soap->error;
	return soap_out__tds__LoadCACertificates(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__LoadCACertificates ** SOAP_FMAC4 soap_in_PointerTo_tds__LoadCACertificates(struct soap *soap, const char *tag, struct _tds__LoadCACertificates **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__LoadCACertificates **)soap_malloc(soap, sizeof(struct _tds__LoadCACertificates *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__LoadCACertificates(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__LoadCACertificates **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__LoadCACertificates, sizeof(struct _tds__LoadCACertificates), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__LoadCACertificates(struct soap *soap, struct _tds__LoadCACertificates *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__LoadCACertificates);
	if (soap_out_PointerTo_tds__LoadCACertificates(soap, tag?tag:"tds:LoadCACertificates", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__LoadCACertificates ** SOAP_FMAC4 soap_get_PointerTo_tds__LoadCACertificates(struct soap *soap, struct _tds__LoadCACertificates **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__LoadCACertificates(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetCertificateInformationResponse(struct soap *soap, struct _tds__GetCertificateInformationResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetCertificateInformationResponse))
		soap_serialize__tds__GetCertificateInformationResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetCertificateInformationResponse(struct soap *soap, const char *tag, int id, struct _tds__GetCertificateInformationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetCertificateInformationResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tds__GetCertificateInformationResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__GetCertificateInformationResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__GetCertificateInformationResponse(struct soap *soap, const char *tag, struct _tds__GetCertificateInformationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__GetCertificateInformationResponse **)soap_malloc(soap, sizeof(struct _tds__GetCertificateInformationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__GetCertificateInformationResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__GetCertificateInformationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetCertificateInformationResponse, sizeof(struct _tds__GetCertificateInformationResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetCertificateInformationResponse(struct soap *soap, struct _tds__GetCertificateInformationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetCertificateInformationResponse);
	if (soap_out_PointerTo_tds__GetCertificateInformationResponse(soap, tag?tag:"tds:GetCertificateInformationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetCertificateInformationResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__GetCertificateInformationResponse(struct soap *soap, struct _tds__GetCertificateInformationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetCertificateInformationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetCertificateInformation(struct soap *soap, struct _tds__GetCertificateInformation *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetCertificateInformation))
		soap_serialize__tds__GetCertificateInformation(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetCertificateInformation(struct soap *soap, const char *tag, int id, struct _tds__GetCertificateInformation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetCertificateInformation);
	if (id < 0)
		return soap->error;
	return soap_out__tds__GetCertificateInformation(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__GetCertificateInformation ** SOAP_FMAC4 soap_in_PointerTo_tds__GetCertificateInformation(struct soap *soap, const char *tag, struct _tds__GetCertificateInformation **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__GetCertificateInformation **)soap_malloc(soap, sizeof(struct _tds__GetCertificateInformation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__GetCertificateInformation(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__GetCertificateInformation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetCertificateInformation, sizeof(struct _tds__GetCertificateInformation), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetCertificateInformation(struct soap *soap, struct _tds__GetCertificateInformation *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetCertificateInformation);
	if (soap_out_PointerTo_tds__GetCertificateInformation(soap, tag?tag:"tds:GetCertificateInformation", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetCertificateInformation ** SOAP_FMAC4 soap_get_PointerTo_tds__GetCertificateInformation(struct soap *soap, struct _tds__GetCertificateInformation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetCertificateInformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__LoadCertificateWithPrivateKeyResponse(struct soap *soap, struct _tds__LoadCertificateWithPrivateKeyResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__LoadCertificateWithPrivateKeyResponse))
		soap_serialize__tds__LoadCertificateWithPrivateKeyResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__LoadCertificateWithPrivateKeyResponse(struct soap *soap, const char *tag, int id, struct _tds__LoadCertificateWithPrivateKeyResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__LoadCertificateWithPrivateKeyResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tds__LoadCertificateWithPrivateKeyResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__LoadCertificateWithPrivateKeyResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__LoadCertificateWithPrivateKeyResponse(struct soap *soap, const char *tag, struct _tds__LoadCertificateWithPrivateKeyResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__LoadCertificateWithPrivateKeyResponse **)soap_malloc(soap, sizeof(struct _tds__LoadCertificateWithPrivateKeyResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__LoadCertificateWithPrivateKeyResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__LoadCertificateWithPrivateKeyResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__LoadCertificateWithPrivateKeyResponse, sizeof(struct _tds__LoadCertificateWithPrivateKeyResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__LoadCertificateWithPrivateKeyResponse(struct soap *soap, struct _tds__LoadCertificateWithPrivateKeyResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__LoadCertificateWithPrivateKeyResponse);
	if (soap_out_PointerTo_tds__LoadCertificateWithPrivateKeyResponse(soap, tag?tag:"tds:LoadCertificateWithPrivateKeyResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__LoadCertificateWithPrivateKeyResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__LoadCertificateWithPrivateKeyResponse(struct soap *soap, struct _tds__LoadCertificateWithPrivateKeyResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__LoadCertificateWithPrivateKeyResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__LoadCertificateWithPrivateKey(struct soap *soap, struct _tds__LoadCertificateWithPrivateKey *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__LoadCertificateWithPrivateKey))
		soap_serialize__tds__LoadCertificateWithPrivateKey(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__LoadCertificateWithPrivateKey(struct soap *soap, const char *tag, int id, struct _tds__LoadCertificateWithPrivateKey *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__LoadCertificateWithPrivateKey);
	if (id < 0)
		return soap->error;
	return soap_out__tds__LoadCertificateWithPrivateKey(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__LoadCertificateWithPrivateKey ** SOAP_FMAC4 soap_in_PointerTo_tds__LoadCertificateWithPrivateKey(struct soap *soap, const char *tag, struct _tds__LoadCertificateWithPrivateKey **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__LoadCertificateWithPrivateKey **)soap_malloc(soap, sizeof(struct _tds__LoadCertificateWithPrivateKey *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__LoadCertificateWithPrivateKey(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__LoadCertificateWithPrivateKey **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__LoadCertificateWithPrivateKey, sizeof(struct _tds__LoadCertificateWithPrivateKey), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__LoadCertificateWithPrivateKey(struct soap *soap, struct _tds__LoadCertificateWithPrivateKey *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__LoadCertificateWithPrivateKey);
	if (soap_out_PointerTo_tds__LoadCertificateWithPrivateKey(soap, tag?tag:"tds:LoadCertificateWithPrivateKey", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__LoadCertificateWithPrivateKey ** SOAP_FMAC4 soap_get_PointerTo_tds__LoadCertificateWithPrivateKey(struct soap *soap, struct _tds__LoadCertificateWithPrivateKey **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__LoadCertificateWithPrivateKey(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetCACertificatesResponse(struct soap *soap, struct _tds__GetCACertificatesResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetCACertificatesResponse))
		soap_serialize__tds__GetCACertificatesResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetCACertificatesResponse(struct soap *soap, const char *tag, int id, struct _tds__GetCACertificatesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetCACertificatesResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tds__GetCACertificatesResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__GetCACertificatesResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__GetCACertificatesResponse(struct soap *soap, const char *tag, struct _tds__GetCACertificatesResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__GetCACertificatesResponse **)soap_malloc(soap, sizeof(struct _tds__GetCACertificatesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__GetCACertificatesResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__GetCACertificatesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetCACertificatesResponse, sizeof(struct _tds__GetCACertificatesResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetCACertificatesResponse(struct soap *soap, struct _tds__GetCACertificatesResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetCACertificatesResponse);
	if (soap_out_PointerTo_tds__GetCACertificatesResponse(soap, tag?tag:"tds:GetCACertificatesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetCACertificatesResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__GetCACertificatesResponse(struct soap *soap, struct _tds__GetCACertificatesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetCACertificatesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetCACertificates(struct soap *soap, struct _tds__GetCACertificates *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetCACertificates))
		soap_serialize__tds__GetCACertificates(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetCACertificates(struct soap *soap, const char *tag, int id, struct _tds__GetCACertificates *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetCACertificates);
	if (id < 0)
		return soap->error;
	return soap_out__tds__GetCACertificates(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__GetCACertificates ** SOAP_FMAC4 soap_in_PointerTo_tds__GetCACertificates(struct soap *soap, const char *tag, struct _tds__GetCACertificates **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__GetCACertificates **)soap_malloc(soap, sizeof(struct _tds__GetCACertificates *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__GetCACertificates(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__GetCACertificates **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetCACertificates, sizeof(struct _tds__GetCACertificates), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetCACertificates(struct soap *soap, struct _tds__GetCACertificates *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetCACertificates);
	if (soap_out_PointerTo_tds__GetCACertificates(soap, tag?tag:"tds:GetCACertificates", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetCACertificates ** SOAP_FMAC4 soap_get_PointerTo_tds__GetCACertificates(struct soap *soap, struct _tds__GetCACertificates **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetCACertificates(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SendAuxiliaryCommandResponse(struct soap *soap, struct _tds__SendAuxiliaryCommandResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SendAuxiliaryCommandResponse))
		soap_serialize__tds__SendAuxiliaryCommandResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SendAuxiliaryCommandResponse(struct soap *soap, const char *tag, int id, struct _tds__SendAuxiliaryCommandResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SendAuxiliaryCommandResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tds__SendAuxiliaryCommandResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__SendAuxiliaryCommandResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__SendAuxiliaryCommandResponse(struct soap *soap, const char *tag, struct _tds__SendAuxiliaryCommandResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__SendAuxiliaryCommandResponse **)soap_malloc(soap, sizeof(struct _tds__SendAuxiliaryCommandResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__SendAuxiliaryCommandResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__SendAuxiliaryCommandResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SendAuxiliaryCommandResponse, sizeof(struct _tds__SendAuxiliaryCommandResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SendAuxiliaryCommandResponse(struct soap *soap, struct _tds__SendAuxiliaryCommandResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__SendAuxiliaryCommandResponse);
	if (soap_out_PointerTo_tds__SendAuxiliaryCommandResponse(soap, tag?tag:"tds:SendAuxiliaryCommandResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SendAuxiliaryCommandResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__SendAuxiliaryCommandResponse(struct soap *soap, struct _tds__SendAuxiliaryCommandResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SendAuxiliaryCommandResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SendAuxiliaryCommand(struct soap *soap, struct _tds__SendAuxiliaryCommand *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SendAuxiliaryCommand))
		soap_serialize__tds__SendAuxiliaryCommand(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SendAuxiliaryCommand(struct soap *soap, const char *tag, int id, struct _tds__SendAuxiliaryCommand *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SendAuxiliaryCommand);
	if (id < 0)
		return soap->error;
	return soap_out__tds__SendAuxiliaryCommand(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__SendAuxiliaryCommand ** SOAP_FMAC4 soap_in_PointerTo_tds__SendAuxiliaryCommand(struct soap *soap, const char *tag, struct _tds__SendAuxiliaryCommand **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__SendAuxiliaryCommand **)soap_malloc(soap, sizeof(struct _tds__SendAuxiliaryCommand *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__SendAuxiliaryCommand(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__SendAuxiliaryCommand **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SendAuxiliaryCommand, sizeof(struct _tds__SendAuxiliaryCommand), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SendAuxiliaryCommand(struct soap *soap, struct _tds__SendAuxiliaryCommand *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__SendAuxiliaryCommand);
	if (soap_out_PointerTo_tds__SendAuxiliaryCommand(soap, tag?tag:"tds:SendAuxiliaryCommand", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SendAuxiliaryCommand ** SOAP_FMAC4 soap_get_PointerTo_tds__SendAuxiliaryCommand(struct soap *soap, struct _tds__SendAuxiliaryCommand **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SendAuxiliaryCommand(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetRelayOutputStateResponse(struct soap *soap, struct _tds__SetRelayOutputStateResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetRelayOutputStateResponse))
		soap_serialize__tds__SetRelayOutputStateResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetRelayOutputStateResponse(struct soap *soap, const char *tag, int id, struct _tds__SetRelayOutputStateResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetRelayOutputStateResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tds__SetRelayOutputStateResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__SetRelayOutputStateResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__SetRelayOutputStateResponse(struct soap *soap, const char *tag, struct _tds__SetRelayOutputStateResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__SetRelayOutputStateResponse **)soap_malloc(soap, sizeof(struct _tds__SetRelayOutputStateResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__SetRelayOutputStateResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__SetRelayOutputStateResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetRelayOutputStateResponse, sizeof(struct _tds__SetRelayOutputStateResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetRelayOutputStateResponse(struct soap *soap, struct _tds__SetRelayOutputStateResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__SetRelayOutputStateResponse);
	if (soap_out_PointerTo_tds__SetRelayOutputStateResponse(soap, tag?tag:"tds:SetRelayOutputStateResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetRelayOutputStateResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__SetRelayOutputStateResponse(struct soap *soap, struct _tds__SetRelayOutputStateResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetRelayOutputStateResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetRelayOutputState(struct soap *soap, struct _tds__SetRelayOutputState *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetRelayOutputState))
		soap_serialize__tds__SetRelayOutputState(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetRelayOutputState(struct soap *soap, const char *tag, int id, struct _tds__SetRelayOutputState *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetRelayOutputState);
	if (id < 0)
		return soap->error;
	return soap_out__tds__SetRelayOutputState(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__SetRelayOutputState ** SOAP_FMAC4 soap_in_PointerTo_tds__SetRelayOutputState(struct soap *soap, const char *tag, struct _tds__SetRelayOutputState **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__SetRelayOutputState **)soap_malloc(soap, sizeof(struct _tds__SetRelayOutputState *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__SetRelayOutputState(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__SetRelayOutputState **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetRelayOutputState, sizeof(struct _tds__SetRelayOutputState), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetRelayOutputState(struct soap *soap, struct _tds__SetRelayOutputState *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__SetRelayOutputState);
	if (soap_out_PointerTo_tds__SetRelayOutputState(soap, tag?tag:"tds:SetRelayOutputState", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetRelayOutputState ** SOAP_FMAC4 soap_get_PointerTo_tds__SetRelayOutputState(struct soap *soap, struct _tds__SetRelayOutputState **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetRelayOutputState(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetRelayOutputSettingsResponse(struct soap *soap, struct _tds__SetRelayOutputSettingsResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetRelayOutputSettingsResponse))
		soap_serialize__tds__SetRelayOutputSettingsResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetRelayOutputSettingsResponse(struct soap *soap, const char *tag, int id, struct _tds__SetRelayOutputSettingsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetRelayOutputSettingsResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tds__SetRelayOutputSettingsResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__SetRelayOutputSettingsResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__SetRelayOutputSettingsResponse(struct soap *soap, const char *tag, struct _tds__SetRelayOutputSettingsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__SetRelayOutputSettingsResponse **)soap_malloc(soap, sizeof(struct _tds__SetRelayOutputSettingsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__SetRelayOutputSettingsResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__SetRelayOutputSettingsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetRelayOutputSettingsResponse, sizeof(struct _tds__SetRelayOutputSettingsResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetRelayOutputSettingsResponse(struct soap *soap, struct _tds__SetRelayOutputSettingsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__SetRelayOutputSettingsResponse);
	if (soap_out_PointerTo_tds__SetRelayOutputSettingsResponse(soap, tag?tag:"tds:SetRelayOutputSettingsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetRelayOutputSettingsResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__SetRelayOutputSettingsResponse(struct soap *soap, struct _tds__SetRelayOutputSettingsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetRelayOutputSettingsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetRelayOutputSettings(struct soap *soap, struct _tds__SetRelayOutputSettings *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetRelayOutputSettings))
		soap_serialize__tds__SetRelayOutputSettings(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetRelayOutputSettings(struct soap *soap, const char *tag, int id, struct _tds__SetRelayOutputSettings *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetRelayOutputSettings);
	if (id < 0)
		return soap->error;
	return soap_out__tds__SetRelayOutputSettings(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__SetRelayOutputSettings ** SOAP_FMAC4 soap_in_PointerTo_tds__SetRelayOutputSettings(struct soap *soap, const char *tag, struct _tds__SetRelayOutputSettings **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__SetRelayOutputSettings **)soap_malloc(soap, sizeof(struct _tds__SetRelayOutputSettings *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__SetRelayOutputSettings(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__SetRelayOutputSettings **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetRelayOutputSettings, sizeof(struct _tds__SetRelayOutputSettings), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetRelayOutputSettings(struct soap *soap, struct _tds__SetRelayOutputSettings *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__SetRelayOutputSettings);
	if (soap_out_PointerTo_tds__SetRelayOutputSettings(soap, tag?tag:"tds:SetRelayOutputSettings", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetRelayOutputSettings ** SOAP_FMAC4 soap_get_PointerTo_tds__SetRelayOutputSettings(struct soap *soap, struct _tds__SetRelayOutputSettings **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetRelayOutputSettings(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetRelayOutputsResponse(struct soap *soap, struct _tds__GetRelayOutputsResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetRelayOutputsResponse))
		soap_serialize__tds__GetRelayOutputsResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetRelayOutputsResponse(struct soap *soap, const char *tag, int id, struct _tds__GetRelayOutputsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetRelayOutputsResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tds__GetRelayOutputsResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__GetRelayOutputsResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__GetRelayOutputsResponse(struct soap *soap, const char *tag, struct _tds__GetRelayOutputsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__GetRelayOutputsResponse **)soap_malloc(soap, sizeof(struct _tds__GetRelayOutputsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__GetRelayOutputsResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__GetRelayOutputsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetRelayOutputsResponse, sizeof(struct _tds__GetRelayOutputsResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetRelayOutputsResponse(struct soap *soap, struct _tds__GetRelayOutputsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetRelayOutputsResponse);
	if (soap_out_PointerTo_tds__GetRelayOutputsResponse(soap, tag?tag:"tds:GetRelayOutputsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetRelayOutputsResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__GetRelayOutputsResponse(struct soap *soap, struct _tds__GetRelayOutputsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetRelayOutputsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetRelayOutputs(struct soap *soap, struct _tds__GetRelayOutputs *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetRelayOutputs))
		soap_serialize__tds__GetRelayOutputs(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetRelayOutputs(struct soap *soap, const char *tag, int id, struct _tds__GetRelayOutputs *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetRelayOutputs);
	if (id < 0)
		return soap->error;
	return soap_out__tds__GetRelayOutputs(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__GetRelayOutputs ** SOAP_FMAC4 soap_in_PointerTo_tds__GetRelayOutputs(struct soap *soap, const char *tag, struct _tds__GetRelayOutputs **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__GetRelayOutputs **)soap_malloc(soap, sizeof(struct _tds__GetRelayOutputs *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__GetRelayOutputs(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__GetRelayOutputs **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetRelayOutputs, sizeof(struct _tds__GetRelayOutputs), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetRelayOutputs(struct soap *soap, struct _tds__GetRelayOutputs *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetRelayOutputs);
	if (soap_out_PointerTo_tds__GetRelayOutputs(soap, tag?tag:"tds:GetRelayOutputs", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetRelayOutputs ** SOAP_FMAC4 soap_get_PointerTo_tds__GetRelayOutputs(struct soap *soap, struct _tds__GetRelayOutputs **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetRelayOutputs(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetClientCertificateModeResponse(struct soap *soap, struct _tds__SetClientCertificateModeResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetClientCertificateModeResponse))
		soap_serialize__tds__SetClientCertificateModeResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetClientCertificateModeResponse(struct soap *soap, const char *tag, int id, struct _tds__SetClientCertificateModeResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetClientCertificateModeResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tds__SetClientCertificateModeResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__SetClientCertificateModeResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__SetClientCertificateModeResponse(struct soap *soap, const char *tag, struct _tds__SetClientCertificateModeResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__SetClientCertificateModeResponse **)soap_malloc(soap, sizeof(struct _tds__SetClientCertificateModeResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__SetClientCertificateModeResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__SetClientCertificateModeResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetClientCertificateModeResponse, sizeof(struct _tds__SetClientCertificateModeResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetClientCertificateModeResponse(struct soap *soap, struct _tds__SetClientCertificateModeResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__SetClientCertificateModeResponse);
	if (soap_out_PointerTo_tds__SetClientCertificateModeResponse(soap, tag?tag:"tds:SetClientCertificateModeResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetClientCertificateModeResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__SetClientCertificateModeResponse(struct soap *soap, struct _tds__SetClientCertificateModeResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetClientCertificateModeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetClientCertificateMode(struct soap *soap, struct _tds__SetClientCertificateMode *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetClientCertificateMode))
		soap_serialize__tds__SetClientCertificateMode(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetClientCertificateMode(struct soap *soap, const char *tag, int id, struct _tds__SetClientCertificateMode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetClientCertificateMode);
	if (id < 0)
		return soap->error;
	return soap_out__tds__SetClientCertificateMode(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__SetClientCertificateMode ** SOAP_FMAC4 soap_in_PointerTo_tds__SetClientCertificateMode(struct soap *soap, const char *tag, struct _tds__SetClientCertificateMode **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__SetClientCertificateMode **)soap_malloc(soap, sizeof(struct _tds__SetClientCertificateMode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__SetClientCertificateMode(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__SetClientCertificateMode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetClientCertificateMode, sizeof(struct _tds__SetClientCertificateMode), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetClientCertificateMode(struct soap *soap, struct _tds__SetClientCertificateMode *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__SetClientCertificateMode);
	if (soap_out_PointerTo_tds__SetClientCertificateMode(soap, tag?tag:"tds:SetClientCertificateMode", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetClientCertificateMode ** SOAP_FMAC4 soap_get_PointerTo_tds__SetClientCertificateMode(struct soap *soap, struct _tds__SetClientCertificateMode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetClientCertificateMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetClientCertificateModeResponse(struct soap *soap, struct _tds__GetClientCertificateModeResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetClientCertificateModeResponse))
		soap_serialize__tds__GetClientCertificateModeResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetClientCertificateModeResponse(struct soap *soap, const char *tag, int id, struct _tds__GetClientCertificateModeResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetClientCertificateModeResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tds__GetClientCertificateModeResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__GetClientCertificateModeResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__GetClientCertificateModeResponse(struct soap *soap, const char *tag, struct _tds__GetClientCertificateModeResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__GetClientCertificateModeResponse **)soap_malloc(soap, sizeof(struct _tds__GetClientCertificateModeResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__GetClientCertificateModeResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__GetClientCertificateModeResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetClientCertificateModeResponse, sizeof(struct _tds__GetClientCertificateModeResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetClientCertificateModeResponse(struct soap *soap, struct _tds__GetClientCertificateModeResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetClientCertificateModeResponse);
	if (soap_out_PointerTo_tds__GetClientCertificateModeResponse(soap, tag?tag:"tds:GetClientCertificateModeResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetClientCertificateModeResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__GetClientCertificateModeResponse(struct soap *soap, struct _tds__GetClientCertificateModeResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetClientCertificateModeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetClientCertificateMode(struct soap *soap, struct _tds__GetClientCertificateMode *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetClientCertificateMode))
		soap_serialize__tds__GetClientCertificateMode(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetClientCertificateMode(struct soap *soap, const char *tag, int id, struct _tds__GetClientCertificateMode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetClientCertificateMode);
	if (id < 0)
		return soap->error;
	return soap_out__tds__GetClientCertificateMode(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__GetClientCertificateMode ** SOAP_FMAC4 soap_in_PointerTo_tds__GetClientCertificateMode(struct soap *soap, const char *tag, struct _tds__GetClientCertificateMode **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__GetClientCertificateMode **)soap_malloc(soap, sizeof(struct _tds__GetClientCertificateMode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__GetClientCertificateMode(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__GetClientCertificateMode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetClientCertificateMode, sizeof(struct _tds__GetClientCertificateMode), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetClientCertificateMode(struct soap *soap, struct _tds__GetClientCertificateMode *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetClientCertificateMode);
	if (soap_out_PointerTo_tds__GetClientCertificateMode(soap, tag?tag:"tds:GetClientCertificateMode", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetClientCertificateMode ** SOAP_FMAC4 soap_get_PointerTo_tds__GetClientCertificateMode(struct soap *soap, struct _tds__GetClientCertificateMode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetClientCertificateMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__LoadCertificatesResponse(struct soap *soap, struct _tds__LoadCertificatesResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__LoadCertificatesResponse))
		soap_serialize__tds__LoadCertificatesResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__LoadCertificatesResponse(struct soap *soap, const char *tag, int id, struct _tds__LoadCertificatesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__LoadCertificatesResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tds__LoadCertificatesResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__LoadCertificatesResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__LoadCertificatesResponse(struct soap *soap, const char *tag, struct _tds__LoadCertificatesResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__LoadCertificatesResponse **)soap_malloc(soap, sizeof(struct _tds__LoadCertificatesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__LoadCertificatesResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__LoadCertificatesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__LoadCertificatesResponse, sizeof(struct _tds__LoadCertificatesResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__LoadCertificatesResponse(struct soap *soap, struct _tds__LoadCertificatesResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__LoadCertificatesResponse);
	if (soap_out_PointerTo_tds__LoadCertificatesResponse(soap, tag?tag:"tds:LoadCertificatesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__LoadCertificatesResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__LoadCertificatesResponse(struct soap *soap, struct _tds__LoadCertificatesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__LoadCertificatesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__LoadCertificates(struct soap *soap, struct _tds__LoadCertificates *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__LoadCertificates))
		soap_serialize__tds__LoadCertificates(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__LoadCertificates(struct soap *soap, const char *tag, int id, struct _tds__LoadCertificates *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__LoadCertificates);
	if (id < 0)
		return soap->error;
	return soap_out__tds__LoadCertificates(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__LoadCertificates ** SOAP_FMAC4 soap_in_PointerTo_tds__LoadCertificates(struct soap *soap, const char *tag, struct _tds__LoadCertificates **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__LoadCertificates **)soap_malloc(soap, sizeof(struct _tds__LoadCertificates *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__LoadCertificates(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__LoadCertificates **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__LoadCertificates, sizeof(struct _tds__LoadCertificates), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__LoadCertificates(struct soap *soap, struct _tds__LoadCertificates *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__LoadCertificates);
	if (soap_out_PointerTo_tds__LoadCertificates(soap, tag?tag:"tds:LoadCertificates", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__LoadCertificates ** SOAP_FMAC4 soap_get_PointerTo_tds__LoadCertificates(struct soap *soap, struct _tds__LoadCertificates **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__LoadCertificates(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetPkcs10RequestResponse(struct soap *soap, struct _tds__GetPkcs10RequestResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetPkcs10RequestResponse))
		soap_serialize__tds__GetPkcs10RequestResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetPkcs10RequestResponse(struct soap *soap, const char *tag, int id, struct _tds__GetPkcs10RequestResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetPkcs10RequestResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tds__GetPkcs10RequestResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__GetPkcs10RequestResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__GetPkcs10RequestResponse(struct soap *soap, const char *tag, struct _tds__GetPkcs10RequestResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__GetPkcs10RequestResponse **)soap_malloc(soap, sizeof(struct _tds__GetPkcs10RequestResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__GetPkcs10RequestResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__GetPkcs10RequestResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetPkcs10RequestResponse, sizeof(struct _tds__GetPkcs10RequestResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetPkcs10RequestResponse(struct soap *soap, struct _tds__GetPkcs10RequestResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetPkcs10RequestResponse);
	if (soap_out_PointerTo_tds__GetPkcs10RequestResponse(soap, tag?tag:"tds:GetPkcs10RequestResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetPkcs10RequestResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__GetPkcs10RequestResponse(struct soap *soap, struct _tds__GetPkcs10RequestResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetPkcs10RequestResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetPkcs10Request(struct soap *soap, struct _tds__GetPkcs10Request *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetPkcs10Request))
		soap_serialize__tds__GetPkcs10Request(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetPkcs10Request(struct soap *soap, const char *tag, int id, struct _tds__GetPkcs10Request *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetPkcs10Request);
	if (id < 0)
		return soap->error;
	return soap_out__tds__GetPkcs10Request(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__GetPkcs10Request ** SOAP_FMAC4 soap_in_PointerTo_tds__GetPkcs10Request(struct soap *soap, const char *tag, struct _tds__GetPkcs10Request **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__GetPkcs10Request **)soap_malloc(soap, sizeof(struct _tds__GetPkcs10Request *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__GetPkcs10Request(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__GetPkcs10Request **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetPkcs10Request, sizeof(struct _tds__GetPkcs10Request), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetPkcs10Request(struct soap *soap, struct _tds__GetPkcs10Request *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetPkcs10Request);
	if (soap_out_PointerTo_tds__GetPkcs10Request(soap, tag?tag:"tds:GetPkcs10Request", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetPkcs10Request ** SOAP_FMAC4 soap_get_PointerTo_tds__GetPkcs10Request(struct soap *soap, struct _tds__GetPkcs10Request **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetPkcs10Request(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__DeleteCertificatesResponse(struct soap *soap, struct _tds__DeleteCertificatesResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__DeleteCertificatesResponse))
		soap_serialize__tds__DeleteCertificatesResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__DeleteCertificatesResponse(struct soap *soap, const char *tag, int id, struct _tds__DeleteCertificatesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__DeleteCertificatesResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tds__DeleteCertificatesResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__DeleteCertificatesResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__DeleteCertificatesResponse(struct soap *soap, const char *tag, struct _tds__DeleteCertificatesResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__DeleteCertificatesResponse **)soap_malloc(soap, sizeof(struct _tds__DeleteCertificatesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__DeleteCertificatesResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__DeleteCertificatesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__DeleteCertificatesResponse, sizeof(struct _tds__DeleteCertificatesResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__DeleteCertificatesResponse(struct soap *soap, struct _tds__DeleteCertificatesResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__DeleteCertificatesResponse);
	if (soap_out_PointerTo_tds__DeleteCertificatesResponse(soap, tag?tag:"tds:DeleteCertificatesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__DeleteCertificatesResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__DeleteCertificatesResponse(struct soap *soap, struct _tds__DeleteCertificatesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__DeleteCertificatesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__DeleteCertificates(struct soap *soap, struct _tds__DeleteCertificates *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__DeleteCertificates))
		soap_serialize__tds__DeleteCertificates(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__DeleteCertificates(struct soap *soap, const char *tag, int id, struct _tds__DeleteCertificates *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__DeleteCertificates);
	if (id < 0)
		return soap->error;
	return soap_out__tds__DeleteCertificates(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__DeleteCertificates ** SOAP_FMAC4 soap_in_PointerTo_tds__DeleteCertificates(struct soap *soap, const char *tag, struct _tds__DeleteCertificates **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__DeleteCertificates **)soap_malloc(soap, sizeof(struct _tds__DeleteCertificates *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__DeleteCertificates(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__DeleteCertificates **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__DeleteCertificates, sizeof(struct _tds__DeleteCertificates), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__DeleteCertificates(struct soap *soap, struct _tds__DeleteCertificates *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__DeleteCertificates);
	if (soap_out_PointerTo_tds__DeleteCertificates(soap, tag?tag:"tds:DeleteCertificates", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__DeleteCertificates ** SOAP_FMAC4 soap_get_PointerTo_tds__DeleteCertificates(struct soap *soap, struct _tds__DeleteCertificates **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__DeleteCertificates(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetCertificatesStatusResponse(struct soap *soap, struct _tds__SetCertificatesStatusResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetCertificatesStatusResponse))
		soap_serialize__tds__SetCertificatesStatusResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetCertificatesStatusResponse(struct soap *soap, const char *tag, int id, struct _tds__SetCertificatesStatusResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetCertificatesStatusResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tds__SetCertificatesStatusResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__SetCertificatesStatusResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__SetCertificatesStatusResponse(struct soap *soap, const char *tag, struct _tds__SetCertificatesStatusResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__SetCertificatesStatusResponse **)soap_malloc(soap, sizeof(struct _tds__SetCertificatesStatusResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__SetCertificatesStatusResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__SetCertificatesStatusResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetCertificatesStatusResponse, sizeof(struct _tds__SetCertificatesStatusResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetCertificatesStatusResponse(struct soap *soap, struct _tds__SetCertificatesStatusResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__SetCertificatesStatusResponse);
	if (soap_out_PointerTo_tds__SetCertificatesStatusResponse(soap, tag?tag:"tds:SetCertificatesStatusResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetCertificatesStatusResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__SetCertificatesStatusResponse(struct soap *soap, struct _tds__SetCertificatesStatusResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetCertificatesStatusResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetCertificatesStatus(struct soap *soap, struct _tds__SetCertificatesStatus *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetCertificatesStatus))
		soap_serialize__tds__SetCertificatesStatus(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetCertificatesStatus(struct soap *soap, const char *tag, int id, struct _tds__SetCertificatesStatus *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetCertificatesStatus);
	if (id < 0)
		return soap->error;
	return soap_out__tds__SetCertificatesStatus(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__SetCertificatesStatus ** SOAP_FMAC4 soap_in_PointerTo_tds__SetCertificatesStatus(struct soap *soap, const char *tag, struct _tds__SetCertificatesStatus **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__SetCertificatesStatus **)soap_malloc(soap, sizeof(struct _tds__SetCertificatesStatus *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__SetCertificatesStatus(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__SetCertificatesStatus **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetCertificatesStatus, sizeof(struct _tds__SetCertificatesStatus), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetCertificatesStatus(struct soap *soap, struct _tds__SetCertificatesStatus *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__SetCertificatesStatus);
	if (soap_out_PointerTo_tds__SetCertificatesStatus(soap, tag?tag:"tds:SetCertificatesStatus", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetCertificatesStatus ** SOAP_FMAC4 soap_get_PointerTo_tds__SetCertificatesStatus(struct soap *soap, struct _tds__SetCertificatesStatus **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetCertificatesStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetCertificatesStatusResponse(struct soap *soap, struct _tds__GetCertificatesStatusResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetCertificatesStatusResponse))
		soap_serialize__tds__GetCertificatesStatusResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetCertificatesStatusResponse(struct soap *soap, const char *tag, int id, struct _tds__GetCertificatesStatusResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetCertificatesStatusResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tds__GetCertificatesStatusResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__GetCertificatesStatusResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__GetCertificatesStatusResponse(struct soap *soap, const char *tag, struct _tds__GetCertificatesStatusResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__GetCertificatesStatusResponse **)soap_malloc(soap, sizeof(struct _tds__GetCertificatesStatusResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__GetCertificatesStatusResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__GetCertificatesStatusResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetCertificatesStatusResponse, sizeof(struct _tds__GetCertificatesStatusResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetCertificatesStatusResponse(struct soap *soap, struct _tds__GetCertificatesStatusResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetCertificatesStatusResponse);
	if (soap_out_PointerTo_tds__GetCertificatesStatusResponse(soap, tag?tag:"tds:GetCertificatesStatusResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetCertificatesStatusResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__GetCertificatesStatusResponse(struct soap *soap, struct _tds__GetCertificatesStatusResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetCertificatesStatusResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetCertificatesStatus(struct soap *soap, struct _tds__GetCertificatesStatus *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetCertificatesStatus))
		soap_serialize__tds__GetCertificatesStatus(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetCertificatesStatus(struct soap *soap, const char *tag, int id, struct _tds__GetCertificatesStatus *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetCertificatesStatus);
	if (id < 0)
		return soap->error;
	return soap_out__tds__GetCertificatesStatus(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__GetCertificatesStatus ** SOAP_FMAC4 soap_in_PointerTo_tds__GetCertificatesStatus(struct soap *soap, const char *tag, struct _tds__GetCertificatesStatus **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__GetCertificatesStatus **)soap_malloc(soap, sizeof(struct _tds__GetCertificatesStatus *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__GetCertificatesStatus(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__GetCertificatesStatus **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetCertificatesStatus, sizeof(struct _tds__GetCertificatesStatus), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetCertificatesStatus(struct soap *soap, struct _tds__GetCertificatesStatus *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetCertificatesStatus);
	if (soap_out_PointerTo_tds__GetCertificatesStatus(soap, tag?tag:"tds:GetCertificatesStatus", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetCertificatesStatus ** SOAP_FMAC4 soap_get_PointerTo_tds__GetCertificatesStatus(struct soap *soap, struct _tds__GetCertificatesStatus **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetCertificatesStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetCertificatesResponse(struct soap *soap, struct _tds__GetCertificatesResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetCertificatesResponse))
		soap_serialize__tds__GetCertificatesResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetCertificatesResponse(struct soap *soap, const char *tag, int id, struct _tds__GetCertificatesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetCertificatesResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tds__GetCertificatesResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__GetCertificatesResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__GetCertificatesResponse(struct soap *soap, const char *tag, struct _tds__GetCertificatesResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__GetCertificatesResponse **)soap_malloc(soap, sizeof(struct _tds__GetCertificatesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__GetCertificatesResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__GetCertificatesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetCertificatesResponse, sizeof(struct _tds__GetCertificatesResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetCertificatesResponse(struct soap *soap, struct _tds__GetCertificatesResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetCertificatesResponse);
	if (soap_out_PointerTo_tds__GetCertificatesResponse(soap, tag?tag:"tds:GetCertificatesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetCertificatesResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__GetCertificatesResponse(struct soap *soap, struct _tds__GetCertificatesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetCertificatesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetCertificates(struct soap *soap, struct _tds__GetCertificates *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetCertificates))
		soap_serialize__tds__GetCertificates(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetCertificates(struct soap *soap, const char *tag, int id, struct _tds__GetCertificates *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetCertificates);
	if (id < 0)
		return soap->error;
	return soap_out__tds__GetCertificates(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__GetCertificates ** SOAP_FMAC4 soap_in_PointerTo_tds__GetCertificates(struct soap *soap, const char *tag, struct _tds__GetCertificates **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__GetCertificates **)soap_malloc(soap, sizeof(struct _tds__GetCertificates *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__GetCertificates(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__GetCertificates **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetCertificates, sizeof(struct _tds__GetCertificates), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetCertificates(struct soap *soap, struct _tds__GetCertificates *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetCertificates);
	if (soap_out_PointerTo_tds__GetCertificates(soap, tag?tag:"tds:GetCertificates", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetCertificates ** SOAP_FMAC4 soap_get_PointerTo_tds__GetCertificates(struct soap *soap, struct _tds__GetCertificates **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetCertificates(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__CreateCertificateResponse(struct soap *soap, struct _tds__CreateCertificateResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__CreateCertificateResponse))
		soap_serialize__tds__CreateCertificateResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__CreateCertificateResponse(struct soap *soap, const char *tag, int id, struct _tds__CreateCertificateResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__CreateCertificateResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tds__CreateCertificateResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__CreateCertificateResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__CreateCertificateResponse(struct soap *soap, const char *tag, struct _tds__CreateCertificateResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__CreateCertificateResponse **)soap_malloc(soap, sizeof(struct _tds__CreateCertificateResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__CreateCertificateResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__CreateCertificateResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__CreateCertificateResponse, sizeof(struct _tds__CreateCertificateResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__CreateCertificateResponse(struct soap *soap, struct _tds__CreateCertificateResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__CreateCertificateResponse);
	if (soap_out_PointerTo_tds__CreateCertificateResponse(soap, tag?tag:"tds:CreateCertificateResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__CreateCertificateResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__CreateCertificateResponse(struct soap *soap, struct _tds__CreateCertificateResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__CreateCertificateResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__CreateCertificate(struct soap *soap, struct _tds__CreateCertificate *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__CreateCertificate))
		soap_serialize__tds__CreateCertificate(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__CreateCertificate(struct soap *soap, const char *tag, int id, struct _tds__CreateCertificate *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__CreateCertificate);
	if (id < 0)
		return soap->error;
	return soap_out__tds__CreateCertificate(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__CreateCertificate ** SOAP_FMAC4 soap_in_PointerTo_tds__CreateCertificate(struct soap *soap, const char *tag, struct _tds__CreateCertificate **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__CreateCertificate **)soap_malloc(soap, sizeof(struct _tds__CreateCertificate *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__CreateCertificate(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__CreateCertificate **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__CreateCertificate, sizeof(struct _tds__CreateCertificate), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__CreateCertificate(struct soap *soap, struct _tds__CreateCertificate *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__CreateCertificate);
	if (soap_out_PointerTo_tds__CreateCertificate(soap, tag?tag:"tds:CreateCertificate", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__CreateCertificate ** SOAP_FMAC4 soap_get_PointerTo_tds__CreateCertificate(struct soap *soap, struct _tds__CreateCertificate **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__CreateCertificate(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetAccessPolicyResponse(struct soap *soap, struct _tds__SetAccessPolicyResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetAccessPolicyResponse))
		soap_serialize__tds__SetAccessPolicyResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetAccessPolicyResponse(struct soap *soap, const char *tag, int id, struct _tds__SetAccessPolicyResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetAccessPolicyResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tds__SetAccessPolicyResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__SetAccessPolicyResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__SetAccessPolicyResponse(struct soap *soap, const char *tag, struct _tds__SetAccessPolicyResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__SetAccessPolicyResponse **)soap_malloc(soap, sizeof(struct _tds__SetAccessPolicyResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__SetAccessPolicyResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__SetAccessPolicyResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetAccessPolicyResponse, sizeof(struct _tds__SetAccessPolicyResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetAccessPolicyResponse(struct soap *soap, struct _tds__SetAccessPolicyResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__SetAccessPolicyResponse);
	if (soap_out_PointerTo_tds__SetAccessPolicyResponse(soap, tag?tag:"tds:SetAccessPolicyResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetAccessPolicyResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__SetAccessPolicyResponse(struct soap *soap, struct _tds__SetAccessPolicyResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetAccessPolicyResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetAccessPolicy(struct soap *soap, struct _tds__SetAccessPolicy *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetAccessPolicy))
		soap_serialize__tds__SetAccessPolicy(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetAccessPolicy(struct soap *soap, const char *tag, int id, struct _tds__SetAccessPolicy *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetAccessPolicy);
	if (id < 0)
		return soap->error;
	return soap_out__tds__SetAccessPolicy(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__SetAccessPolicy ** SOAP_FMAC4 soap_in_PointerTo_tds__SetAccessPolicy(struct soap *soap, const char *tag, struct _tds__SetAccessPolicy **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__SetAccessPolicy **)soap_malloc(soap, sizeof(struct _tds__SetAccessPolicy *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__SetAccessPolicy(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__SetAccessPolicy **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetAccessPolicy, sizeof(struct _tds__SetAccessPolicy), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetAccessPolicy(struct soap *soap, struct _tds__SetAccessPolicy *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__SetAccessPolicy);
	if (soap_out_PointerTo_tds__SetAccessPolicy(soap, tag?tag:"tds:SetAccessPolicy", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetAccessPolicy ** SOAP_FMAC4 soap_get_PointerTo_tds__SetAccessPolicy(struct soap *soap, struct _tds__SetAccessPolicy **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetAccessPolicy(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetAccessPolicyResponse(struct soap *soap, struct _tds__GetAccessPolicyResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetAccessPolicyResponse))
		soap_serialize__tds__GetAccessPolicyResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetAccessPolicyResponse(struct soap *soap, const char *tag, int id, struct _tds__GetAccessPolicyResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetAccessPolicyResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tds__GetAccessPolicyResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__GetAccessPolicyResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__GetAccessPolicyResponse(struct soap *soap, const char *tag, struct _tds__GetAccessPolicyResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__GetAccessPolicyResponse **)soap_malloc(soap, sizeof(struct _tds__GetAccessPolicyResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__GetAccessPolicyResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__GetAccessPolicyResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetAccessPolicyResponse, sizeof(struct _tds__GetAccessPolicyResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetAccessPolicyResponse(struct soap *soap, struct _tds__GetAccessPolicyResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetAccessPolicyResponse);
	if (soap_out_PointerTo_tds__GetAccessPolicyResponse(soap, tag?tag:"tds:GetAccessPolicyResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetAccessPolicyResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__GetAccessPolicyResponse(struct soap *soap, struct _tds__GetAccessPolicyResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetAccessPolicyResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetAccessPolicy(struct soap *soap, struct _tds__GetAccessPolicy *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetAccessPolicy))
		soap_serialize__tds__GetAccessPolicy(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetAccessPolicy(struct soap *soap, const char *tag, int id, struct _tds__GetAccessPolicy *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetAccessPolicy);
	if (id < 0)
		return soap->error;
	return soap_out__tds__GetAccessPolicy(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__GetAccessPolicy ** SOAP_FMAC4 soap_in_PointerTo_tds__GetAccessPolicy(struct soap *soap, const char *tag, struct _tds__GetAccessPolicy **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__GetAccessPolicy **)soap_malloc(soap, sizeof(struct _tds__GetAccessPolicy *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__GetAccessPolicy(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__GetAccessPolicy **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetAccessPolicy, sizeof(struct _tds__GetAccessPolicy), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetAccessPolicy(struct soap *soap, struct _tds__GetAccessPolicy *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetAccessPolicy);
	if (soap_out_PointerTo_tds__GetAccessPolicy(soap, tag?tag:"tds:GetAccessPolicy", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetAccessPolicy ** SOAP_FMAC4 soap_get_PointerTo_tds__GetAccessPolicy(struct soap *soap, struct _tds__GetAccessPolicy **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetAccessPolicy(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__RemoveIPAddressFilterResponse(struct soap *soap, struct _tds__RemoveIPAddressFilterResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__RemoveIPAddressFilterResponse))
		soap_serialize__tds__RemoveIPAddressFilterResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__RemoveIPAddressFilterResponse(struct soap *soap, const char *tag, int id, struct _tds__RemoveIPAddressFilterResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__RemoveIPAddressFilterResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tds__RemoveIPAddressFilterResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__RemoveIPAddressFilterResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__RemoveIPAddressFilterResponse(struct soap *soap, const char *tag, struct _tds__RemoveIPAddressFilterResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__RemoveIPAddressFilterResponse **)soap_malloc(soap, sizeof(struct _tds__RemoveIPAddressFilterResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__RemoveIPAddressFilterResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__RemoveIPAddressFilterResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__RemoveIPAddressFilterResponse, sizeof(struct _tds__RemoveIPAddressFilterResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__RemoveIPAddressFilterResponse(struct soap *soap, struct _tds__RemoveIPAddressFilterResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__RemoveIPAddressFilterResponse);
	if (soap_out_PointerTo_tds__RemoveIPAddressFilterResponse(soap, tag?tag:"tds:RemoveIPAddressFilterResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__RemoveIPAddressFilterResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__RemoveIPAddressFilterResponse(struct soap *soap, struct _tds__RemoveIPAddressFilterResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__RemoveIPAddressFilterResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__RemoveIPAddressFilter(struct soap *soap, struct _tds__RemoveIPAddressFilter *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__RemoveIPAddressFilter))
		soap_serialize__tds__RemoveIPAddressFilter(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__RemoveIPAddressFilter(struct soap *soap, const char *tag, int id, struct _tds__RemoveIPAddressFilter *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__RemoveIPAddressFilter);
	if (id < 0)
		return soap->error;
	return soap_out__tds__RemoveIPAddressFilter(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__RemoveIPAddressFilter ** SOAP_FMAC4 soap_in_PointerTo_tds__RemoveIPAddressFilter(struct soap *soap, const char *tag, struct _tds__RemoveIPAddressFilter **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__RemoveIPAddressFilter **)soap_malloc(soap, sizeof(struct _tds__RemoveIPAddressFilter *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__RemoveIPAddressFilter(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__RemoveIPAddressFilter **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__RemoveIPAddressFilter, sizeof(struct _tds__RemoveIPAddressFilter), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__RemoveIPAddressFilter(struct soap *soap, struct _tds__RemoveIPAddressFilter *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__RemoveIPAddressFilter);
	if (soap_out_PointerTo_tds__RemoveIPAddressFilter(soap, tag?tag:"tds:RemoveIPAddressFilter", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__RemoveIPAddressFilter ** SOAP_FMAC4 soap_get_PointerTo_tds__RemoveIPAddressFilter(struct soap *soap, struct _tds__RemoveIPAddressFilter **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__RemoveIPAddressFilter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__AddIPAddressFilterResponse(struct soap *soap, struct _tds__AddIPAddressFilterResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__AddIPAddressFilterResponse))
		soap_serialize__tds__AddIPAddressFilterResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__AddIPAddressFilterResponse(struct soap *soap, const char *tag, int id, struct _tds__AddIPAddressFilterResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__AddIPAddressFilterResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tds__AddIPAddressFilterResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__AddIPAddressFilterResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__AddIPAddressFilterResponse(struct soap *soap, const char *tag, struct _tds__AddIPAddressFilterResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__AddIPAddressFilterResponse **)soap_malloc(soap, sizeof(struct _tds__AddIPAddressFilterResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__AddIPAddressFilterResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__AddIPAddressFilterResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__AddIPAddressFilterResponse, sizeof(struct _tds__AddIPAddressFilterResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__AddIPAddressFilterResponse(struct soap *soap, struct _tds__AddIPAddressFilterResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__AddIPAddressFilterResponse);
	if (soap_out_PointerTo_tds__AddIPAddressFilterResponse(soap, tag?tag:"tds:AddIPAddressFilterResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__AddIPAddressFilterResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__AddIPAddressFilterResponse(struct soap *soap, struct _tds__AddIPAddressFilterResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__AddIPAddressFilterResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__AddIPAddressFilter(struct soap *soap, struct _tds__AddIPAddressFilter *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__AddIPAddressFilter))
		soap_serialize__tds__AddIPAddressFilter(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__AddIPAddressFilter(struct soap *soap, const char *tag, int id, struct _tds__AddIPAddressFilter *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__AddIPAddressFilter);
	if (id < 0)
		return soap->error;
	return soap_out__tds__AddIPAddressFilter(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__AddIPAddressFilter ** SOAP_FMAC4 soap_in_PointerTo_tds__AddIPAddressFilter(struct soap *soap, const char *tag, struct _tds__AddIPAddressFilter **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__AddIPAddressFilter **)soap_malloc(soap, sizeof(struct _tds__AddIPAddressFilter *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__AddIPAddressFilter(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__AddIPAddressFilter **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__AddIPAddressFilter, sizeof(struct _tds__AddIPAddressFilter), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__AddIPAddressFilter(struct soap *soap, struct _tds__AddIPAddressFilter *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__AddIPAddressFilter);
	if (soap_out_PointerTo_tds__AddIPAddressFilter(soap, tag?tag:"tds:AddIPAddressFilter", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__AddIPAddressFilter ** SOAP_FMAC4 soap_get_PointerTo_tds__AddIPAddressFilter(struct soap *soap, struct _tds__AddIPAddressFilter **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__AddIPAddressFilter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetIPAddressFilterResponse(struct soap *soap, struct _tds__SetIPAddressFilterResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetIPAddressFilterResponse))
		soap_serialize__tds__SetIPAddressFilterResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetIPAddressFilterResponse(struct soap *soap, const char *tag, int id, struct _tds__SetIPAddressFilterResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetIPAddressFilterResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tds__SetIPAddressFilterResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__SetIPAddressFilterResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__SetIPAddressFilterResponse(struct soap *soap, const char *tag, struct _tds__SetIPAddressFilterResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__SetIPAddressFilterResponse **)soap_malloc(soap, sizeof(struct _tds__SetIPAddressFilterResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__SetIPAddressFilterResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__SetIPAddressFilterResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetIPAddressFilterResponse, sizeof(struct _tds__SetIPAddressFilterResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetIPAddressFilterResponse(struct soap *soap, struct _tds__SetIPAddressFilterResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__SetIPAddressFilterResponse);
	if (soap_out_PointerTo_tds__SetIPAddressFilterResponse(soap, tag?tag:"tds:SetIPAddressFilterResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetIPAddressFilterResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__SetIPAddressFilterResponse(struct soap *soap, struct _tds__SetIPAddressFilterResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetIPAddressFilterResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetIPAddressFilter(struct soap *soap, struct _tds__SetIPAddressFilter *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetIPAddressFilter))
		soap_serialize__tds__SetIPAddressFilter(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetIPAddressFilter(struct soap *soap, const char *tag, int id, struct _tds__SetIPAddressFilter *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetIPAddressFilter);
	if (id < 0)
		return soap->error;
	return soap_out__tds__SetIPAddressFilter(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__SetIPAddressFilter ** SOAP_FMAC4 soap_in_PointerTo_tds__SetIPAddressFilter(struct soap *soap, const char *tag, struct _tds__SetIPAddressFilter **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__SetIPAddressFilter **)soap_malloc(soap, sizeof(struct _tds__SetIPAddressFilter *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__SetIPAddressFilter(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__SetIPAddressFilter **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetIPAddressFilter, sizeof(struct _tds__SetIPAddressFilter), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetIPAddressFilter(struct soap *soap, struct _tds__SetIPAddressFilter *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__SetIPAddressFilter);
	if (soap_out_PointerTo_tds__SetIPAddressFilter(soap, tag?tag:"tds:SetIPAddressFilter", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetIPAddressFilter ** SOAP_FMAC4 soap_get_PointerTo_tds__SetIPAddressFilter(struct soap *soap, struct _tds__SetIPAddressFilter **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetIPAddressFilter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetIPAddressFilterResponse(struct soap *soap, struct _tds__GetIPAddressFilterResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetIPAddressFilterResponse))
		soap_serialize__tds__GetIPAddressFilterResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetIPAddressFilterResponse(struct soap *soap, const char *tag, int id, struct _tds__GetIPAddressFilterResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetIPAddressFilterResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tds__GetIPAddressFilterResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__GetIPAddressFilterResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__GetIPAddressFilterResponse(struct soap *soap, const char *tag, struct _tds__GetIPAddressFilterResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__GetIPAddressFilterResponse **)soap_malloc(soap, sizeof(struct _tds__GetIPAddressFilterResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__GetIPAddressFilterResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__GetIPAddressFilterResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetIPAddressFilterResponse, sizeof(struct _tds__GetIPAddressFilterResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetIPAddressFilterResponse(struct soap *soap, struct _tds__GetIPAddressFilterResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetIPAddressFilterResponse);
	if (soap_out_PointerTo_tds__GetIPAddressFilterResponse(soap, tag?tag:"tds:GetIPAddressFilterResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetIPAddressFilterResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__GetIPAddressFilterResponse(struct soap *soap, struct _tds__GetIPAddressFilterResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetIPAddressFilterResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetIPAddressFilter(struct soap *soap, struct _tds__GetIPAddressFilter *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetIPAddressFilter))
		soap_serialize__tds__GetIPAddressFilter(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetIPAddressFilter(struct soap *soap, const char *tag, int id, struct _tds__GetIPAddressFilter *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetIPAddressFilter);
	if (id < 0)
		return soap->error;
	return soap_out__tds__GetIPAddressFilter(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__GetIPAddressFilter ** SOAP_FMAC4 soap_in_PointerTo_tds__GetIPAddressFilter(struct soap *soap, const char *tag, struct _tds__GetIPAddressFilter **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__GetIPAddressFilter **)soap_malloc(soap, sizeof(struct _tds__GetIPAddressFilter *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__GetIPAddressFilter(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__GetIPAddressFilter **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetIPAddressFilter, sizeof(struct _tds__GetIPAddressFilter), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetIPAddressFilter(struct soap *soap, struct _tds__GetIPAddressFilter *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetIPAddressFilter);
	if (soap_out_PointerTo_tds__GetIPAddressFilter(soap, tag?tag:"tds:GetIPAddressFilter", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetIPAddressFilter ** SOAP_FMAC4 soap_get_PointerTo_tds__GetIPAddressFilter(struct soap *soap, struct _tds__GetIPAddressFilter **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetIPAddressFilter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetZeroConfigurationResponse(struct soap *soap, struct _tds__SetZeroConfigurationResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetZeroConfigurationResponse))
		soap_serialize__tds__SetZeroConfigurationResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetZeroConfigurationResponse(struct soap *soap, const char *tag, int id, struct _tds__SetZeroConfigurationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetZeroConfigurationResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tds__SetZeroConfigurationResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__SetZeroConfigurationResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__SetZeroConfigurationResponse(struct soap *soap, const char *tag, struct _tds__SetZeroConfigurationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__SetZeroConfigurationResponse **)soap_malloc(soap, sizeof(struct _tds__SetZeroConfigurationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__SetZeroConfigurationResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__SetZeroConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetZeroConfigurationResponse, sizeof(struct _tds__SetZeroConfigurationResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetZeroConfigurationResponse(struct soap *soap, struct _tds__SetZeroConfigurationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__SetZeroConfigurationResponse);
	if (soap_out_PointerTo_tds__SetZeroConfigurationResponse(soap, tag?tag:"tds:SetZeroConfigurationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetZeroConfigurationResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__SetZeroConfigurationResponse(struct soap *soap, struct _tds__SetZeroConfigurationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetZeroConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetZeroConfiguration(struct soap *soap, struct _tds__SetZeroConfiguration *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetZeroConfiguration))
		soap_serialize__tds__SetZeroConfiguration(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetZeroConfiguration(struct soap *soap, const char *tag, int id, struct _tds__SetZeroConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetZeroConfiguration);
	if (id < 0)
		return soap->error;
	return soap_out__tds__SetZeroConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__SetZeroConfiguration ** SOAP_FMAC4 soap_in_PointerTo_tds__SetZeroConfiguration(struct soap *soap, const char *tag, struct _tds__SetZeroConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__SetZeroConfiguration **)soap_malloc(soap, sizeof(struct _tds__SetZeroConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__SetZeroConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__SetZeroConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetZeroConfiguration, sizeof(struct _tds__SetZeroConfiguration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetZeroConfiguration(struct soap *soap, struct _tds__SetZeroConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__SetZeroConfiguration);
	if (soap_out_PointerTo_tds__SetZeroConfiguration(soap, tag?tag:"tds:SetZeroConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetZeroConfiguration ** SOAP_FMAC4 soap_get_PointerTo_tds__SetZeroConfiguration(struct soap *soap, struct _tds__SetZeroConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetZeroConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetZeroConfigurationResponse(struct soap *soap, struct _tds__GetZeroConfigurationResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetZeroConfigurationResponse))
		soap_serialize__tds__GetZeroConfigurationResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetZeroConfigurationResponse(struct soap *soap, const char *tag, int id, struct _tds__GetZeroConfigurationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetZeroConfigurationResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tds__GetZeroConfigurationResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__GetZeroConfigurationResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__GetZeroConfigurationResponse(struct soap *soap, const char *tag, struct _tds__GetZeroConfigurationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__GetZeroConfigurationResponse **)soap_malloc(soap, sizeof(struct _tds__GetZeroConfigurationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__GetZeroConfigurationResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__GetZeroConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetZeroConfigurationResponse, sizeof(struct _tds__GetZeroConfigurationResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetZeroConfigurationResponse(struct soap *soap, struct _tds__GetZeroConfigurationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetZeroConfigurationResponse);
	if (soap_out_PointerTo_tds__GetZeroConfigurationResponse(soap, tag?tag:"tds:GetZeroConfigurationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetZeroConfigurationResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__GetZeroConfigurationResponse(struct soap *soap, struct _tds__GetZeroConfigurationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetZeroConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetZeroConfiguration(struct soap *soap, struct _tds__GetZeroConfiguration *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetZeroConfiguration))
		soap_serialize__tds__GetZeroConfiguration(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetZeroConfiguration(struct soap *soap, const char *tag, int id, struct _tds__GetZeroConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetZeroConfiguration);
	if (id < 0)
		return soap->error;
	return soap_out__tds__GetZeroConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__GetZeroConfiguration ** SOAP_FMAC4 soap_in_PointerTo_tds__GetZeroConfiguration(struct soap *soap, const char *tag, struct _tds__GetZeroConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__GetZeroConfiguration **)soap_malloc(soap, sizeof(struct _tds__GetZeroConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__GetZeroConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__GetZeroConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetZeroConfiguration, sizeof(struct _tds__GetZeroConfiguration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetZeroConfiguration(struct soap *soap, struct _tds__GetZeroConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetZeroConfiguration);
	if (soap_out_PointerTo_tds__GetZeroConfiguration(soap, tag?tag:"tds:GetZeroConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetZeroConfiguration ** SOAP_FMAC4 soap_get_PointerTo_tds__GetZeroConfiguration(struct soap *soap, struct _tds__GetZeroConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetZeroConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetNetworkDefaultGatewayResponse(struct soap *soap, struct _tds__SetNetworkDefaultGatewayResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetNetworkDefaultGatewayResponse))
		soap_serialize__tds__SetNetworkDefaultGatewayResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetNetworkDefaultGatewayResponse(struct soap *soap, const char *tag, int id, struct _tds__SetNetworkDefaultGatewayResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetNetworkDefaultGatewayResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tds__SetNetworkDefaultGatewayResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__SetNetworkDefaultGatewayResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__SetNetworkDefaultGatewayResponse(struct soap *soap, const char *tag, struct _tds__SetNetworkDefaultGatewayResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__SetNetworkDefaultGatewayResponse **)soap_malloc(soap, sizeof(struct _tds__SetNetworkDefaultGatewayResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__SetNetworkDefaultGatewayResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__SetNetworkDefaultGatewayResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetNetworkDefaultGatewayResponse, sizeof(struct _tds__SetNetworkDefaultGatewayResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetNetworkDefaultGatewayResponse(struct soap *soap, struct _tds__SetNetworkDefaultGatewayResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__SetNetworkDefaultGatewayResponse);
	if (soap_out_PointerTo_tds__SetNetworkDefaultGatewayResponse(soap, tag?tag:"tds:SetNetworkDefaultGatewayResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetNetworkDefaultGatewayResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__SetNetworkDefaultGatewayResponse(struct soap *soap, struct _tds__SetNetworkDefaultGatewayResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetNetworkDefaultGatewayResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetNetworkDefaultGateway(struct soap *soap, struct _tds__SetNetworkDefaultGateway *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetNetworkDefaultGateway))
		soap_serialize__tds__SetNetworkDefaultGateway(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetNetworkDefaultGateway(struct soap *soap, const char *tag, int id, struct _tds__SetNetworkDefaultGateway *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetNetworkDefaultGateway);
	if (id < 0)
		return soap->error;
	return soap_out__tds__SetNetworkDefaultGateway(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__SetNetworkDefaultGateway ** SOAP_FMAC4 soap_in_PointerTo_tds__SetNetworkDefaultGateway(struct soap *soap, const char *tag, struct _tds__SetNetworkDefaultGateway **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__SetNetworkDefaultGateway **)soap_malloc(soap, sizeof(struct _tds__SetNetworkDefaultGateway *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__SetNetworkDefaultGateway(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__SetNetworkDefaultGateway **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetNetworkDefaultGateway, sizeof(struct _tds__SetNetworkDefaultGateway), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetNetworkDefaultGateway(struct soap *soap, struct _tds__SetNetworkDefaultGateway *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__SetNetworkDefaultGateway);
	if (soap_out_PointerTo_tds__SetNetworkDefaultGateway(soap, tag?tag:"tds:SetNetworkDefaultGateway", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetNetworkDefaultGateway ** SOAP_FMAC4 soap_get_PointerTo_tds__SetNetworkDefaultGateway(struct soap *soap, struct _tds__SetNetworkDefaultGateway **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetNetworkDefaultGateway(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetNetworkDefaultGatewayResponse(struct soap *soap, struct _tds__GetNetworkDefaultGatewayResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetNetworkDefaultGatewayResponse))
		soap_serialize__tds__GetNetworkDefaultGatewayResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetNetworkDefaultGatewayResponse(struct soap *soap, const char *tag, int id, struct _tds__GetNetworkDefaultGatewayResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetNetworkDefaultGatewayResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tds__GetNetworkDefaultGatewayResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__GetNetworkDefaultGatewayResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__GetNetworkDefaultGatewayResponse(struct soap *soap, const char *tag, struct _tds__GetNetworkDefaultGatewayResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__GetNetworkDefaultGatewayResponse **)soap_malloc(soap, sizeof(struct _tds__GetNetworkDefaultGatewayResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__GetNetworkDefaultGatewayResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__GetNetworkDefaultGatewayResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetNetworkDefaultGatewayResponse, sizeof(struct _tds__GetNetworkDefaultGatewayResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetNetworkDefaultGatewayResponse(struct soap *soap, struct _tds__GetNetworkDefaultGatewayResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetNetworkDefaultGatewayResponse);
	if (soap_out_PointerTo_tds__GetNetworkDefaultGatewayResponse(soap, tag?tag:"tds:GetNetworkDefaultGatewayResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetNetworkDefaultGatewayResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__GetNetworkDefaultGatewayResponse(struct soap *soap, struct _tds__GetNetworkDefaultGatewayResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetNetworkDefaultGatewayResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetNetworkDefaultGateway(struct soap *soap, struct _tds__GetNetworkDefaultGateway *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetNetworkDefaultGateway))
		soap_serialize__tds__GetNetworkDefaultGateway(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetNetworkDefaultGateway(struct soap *soap, const char *tag, int id, struct _tds__GetNetworkDefaultGateway *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetNetworkDefaultGateway);
	if (id < 0)
		return soap->error;
	return soap_out__tds__GetNetworkDefaultGateway(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__GetNetworkDefaultGateway ** SOAP_FMAC4 soap_in_PointerTo_tds__GetNetworkDefaultGateway(struct soap *soap, const char *tag, struct _tds__GetNetworkDefaultGateway **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__GetNetworkDefaultGateway **)soap_malloc(soap, sizeof(struct _tds__GetNetworkDefaultGateway *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__GetNetworkDefaultGateway(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__GetNetworkDefaultGateway **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetNetworkDefaultGateway, sizeof(struct _tds__GetNetworkDefaultGateway), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetNetworkDefaultGateway(struct soap *soap, struct _tds__GetNetworkDefaultGateway *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetNetworkDefaultGateway);
	if (soap_out_PointerTo_tds__GetNetworkDefaultGateway(soap, tag?tag:"tds:GetNetworkDefaultGateway", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetNetworkDefaultGateway ** SOAP_FMAC4 soap_get_PointerTo_tds__GetNetworkDefaultGateway(struct soap *soap, struct _tds__GetNetworkDefaultGateway **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetNetworkDefaultGateway(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetNetworkProtocolsResponse(struct soap *soap, struct _tds__SetNetworkProtocolsResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetNetworkProtocolsResponse))
		soap_serialize__tds__SetNetworkProtocolsResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetNetworkProtocolsResponse(struct soap *soap, const char *tag, int id, struct _tds__SetNetworkProtocolsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetNetworkProtocolsResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tds__SetNetworkProtocolsResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__SetNetworkProtocolsResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__SetNetworkProtocolsResponse(struct soap *soap, const char *tag, struct _tds__SetNetworkProtocolsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__SetNetworkProtocolsResponse **)soap_malloc(soap, sizeof(struct _tds__SetNetworkProtocolsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__SetNetworkProtocolsResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__SetNetworkProtocolsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetNetworkProtocolsResponse, sizeof(struct _tds__SetNetworkProtocolsResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetNetworkProtocolsResponse(struct soap *soap, struct _tds__SetNetworkProtocolsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__SetNetworkProtocolsResponse);
	if (soap_out_PointerTo_tds__SetNetworkProtocolsResponse(soap, tag?tag:"tds:SetNetworkProtocolsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetNetworkProtocolsResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__SetNetworkProtocolsResponse(struct soap *soap, struct _tds__SetNetworkProtocolsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetNetworkProtocolsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetNetworkProtocols(struct soap *soap, struct _tds__SetNetworkProtocols *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetNetworkProtocols))
		soap_serialize__tds__SetNetworkProtocols(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetNetworkProtocols(struct soap *soap, const char *tag, int id, struct _tds__SetNetworkProtocols *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetNetworkProtocols);
	if (id < 0)
		return soap->error;
	return soap_out__tds__SetNetworkProtocols(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__SetNetworkProtocols ** SOAP_FMAC4 soap_in_PointerTo_tds__SetNetworkProtocols(struct soap *soap, const char *tag, struct _tds__SetNetworkProtocols **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__SetNetworkProtocols **)soap_malloc(soap, sizeof(struct _tds__SetNetworkProtocols *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__SetNetworkProtocols(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__SetNetworkProtocols **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetNetworkProtocols, sizeof(struct _tds__SetNetworkProtocols), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetNetworkProtocols(struct soap *soap, struct _tds__SetNetworkProtocols *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__SetNetworkProtocols);
	if (soap_out_PointerTo_tds__SetNetworkProtocols(soap, tag?tag:"tds:SetNetworkProtocols", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetNetworkProtocols ** SOAP_FMAC4 soap_get_PointerTo_tds__SetNetworkProtocols(struct soap *soap, struct _tds__SetNetworkProtocols **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetNetworkProtocols(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetNetworkProtocolsResponse(struct soap *soap, struct _tds__GetNetworkProtocolsResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetNetworkProtocolsResponse))
		soap_serialize__tds__GetNetworkProtocolsResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetNetworkProtocolsResponse(struct soap *soap, const char *tag, int id, struct _tds__GetNetworkProtocolsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetNetworkProtocolsResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tds__GetNetworkProtocolsResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__GetNetworkProtocolsResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__GetNetworkProtocolsResponse(struct soap *soap, const char *tag, struct _tds__GetNetworkProtocolsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__GetNetworkProtocolsResponse **)soap_malloc(soap, sizeof(struct _tds__GetNetworkProtocolsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__GetNetworkProtocolsResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__GetNetworkProtocolsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetNetworkProtocolsResponse, sizeof(struct _tds__GetNetworkProtocolsResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetNetworkProtocolsResponse(struct soap *soap, struct _tds__GetNetworkProtocolsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetNetworkProtocolsResponse);
	if (soap_out_PointerTo_tds__GetNetworkProtocolsResponse(soap, tag?tag:"tds:GetNetworkProtocolsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetNetworkProtocolsResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__GetNetworkProtocolsResponse(struct soap *soap, struct _tds__GetNetworkProtocolsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetNetworkProtocolsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetNetworkProtocols(struct soap *soap, struct _tds__GetNetworkProtocols *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetNetworkProtocols))
		soap_serialize__tds__GetNetworkProtocols(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetNetworkProtocols(struct soap *soap, const char *tag, int id, struct _tds__GetNetworkProtocols *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetNetworkProtocols);
	if (id < 0)
		return soap->error;
	return soap_out__tds__GetNetworkProtocols(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__GetNetworkProtocols ** SOAP_FMAC4 soap_in_PointerTo_tds__GetNetworkProtocols(struct soap *soap, const char *tag, struct _tds__GetNetworkProtocols **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__GetNetworkProtocols **)soap_malloc(soap, sizeof(struct _tds__GetNetworkProtocols *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__GetNetworkProtocols(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__GetNetworkProtocols **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetNetworkProtocols, sizeof(struct _tds__GetNetworkProtocols), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetNetworkProtocols(struct soap *soap, struct _tds__GetNetworkProtocols *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetNetworkProtocols);
	if (soap_out_PointerTo_tds__GetNetworkProtocols(soap, tag?tag:"tds:GetNetworkProtocols", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetNetworkProtocols ** SOAP_FMAC4 soap_get_PointerTo_tds__GetNetworkProtocols(struct soap *soap, struct _tds__GetNetworkProtocols **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetNetworkProtocols(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetNetworkInterfacesResponse(struct soap *soap, struct _tds__SetNetworkInterfacesResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetNetworkInterfacesResponse))
		soap_serialize__tds__SetNetworkInterfacesResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetNetworkInterfacesResponse(struct soap *soap, const char *tag, int id, struct _tds__SetNetworkInterfacesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetNetworkInterfacesResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tds__SetNetworkInterfacesResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__SetNetworkInterfacesResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__SetNetworkInterfacesResponse(struct soap *soap, const char *tag, struct _tds__SetNetworkInterfacesResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__SetNetworkInterfacesResponse **)soap_malloc(soap, sizeof(struct _tds__SetNetworkInterfacesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__SetNetworkInterfacesResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__SetNetworkInterfacesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetNetworkInterfacesResponse, sizeof(struct _tds__SetNetworkInterfacesResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetNetworkInterfacesResponse(struct soap *soap, struct _tds__SetNetworkInterfacesResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__SetNetworkInterfacesResponse);
	if (soap_out_PointerTo_tds__SetNetworkInterfacesResponse(soap, tag?tag:"tds:SetNetworkInterfacesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetNetworkInterfacesResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__SetNetworkInterfacesResponse(struct soap *soap, struct _tds__SetNetworkInterfacesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetNetworkInterfacesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetNetworkInterfaces(struct soap *soap, struct _tds__SetNetworkInterfaces *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetNetworkInterfaces))
		soap_serialize__tds__SetNetworkInterfaces(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetNetworkInterfaces(struct soap *soap, const char *tag, int id, struct _tds__SetNetworkInterfaces *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetNetworkInterfaces);
	if (id < 0)
		return soap->error;
	return soap_out__tds__SetNetworkInterfaces(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__SetNetworkInterfaces ** SOAP_FMAC4 soap_in_PointerTo_tds__SetNetworkInterfaces(struct soap *soap, const char *tag, struct _tds__SetNetworkInterfaces **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__SetNetworkInterfaces **)soap_malloc(soap, sizeof(struct _tds__SetNetworkInterfaces *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__SetNetworkInterfaces(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__SetNetworkInterfaces **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetNetworkInterfaces, sizeof(struct _tds__SetNetworkInterfaces), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetNetworkInterfaces(struct soap *soap, struct _tds__SetNetworkInterfaces *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__SetNetworkInterfaces);
	if (soap_out_PointerTo_tds__SetNetworkInterfaces(soap, tag?tag:"tds:SetNetworkInterfaces", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetNetworkInterfaces ** SOAP_FMAC4 soap_get_PointerTo_tds__SetNetworkInterfaces(struct soap *soap, struct _tds__SetNetworkInterfaces **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetNetworkInterfaces(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetNetworkInterfacesResponse(struct soap *soap, struct _tds__GetNetworkInterfacesResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetNetworkInterfacesResponse))
		soap_serialize__tds__GetNetworkInterfacesResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetNetworkInterfacesResponse(struct soap *soap, const char *tag, int id, struct _tds__GetNetworkInterfacesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetNetworkInterfacesResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tds__GetNetworkInterfacesResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__GetNetworkInterfacesResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__GetNetworkInterfacesResponse(struct soap *soap, const char *tag, struct _tds__GetNetworkInterfacesResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__GetNetworkInterfacesResponse **)soap_malloc(soap, sizeof(struct _tds__GetNetworkInterfacesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__GetNetworkInterfacesResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__GetNetworkInterfacesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetNetworkInterfacesResponse, sizeof(struct _tds__GetNetworkInterfacesResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetNetworkInterfacesResponse(struct soap *soap, struct _tds__GetNetworkInterfacesResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetNetworkInterfacesResponse);
	if (soap_out_PointerTo_tds__GetNetworkInterfacesResponse(soap, tag?tag:"tds:GetNetworkInterfacesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetNetworkInterfacesResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__GetNetworkInterfacesResponse(struct soap *soap, struct _tds__GetNetworkInterfacesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetNetworkInterfacesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetNetworkInterfaces(struct soap *soap, struct _tds__GetNetworkInterfaces *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetNetworkInterfaces))
		soap_serialize__tds__GetNetworkInterfaces(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetNetworkInterfaces(struct soap *soap, const char *tag, int id, struct _tds__GetNetworkInterfaces *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetNetworkInterfaces);
	if (id < 0)
		return soap->error;
	return soap_out__tds__GetNetworkInterfaces(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__GetNetworkInterfaces ** SOAP_FMAC4 soap_in_PointerTo_tds__GetNetworkInterfaces(struct soap *soap, const char *tag, struct _tds__GetNetworkInterfaces **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__GetNetworkInterfaces **)soap_malloc(soap, sizeof(struct _tds__GetNetworkInterfaces *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__GetNetworkInterfaces(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__GetNetworkInterfaces **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetNetworkInterfaces, sizeof(struct _tds__GetNetworkInterfaces), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetNetworkInterfaces(struct soap *soap, struct _tds__GetNetworkInterfaces *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetNetworkInterfaces);
	if (soap_out_PointerTo_tds__GetNetworkInterfaces(soap, tag?tag:"tds:GetNetworkInterfaces", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetNetworkInterfaces ** SOAP_FMAC4 soap_get_PointerTo_tds__GetNetworkInterfaces(struct soap *soap, struct _tds__GetNetworkInterfaces **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetNetworkInterfaces(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetDynamicDNSResponse(struct soap *soap, struct _tds__SetDynamicDNSResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetDynamicDNSResponse))
		soap_serialize__tds__SetDynamicDNSResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetDynamicDNSResponse(struct soap *soap, const char *tag, int id, struct _tds__SetDynamicDNSResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetDynamicDNSResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tds__SetDynamicDNSResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__SetDynamicDNSResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__SetDynamicDNSResponse(struct soap *soap, const char *tag, struct _tds__SetDynamicDNSResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__SetDynamicDNSResponse **)soap_malloc(soap, sizeof(struct _tds__SetDynamicDNSResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__SetDynamicDNSResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__SetDynamicDNSResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetDynamicDNSResponse, sizeof(struct _tds__SetDynamicDNSResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetDynamicDNSResponse(struct soap *soap, struct _tds__SetDynamicDNSResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__SetDynamicDNSResponse);
	if (soap_out_PointerTo_tds__SetDynamicDNSResponse(soap, tag?tag:"tds:SetDynamicDNSResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetDynamicDNSResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__SetDynamicDNSResponse(struct soap *soap, struct _tds__SetDynamicDNSResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetDynamicDNSResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetDynamicDNS(struct soap *soap, struct _tds__SetDynamicDNS *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetDynamicDNS))
		soap_serialize__tds__SetDynamicDNS(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetDynamicDNS(struct soap *soap, const char *tag, int id, struct _tds__SetDynamicDNS *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetDynamicDNS);
	if (id < 0)
		return soap->error;
	return soap_out__tds__SetDynamicDNS(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__SetDynamicDNS ** SOAP_FMAC4 soap_in_PointerTo_tds__SetDynamicDNS(struct soap *soap, const char *tag, struct _tds__SetDynamicDNS **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__SetDynamicDNS **)soap_malloc(soap, sizeof(struct _tds__SetDynamicDNS *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__SetDynamicDNS(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__SetDynamicDNS **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetDynamicDNS, sizeof(struct _tds__SetDynamicDNS), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetDynamicDNS(struct soap *soap, struct _tds__SetDynamicDNS *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__SetDynamicDNS);
	if (soap_out_PointerTo_tds__SetDynamicDNS(soap, tag?tag:"tds:SetDynamicDNS", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetDynamicDNS ** SOAP_FMAC4 soap_get_PointerTo_tds__SetDynamicDNS(struct soap *soap, struct _tds__SetDynamicDNS **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetDynamicDNS(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetDynamicDNSResponse(struct soap *soap, struct _tds__GetDynamicDNSResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetDynamicDNSResponse))
		soap_serialize__tds__GetDynamicDNSResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetDynamicDNSResponse(struct soap *soap, const char *tag, int id, struct _tds__GetDynamicDNSResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetDynamicDNSResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tds__GetDynamicDNSResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__GetDynamicDNSResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__GetDynamicDNSResponse(struct soap *soap, const char *tag, struct _tds__GetDynamicDNSResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__GetDynamicDNSResponse **)soap_malloc(soap, sizeof(struct _tds__GetDynamicDNSResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__GetDynamicDNSResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__GetDynamicDNSResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetDynamicDNSResponse, sizeof(struct _tds__GetDynamicDNSResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetDynamicDNSResponse(struct soap *soap, struct _tds__GetDynamicDNSResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetDynamicDNSResponse);
	if (soap_out_PointerTo_tds__GetDynamicDNSResponse(soap, tag?tag:"tds:GetDynamicDNSResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetDynamicDNSResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__GetDynamicDNSResponse(struct soap *soap, struct _tds__GetDynamicDNSResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetDynamicDNSResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetDynamicDNS(struct soap *soap, struct _tds__GetDynamicDNS *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetDynamicDNS))
		soap_serialize__tds__GetDynamicDNS(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetDynamicDNS(struct soap *soap, const char *tag, int id, struct _tds__GetDynamicDNS *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetDynamicDNS);
	if (id < 0)
		return soap->error;
	return soap_out__tds__GetDynamicDNS(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__GetDynamicDNS ** SOAP_FMAC4 soap_in_PointerTo_tds__GetDynamicDNS(struct soap *soap, const char *tag, struct _tds__GetDynamicDNS **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__GetDynamicDNS **)soap_malloc(soap, sizeof(struct _tds__GetDynamicDNS *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__GetDynamicDNS(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__GetDynamicDNS **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetDynamicDNS, sizeof(struct _tds__GetDynamicDNS), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetDynamicDNS(struct soap *soap, struct _tds__GetDynamicDNS *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetDynamicDNS);
	if (soap_out_PointerTo_tds__GetDynamicDNS(soap, tag?tag:"tds:GetDynamicDNS", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetDynamicDNS ** SOAP_FMAC4 soap_get_PointerTo_tds__GetDynamicDNS(struct soap *soap, struct _tds__GetDynamicDNS **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetDynamicDNS(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetNTPResponse(struct soap *soap, struct _tds__SetNTPResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetNTPResponse))
		soap_serialize__tds__SetNTPResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetNTPResponse(struct soap *soap, const char *tag, int id, struct _tds__SetNTPResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetNTPResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tds__SetNTPResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__SetNTPResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__SetNTPResponse(struct soap *soap, const char *tag, struct _tds__SetNTPResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__SetNTPResponse **)soap_malloc(soap, sizeof(struct _tds__SetNTPResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__SetNTPResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__SetNTPResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetNTPResponse, sizeof(struct _tds__SetNTPResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetNTPResponse(struct soap *soap, struct _tds__SetNTPResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__SetNTPResponse);
	if (soap_out_PointerTo_tds__SetNTPResponse(soap, tag?tag:"tds:SetNTPResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetNTPResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__SetNTPResponse(struct soap *soap, struct _tds__SetNTPResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetNTPResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetNTP(struct soap *soap, struct _tds__SetNTP *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetNTP))
		soap_serialize__tds__SetNTP(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetNTP(struct soap *soap, const char *tag, int id, struct _tds__SetNTP *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetNTP);
	if (id < 0)
		return soap->error;
	return soap_out__tds__SetNTP(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__SetNTP ** SOAP_FMAC4 soap_in_PointerTo_tds__SetNTP(struct soap *soap, const char *tag, struct _tds__SetNTP **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__SetNTP **)soap_malloc(soap, sizeof(struct _tds__SetNTP *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__SetNTP(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__SetNTP **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetNTP, sizeof(struct _tds__SetNTP), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetNTP(struct soap *soap, struct _tds__SetNTP *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__SetNTP);
	if (soap_out_PointerTo_tds__SetNTP(soap, tag?tag:"tds:SetNTP", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetNTP ** SOAP_FMAC4 soap_get_PointerTo_tds__SetNTP(struct soap *soap, struct _tds__SetNTP **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetNTP(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetNTPResponse(struct soap *soap, struct _tds__GetNTPResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetNTPResponse))
		soap_serialize__tds__GetNTPResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetNTPResponse(struct soap *soap, const char *tag, int id, struct _tds__GetNTPResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetNTPResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tds__GetNTPResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__GetNTPResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__GetNTPResponse(struct soap *soap, const char *tag, struct _tds__GetNTPResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__GetNTPResponse **)soap_malloc(soap, sizeof(struct _tds__GetNTPResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__GetNTPResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__GetNTPResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetNTPResponse, sizeof(struct _tds__GetNTPResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetNTPResponse(struct soap *soap, struct _tds__GetNTPResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetNTPResponse);
	if (soap_out_PointerTo_tds__GetNTPResponse(soap, tag?tag:"tds:GetNTPResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetNTPResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__GetNTPResponse(struct soap *soap, struct _tds__GetNTPResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetNTPResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetNTP(struct soap *soap, struct _tds__GetNTP *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetNTP))
		soap_serialize__tds__GetNTP(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetNTP(struct soap *soap, const char *tag, int id, struct _tds__GetNTP *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetNTP);
	if (id < 0)
		return soap->error;
	return soap_out__tds__GetNTP(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__GetNTP ** SOAP_FMAC4 soap_in_PointerTo_tds__GetNTP(struct soap *soap, const char *tag, struct _tds__GetNTP **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__GetNTP **)soap_malloc(soap, sizeof(struct _tds__GetNTP *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__GetNTP(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__GetNTP **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetNTP, sizeof(struct _tds__GetNTP), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetNTP(struct soap *soap, struct _tds__GetNTP *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetNTP);
	if (soap_out_PointerTo_tds__GetNTP(soap, tag?tag:"tds:GetNTP", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetNTP ** SOAP_FMAC4 soap_get_PointerTo_tds__GetNTP(struct soap *soap, struct _tds__GetNTP **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetNTP(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetDNSResponse(struct soap *soap, struct _tds__SetDNSResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetDNSResponse))
		soap_serialize__tds__SetDNSResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetDNSResponse(struct soap *soap, const char *tag, int id, struct _tds__SetDNSResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetDNSResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tds__SetDNSResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__SetDNSResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__SetDNSResponse(struct soap *soap, const char *tag, struct _tds__SetDNSResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__SetDNSResponse **)soap_malloc(soap, sizeof(struct _tds__SetDNSResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__SetDNSResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__SetDNSResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetDNSResponse, sizeof(struct _tds__SetDNSResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetDNSResponse(struct soap *soap, struct _tds__SetDNSResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__SetDNSResponse);
	if (soap_out_PointerTo_tds__SetDNSResponse(soap, tag?tag:"tds:SetDNSResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetDNSResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__SetDNSResponse(struct soap *soap, struct _tds__SetDNSResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetDNSResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetDNS(struct soap *soap, struct _tds__SetDNS *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetDNS))
		soap_serialize__tds__SetDNS(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetDNS(struct soap *soap, const char *tag, int id, struct _tds__SetDNS *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetDNS);
	if (id < 0)
		return soap->error;
	return soap_out__tds__SetDNS(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__SetDNS ** SOAP_FMAC4 soap_in_PointerTo_tds__SetDNS(struct soap *soap, const char *tag, struct _tds__SetDNS **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__SetDNS **)soap_malloc(soap, sizeof(struct _tds__SetDNS *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__SetDNS(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__SetDNS **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetDNS, sizeof(struct _tds__SetDNS), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetDNS(struct soap *soap, struct _tds__SetDNS *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__SetDNS);
	if (soap_out_PointerTo_tds__SetDNS(soap, tag?tag:"tds:SetDNS", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetDNS ** SOAP_FMAC4 soap_get_PointerTo_tds__SetDNS(struct soap *soap, struct _tds__SetDNS **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetDNS(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetDNSResponse(struct soap *soap, struct _tds__GetDNSResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetDNSResponse))
		soap_serialize__tds__GetDNSResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetDNSResponse(struct soap *soap, const char *tag, int id, struct _tds__GetDNSResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetDNSResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tds__GetDNSResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__GetDNSResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__GetDNSResponse(struct soap *soap, const char *tag, struct _tds__GetDNSResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__GetDNSResponse **)soap_malloc(soap, sizeof(struct _tds__GetDNSResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__GetDNSResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__GetDNSResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetDNSResponse, sizeof(struct _tds__GetDNSResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetDNSResponse(struct soap *soap, struct _tds__GetDNSResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetDNSResponse);
	if (soap_out_PointerTo_tds__GetDNSResponse(soap, tag?tag:"tds:GetDNSResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetDNSResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__GetDNSResponse(struct soap *soap, struct _tds__GetDNSResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetDNSResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetDNS(struct soap *soap, struct _tds__GetDNS *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetDNS))
		soap_serialize__tds__GetDNS(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetDNS(struct soap *soap, const char *tag, int id, struct _tds__GetDNS *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetDNS);
	if (id < 0)
		return soap->error;
	return soap_out__tds__GetDNS(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__GetDNS ** SOAP_FMAC4 soap_in_PointerTo_tds__GetDNS(struct soap *soap, const char *tag, struct _tds__GetDNS **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__GetDNS **)soap_malloc(soap, sizeof(struct _tds__GetDNS *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__GetDNS(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__GetDNS **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetDNS, sizeof(struct _tds__GetDNS), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetDNS(struct soap *soap, struct _tds__GetDNS *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetDNS);
	if (soap_out_PointerTo_tds__GetDNS(soap, tag?tag:"tds:GetDNS", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetDNS ** SOAP_FMAC4 soap_get_PointerTo_tds__GetDNS(struct soap *soap, struct _tds__GetDNS **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetDNS(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetHostnameFromDHCPResponse(struct soap *soap, struct _tds__SetHostnameFromDHCPResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetHostnameFromDHCPResponse))
		soap_serialize__tds__SetHostnameFromDHCPResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetHostnameFromDHCPResponse(struct soap *soap, const char *tag, int id, struct _tds__SetHostnameFromDHCPResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetHostnameFromDHCPResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tds__SetHostnameFromDHCPResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__SetHostnameFromDHCPResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__SetHostnameFromDHCPResponse(struct soap *soap, const char *tag, struct _tds__SetHostnameFromDHCPResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__SetHostnameFromDHCPResponse **)soap_malloc(soap, sizeof(struct _tds__SetHostnameFromDHCPResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__SetHostnameFromDHCPResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__SetHostnameFromDHCPResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetHostnameFromDHCPResponse, sizeof(struct _tds__SetHostnameFromDHCPResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetHostnameFromDHCPResponse(struct soap *soap, struct _tds__SetHostnameFromDHCPResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__SetHostnameFromDHCPResponse);
	if (soap_out_PointerTo_tds__SetHostnameFromDHCPResponse(soap, tag?tag:"tds:SetHostnameFromDHCPResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetHostnameFromDHCPResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__SetHostnameFromDHCPResponse(struct soap *soap, struct _tds__SetHostnameFromDHCPResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetHostnameFromDHCPResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetHostnameFromDHCP(struct soap *soap, struct _tds__SetHostnameFromDHCP *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetHostnameFromDHCP))
		soap_serialize__tds__SetHostnameFromDHCP(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetHostnameFromDHCP(struct soap *soap, const char *tag, int id, struct _tds__SetHostnameFromDHCP *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetHostnameFromDHCP);
	if (id < 0)
		return soap->error;
	return soap_out__tds__SetHostnameFromDHCP(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__SetHostnameFromDHCP ** SOAP_FMAC4 soap_in_PointerTo_tds__SetHostnameFromDHCP(struct soap *soap, const char *tag, struct _tds__SetHostnameFromDHCP **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__SetHostnameFromDHCP **)soap_malloc(soap, sizeof(struct _tds__SetHostnameFromDHCP *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__SetHostnameFromDHCP(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__SetHostnameFromDHCP **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetHostnameFromDHCP, sizeof(struct _tds__SetHostnameFromDHCP), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetHostnameFromDHCP(struct soap *soap, struct _tds__SetHostnameFromDHCP *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__SetHostnameFromDHCP);
	if (soap_out_PointerTo_tds__SetHostnameFromDHCP(soap, tag?tag:"tds:SetHostnameFromDHCP", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetHostnameFromDHCP ** SOAP_FMAC4 soap_get_PointerTo_tds__SetHostnameFromDHCP(struct soap *soap, struct _tds__SetHostnameFromDHCP **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetHostnameFromDHCP(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetHostnameResponse(struct soap *soap, struct _tds__SetHostnameResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetHostnameResponse))
		soap_serialize__tds__SetHostnameResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetHostnameResponse(struct soap *soap, const char *tag, int id, struct _tds__SetHostnameResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetHostnameResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tds__SetHostnameResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__SetHostnameResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__SetHostnameResponse(struct soap *soap, const char *tag, struct _tds__SetHostnameResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__SetHostnameResponse **)soap_malloc(soap, sizeof(struct _tds__SetHostnameResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__SetHostnameResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__SetHostnameResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetHostnameResponse, sizeof(struct _tds__SetHostnameResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetHostnameResponse(struct soap *soap, struct _tds__SetHostnameResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__SetHostnameResponse);
	if (soap_out_PointerTo_tds__SetHostnameResponse(soap, tag?tag:"tds:SetHostnameResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetHostnameResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__SetHostnameResponse(struct soap *soap, struct _tds__SetHostnameResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetHostnameResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetHostname(struct soap *soap, struct _tds__SetHostname *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetHostname))
		soap_serialize__tds__SetHostname(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetHostname(struct soap *soap, const char *tag, int id, struct _tds__SetHostname *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetHostname);
	if (id < 0)
		return soap->error;
	return soap_out__tds__SetHostname(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__SetHostname ** SOAP_FMAC4 soap_in_PointerTo_tds__SetHostname(struct soap *soap, const char *tag, struct _tds__SetHostname **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__SetHostname **)soap_malloc(soap, sizeof(struct _tds__SetHostname *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__SetHostname(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__SetHostname **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetHostname, sizeof(struct _tds__SetHostname), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetHostname(struct soap *soap, struct _tds__SetHostname *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__SetHostname);
	if (soap_out_PointerTo_tds__SetHostname(soap, tag?tag:"tds:SetHostname", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetHostname ** SOAP_FMAC4 soap_get_PointerTo_tds__SetHostname(struct soap *soap, struct _tds__SetHostname **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetHostname(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetHostnameResponse(struct soap *soap, struct _tds__GetHostnameResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetHostnameResponse))
		soap_serialize__tds__GetHostnameResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetHostnameResponse(struct soap *soap, const char *tag, int id, struct _tds__GetHostnameResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetHostnameResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tds__GetHostnameResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__GetHostnameResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__GetHostnameResponse(struct soap *soap, const char *tag, struct _tds__GetHostnameResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__GetHostnameResponse **)soap_malloc(soap, sizeof(struct _tds__GetHostnameResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__GetHostnameResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__GetHostnameResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetHostnameResponse, sizeof(struct _tds__GetHostnameResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetHostnameResponse(struct soap *soap, struct _tds__GetHostnameResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetHostnameResponse);
	if (soap_out_PointerTo_tds__GetHostnameResponse(soap, tag?tag:"tds:GetHostnameResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetHostnameResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__GetHostnameResponse(struct soap *soap, struct _tds__GetHostnameResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetHostnameResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetHostname(struct soap *soap, struct _tds__GetHostname *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetHostname))
		soap_serialize__tds__GetHostname(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetHostname(struct soap *soap, const char *tag, int id, struct _tds__GetHostname *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetHostname);
	if (id < 0)
		return soap->error;
	return soap_out__tds__GetHostname(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__GetHostname ** SOAP_FMAC4 soap_in_PointerTo_tds__GetHostname(struct soap *soap, const char *tag, struct _tds__GetHostname **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__GetHostname **)soap_malloc(soap, sizeof(struct _tds__GetHostname *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__GetHostname(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__GetHostname **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetHostname, sizeof(struct _tds__GetHostname), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetHostname(struct soap *soap, struct _tds__GetHostname *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetHostname);
	if (soap_out_PointerTo_tds__GetHostname(soap, tag?tag:"tds:GetHostname", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetHostname ** SOAP_FMAC4 soap_get_PointerTo_tds__GetHostname(struct soap *soap, struct _tds__GetHostname **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetHostname(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetDPAddressesResponse(struct soap *soap, struct _tds__SetDPAddressesResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetDPAddressesResponse))
		soap_serialize__tds__SetDPAddressesResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetDPAddressesResponse(struct soap *soap, const char *tag, int id, struct _tds__SetDPAddressesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetDPAddressesResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tds__SetDPAddressesResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__SetDPAddressesResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__SetDPAddressesResponse(struct soap *soap, const char *tag, struct _tds__SetDPAddressesResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__SetDPAddressesResponse **)soap_malloc(soap, sizeof(struct _tds__SetDPAddressesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__SetDPAddressesResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__SetDPAddressesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetDPAddressesResponse, sizeof(struct _tds__SetDPAddressesResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetDPAddressesResponse(struct soap *soap, struct _tds__SetDPAddressesResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__SetDPAddressesResponse);
	if (soap_out_PointerTo_tds__SetDPAddressesResponse(soap, tag?tag:"tds:SetDPAddressesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetDPAddressesResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__SetDPAddressesResponse(struct soap *soap, struct _tds__SetDPAddressesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetDPAddressesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetDPAddresses(struct soap *soap, struct _tds__SetDPAddresses *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetDPAddresses))
		soap_serialize__tds__SetDPAddresses(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetDPAddresses(struct soap *soap, const char *tag, int id, struct _tds__SetDPAddresses *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetDPAddresses);
	if (id < 0)
		return soap->error;
	return soap_out__tds__SetDPAddresses(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__SetDPAddresses ** SOAP_FMAC4 soap_in_PointerTo_tds__SetDPAddresses(struct soap *soap, const char *tag, struct _tds__SetDPAddresses **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__SetDPAddresses **)soap_malloc(soap, sizeof(struct _tds__SetDPAddresses *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__SetDPAddresses(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__SetDPAddresses **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetDPAddresses, sizeof(struct _tds__SetDPAddresses), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetDPAddresses(struct soap *soap, struct _tds__SetDPAddresses *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__SetDPAddresses);
	if (soap_out_PointerTo_tds__SetDPAddresses(soap, tag?tag:"tds:SetDPAddresses", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetDPAddresses ** SOAP_FMAC4 soap_get_PointerTo_tds__SetDPAddresses(struct soap *soap, struct _tds__SetDPAddresses **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetDPAddresses(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetCapabilitiesResponse(struct soap *soap, struct _tds__GetCapabilitiesResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetCapabilitiesResponse))
		soap_serialize__tds__GetCapabilitiesResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetCapabilitiesResponse(struct soap *soap, const char *tag, int id, struct _tds__GetCapabilitiesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetCapabilitiesResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tds__GetCapabilitiesResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__GetCapabilitiesResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__GetCapabilitiesResponse(struct soap *soap, const char *tag, struct _tds__GetCapabilitiesResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__GetCapabilitiesResponse **)soap_malloc(soap, sizeof(struct _tds__GetCapabilitiesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__GetCapabilitiesResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__GetCapabilitiesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetCapabilitiesResponse, sizeof(struct _tds__GetCapabilitiesResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetCapabilitiesResponse(struct soap *soap, struct _tds__GetCapabilitiesResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetCapabilitiesResponse);
	if (soap_out_PointerTo_tds__GetCapabilitiesResponse(soap, tag?tag:"tds:GetCapabilitiesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetCapabilitiesResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__GetCapabilitiesResponse(struct soap *soap, struct _tds__GetCapabilitiesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetCapabilitiesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetCapabilities(struct soap *soap, struct _tds__GetCapabilities *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetCapabilities))
		soap_serialize__tds__GetCapabilities(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetCapabilities(struct soap *soap, const char *tag, int id, struct _tds__GetCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetCapabilities);
	if (id < 0)
		return soap->error;
	return soap_out__tds__GetCapabilities(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__GetCapabilities ** SOAP_FMAC4 soap_in_PointerTo_tds__GetCapabilities(struct soap *soap, const char *tag, struct _tds__GetCapabilities **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__GetCapabilities **)soap_malloc(soap, sizeof(struct _tds__GetCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__GetCapabilities(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__GetCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetCapabilities, sizeof(struct _tds__GetCapabilities), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetCapabilities(struct soap *soap, struct _tds__GetCapabilities *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetCapabilities);
	if (soap_out_PointerTo_tds__GetCapabilities(soap, tag?tag:"tds:GetCapabilities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetCapabilities ** SOAP_FMAC4 soap_get_PointerTo_tds__GetCapabilities(struct soap *soap, struct _tds__GetCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetWsdlUrlResponse(struct soap *soap, struct _tds__GetWsdlUrlResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetWsdlUrlResponse))
		soap_serialize__tds__GetWsdlUrlResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetWsdlUrlResponse(struct soap *soap, const char *tag, int id, struct _tds__GetWsdlUrlResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetWsdlUrlResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tds__GetWsdlUrlResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__GetWsdlUrlResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__GetWsdlUrlResponse(struct soap *soap, const char *tag, struct _tds__GetWsdlUrlResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__GetWsdlUrlResponse **)soap_malloc(soap, sizeof(struct _tds__GetWsdlUrlResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__GetWsdlUrlResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__GetWsdlUrlResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetWsdlUrlResponse, sizeof(struct _tds__GetWsdlUrlResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetWsdlUrlResponse(struct soap *soap, struct _tds__GetWsdlUrlResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetWsdlUrlResponse);
	if (soap_out_PointerTo_tds__GetWsdlUrlResponse(soap, tag?tag:"tds:GetWsdlUrlResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetWsdlUrlResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__GetWsdlUrlResponse(struct soap *soap, struct _tds__GetWsdlUrlResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetWsdlUrlResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetWsdlUrl(struct soap *soap, struct _tds__GetWsdlUrl *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetWsdlUrl))
		soap_serialize__tds__GetWsdlUrl(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetWsdlUrl(struct soap *soap, const char *tag, int id, struct _tds__GetWsdlUrl *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetWsdlUrl);
	if (id < 0)
		return soap->error;
	return soap_out__tds__GetWsdlUrl(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__GetWsdlUrl ** SOAP_FMAC4 soap_in_PointerTo_tds__GetWsdlUrl(struct soap *soap, const char *tag, struct _tds__GetWsdlUrl **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__GetWsdlUrl **)soap_malloc(soap, sizeof(struct _tds__GetWsdlUrl *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__GetWsdlUrl(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__GetWsdlUrl **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetWsdlUrl, sizeof(struct _tds__GetWsdlUrl), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetWsdlUrl(struct soap *soap, struct _tds__GetWsdlUrl *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetWsdlUrl);
	if (soap_out_PointerTo_tds__GetWsdlUrl(soap, tag?tag:"tds:GetWsdlUrl", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetWsdlUrl ** SOAP_FMAC4 soap_get_PointerTo_tds__GetWsdlUrl(struct soap *soap, struct _tds__GetWsdlUrl **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetWsdlUrl(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetUserResponse(struct soap *soap, struct _tds__SetUserResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetUserResponse))
		soap_serialize__tds__SetUserResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetUserResponse(struct soap *soap, const char *tag, int id, struct _tds__SetUserResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetUserResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tds__SetUserResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__SetUserResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__SetUserResponse(struct soap *soap, const char *tag, struct _tds__SetUserResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__SetUserResponse **)soap_malloc(soap, sizeof(struct _tds__SetUserResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__SetUserResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__SetUserResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetUserResponse, sizeof(struct _tds__SetUserResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetUserResponse(struct soap *soap, struct _tds__SetUserResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__SetUserResponse);
	if (soap_out_PointerTo_tds__SetUserResponse(soap, tag?tag:"tds:SetUserResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetUserResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__SetUserResponse(struct soap *soap, struct _tds__SetUserResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetUserResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetUser(struct soap *soap, struct _tds__SetUser *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetUser))
		soap_serialize__tds__SetUser(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetUser(struct soap *soap, const char *tag, int id, struct _tds__SetUser *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetUser);
	if (id < 0)
		return soap->error;
	return soap_out__tds__SetUser(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__SetUser ** SOAP_FMAC4 soap_in_PointerTo_tds__SetUser(struct soap *soap, const char *tag, struct _tds__SetUser **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__SetUser **)soap_malloc(soap, sizeof(struct _tds__SetUser *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__SetUser(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__SetUser **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetUser, sizeof(struct _tds__SetUser), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetUser(struct soap *soap, struct _tds__SetUser *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__SetUser);
	if (soap_out_PointerTo_tds__SetUser(soap, tag?tag:"tds:SetUser", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetUser ** SOAP_FMAC4 soap_get_PointerTo_tds__SetUser(struct soap *soap, struct _tds__SetUser **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetUser(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__DeleteUsersResponse(struct soap *soap, struct _tds__DeleteUsersResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__DeleteUsersResponse))
		soap_serialize__tds__DeleteUsersResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__DeleteUsersResponse(struct soap *soap, const char *tag, int id, struct _tds__DeleteUsersResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__DeleteUsersResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tds__DeleteUsersResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__DeleteUsersResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__DeleteUsersResponse(struct soap *soap, const char *tag, struct _tds__DeleteUsersResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__DeleteUsersResponse **)soap_malloc(soap, sizeof(struct _tds__DeleteUsersResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__DeleteUsersResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__DeleteUsersResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__DeleteUsersResponse, sizeof(struct _tds__DeleteUsersResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__DeleteUsersResponse(struct soap *soap, struct _tds__DeleteUsersResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__DeleteUsersResponse);
	if (soap_out_PointerTo_tds__DeleteUsersResponse(soap, tag?tag:"tds:DeleteUsersResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__DeleteUsersResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__DeleteUsersResponse(struct soap *soap, struct _tds__DeleteUsersResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__DeleteUsersResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__DeleteUsers(struct soap *soap, struct _tds__DeleteUsers *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__DeleteUsers))
		soap_serialize__tds__DeleteUsers(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__DeleteUsers(struct soap *soap, const char *tag, int id, struct _tds__DeleteUsers *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__DeleteUsers);
	if (id < 0)
		return soap->error;
	return soap_out__tds__DeleteUsers(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__DeleteUsers ** SOAP_FMAC4 soap_in_PointerTo_tds__DeleteUsers(struct soap *soap, const char *tag, struct _tds__DeleteUsers **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__DeleteUsers **)soap_malloc(soap, sizeof(struct _tds__DeleteUsers *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__DeleteUsers(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__DeleteUsers **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__DeleteUsers, sizeof(struct _tds__DeleteUsers), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__DeleteUsers(struct soap *soap, struct _tds__DeleteUsers *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__DeleteUsers);
	if (soap_out_PointerTo_tds__DeleteUsers(soap, tag?tag:"tds:DeleteUsers", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__DeleteUsers ** SOAP_FMAC4 soap_get_PointerTo_tds__DeleteUsers(struct soap *soap, struct _tds__DeleteUsers **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__DeleteUsers(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__CreateUsersResponse(struct soap *soap, struct _tds__CreateUsersResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__CreateUsersResponse))
		soap_serialize__tds__CreateUsersResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__CreateUsersResponse(struct soap *soap, const char *tag, int id, struct _tds__CreateUsersResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__CreateUsersResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tds__CreateUsersResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__CreateUsersResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__CreateUsersResponse(struct soap *soap, const char *tag, struct _tds__CreateUsersResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__CreateUsersResponse **)soap_malloc(soap, sizeof(struct _tds__CreateUsersResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__CreateUsersResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__CreateUsersResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__CreateUsersResponse, sizeof(struct _tds__CreateUsersResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__CreateUsersResponse(struct soap *soap, struct _tds__CreateUsersResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__CreateUsersResponse);
	if (soap_out_PointerTo_tds__CreateUsersResponse(soap, tag?tag:"tds:CreateUsersResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__CreateUsersResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__CreateUsersResponse(struct soap *soap, struct _tds__CreateUsersResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__CreateUsersResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__CreateUsers(struct soap *soap, struct _tds__CreateUsers *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__CreateUsers))
		soap_serialize__tds__CreateUsers(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__CreateUsers(struct soap *soap, const char *tag, int id, struct _tds__CreateUsers *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__CreateUsers);
	if (id < 0)
		return soap->error;
	return soap_out__tds__CreateUsers(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__CreateUsers ** SOAP_FMAC4 soap_in_PointerTo_tds__CreateUsers(struct soap *soap, const char *tag, struct _tds__CreateUsers **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__CreateUsers **)soap_malloc(soap, sizeof(struct _tds__CreateUsers *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__CreateUsers(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__CreateUsers **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__CreateUsers, sizeof(struct _tds__CreateUsers), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__CreateUsers(struct soap *soap, struct _tds__CreateUsers *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__CreateUsers);
	if (soap_out_PointerTo_tds__CreateUsers(soap, tag?tag:"tds:CreateUsers", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__CreateUsers ** SOAP_FMAC4 soap_get_PointerTo_tds__CreateUsers(struct soap *soap, struct _tds__CreateUsers **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__CreateUsers(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetUsersResponse(struct soap *soap, struct _tds__GetUsersResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetUsersResponse))
		soap_serialize__tds__GetUsersResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetUsersResponse(struct soap *soap, const char *tag, int id, struct _tds__GetUsersResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetUsersResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tds__GetUsersResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__GetUsersResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__GetUsersResponse(struct soap *soap, const char *tag, struct _tds__GetUsersResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__GetUsersResponse **)soap_malloc(soap, sizeof(struct _tds__GetUsersResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__GetUsersResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__GetUsersResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetUsersResponse, sizeof(struct _tds__GetUsersResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetUsersResponse(struct soap *soap, struct _tds__GetUsersResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetUsersResponse);
	if (soap_out_PointerTo_tds__GetUsersResponse(soap, tag?tag:"tds:GetUsersResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetUsersResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__GetUsersResponse(struct soap *soap, struct _tds__GetUsersResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetUsersResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetUsers(struct soap *soap, struct _tds__GetUsers *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetUsers))
		soap_serialize__tds__GetUsers(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetUsers(struct soap *soap, const char *tag, int id, struct _tds__GetUsers *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetUsers);
	if (id < 0)
		return soap->error;
	return soap_out__tds__GetUsers(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__GetUsers ** SOAP_FMAC4 soap_in_PointerTo_tds__GetUsers(struct soap *soap, const char *tag, struct _tds__GetUsers **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__GetUsers **)soap_malloc(soap, sizeof(struct _tds__GetUsers *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__GetUsers(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__GetUsers **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetUsers, sizeof(struct _tds__GetUsers), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetUsers(struct soap *soap, struct _tds__GetUsers *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetUsers);
	if (soap_out_PointerTo_tds__GetUsers(soap, tag?tag:"tds:GetUsers", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetUsers ** SOAP_FMAC4 soap_get_PointerTo_tds__GetUsers(struct soap *soap, struct _tds__GetUsers **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetUsers(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetRemoteUserResponse(struct soap *soap, struct _tds__SetRemoteUserResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetRemoteUserResponse))
		soap_serialize__tds__SetRemoteUserResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetRemoteUserResponse(struct soap *soap, const char *tag, int id, struct _tds__SetRemoteUserResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetRemoteUserResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tds__SetRemoteUserResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__SetRemoteUserResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__SetRemoteUserResponse(struct soap *soap, const char *tag, struct _tds__SetRemoteUserResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__SetRemoteUserResponse **)soap_malloc(soap, sizeof(struct _tds__SetRemoteUserResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__SetRemoteUserResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__SetRemoteUserResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetRemoteUserResponse, sizeof(struct _tds__SetRemoteUserResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetRemoteUserResponse(struct soap *soap, struct _tds__SetRemoteUserResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__SetRemoteUserResponse);
	if (soap_out_PointerTo_tds__SetRemoteUserResponse(soap, tag?tag:"tds:SetRemoteUserResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetRemoteUserResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__SetRemoteUserResponse(struct soap *soap, struct _tds__SetRemoteUserResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetRemoteUserResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetRemoteUser(struct soap *soap, struct _tds__SetRemoteUser *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetRemoteUser))
		soap_serialize__tds__SetRemoteUser(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetRemoteUser(struct soap *soap, const char *tag, int id, struct _tds__SetRemoteUser *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetRemoteUser);
	if (id < 0)
		return soap->error;
	return soap_out__tds__SetRemoteUser(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__SetRemoteUser ** SOAP_FMAC4 soap_in_PointerTo_tds__SetRemoteUser(struct soap *soap, const char *tag, struct _tds__SetRemoteUser **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__SetRemoteUser **)soap_malloc(soap, sizeof(struct _tds__SetRemoteUser *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__SetRemoteUser(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__SetRemoteUser **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetRemoteUser, sizeof(struct _tds__SetRemoteUser), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetRemoteUser(struct soap *soap, struct _tds__SetRemoteUser *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__SetRemoteUser);
	if (soap_out_PointerTo_tds__SetRemoteUser(soap, tag?tag:"tds:SetRemoteUser", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetRemoteUser ** SOAP_FMAC4 soap_get_PointerTo_tds__SetRemoteUser(struct soap *soap, struct _tds__SetRemoteUser **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetRemoteUser(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetRemoteUserResponse(struct soap *soap, struct _tds__GetRemoteUserResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetRemoteUserResponse))
		soap_serialize__tds__GetRemoteUserResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetRemoteUserResponse(struct soap *soap, const char *tag, int id, struct _tds__GetRemoteUserResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetRemoteUserResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tds__GetRemoteUserResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__GetRemoteUserResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__GetRemoteUserResponse(struct soap *soap, const char *tag, struct _tds__GetRemoteUserResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__GetRemoteUserResponse **)soap_malloc(soap, sizeof(struct _tds__GetRemoteUserResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__GetRemoteUserResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__GetRemoteUserResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetRemoteUserResponse, sizeof(struct _tds__GetRemoteUserResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetRemoteUserResponse(struct soap *soap, struct _tds__GetRemoteUserResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetRemoteUserResponse);
	if (soap_out_PointerTo_tds__GetRemoteUserResponse(soap, tag?tag:"tds:GetRemoteUserResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetRemoteUserResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__GetRemoteUserResponse(struct soap *soap, struct _tds__GetRemoteUserResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetRemoteUserResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetRemoteUser(struct soap *soap, struct _tds__GetRemoteUser *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetRemoteUser))
		soap_serialize__tds__GetRemoteUser(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetRemoteUser(struct soap *soap, const char *tag, int id, struct _tds__GetRemoteUser *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetRemoteUser);
	if (id < 0)
		return soap->error;
	return soap_out__tds__GetRemoteUser(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__GetRemoteUser ** SOAP_FMAC4 soap_in_PointerTo_tds__GetRemoteUser(struct soap *soap, const char *tag, struct _tds__GetRemoteUser **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__GetRemoteUser **)soap_malloc(soap, sizeof(struct _tds__GetRemoteUser *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__GetRemoteUser(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__GetRemoteUser **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetRemoteUser, sizeof(struct _tds__GetRemoteUser), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetRemoteUser(struct soap *soap, struct _tds__GetRemoteUser *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetRemoteUser);
	if (soap_out_PointerTo_tds__GetRemoteUser(soap, tag?tag:"tds:GetRemoteUser", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetRemoteUser ** SOAP_FMAC4 soap_get_PointerTo_tds__GetRemoteUser(struct soap *soap, struct _tds__GetRemoteUser **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetRemoteUser(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetEndpointReferenceResponse(struct soap *soap, struct _tds__GetEndpointReferenceResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetEndpointReferenceResponse))
		soap_serialize__tds__GetEndpointReferenceResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetEndpointReferenceResponse(struct soap *soap, const char *tag, int id, struct _tds__GetEndpointReferenceResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetEndpointReferenceResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tds__GetEndpointReferenceResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__GetEndpointReferenceResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__GetEndpointReferenceResponse(struct soap *soap, const char *tag, struct _tds__GetEndpointReferenceResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__GetEndpointReferenceResponse **)soap_malloc(soap, sizeof(struct _tds__GetEndpointReferenceResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__GetEndpointReferenceResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__GetEndpointReferenceResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetEndpointReferenceResponse, sizeof(struct _tds__GetEndpointReferenceResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetEndpointReferenceResponse(struct soap *soap, struct _tds__GetEndpointReferenceResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetEndpointReferenceResponse);
	if (soap_out_PointerTo_tds__GetEndpointReferenceResponse(soap, tag?tag:"tds:GetEndpointReferenceResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetEndpointReferenceResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__GetEndpointReferenceResponse(struct soap *soap, struct _tds__GetEndpointReferenceResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetEndpointReferenceResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetEndpointReference(struct soap *soap, struct _tds__GetEndpointReference *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetEndpointReference))
		soap_serialize__tds__GetEndpointReference(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetEndpointReference(struct soap *soap, const char *tag, int id, struct _tds__GetEndpointReference *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetEndpointReference);
	if (id < 0)
		return soap->error;
	return soap_out__tds__GetEndpointReference(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__GetEndpointReference ** SOAP_FMAC4 soap_in_PointerTo_tds__GetEndpointReference(struct soap *soap, const char *tag, struct _tds__GetEndpointReference **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__GetEndpointReference **)soap_malloc(soap, sizeof(struct _tds__GetEndpointReference *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__GetEndpointReference(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__GetEndpointReference **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetEndpointReference, sizeof(struct _tds__GetEndpointReference), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetEndpointReference(struct soap *soap, struct _tds__GetEndpointReference *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetEndpointReference);
	if (soap_out_PointerTo_tds__GetEndpointReference(soap, tag?tag:"tds:GetEndpointReference", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetEndpointReference ** SOAP_FMAC4 soap_get_PointerTo_tds__GetEndpointReference(struct soap *soap, struct _tds__GetEndpointReference **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetEndpointReference(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetDPAddressesResponse(struct soap *soap, struct _tds__GetDPAddressesResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetDPAddressesResponse))
		soap_serialize__tds__GetDPAddressesResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetDPAddressesResponse(struct soap *soap, const char *tag, int id, struct _tds__GetDPAddressesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetDPAddressesResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tds__GetDPAddressesResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__GetDPAddressesResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__GetDPAddressesResponse(struct soap *soap, const char *tag, struct _tds__GetDPAddressesResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__GetDPAddressesResponse **)soap_malloc(soap, sizeof(struct _tds__GetDPAddressesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__GetDPAddressesResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__GetDPAddressesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetDPAddressesResponse, sizeof(struct _tds__GetDPAddressesResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetDPAddressesResponse(struct soap *soap, struct _tds__GetDPAddressesResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetDPAddressesResponse);
	if (soap_out_PointerTo_tds__GetDPAddressesResponse(soap, tag?tag:"tds:GetDPAddressesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetDPAddressesResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__GetDPAddressesResponse(struct soap *soap, struct _tds__GetDPAddressesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetDPAddressesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetDPAddresses(struct soap *soap, struct _tds__GetDPAddresses *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetDPAddresses))
		soap_serialize__tds__GetDPAddresses(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetDPAddresses(struct soap *soap, const char *tag, int id, struct _tds__GetDPAddresses *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetDPAddresses);
	if (id < 0)
		return soap->error;
	return soap_out__tds__GetDPAddresses(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__GetDPAddresses ** SOAP_FMAC4 soap_in_PointerTo_tds__GetDPAddresses(struct soap *soap, const char *tag, struct _tds__GetDPAddresses **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__GetDPAddresses **)soap_malloc(soap, sizeof(struct _tds__GetDPAddresses *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__GetDPAddresses(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__GetDPAddresses **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetDPAddresses, sizeof(struct _tds__GetDPAddresses), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetDPAddresses(struct soap *soap, struct _tds__GetDPAddresses *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetDPAddresses);
	if (soap_out_PointerTo_tds__GetDPAddresses(soap, tag?tag:"tds:GetDPAddresses", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetDPAddresses ** SOAP_FMAC4 soap_get_PointerTo_tds__GetDPAddresses(struct soap *soap, struct _tds__GetDPAddresses **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetDPAddresses(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetRemoteDiscoveryModeResponse(struct soap *soap, struct _tds__SetRemoteDiscoveryModeResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetRemoteDiscoveryModeResponse))
		soap_serialize__tds__SetRemoteDiscoveryModeResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetRemoteDiscoveryModeResponse(struct soap *soap, const char *tag, int id, struct _tds__SetRemoteDiscoveryModeResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetRemoteDiscoveryModeResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tds__SetRemoteDiscoveryModeResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__SetRemoteDiscoveryModeResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__SetRemoteDiscoveryModeResponse(struct soap *soap, const char *tag, struct _tds__SetRemoteDiscoveryModeResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__SetRemoteDiscoveryModeResponse **)soap_malloc(soap, sizeof(struct _tds__SetRemoteDiscoveryModeResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__SetRemoteDiscoveryModeResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__SetRemoteDiscoveryModeResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetRemoteDiscoveryModeResponse, sizeof(struct _tds__SetRemoteDiscoveryModeResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetRemoteDiscoveryModeResponse(struct soap *soap, struct _tds__SetRemoteDiscoveryModeResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__SetRemoteDiscoveryModeResponse);
	if (soap_out_PointerTo_tds__SetRemoteDiscoveryModeResponse(soap, tag?tag:"tds:SetRemoteDiscoveryModeResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetRemoteDiscoveryModeResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__SetRemoteDiscoveryModeResponse(struct soap *soap, struct _tds__SetRemoteDiscoveryModeResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetRemoteDiscoveryModeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetRemoteDiscoveryMode(struct soap *soap, struct _tds__SetRemoteDiscoveryMode *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetRemoteDiscoveryMode))
		soap_serialize__tds__SetRemoteDiscoveryMode(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetRemoteDiscoveryMode(struct soap *soap, const char *tag, int id, struct _tds__SetRemoteDiscoveryMode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetRemoteDiscoveryMode);
	if (id < 0)
		return soap->error;
	return soap_out__tds__SetRemoteDiscoveryMode(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__SetRemoteDiscoveryMode ** SOAP_FMAC4 soap_in_PointerTo_tds__SetRemoteDiscoveryMode(struct soap *soap, const char *tag, struct _tds__SetRemoteDiscoveryMode **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__SetRemoteDiscoveryMode **)soap_malloc(soap, sizeof(struct _tds__SetRemoteDiscoveryMode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__SetRemoteDiscoveryMode(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__SetRemoteDiscoveryMode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetRemoteDiscoveryMode, sizeof(struct _tds__SetRemoteDiscoveryMode), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetRemoteDiscoveryMode(struct soap *soap, struct _tds__SetRemoteDiscoveryMode *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__SetRemoteDiscoveryMode);
	if (soap_out_PointerTo_tds__SetRemoteDiscoveryMode(soap, tag?tag:"tds:SetRemoteDiscoveryMode", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetRemoteDiscoveryMode ** SOAP_FMAC4 soap_get_PointerTo_tds__SetRemoteDiscoveryMode(struct soap *soap, struct _tds__SetRemoteDiscoveryMode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetRemoteDiscoveryMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetRemoteDiscoveryModeResponse(struct soap *soap, struct _tds__GetRemoteDiscoveryModeResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetRemoteDiscoveryModeResponse))
		soap_serialize__tds__GetRemoteDiscoveryModeResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetRemoteDiscoveryModeResponse(struct soap *soap, const char *tag, int id, struct _tds__GetRemoteDiscoveryModeResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetRemoteDiscoveryModeResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tds__GetRemoteDiscoveryModeResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__GetRemoteDiscoveryModeResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__GetRemoteDiscoveryModeResponse(struct soap *soap, const char *tag, struct _tds__GetRemoteDiscoveryModeResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__GetRemoteDiscoveryModeResponse **)soap_malloc(soap, sizeof(struct _tds__GetRemoteDiscoveryModeResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__GetRemoteDiscoveryModeResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__GetRemoteDiscoveryModeResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetRemoteDiscoveryModeResponse, sizeof(struct _tds__GetRemoteDiscoveryModeResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetRemoteDiscoveryModeResponse(struct soap *soap, struct _tds__GetRemoteDiscoveryModeResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetRemoteDiscoveryModeResponse);
	if (soap_out_PointerTo_tds__GetRemoteDiscoveryModeResponse(soap, tag?tag:"tds:GetRemoteDiscoveryModeResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetRemoteDiscoveryModeResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__GetRemoteDiscoveryModeResponse(struct soap *soap, struct _tds__GetRemoteDiscoveryModeResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetRemoteDiscoveryModeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetRemoteDiscoveryMode(struct soap *soap, struct _tds__GetRemoteDiscoveryMode *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetRemoteDiscoveryMode))
		soap_serialize__tds__GetRemoteDiscoveryMode(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetRemoteDiscoveryMode(struct soap *soap, const char *tag, int id, struct _tds__GetRemoteDiscoveryMode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetRemoteDiscoveryMode);
	if (id < 0)
		return soap->error;
	return soap_out__tds__GetRemoteDiscoveryMode(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__GetRemoteDiscoveryMode ** SOAP_FMAC4 soap_in_PointerTo_tds__GetRemoteDiscoveryMode(struct soap *soap, const char *tag, struct _tds__GetRemoteDiscoveryMode **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__GetRemoteDiscoveryMode **)soap_malloc(soap, sizeof(struct _tds__GetRemoteDiscoveryMode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__GetRemoteDiscoveryMode(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__GetRemoteDiscoveryMode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetRemoteDiscoveryMode, sizeof(struct _tds__GetRemoteDiscoveryMode), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetRemoteDiscoveryMode(struct soap *soap, struct _tds__GetRemoteDiscoveryMode *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetRemoteDiscoveryMode);
	if (soap_out_PointerTo_tds__GetRemoteDiscoveryMode(soap, tag?tag:"tds:GetRemoteDiscoveryMode", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetRemoteDiscoveryMode ** SOAP_FMAC4 soap_get_PointerTo_tds__GetRemoteDiscoveryMode(struct soap *soap, struct _tds__GetRemoteDiscoveryMode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetRemoteDiscoveryMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetDiscoveryModeResponse(struct soap *soap, struct _tds__SetDiscoveryModeResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetDiscoveryModeResponse))
		soap_serialize__tds__SetDiscoveryModeResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetDiscoveryModeResponse(struct soap *soap, const char *tag, int id, struct _tds__SetDiscoveryModeResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetDiscoveryModeResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tds__SetDiscoveryModeResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__SetDiscoveryModeResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__SetDiscoveryModeResponse(struct soap *soap, const char *tag, struct _tds__SetDiscoveryModeResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__SetDiscoveryModeResponse **)soap_malloc(soap, sizeof(struct _tds__SetDiscoveryModeResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__SetDiscoveryModeResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__SetDiscoveryModeResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetDiscoveryModeResponse, sizeof(struct _tds__SetDiscoveryModeResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetDiscoveryModeResponse(struct soap *soap, struct _tds__SetDiscoveryModeResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__SetDiscoveryModeResponse);
	if (soap_out_PointerTo_tds__SetDiscoveryModeResponse(soap, tag?tag:"tds:SetDiscoveryModeResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetDiscoveryModeResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__SetDiscoveryModeResponse(struct soap *soap, struct _tds__SetDiscoveryModeResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetDiscoveryModeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetDiscoveryMode(struct soap *soap, struct _tds__SetDiscoveryMode *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetDiscoveryMode))
		soap_serialize__tds__SetDiscoveryMode(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetDiscoveryMode(struct soap *soap, const char *tag, int id, struct _tds__SetDiscoveryMode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetDiscoveryMode);
	if (id < 0)
		return soap->error;
	return soap_out__tds__SetDiscoveryMode(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__SetDiscoveryMode ** SOAP_FMAC4 soap_in_PointerTo_tds__SetDiscoveryMode(struct soap *soap, const char *tag, struct _tds__SetDiscoveryMode **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__SetDiscoveryMode **)soap_malloc(soap, sizeof(struct _tds__SetDiscoveryMode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__SetDiscoveryMode(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__SetDiscoveryMode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetDiscoveryMode, sizeof(struct _tds__SetDiscoveryMode), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetDiscoveryMode(struct soap *soap, struct _tds__SetDiscoveryMode *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__SetDiscoveryMode);
	if (soap_out_PointerTo_tds__SetDiscoveryMode(soap, tag?tag:"tds:SetDiscoveryMode", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetDiscoveryMode ** SOAP_FMAC4 soap_get_PointerTo_tds__SetDiscoveryMode(struct soap *soap, struct _tds__SetDiscoveryMode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetDiscoveryMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetDiscoveryModeResponse(struct soap *soap, struct _tds__GetDiscoveryModeResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetDiscoveryModeResponse))
		soap_serialize__tds__GetDiscoveryModeResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetDiscoveryModeResponse(struct soap *soap, const char *tag, int id, struct _tds__GetDiscoveryModeResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetDiscoveryModeResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tds__GetDiscoveryModeResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__GetDiscoveryModeResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__GetDiscoveryModeResponse(struct soap *soap, const char *tag, struct _tds__GetDiscoveryModeResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__GetDiscoveryModeResponse **)soap_malloc(soap, sizeof(struct _tds__GetDiscoveryModeResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__GetDiscoveryModeResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__GetDiscoveryModeResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetDiscoveryModeResponse, sizeof(struct _tds__GetDiscoveryModeResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetDiscoveryModeResponse(struct soap *soap, struct _tds__GetDiscoveryModeResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetDiscoveryModeResponse);
	if (soap_out_PointerTo_tds__GetDiscoveryModeResponse(soap, tag?tag:"tds:GetDiscoveryModeResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetDiscoveryModeResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__GetDiscoveryModeResponse(struct soap *soap, struct _tds__GetDiscoveryModeResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetDiscoveryModeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetDiscoveryMode(struct soap *soap, struct _tds__GetDiscoveryMode *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetDiscoveryMode))
		soap_serialize__tds__GetDiscoveryMode(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetDiscoveryMode(struct soap *soap, const char *tag, int id, struct _tds__GetDiscoveryMode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetDiscoveryMode);
	if (id < 0)
		return soap->error;
	return soap_out__tds__GetDiscoveryMode(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__GetDiscoveryMode ** SOAP_FMAC4 soap_in_PointerTo_tds__GetDiscoveryMode(struct soap *soap, const char *tag, struct _tds__GetDiscoveryMode **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__GetDiscoveryMode **)soap_malloc(soap, sizeof(struct _tds__GetDiscoveryMode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__GetDiscoveryMode(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__GetDiscoveryMode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetDiscoveryMode, sizeof(struct _tds__GetDiscoveryMode), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetDiscoveryMode(struct soap *soap, struct _tds__GetDiscoveryMode *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetDiscoveryMode);
	if (soap_out_PointerTo_tds__GetDiscoveryMode(soap, tag?tag:"tds:GetDiscoveryMode", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetDiscoveryMode ** SOAP_FMAC4 soap_get_PointerTo_tds__GetDiscoveryMode(struct soap *soap, struct _tds__GetDiscoveryMode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetDiscoveryMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__RemoveScopesResponse(struct soap *soap, struct _tds__RemoveScopesResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__RemoveScopesResponse))
		soap_serialize__tds__RemoveScopesResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__RemoveScopesResponse(struct soap *soap, const char *tag, int id, struct _tds__RemoveScopesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__RemoveScopesResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tds__RemoveScopesResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__RemoveScopesResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__RemoveScopesResponse(struct soap *soap, const char *tag, struct _tds__RemoveScopesResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__RemoveScopesResponse **)soap_malloc(soap, sizeof(struct _tds__RemoveScopesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__RemoveScopesResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__RemoveScopesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__RemoveScopesResponse, sizeof(struct _tds__RemoveScopesResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__RemoveScopesResponse(struct soap *soap, struct _tds__RemoveScopesResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__RemoveScopesResponse);
	if (soap_out_PointerTo_tds__RemoveScopesResponse(soap, tag?tag:"tds:RemoveScopesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__RemoveScopesResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__RemoveScopesResponse(struct soap *soap, struct _tds__RemoveScopesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__RemoveScopesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__RemoveScopes(struct soap *soap, struct _tds__RemoveScopes *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__RemoveScopes))
		soap_serialize__tds__RemoveScopes(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__RemoveScopes(struct soap *soap, const char *tag, int id, struct _tds__RemoveScopes *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__RemoveScopes);
	if (id < 0)
		return soap->error;
	return soap_out__tds__RemoveScopes(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__RemoveScopes ** SOAP_FMAC4 soap_in_PointerTo_tds__RemoveScopes(struct soap *soap, const char *tag, struct _tds__RemoveScopes **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__RemoveScopes **)soap_malloc(soap, sizeof(struct _tds__RemoveScopes *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__RemoveScopes(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__RemoveScopes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__RemoveScopes, sizeof(struct _tds__RemoveScopes), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__RemoveScopes(struct soap *soap, struct _tds__RemoveScopes *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__RemoveScopes);
	if (soap_out_PointerTo_tds__RemoveScopes(soap, tag?tag:"tds:RemoveScopes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__RemoveScopes ** SOAP_FMAC4 soap_get_PointerTo_tds__RemoveScopes(struct soap *soap, struct _tds__RemoveScopes **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__RemoveScopes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__AddScopesResponse(struct soap *soap, struct _tds__AddScopesResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__AddScopesResponse))
		soap_serialize__tds__AddScopesResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__AddScopesResponse(struct soap *soap, const char *tag, int id, struct _tds__AddScopesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__AddScopesResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tds__AddScopesResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__AddScopesResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__AddScopesResponse(struct soap *soap, const char *tag, struct _tds__AddScopesResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__AddScopesResponse **)soap_malloc(soap, sizeof(struct _tds__AddScopesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__AddScopesResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__AddScopesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__AddScopesResponse, sizeof(struct _tds__AddScopesResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__AddScopesResponse(struct soap *soap, struct _tds__AddScopesResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__AddScopesResponse);
	if (soap_out_PointerTo_tds__AddScopesResponse(soap, tag?tag:"tds:AddScopesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__AddScopesResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__AddScopesResponse(struct soap *soap, struct _tds__AddScopesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__AddScopesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__AddScopes(struct soap *soap, struct _tds__AddScopes *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__AddScopes))
		soap_serialize__tds__AddScopes(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__AddScopes(struct soap *soap, const char *tag, int id, struct _tds__AddScopes *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__AddScopes);
	if (id < 0)
		return soap->error;
	return soap_out__tds__AddScopes(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__AddScopes ** SOAP_FMAC4 soap_in_PointerTo_tds__AddScopes(struct soap *soap, const char *tag, struct _tds__AddScopes **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__AddScopes **)soap_malloc(soap, sizeof(struct _tds__AddScopes *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__AddScopes(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__AddScopes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__AddScopes, sizeof(struct _tds__AddScopes), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__AddScopes(struct soap *soap, struct _tds__AddScopes *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__AddScopes);
	if (soap_out_PointerTo_tds__AddScopes(soap, tag?tag:"tds:AddScopes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__AddScopes ** SOAP_FMAC4 soap_get_PointerTo_tds__AddScopes(struct soap *soap, struct _tds__AddScopes **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__AddScopes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetScopesResponse(struct soap *soap, struct _tds__SetScopesResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetScopesResponse))
		soap_serialize__tds__SetScopesResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetScopesResponse(struct soap *soap, const char *tag, int id, struct _tds__SetScopesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetScopesResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tds__SetScopesResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__SetScopesResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__SetScopesResponse(struct soap *soap, const char *tag, struct _tds__SetScopesResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__SetScopesResponse **)soap_malloc(soap, sizeof(struct _tds__SetScopesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__SetScopesResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__SetScopesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetScopesResponse, sizeof(struct _tds__SetScopesResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetScopesResponse(struct soap *soap, struct _tds__SetScopesResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__SetScopesResponse);
	if (soap_out_PointerTo_tds__SetScopesResponse(soap, tag?tag:"tds:SetScopesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetScopesResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__SetScopesResponse(struct soap *soap, struct _tds__SetScopesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetScopesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetScopes(struct soap *soap, struct _tds__SetScopes *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetScopes))
		soap_serialize__tds__SetScopes(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetScopes(struct soap *soap, const char *tag, int id, struct _tds__SetScopes *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetScopes);
	if (id < 0)
		return soap->error;
	return soap_out__tds__SetScopes(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__SetScopes ** SOAP_FMAC4 soap_in_PointerTo_tds__SetScopes(struct soap *soap, const char *tag, struct _tds__SetScopes **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__SetScopes **)soap_malloc(soap, sizeof(struct _tds__SetScopes *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__SetScopes(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__SetScopes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetScopes, sizeof(struct _tds__SetScopes), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetScopes(struct soap *soap, struct _tds__SetScopes *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__SetScopes);
	if (soap_out_PointerTo_tds__SetScopes(soap, tag?tag:"tds:SetScopes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetScopes ** SOAP_FMAC4 soap_get_PointerTo_tds__SetScopes(struct soap *soap, struct _tds__SetScopes **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetScopes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetScopesResponse(struct soap *soap, struct _tds__GetScopesResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetScopesResponse))
		soap_serialize__tds__GetScopesResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetScopesResponse(struct soap *soap, const char *tag, int id, struct _tds__GetScopesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetScopesResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tds__GetScopesResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__GetScopesResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__GetScopesResponse(struct soap *soap, const char *tag, struct _tds__GetScopesResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__GetScopesResponse **)soap_malloc(soap, sizeof(struct _tds__GetScopesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__GetScopesResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__GetScopesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetScopesResponse, sizeof(struct _tds__GetScopesResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetScopesResponse(struct soap *soap, struct _tds__GetScopesResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetScopesResponse);
	if (soap_out_PointerTo_tds__GetScopesResponse(soap, tag?tag:"tds:GetScopesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetScopesResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__GetScopesResponse(struct soap *soap, struct _tds__GetScopesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetScopesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetScopes(struct soap *soap, struct _tds__GetScopes *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetScopes))
		soap_serialize__tds__GetScopes(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetScopes(struct soap *soap, const char *tag, int id, struct _tds__GetScopes *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetScopes);
	if (id < 0)
		return soap->error;
	return soap_out__tds__GetScopes(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__GetScopes ** SOAP_FMAC4 soap_in_PointerTo_tds__GetScopes(struct soap *soap, const char *tag, struct _tds__GetScopes **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__GetScopes **)soap_malloc(soap, sizeof(struct _tds__GetScopes *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__GetScopes(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__GetScopes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetScopes, sizeof(struct _tds__GetScopes), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetScopes(struct soap *soap, struct _tds__GetScopes *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetScopes);
	if (soap_out_PointerTo_tds__GetScopes(soap, tag?tag:"tds:GetScopes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetScopes ** SOAP_FMAC4 soap_get_PointerTo_tds__GetScopes(struct soap *soap, struct _tds__GetScopes **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetScopes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetSystemSupportInformationResponse(struct soap *soap, struct _tds__GetSystemSupportInformationResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetSystemSupportInformationResponse))
		soap_serialize__tds__GetSystemSupportInformationResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetSystemSupportInformationResponse(struct soap *soap, const char *tag, int id, struct _tds__GetSystemSupportInformationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetSystemSupportInformationResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tds__GetSystemSupportInformationResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__GetSystemSupportInformationResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__GetSystemSupportInformationResponse(struct soap *soap, const char *tag, struct _tds__GetSystemSupportInformationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__GetSystemSupportInformationResponse **)soap_malloc(soap, sizeof(struct _tds__GetSystemSupportInformationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__GetSystemSupportInformationResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__GetSystemSupportInformationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetSystemSupportInformationResponse, sizeof(struct _tds__GetSystemSupportInformationResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetSystemSupportInformationResponse(struct soap *soap, struct _tds__GetSystemSupportInformationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetSystemSupportInformationResponse);
	if (soap_out_PointerTo_tds__GetSystemSupportInformationResponse(soap, tag?tag:"tds:GetSystemSupportInformationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetSystemSupportInformationResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__GetSystemSupportInformationResponse(struct soap *soap, struct _tds__GetSystemSupportInformationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetSystemSupportInformationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetSystemSupportInformation(struct soap *soap, struct _tds__GetSystemSupportInformation *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetSystemSupportInformation))
		soap_serialize__tds__GetSystemSupportInformation(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetSystemSupportInformation(struct soap *soap, const char *tag, int id, struct _tds__GetSystemSupportInformation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetSystemSupportInformation);
	if (id < 0)
		return soap->error;
	return soap_out__tds__GetSystemSupportInformation(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__GetSystemSupportInformation ** SOAP_FMAC4 soap_in_PointerTo_tds__GetSystemSupportInformation(struct soap *soap, const char *tag, struct _tds__GetSystemSupportInformation **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__GetSystemSupportInformation **)soap_malloc(soap, sizeof(struct _tds__GetSystemSupportInformation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__GetSystemSupportInformation(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__GetSystemSupportInformation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetSystemSupportInformation, sizeof(struct _tds__GetSystemSupportInformation), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetSystemSupportInformation(struct soap *soap, struct _tds__GetSystemSupportInformation *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetSystemSupportInformation);
	if (soap_out_PointerTo_tds__GetSystemSupportInformation(soap, tag?tag:"tds:GetSystemSupportInformation", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetSystemSupportInformation ** SOAP_FMAC4 soap_get_PointerTo_tds__GetSystemSupportInformation(struct soap *soap, struct _tds__GetSystemSupportInformation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetSystemSupportInformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetSystemLogResponse(struct soap *soap, struct _tds__GetSystemLogResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetSystemLogResponse))
		soap_serialize__tds__GetSystemLogResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetSystemLogResponse(struct soap *soap, const char *tag, int id, struct _tds__GetSystemLogResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetSystemLogResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tds__GetSystemLogResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__GetSystemLogResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__GetSystemLogResponse(struct soap *soap, const char *tag, struct _tds__GetSystemLogResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__GetSystemLogResponse **)soap_malloc(soap, sizeof(struct _tds__GetSystemLogResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__GetSystemLogResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__GetSystemLogResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetSystemLogResponse, sizeof(struct _tds__GetSystemLogResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetSystemLogResponse(struct soap *soap, struct _tds__GetSystemLogResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetSystemLogResponse);
	if (soap_out_PointerTo_tds__GetSystemLogResponse(soap, tag?tag:"tds:GetSystemLogResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetSystemLogResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__GetSystemLogResponse(struct soap *soap, struct _tds__GetSystemLogResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetSystemLogResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetSystemLog(struct soap *soap, struct _tds__GetSystemLog *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetSystemLog))
		soap_serialize__tds__GetSystemLog(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetSystemLog(struct soap *soap, const char *tag, int id, struct _tds__GetSystemLog *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetSystemLog);
	if (id < 0)
		return soap->error;
	return soap_out__tds__GetSystemLog(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__GetSystemLog ** SOAP_FMAC4 soap_in_PointerTo_tds__GetSystemLog(struct soap *soap, const char *tag, struct _tds__GetSystemLog **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__GetSystemLog **)soap_malloc(soap, sizeof(struct _tds__GetSystemLog *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__GetSystemLog(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__GetSystemLog **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetSystemLog, sizeof(struct _tds__GetSystemLog), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetSystemLog(struct soap *soap, struct _tds__GetSystemLog *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetSystemLog);
	if (soap_out_PointerTo_tds__GetSystemLog(soap, tag?tag:"tds:GetSystemLog", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetSystemLog ** SOAP_FMAC4 soap_get_PointerTo_tds__GetSystemLog(struct soap *soap, struct _tds__GetSystemLog **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetSystemLog(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetSystemBackupResponse(struct soap *soap, struct _tds__GetSystemBackupResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetSystemBackupResponse))
		soap_serialize__tds__GetSystemBackupResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetSystemBackupResponse(struct soap *soap, const char *tag, int id, struct _tds__GetSystemBackupResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetSystemBackupResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tds__GetSystemBackupResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__GetSystemBackupResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__GetSystemBackupResponse(struct soap *soap, const char *tag, struct _tds__GetSystemBackupResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__GetSystemBackupResponse **)soap_malloc(soap, sizeof(struct _tds__GetSystemBackupResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__GetSystemBackupResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__GetSystemBackupResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetSystemBackupResponse, sizeof(struct _tds__GetSystemBackupResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetSystemBackupResponse(struct soap *soap, struct _tds__GetSystemBackupResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetSystemBackupResponse);
	if (soap_out_PointerTo_tds__GetSystemBackupResponse(soap, tag?tag:"tds:GetSystemBackupResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetSystemBackupResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__GetSystemBackupResponse(struct soap *soap, struct _tds__GetSystemBackupResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetSystemBackupResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetSystemBackup(struct soap *soap, struct _tds__GetSystemBackup *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetSystemBackup))
		soap_serialize__tds__GetSystemBackup(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetSystemBackup(struct soap *soap, const char *tag, int id, struct _tds__GetSystemBackup *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetSystemBackup);
	if (id < 0)
		return soap->error;
	return soap_out__tds__GetSystemBackup(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__GetSystemBackup ** SOAP_FMAC4 soap_in_PointerTo_tds__GetSystemBackup(struct soap *soap, const char *tag, struct _tds__GetSystemBackup **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__GetSystemBackup **)soap_malloc(soap, sizeof(struct _tds__GetSystemBackup *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__GetSystemBackup(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__GetSystemBackup **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetSystemBackup, sizeof(struct _tds__GetSystemBackup), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetSystemBackup(struct soap *soap, struct _tds__GetSystemBackup *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetSystemBackup);
	if (soap_out_PointerTo_tds__GetSystemBackup(soap, tag?tag:"tds:GetSystemBackup", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetSystemBackup ** SOAP_FMAC4 soap_get_PointerTo_tds__GetSystemBackup(struct soap *soap, struct _tds__GetSystemBackup **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetSystemBackup(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__RestoreSystemResponse(struct soap *soap, struct _tds__RestoreSystemResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__RestoreSystemResponse))
		soap_serialize__tds__RestoreSystemResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__RestoreSystemResponse(struct soap *soap, const char *tag, int id, struct _tds__RestoreSystemResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__RestoreSystemResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tds__RestoreSystemResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__RestoreSystemResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__RestoreSystemResponse(struct soap *soap, const char *tag, struct _tds__RestoreSystemResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__RestoreSystemResponse **)soap_malloc(soap, sizeof(struct _tds__RestoreSystemResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__RestoreSystemResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__RestoreSystemResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__RestoreSystemResponse, sizeof(struct _tds__RestoreSystemResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__RestoreSystemResponse(struct soap *soap, struct _tds__RestoreSystemResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__RestoreSystemResponse);
	if (soap_out_PointerTo_tds__RestoreSystemResponse(soap, tag?tag:"tds:RestoreSystemResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__RestoreSystemResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__RestoreSystemResponse(struct soap *soap, struct _tds__RestoreSystemResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__RestoreSystemResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__RestoreSystem(struct soap *soap, struct _tds__RestoreSystem *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__RestoreSystem))
		soap_serialize__tds__RestoreSystem(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__RestoreSystem(struct soap *soap, const char *tag, int id, struct _tds__RestoreSystem *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__RestoreSystem);
	if (id < 0)
		return soap->error;
	return soap_out__tds__RestoreSystem(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__RestoreSystem ** SOAP_FMAC4 soap_in_PointerTo_tds__RestoreSystem(struct soap *soap, const char *tag, struct _tds__RestoreSystem **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__RestoreSystem **)soap_malloc(soap, sizeof(struct _tds__RestoreSystem *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__RestoreSystem(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__RestoreSystem **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__RestoreSystem, sizeof(struct _tds__RestoreSystem), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__RestoreSystem(struct soap *soap, struct _tds__RestoreSystem *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__RestoreSystem);
	if (soap_out_PointerTo_tds__RestoreSystem(soap, tag?tag:"tds:RestoreSystem", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__RestoreSystem ** SOAP_FMAC4 soap_get_PointerTo_tds__RestoreSystem(struct soap *soap, struct _tds__RestoreSystem **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__RestoreSystem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SystemRebootResponse(struct soap *soap, struct _tds__SystemRebootResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SystemRebootResponse))
		soap_serialize__tds__SystemRebootResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SystemRebootResponse(struct soap *soap, const char *tag, int id, struct _tds__SystemRebootResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SystemRebootResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tds__SystemRebootResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__SystemRebootResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__SystemRebootResponse(struct soap *soap, const char *tag, struct _tds__SystemRebootResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__SystemRebootResponse **)soap_malloc(soap, sizeof(struct _tds__SystemRebootResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__SystemRebootResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__SystemRebootResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SystemRebootResponse, sizeof(struct _tds__SystemRebootResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SystemRebootResponse(struct soap *soap, struct _tds__SystemRebootResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__SystemRebootResponse);
	if (soap_out_PointerTo_tds__SystemRebootResponse(soap, tag?tag:"tds:SystemRebootResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SystemRebootResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__SystemRebootResponse(struct soap *soap, struct _tds__SystemRebootResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SystemRebootResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SystemReboot(struct soap *soap, struct _tds__SystemReboot *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SystemReboot))
		soap_serialize__tds__SystemReboot(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SystemReboot(struct soap *soap, const char *tag, int id, struct _tds__SystemReboot *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SystemReboot);
	if (id < 0)
		return soap->error;
	return soap_out__tds__SystemReboot(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__SystemReboot ** SOAP_FMAC4 soap_in_PointerTo_tds__SystemReboot(struct soap *soap, const char *tag, struct _tds__SystemReboot **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__SystemReboot **)soap_malloc(soap, sizeof(struct _tds__SystemReboot *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__SystemReboot(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__SystemReboot **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SystemReboot, sizeof(struct _tds__SystemReboot), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SystemReboot(struct soap *soap, struct _tds__SystemReboot *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__SystemReboot);
	if (soap_out_PointerTo_tds__SystemReboot(soap, tag?tag:"tds:SystemReboot", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SystemReboot ** SOAP_FMAC4 soap_get_PointerTo_tds__SystemReboot(struct soap *soap, struct _tds__SystemReboot **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SystemReboot(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__UpgradeSystemFirmwareResponse(struct soap *soap, struct _tds__UpgradeSystemFirmwareResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__UpgradeSystemFirmwareResponse))
		soap_serialize__tds__UpgradeSystemFirmwareResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__UpgradeSystemFirmwareResponse(struct soap *soap, const char *tag, int id, struct _tds__UpgradeSystemFirmwareResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__UpgradeSystemFirmwareResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tds__UpgradeSystemFirmwareResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__UpgradeSystemFirmwareResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__UpgradeSystemFirmwareResponse(struct soap *soap, const char *tag, struct _tds__UpgradeSystemFirmwareResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__UpgradeSystemFirmwareResponse **)soap_malloc(soap, sizeof(struct _tds__UpgradeSystemFirmwareResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__UpgradeSystemFirmwareResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__UpgradeSystemFirmwareResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__UpgradeSystemFirmwareResponse, sizeof(struct _tds__UpgradeSystemFirmwareResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__UpgradeSystemFirmwareResponse(struct soap *soap, struct _tds__UpgradeSystemFirmwareResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__UpgradeSystemFirmwareResponse);
	if (soap_out_PointerTo_tds__UpgradeSystemFirmwareResponse(soap, tag?tag:"tds:UpgradeSystemFirmwareResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__UpgradeSystemFirmwareResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__UpgradeSystemFirmwareResponse(struct soap *soap, struct _tds__UpgradeSystemFirmwareResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__UpgradeSystemFirmwareResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__UpgradeSystemFirmware(struct soap *soap, struct _tds__UpgradeSystemFirmware *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__UpgradeSystemFirmware))
		soap_serialize__tds__UpgradeSystemFirmware(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__UpgradeSystemFirmware(struct soap *soap, const char *tag, int id, struct _tds__UpgradeSystemFirmware *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__UpgradeSystemFirmware);
	if (id < 0)
		return soap->error;
	return soap_out__tds__UpgradeSystemFirmware(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__UpgradeSystemFirmware ** SOAP_FMAC4 soap_in_PointerTo_tds__UpgradeSystemFirmware(struct soap *soap, const char *tag, struct _tds__UpgradeSystemFirmware **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__UpgradeSystemFirmware **)soap_malloc(soap, sizeof(struct _tds__UpgradeSystemFirmware *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__UpgradeSystemFirmware(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__UpgradeSystemFirmware **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__UpgradeSystemFirmware, sizeof(struct _tds__UpgradeSystemFirmware), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__UpgradeSystemFirmware(struct soap *soap, struct _tds__UpgradeSystemFirmware *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__UpgradeSystemFirmware);
	if (soap_out_PointerTo_tds__UpgradeSystemFirmware(soap, tag?tag:"tds:UpgradeSystemFirmware", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__UpgradeSystemFirmware ** SOAP_FMAC4 soap_get_PointerTo_tds__UpgradeSystemFirmware(struct soap *soap, struct _tds__UpgradeSystemFirmware **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__UpgradeSystemFirmware(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetSystemFactoryDefaultResponse(struct soap *soap, struct _tds__SetSystemFactoryDefaultResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetSystemFactoryDefaultResponse))
		soap_serialize__tds__SetSystemFactoryDefaultResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetSystemFactoryDefaultResponse(struct soap *soap, const char *tag, int id, struct _tds__SetSystemFactoryDefaultResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetSystemFactoryDefaultResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tds__SetSystemFactoryDefaultResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__SetSystemFactoryDefaultResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__SetSystemFactoryDefaultResponse(struct soap *soap, const char *tag, struct _tds__SetSystemFactoryDefaultResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__SetSystemFactoryDefaultResponse **)soap_malloc(soap, sizeof(struct _tds__SetSystemFactoryDefaultResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__SetSystemFactoryDefaultResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__SetSystemFactoryDefaultResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetSystemFactoryDefaultResponse, sizeof(struct _tds__SetSystemFactoryDefaultResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetSystemFactoryDefaultResponse(struct soap *soap, struct _tds__SetSystemFactoryDefaultResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__SetSystemFactoryDefaultResponse);
	if (soap_out_PointerTo_tds__SetSystemFactoryDefaultResponse(soap, tag?tag:"tds:SetSystemFactoryDefaultResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetSystemFactoryDefaultResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__SetSystemFactoryDefaultResponse(struct soap *soap, struct _tds__SetSystemFactoryDefaultResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetSystemFactoryDefaultResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetSystemFactoryDefault(struct soap *soap, struct _tds__SetSystemFactoryDefault *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetSystemFactoryDefault))
		soap_serialize__tds__SetSystemFactoryDefault(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetSystemFactoryDefault(struct soap *soap, const char *tag, int id, struct _tds__SetSystemFactoryDefault *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetSystemFactoryDefault);
	if (id < 0)
		return soap->error;
	return soap_out__tds__SetSystemFactoryDefault(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__SetSystemFactoryDefault ** SOAP_FMAC4 soap_in_PointerTo_tds__SetSystemFactoryDefault(struct soap *soap, const char *tag, struct _tds__SetSystemFactoryDefault **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__SetSystemFactoryDefault **)soap_malloc(soap, sizeof(struct _tds__SetSystemFactoryDefault *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__SetSystemFactoryDefault(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__SetSystemFactoryDefault **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetSystemFactoryDefault, sizeof(struct _tds__SetSystemFactoryDefault), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetSystemFactoryDefault(struct soap *soap, struct _tds__SetSystemFactoryDefault *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__SetSystemFactoryDefault);
	if (soap_out_PointerTo_tds__SetSystemFactoryDefault(soap, tag?tag:"tds:SetSystemFactoryDefault", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetSystemFactoryDefault ** SOAP_FMAC4 soap_get_PointerTo_tds__SetSystemFactoryDefault(struct soap *soap, struct _tds__SetSystemFactoryDefault **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetSystemFactoryDefault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetSystemDateAndTimeResponse(struct soap *soap, struct _tds__GetSystemDateAndTimeResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetSystemDateAndTimeResponse))
		soap_serialize__tds__GetSystemDateAndTimeResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetSystemDateAndTimeResponse(struct soap *soap, const char *tag, int id, struct _tds__GetSystemDateAndTimeResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetSystemDateAndTimeResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tds__GetSystemDateAndTimeResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__GetSystemDateAndTimeResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__GetSystemDateAndTimeResponse(struct soap *soap, const char *tag, struct _tds__GetSystemDateAndTimeResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__GetSystemDateAndTimeResponse **)soap_malloc(soap, sizeof(struct _tds__GetSystemDateAndTimeResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__GetSystemDateAndTimeResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__GetSystemDateAndTimeResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetSystemDateAndTimeResponse, sizeof(struct _tds__GetSystemDateAndTimeResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetSystemDateAndTimeResponse(struct soap *soap, struct _tds__GetSystemDateAndTimeResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetSystemDateAndTimeResponse);
	if (soap_out_PointerTo_tds__GetSystemDateAndTimeResponse(soap, tag?tag:"tds:GetSystemDateAndTimeResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetSystemDateAndTimeResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__GetSystemDateAndTimeResponse(struct soap *soap, struct _tds__GetSystemDateAndTimeResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetSystemDateAndTimeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetSystemDateAndTime(struct soap *soap, struct _tds__GetSystemDateAndTime *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetSystemDateAndTime))
		soap_serialize__tds__GetSystemDateAndTime(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetSystemDateAndTime(struct soap *soap, const char *tag, int id, struct _tds__GetSystemDateAndTime *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetSystemDateAndTime);
	if (id < 0)
		return soap->error;
	return soap_out__tds__GetSystemDateAndTime(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__GetSystemDateAndTime ** SOAP_FMAC4 soap_in_PointerTo_tds__GetSystemDateAndTime(struct soap *soap, const char *tag, struct _tds__GetSystemDateAndTime **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__GetSystemDateAndTime **)soap_malloc(soap, sizeof(struct _tds__GetSystemDateAndTime *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__GetSystemDateAndTime(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__GetSystemDateAndTime **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetSystemDateAndTime, sizeof(struct _tds__GetSystemDateAndTime), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetSystemDateAndTime(struct soap *soap, struct _tds__GetSystemDateAndTime *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetSystemDateAndTime);
	if (soap_out_PointerTo_tds__GetSystemDateAndTime(soap, tag?tag:"tds:GetSystemDateAndTime", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetSystemDateAndTime ** SOAP_FMAC4 soap_get_PointerTo_tds__GetSystemDateAndTime(struct soap *soap, struct _tds__GetSystemDateAndTime **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetSystemDateAndTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetSystemDateAndTimeResponse(struct soap *soap, struct _tds__SetSystemDateAndTimeResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetSystemDateAndTimeResponse))
		soap_serialize__tds__SetSystemDateAndTimeResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetSystemDateAndTimeResponse(struct soap *soap, const char *tag, int id, struct _tds__SetSystemDateAndTimeResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetSystemDateAndTimeResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tds__SetSystemDateAndTimeResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__SetSystemDateAndTimeResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__SetSystemDateAndTimeResponse(struct soap *soap, const char *tag, struct _tds__SetSystemDateAndTimeResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__SetSystemDateAndTimeResponse **)soap_malloc(soap, sizeof(struct _tds__SetSystemDateAndTimeResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__SetSystemDateAndTimeResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__SetSystemDateAndTimeResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetSystemDateAndTimeResponse, sizeof(struct _tds__SetSystemDateAndTimeResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetSystemDateAndTimeResponse(struct soap *soap, struct _tds__SetSystemDateAndTimeResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__SetSystemDateAndTimeResponse);
	if (soap_out_PointerTo_tds__SetSystemDateAndTimeResponse(soap, tag?tag:"tds:SetSystemDateAndTimeResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetSystemDateAndTimeResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__SetSystemDateAndTimeResponse(struct soap *soap, struct _tds__SetSystemDateAndTimeResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetSystemDateAndTimeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetSystemDateAndTime(struct soap *soap, struct _tds__SetSystemDateAndTime *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetSystemDateAndTime))
		soap_serialize__tds__SetSystemDateAndTime(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetSystemDateAndTime(struct soap *soap, const char *tag, int id, struct _tds__SetSystemDateAndTime *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetSystemDateAndTime);
	if (id < 0)
		return soap->error;
	return soap_out__tds__SetSystemDateAndTime(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__SetSystemDateAndTime ** SOAP_FMAC4 soap_in_PointerTo_tds__SetSystemDateAndTime(struct soap *soap, const char *tag, struct _tds__SetSystemDateAndTime **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__SetSystemDateAndTime **)soap_malloc(soap, sizeof(struct _tds__SetSystemDateAndTime *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__SetSystemDateAndTime(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__SetSystemDateAndTime **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetSystemDateAndTime, sizeof(struct _tds__SetSystemDateAndTime), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetSystemDateAndTime(struct soap *soap, struct _tds__SetSystemDateAndTime *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__SetSystemDateAndTime);
	if (soap_out_PointerTo_tds__SetSystemDateAndTime(soap, tag?tag:"tds:SetSystemDateAndTime", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetSystemDateAndTime ** SOAP_FMAC4 soap_get_PointerTo_tds__SetSystemDateAndTime(struct soap *soap, struct _tds__SetSystemDateAndTime **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetSystemDateAndTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetDeviceInformationResponse(struct soap *soap, struct _tds__GetDeviceInformationResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetDeviceInformationResponse))
		soap_serialize__tds__GetDeviceInformationResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetDeviceInformationResponse(struct soap *soap, const char *tag, int id, struct _tds__GetDeviceInformationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetDeviceInformationResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tds__GetDeviceInformationResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__GetDeviceInformationResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__GetDeviceInformationResponse(struct soap *soap, const char *tag, struct _tds__GetDeviceInformationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__GetDeviceInformationResponse **)soap_malloc(soap, sizeof(struct _tds__GetDeviceInformationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__GetDeviceInformationResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__GetDeviceInformationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetDeviceInformationResponse, sizeof(struct _tds__GetDeviceInformationResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetDeviceInformationResponse(struct soap *soap, struct _tds__GetDeviceInformationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetDeviceInformationResponse);
	if (soap_out_PointerTo_tds__GetDeviceInformationResponse(soap, tag?tag:"tds:GetDeviceInformationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetDeviceInformationResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__GetDeviceInformationResponse(struct soap *soap, struct _tds__GetDeviceInformationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetDeviceInformationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetDeviceInformation(struct soap *soap, struct _tds__GetDeviceInformation *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetDeviceInformation))
		soap_serialize__tds__GetDeviceInformation(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetDeviceInformation(struct soap *soap, const char *tag, int id, struct _tds__GetDeviceInformation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetDeviceInformation);
	if (id < 0)
		return soap->error;
	return soap_out__tds__GetDeviceInformation(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__GetDeviceInformation ** SOAP_FMAC4 soap_in_PointerTo_tds__GetDeviceInformation(struct soap *soap, const char *tag, struct _tds__GetDeviceInformation **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__GetDeviceInformation **)soap_malloc(soap, sizeof(struct _tds__GetDeviceInformation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__GetDeviceInformation(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__GetDeviceInformation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetDeviceInformation, sizeof(struct _tds__GetDeviceInformation), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetDeviceInformation(struct soap *soap, struct _tds__GetDeviceInformation *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetDeviceInformation);
	if (soap_out_PointerTo_tds__GetDeviceInformation(soap, tag?tag:"tds:GetDeviceInformation", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetDeviceInformation ** SOAP_FMAC4 soap_get_PointerTo_tds__GetDeviceInformation(struct soap *soap, struct _tds__GetDeviceInformation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetDeviceInformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetServiceCapabilitiesResponse(struct soap *soap, struct _tds__GetServiceCapabilitiesResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetServiceCapabilitiesResponse))
		soap_serialize__tds__GetServiceCapabilitiesResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetServiceCapabilitiesResponse(struct soap *soap, const char *tag, int id, struct _tds__GetServiceCapabilitiesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetServiceCapabilitiesResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tds__GetServiceCapabilitiesResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__GetServiceCapabilitiesResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__GetServiceCapabilitiesResponse(struct soap *soap, const char *tag, struct _tds__GetServiceCapabilitiesResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__GetServiceCapabilitiesResponse **)soap_malloc(soap, sizeof(struct _tds__GetServiceCapabilitiesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__GetServiceCapabilitiesResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__GetServiceCapabilitiesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetServiceCapabilitiesResponse, sizeof(struct _tds__GetServiceCapabilitiesResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetServiceCapabilitiesResponse(struct soap *soap, struct _tds__GetServiceCapabilitiesResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetServiceCapabilitiesResponse);
	if (soap_out_PointerTo_tds__GetServiceCapabilitiesResponse(soap, tag?tag:"tds:GetServiceCapabilitiesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetServiceCapabilitiesResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__GetServiceCapabilitiesResponse(struct soap *soap, struct _tds__GetServiceCapabilitiesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetServiceCapabilitiesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetServiceCapabilities(struct soap *soap, struct _tds__GetServiceCapabilities *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetServiceCapabilities))
		soap_serialize__tds__GetServiceCapabilities(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetServiceCapabilities(struct soap *soap, const char *tag, int id, struct _tds__GetServiceCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetServiceCapabilities);
	if (id < 0)
		return soap->error;
	return soap_out__tds__GetServiceCapabilities(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__GetServiceCapabilities ** SOAP_FMAC4 soap_in_PointerTo_tds__GetServiceCapabilities(struct soap *soap, const char *tag, struct _tds__GetServiceCapabilities **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__GetServiceCapabilities **)soap_malloc(soap, sizeof(struct _tds__GetServiceCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__GetServiceCapabilities(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__GetServiceCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetServiceCapabilities, sizeof(struct _tds__GetServiceCapabilities), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetServiceCapabilities(struct soap *soap, struct _tds__GetServiceCapabilities *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetServiceCapabilities);
	if (soap_out_PointerTo_tds__GetServiceCapabilities(soap, tag?tag:"tds:GetServiceCapabilities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetServiceCapabilities ** SOAP_FMAC4 soap_get_PointerTo_tds__GetServiceCapabilities(struct soap *soap, struct _tds__GetServiceCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetServiceCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetServicesResponse(struct soap *soap, struct _tds__GetServicesResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetServicesResponse))
		soap_serialize__tds__GetServicesResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetServicesResponse(struct soap *soap, const char *tag, int id, struct _tds__GetServicesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetServicesResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tds__GetServicesResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__GetServicesResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__GetServicesResponse(struct soap *soap, const char *tag, struct _tds__GetServicesResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__GetServicesResponse **)soap_malloc(soap, sizeof(struct _tds__GetServicesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__GetServicesResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__GetServicesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetServicesResponse, sizeof(struct _tds__GetServicesResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetServicesResponse(struct soap *soap, struct _tds__GetServicesResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetServicesResponse);
	if (soap_out_PointerTo_tds__GetServicesResponse(soap, tag?tag:"tds:GetServicesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetServicesResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__GetServicesResponse(struct soap *soap, struct _tds__GetServicesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetServicesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetServices(struct soap *soap, struct _tds__GetServices *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetServices))
		soap_serialize__tds__GetServices(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetServices(struct soap *soap, const char *tag, int id, struct _tds__GetServices *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetServices);
	if (id < 0)
		return soap->error;
	return soap_out__tds__GetServices(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__GetServices ** SOAP_FMAC4 soap_in_PointerTo_tds__GetServices(struct soap *soap, const char *tag, struct _tds__GetServices **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__GetServices **)soap_malloc(soap, sizeof(struct _tds__GetServices *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__GetServices(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__GetServices **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetServices, sizeof(struct _tds__GetServices), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetServices(struct soap *soap, struct _tds__GetServices *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetServices);
	if (soap_out_PointerTo_tds__GetServices(soap, tag?tag:"tds:GetServices", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetServices ** SOAP_FMAC4 soap_get_PointerTo_tds__GetServices(struct soap *soap, struct _tds__GetServices **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetServices(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTod__ByeType(struct soap *soap, struct d__ByeType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_d__ByeType))
		soap_serialize_d__ByeType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTod__ByeType(struct soap *soap, const char *tag, int id, struct d__ByeType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_d__ByeType);
	if (id < 0)
		return soap->error;
	return soap_out_d__ByeType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct d__ByeType ** SOAP_FMAC4 soap_in_PointerTod__ByeType(struct soap *soap, const char *tag, struct d__ByeType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct d__ByeType **)soap_malloc(soap, sizeof(struct d__ByeType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_d__ByeType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct d__ByeType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_d__ByeType, sizeof(struct d__ByeType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTod__ByeType(struct soap *soap, struct d__ByeType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTod__ByeType);
	if (soap_out_PointerTod__ByeType(soap, tag?tag:"d:ByeType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct d__ByeType ** SOAP_FMAC4 soap_get_PointerTod__ByeType(struct soap *soap, struct d__ByeType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTod__ByeType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTod__ResolveType(struct soap *soap, struct d__ResolveType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_d__ResolveType))
		soap_serialize_d__ResolveType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTod__ResolveType(struct soap *soap, const char *tag, int id, struct d__ResolveType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_d__ResolveType);
	if (id < 0)
		return soap->error;
	return soap_out_d__ResolveType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct d__ResolveType ** SOAP_FMAC4 soap_in_PointerTod__ResolveType(struct soap *soap, const char *tag, struct d__ResolveType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct d__ResolveType **)soap_malloc(soap, sizeof(struct d__ResolveType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_d__ResolveType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct d__ResolveType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_d__ResolveType, sizeof(struct d__ResolveType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTod__ResolveType(struct soap *soap, struct d__ResolveType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTod__ResolveType);
	if (soap_out_PointerTod__ResolveType(soap, tag?tag:"d:ResolveType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct d__ResolveType ** SOAP_FMAC4 soap_get_PointerTod__ResolveType(struct soap *soap, struct d__ResolveType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTod__ResolveType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTod__HelloType(struct soap *soap, struct d__HelloType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_d__HelloType))
		soap_serialize_d__HelloType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTod__HelloType(struct soap *soap, const char *tag, int id, struct d__HelloType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_d__HelloType);
	if (id < 0)
		return soap->error;
	return soap_out_d__HelloType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct d__HelloType ** SOAP_FMAC4 soap_in_PointerTod__HelloType(struct soap *soap, const char *tag, struct d__HelloType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct d__HelloType **)soap_malloc(soap, sizeof(struct d__HelloType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_d__HelloType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct d__HelloType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_d__HelloType, sizeof(struct d__HelloType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTod__HelloType(struct soap *soap, struct d__HelloType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTod__HelloType);
	if (soap_out_PointerTod__HelloType(soap, tag?tag:"d:HelloType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct d__HelloType ** SOAP_FMAC4 soap_get_PointerTod__HelloType(struct soap *soap, struct d__HelloType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTod__HelloType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTod__ProbeMatchesType(struct soap *soap, struct d__ProbeMatchesType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_d__ProbeMatchesType))
		soap_serialize_d__ProbeMatchesType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTod__ProbeMatchesType(struct soap *soap, const char *tag, int id, struct d__ProbeMatchesType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_d__ProbeMatchesType);
	if (id < 0)
		return soap->error;
	return soap_out_d__ProbeMatchesType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct d__ProbeMatchesType ** SOAP_FMAC4 soap_in_PointerTod__ProbeMatchesType(struct soap *soap, const char *tag, struct d__ProbeMatchesType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct d__ProbeMatchesType **)soap_malloc(soap, sizeof(struct d__ProbeMatchesType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_d__ProbeMatchesType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct d__ProbeMatchesType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_d__ProbeMatchesType, sizeof(struct d__ProbeMatchesType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTod__ProbeMatchesType(struct soap *soap, struct d__ProbeMatchesType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTod__ProbeMatchesType);
	if (soap_out_PointerTod__ProbeMatchesType(soap, tag?tag:"d:ProbeMatchesType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct d__ProbeMatchesType ** SOAP_FMAC4 soap_get_PointerTod__ProbeMatchesType(struct soap *soap, struct d__ProbeMatchesType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTod__ProbeMatchesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTod__ProbeType(struct soap *soap, struct d__ProbeType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_d__ProbeType))
		soap_serialize_d__ProbeType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTod__ProbeType(struct soap *soap, const char *tag, int id, struct d__ProbeType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_d__ProbeType);
	if (id < 0)
		return soap->error;
	return soap_out_d__ProbeType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct d__ProbeType ** SOAP_FMAC4 soap_in_PointerTod__ProbeType(struct soap *soap, const char *tag, struct d__ProbeType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct d__ProbeType **)soap_malloc(soap, sizeof(struct d__ProbeType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_d__ProbeType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct d__ProbeType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_d__ProbeType, sizeof(struct d__ProbeType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTod__ProbeType(struct soap *soap, struct d__ProbeType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTod__ProbeType);
	if (soap_out_PointerTod__ProbeType(soap, tag?tag:"d:ProbeType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct d__ProbeType ** SOAP_FMAC4 soap_get_PointerTod__ProbeType(struct soap *soap, struct d__ProbeType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTod__ProbeType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wstop__TopicNamespaceType_Topic(struct soap *soap, struct _wstop__TopicNamespaceType_Topic *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__wstop__TopicNamespaceType_Topic))
		soap_serialize__wstop__TopicNamespaceType_Topic(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wstop__TopicNamespaceType_Topic(struct soap *soap, const char *tag, int id, struct _wstop__TopicNamespaceType_Topic *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wstop__TopicNamespaceType_Topic);
	if (id < 0)
		return soap->error;
	return soap_out__wstop__TopicNamespaceType_Topic(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wstop__TopicNamespaceType_Topic ** SOAP_FMAC4 soap_in_PointerTo_wstop__TopicNamespaceType_Topic(struct soap *soap, const char *tag, struct _wstop__TopicNamespaceType_Topic **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wstop__TopicNamespaceType_Topic **)soap_malloc(soap, sizeof(struct _wstop__TopicNamespaceType_Topic *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wstop__TopicNamespaceType_Topic(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wstop__TopicNamespaceType_Topic **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wstop__TopicNamespaceType_Topic, sizeof(struct _wstop__TopicNamespaceType_Topic), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wstop__TopicNamespaceType_Topic(struct soap *soap, struct _wstop__TopicNamespaceType_Topic *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wstop__TopicNamespaceType_Topic);
	if (soap_out_PointerTo_wstop__TopicNamespaceType_Topic(soap, tag?tag:"wstop:TopicNamespaceType-Topic", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wstop__TopicNamespaceType_Topic ** SOAP_FMAC4 soap_get_PointerTo_wstop__TopicNamespaceType_Topic(struct soap *soap, struct _wstop__TopicNamespaceType_Topic **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wstop__TopicNamespaceType_Topic(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowstop__ConcreteTopicExpression(struct soap *soap, char **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_wstop__ConcreteTopicExpression))
		soap_serialize_wstop__ConcreteTopicExpression(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowstop__ConcreteTopicExpression(struct soap *soap, const char *tag, int id, char **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wstop__ConcreteTopicExpression);
	if (id < 0)
		return soap->error;
	return soap_out_wstop__ConcreteTopicExpression(soap, tag, id, *a, type);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_in_PointerTowstop__ConcreteTopicExpression(struct soap *soap, const char *tag, char ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (char ***)soap_malloc(soap, sizeof(char **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wstop__ConcreteTopicExpression(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (char ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wstop__ConcreteTopicExpression, sizeof(char *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowstop__ConcreteTopicExpression(struct soap *soap, char **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowstop__ConcreteTopicExpression);
	if (soap_out_PointerTowstop__ConcreteTopicExpression(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_get_PointerTowstop__ConcreteTopicExpression(struct soap *soap, char ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowstop__ConcreteTopicExpression(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowstop__TopicType(struct soap *soap, struct wstop__TopicType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_wstop__TopicType))
		soap_serialize_wstop__TopicType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowstop__TopicType(struct soap *soap, const char *tag, int id, struct wstop__TopicType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wstop__TopicType);
	if (id < 0)
		return soap->error;
	return soap_out_wstop__TopicType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wstop__TopicType ** SOAP_FMAC4 soap_in_PointerTowstop__TopicType(struct soap *soap, const char *tag, struct wstop__TopicType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wstop__TopicType **)soap_malloc(soap, sizeof(struct wstop__TopicType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wstop__TopicType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wstop__TopicType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wstop__TopicType, sizeof(struct wstop__TopicType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowstop__TopicType(struct soap *soap, struct wstop__TopicType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowstop__TopicType);
	if (soap_out_PointerTowstop__TopicType(soap, tag?tag:"wstop:TopicType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wstop__TopicType ** SOAP_FMAC4 soap_get_PointerTowstop__TopicType(struct soap *soap, struct wstop__TopicType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowstop__TopicType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowstop__QueryExpressionType(struct soap *soap, struct wstop__QueryExpressionType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_wstop__QueryExpressionType))
		soap_serialize_wstop__QueryExpressionType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowstop__QueryExpressionType(struct soap *soap, const char *tag, int id, struct wstop__QueryExpressionType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wstop__QueryExpressionType);
	if (id < 0)
		return soap->error;
	return soap_out_wstop__QueryExpressionType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wstop__QueryExpressionType ** SOAP_FMAC4 soap_in_PointerTowstop__QueryExpressionType(struct soap *soap, const char *tag, struct wstop__QueryExpressionType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wstop__QueryExpressionType **)soap_malloc(soap, sizeof(struct wstop__QueryExpressionType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wstop__QueryExpressionType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wstop__QueryExpressionType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wstop__QueryExpressionType, sizeof(struct wstop__QueryExpressionType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowstop__QueryExpressionType(struct soap *soap, struct wstop__QueryExpressionType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowstop__QueryExpressionType);
	if (soap_out_PointerTowstop__QueryExpressionType(soap, tag?tag:"wstop:QueryExpressionType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wstop__QueryExpressionType ** SOAP_FMAC4 soap_get_PointerTowstop__QueryExpressionType(struct soap *soap, struct wstop__QueryExpressionType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowstop__QueryExpressionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__ResumeFailedFaultType_FaultCause(struct soap *soap, struct _wsnt__ResumeFailedFaultType_FaultCause *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__ResumeFailedFaultType_FaultCause))
		soap_serialize__wsnt__ResumeFailedFaultType_FaultCause(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__ResumeFailedFaultType_FaultCause(struct soap *soap, const char *tag, int id, struct _wsnt__ResumeFailedFaultType_FaultCause *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__ResumeFailedFaultType_FaultCause);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__ResumeFailedFaultType_FaultCause(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__ResumeFailedFaultType_FaultCause ** SOAP_FMAC4 soap_in_PointerTo_wsnt__ResumeFailedFaultType_FaultCause(struct soap *soap, const char *tag, struct _wsnt__ResumeFailedFaultType_FaultCause **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__ResumeFailedFaultType_FaultCause **)soap_malloc(soap, sizeof(struct _wsnt__ResumeFailedFaultType_FaultCause *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__ResumeFailedFaultType_FaultCause(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__ResumeFailedFaultType_FaultCause **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__ResumeFailedFaultType_FaultCause, sizeof(struct _wsnt__ResumeFailedFaultType_FaultCause), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__ResumeFailedFaultType_FaultCause(struct soap *soap, struct _wsnt__ResumeFailedFaultType_FaultCause *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsnt__ResumeFailedFaultType_FaultCause);
	if (soap_out_PointerTo_wsnt__ResumeFailedFaultType_FaultCause(soap, tag?tag:"wsnt:ResumeFailedFaultType-FaultCause", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__ResumeFailedFaultType_FaultCause ** SOAP_FMAC4 soap_get_PointerTo_wsnt__ResumeFailedFaultType_FaultCause(struct soap *soap, struct _wsnt__ResumeFailedFaultType_FaultCause **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__ResumeFailedFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__ResumeFailedFaultType_Description(struct soap *soap, struct _wsnt__ResumeFailedFaultType_Description *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__ResumeFailedFaultType_Description))
		soap_serialize__wsnt__ResumeFailedFaultType_Description(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__ResumeFailedFaultType_Description(struct soap *soap, const char *tag, int id, struct _wsnt__ResumeFailedFaultType_Description *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__ResumeFailedFaultType_Description);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__ResumeFailedFaultType_Description(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__ResumeFailedFaultType_Description ** SOAP_FMAC4 soap_in_PointerTo_wsnt__ResumeFailedFaultType_Description(struct soap *soap, const char *tag, struct _wsnt__ResumeFailedFaultType_Description **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__ResumeFailedFaultType_Description **)soap_malloc(soap, sizeof(struct _wsnt__ResumeFailedFaultType_Description *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__ResumeFailedFaultType_Description(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__ResumeFailedFaultType_Description **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__ResumeFailedFaultType_Description, sizeof(struct _wsnt__ResumeFailedFaultType_Description), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__ResumeFailedFaultType_Description(struct soap *soap, struct _wsnt__ResumeFailedFaultType_Description *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsnt__ResumeFailedFaultType_Description);
	if (soap_out_PointerTo_wsnt__ResumeFailedFaultType_Description(soap, tag?tag:"wsnt:ResumeFailedFaultType-Description", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__ResumeFailedFaultType_Description ** SOAP_FMAC4 soap_get_PointerTo_wsnt__ResumeFailedFaultType_Description(struct soap *soap, struct _wsnt__ResumeFailedFaultType_Description **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__ResumeFailedFaultType_Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__ResumeFailedFaultType_ErrorCode(struct soap *soap, struct _wsnt__ResumeFailedFaultType_ErrorCode *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__ResumeFailedFaultType_ErrorCode))
		soap_serialize__wsnt__ResumeFailedFaultType_ErrorCode(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__ResumeFailedFaultType_ErrorCode(struct soap *soap, const char *tag, int id, struct _wsnt__ResumeFailedFaultType_ErrorCode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__ResumeFailedFaultType_ErrorCode);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__ResumeFailedFaultType_ErrorCode(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__ResumeFailedFaultType_ErrorCode ** SOAP_FMAC4 soap_in_PointerTo_wsnt__ResumeFailedFaultType_ErrorCode(struct soap *soap, const char *tag, struct _wsnt__ResumeFailedFaultType_ErrorCode **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__ResumeFailedFaultType_ErrorCode **)soap_malloc(soap, sizeof(struct _wsnt__ResumeFailedFaultType_ErrorCode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__ResumeFailedFaultType_ErrorCode(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__ResumeFailedFaultType_ErrorCode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__ResumeFailedFaultType_ErrorCode, sizeof(struct _wsnt__ResumeFailedFaultType_ErrorCode), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__ResumeFailedFaultType_ErrorCode(struct soap *soap, struct _wsnt__ResumeFailedFaultType_ErrorCode *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsnt__ResumeFailedFaultType_ErrorCode);
	if (soap_out_PointerTo_wsnt__ResumeFailedFaultType_ErrorCode(soap, tag?tag:"wsnt:ResumeFailedFaultType-ErrorCode", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__ResumeFailedFaultType_ErrorCode ** SOAP_FMAC4 soap_get_PointerTo_wsnt__ResumeFailedFaultType_ErrorCode(struct soap *soap, struct _wsnt__ResumeFailedFaultType_ErrorCode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__ResumeFailedFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__PauseFailedFaultType_FaultCause(struct soap *soap, struct _wsnt__PauseFailedFaultType_FaultCause *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__PauseFailedFaultType_FaultCause))
		soap_serialize__wsnt__PauseFailedFaultType_FaultCause(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__PauseFailedFaultType_FaultCause(struct soap *soap, const char *tag, int id, struct _wsnt__PauseFailedFaultType_FaultCause *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__PauseFailedFaultType_FaultCause);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__PauseFailedFaultType_FaultCause(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__PauseFailedFaultType_FaultCause ** SOAP_FMAC4 soap_in_PointerTo_wsnt__PauseFailedFaultType_FaultCause(struct soap *soap, const char *tag, struct _wsnt__PauseFailedFaultType_FaultCause **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__PauseFailedFaultType_FaultCause **)soap_malloc(soap, sizeof(struct _wsnt__PauseFailedFaultType_FaultCause *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__PauseFailedFaultType_FaultCause(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__PauseFailedFaultType_FaultCause **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__PauseFailedFaultType_FaultCause, sizeof(struct _wsnt__PauseFailedFaultType_FaultCause), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__PauseFailedFaultType_FaultCause(struct soap *soap, struct _wsnt__PauseFailedFaultType_FaultCause *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsnt__PauseFailedFaultType_FaultCause);
	if (soap_out_PointerTo_wsnt__PauseFailedFaultType_FaultCause(soap, tag?tag:"wsnt:PauseFailedFaultType-FaultCause", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__PauseFailedFaultType_FaultCause ** SOAP_FMAC4 soap_get_PointerTo_wsnt__PauseFailedFaultType_FaultCause(struct soap *soap, struct _wsnt__PauseFailedFaultType_FaultCause **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__PauseFailedFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__PauseFailedFaultType_Description(struct soap *soap, struct _wsnt__PauseFailedFaultType_Description *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__PauseFailedFaultType_Description))
		soap_serialize__wsnt__PauseFailedFaultType_Description(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__PauseFailedFaultType_Description(struct soap *soap, const char *tag, int id, struct _wsnt__PauseFailedFaultType_Description *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__PauseFailedFaultType_Description);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__PauseFailedFaultType_Description(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__PauseFailedFaultType_Description ** SOAP_FMAC4 soap_in_PointerTo_wsnt__PauseFailedFaultType_Description(struct soap *soap, const char *tag, struct _wsnt__PauseFailedFaultType_Description **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__PauseFailedFaultType_Description **)soap_malloc(soap, sizeof(struct _wsnt__PauseFailedFaultType_Description *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__PauseFailedFaultType_Description(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__PauseFailedFaultType_Description **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__PauseFailedFaultType_Description, sizeof(struct _wsnt__PauseFailedFaultType_Description), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__PauseFailedFaultType_Description(struct soap *soap, struct _wsnt__PauseFailedFaultType_Description *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsnt__PauseFailedFaultType_Description);
	if (soap_out_PointerTo_wsnt__PauseFailedFaultType_Description(soap, tag?tag:"wsnt:PauseFailedFaultType-Description", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__PauseFailedFaultType_Description ** SOAP_FMAC4 soap_get_PointerTo_wsnt__PauseFailedFaultType_Description(struct soap *soap, struct _wsnt__PauseFailedFaultType_Description **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__PauseFailedFaultType_Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__PauseFailedFaultType_ErrorCode(struct soap *soap, struct _wsnt__PauseFailedFaultType_ErrorCode *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__PauseFailedFaultType_ErrorCode))
		soap_serialize__wsnt__PauseFailedFaultType_ErrorCode(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__PauseFailedFaultType_ErrorCode(struct soap *soap, const char *tag, int id, struct _wsnt__PauseFailedFaultType_ErrorCode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__PauseFailedFaultType_ErrorCode);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__PauseFailedFaultType_ErrorCode(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__PauseFailedFaultType_ErrorCode ** SOAP_FMAC4 soap_in_PointerTo_wsnt__PauseFailedFaultType_ErrorCode(struct soap *soap, const char *tag, struct _wsnt__PauseFailedFaultType_ErrorCode **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__PauseFailedFaultType_ErrorCode **)soap_malloc(soap, sizeof(struct _wsnt__PauseFailedFaultType_ErrorCode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__PauseFailedFaultType_ErrorCode(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__PauseFailedFaultType_ErrorCode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__PauseFailedFaultType_ErrorCode, sizeof(struct _wsnt__PauseFailedFaultType_ErrorCode), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__PauseFailedFaultType_ErrorCode(struct soap *soap, struct _wsnt__PauseFailedFaultType_ErrorCode *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsnt__PauseFailedFaultType_ErrorCode);
	if (soap_out_PointerTo_wsnt__PauseFailedFaultType_ErrorCode(soap, tag?tag:"wsnt:PauseFailedFaultType-ErrorCode", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__PauseFailedFaultType_ErrorCode ** SOAP_FMAC4 soap_get_PointerTo_wsnt__PauseFailedFaultType_ErrorCode(struct soap *soap, struct _wsnt__PauseFailedFaultType_ErrorCode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__PauseFailedFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__UnableToDestroySubscriptionFaultType_FaultCause(struct soap *soap, struct _wsnt__UnableToDestroySubscriptionFaultType_FaultCause *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__UnableToDestroySubscriptionFaultType_FaultCause))
		soap_serialize__wsnt__UnableToDestroySubscriptionFaultType_FaultCause(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__UnableToDestroySubscriptionFaultType_FaultCause(struct soap *soap, const char *tag, int id, struct _wsnt__UnableToDestroySubscriptionFaultType_FaultCause *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__UnableToDestroySubscriptionFaultType_FaultCause);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__UnableToDestroySubscriptionFaultType_FaultCause(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__UnableToDestroySubscriptionFaultType_FaultCause ** SOAP_FMAC4 soap_in_PointerTo_wsnt__UnableToDestroySubscriptionFaultType_FaultCause(struct soap *soap, const char *tag, struct _wsnt__UnableToDestroySubscriptionFaultType_FaultCause **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__UnableToDestroySubscriptionFaultType_FaultCause **)soap_malloc(soap, sizeof(struct _wsnt__UnableToDestroySubscriptionFaultType_FaultCause *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__UnableToDestroySubscriptionFaultType_FaultCause(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__UnableToDestroySubscriptionFaultType_FaultCause **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__UnableToDestroySubscriptionFaultType_FaultCause, sizeof(struct _wsnt__UnableToDestroySubscriptionFaultType_FaultCause), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__UnableToDestroySubscriptionFaultType_FaultCause(struct soap *soap, struct _wsnt__UnableToDestroySubscriptionFaultType_FaultCause *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsnt__UnableToDestroySubscriptionFaultType_FaultCause);
	if (soap_out_PointerTo_wsnt__UnableToDestroySubscriptionFaultType_FaultCause(soap, tag?tag:"wsnt:UnableToDestroySubscriptionFaultType-FaultCause", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnableToDestroySubscriptionFaultType_FaultCause ** SOAP_FMAC4 soap_get_PointerTo_wsnt__UnableToDestroySubscriptionFaultType_FaultCause(struct soap *soap, struct _wsnt__UnableToDestroySubscriptionFaultType_FaultCause **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__UnableToDestroySubscriptionFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__UnableToDestroySubscriptionFaultType_Description(struct soap *soap, struct _wsnt__UnableToDestroySubscriptionFaultType_Description *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__UnableToDestroySubscriptionFaultType_Description))
		soap_serialize__wsnt__UnableToDestroySubscriptionFaultType_Description(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__UnableToDestroySubscriptionFaultType_Description(struct soap *soap, const char *tag, int id, struct _wsnt__UnableToDestroySubscriptionFaultType_Description *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__UnableToDestroySubscriptionFaultType_Description);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__UnableToDestroySubscriptionFaultType_Description(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__UnableToDestroySubscriptionFaultType_Description ** SOAP_FMAC4 soap_in_PointerTo_wsnt__UnableToDestroySubscriptionFaultType_Description(struct soap *soap, const char *tag, struct _wsnt__UnableToDestroySubscriptionFaultType_Description **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__UnableToDestroySubscriptionFaultType_Description **)soap_malloc(soap, sizeof(struct _wsnt__UnableToDestroySubscriptionFaultType_Description *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__UnableToDestroySubscriptionFaultType_Description(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__UnableToDestroySubscriptionFaultType_Description **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__UnableToDestroySubscriptionFaultType_Description, sizeof(struct _wsnt__UnableToDestroySubscriptionFaultType_Description), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__UnableToDestroySubscriptionFaultType_Description(struct soap *soap, struct _wsnt__UnableToDestroySubscriptionFaultType_Description *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsnt__UnableToDestroySubscriptionFaultType_Description);
	if (soap_out_PointerTo_wsnt__UnableToDestroySubscriptionFaultType_Description(soap, tag?tag:"wsnt:UnableToDestroySubscriptionFaultType-Description", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnableToDestroySubscriptionFaultType_Description ** SOAP_FMAC4 soap_get_PointerTo_wsnt__UnableToDestroySubscriptionFaultType_Description(struct soap *soap, struct _wsnt__UnableToDestroySubscriptionFaultType_Description **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__UnableToDestroySubscriptionFaultType_Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__UnableToDestroySubscriptionFaultType_ErrorCode(struct soap *soap, struct _wsnt__UnableToDestroySubscriptionFaultType_ErrorCode *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__UnableToDestroySubscriptionFaultType_ErrorCode))
		soap_serialize__wsnt__UnableToDestroySubscriptionFaultType_ErrorCode(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__UnableToDestroySubscriptionFaultType_ErrorCode(struct soap *soap, const char *tag, int id, struct _wsnt__UnableToDestroySubscriptionFaultType_ErrorCode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__UnableToDestroySubscriptionFaultType_ErrorCode);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__UnableToDestroySubscriptionFaultType_ErrorCode(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__UnableToDestroySubscriptionFaultType_ErrorCode ** SOAP_FMAC4 soap_in_PointerTo_wsnt__UnableToDestroySubscriptionFaultType_ErrorCode(struct soap *soap, const char *tag, struct _wsnt__UnableToDestroySubscriptionFaultType_ErrorCode **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__UnableToDestroySubscriptionFaultType_ErrorCode **)soap_malloc(soap, sizeof(struct _wsnt__UnableToDestroySubscriptionFaultType_ErrorCode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__UnableToDestroySubscriptionFaultType_ErrorCode(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__UnableToDestroySubscriptionFaultType_ErrorCode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__UnableToDestroySubscriptionFaultType_ErrorCode, sizeof(struct _wsnt__UnableToDestroySubscriptionFaultType_ErrorCode), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__UnableToDestroySubscriptionFaultType_ErrorCode(struct soap *soap, struct _wsnt__UnableToDestroySubscriptionFaultType_ErrorCode *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsnt__UnableToDestroySubscriptionFaultType_ErrorCode);
	if (soap_out_PointerTo_wsnt__UnableToDestroySubscriptionFaultType_ErrorCode(soap, tag?tag:"wsnt:UnableToDestroySubscriptionFaultType-ErrorCode", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnableToDestroySubscriptionFaultType_ErrorCode ** SOAP_FMAC4 soap_get_PointerTo_wsnt__UnableToDestroySubscriptionFaultType_ErrorCode(struct soap *soap, struct _wsnt__UnableToDestroySubscriptionFaultType_ErrorCode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__UnableToDestroySubscriptionFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__UnacceptableTerminationTimeFaultType_FaultCause(struct soap *soap, struct _wsnt__UnacceptableTerminationTimeFaultType_FaultCause *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__UnacceptableTerminationTimeFaultType_FaultCause))
		soap_serialize__wsnt__UnacceptableTerminationTimeFaultType_FaultCause(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__UnacceptableTerminationTimeFaultType_FaultCause(struct soap *soap, const char *tag, int id, struct _wsnt__UnacceptableTerminationTimeFaultType_FaultCause *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__UnacceptableTerminationTimeFaultType_FaultCause);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__UnacceptableTerminationTimeFaultType_FaultCause(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__UnacceptableTerminationTimeFaultType_FaultCause ** SOAP_FMAC4 soap_in_PointerTo_wsnt__UnacceptableTerminationTimeFaultType_FaultCause(struct soap *soap, const char *tag, struct _wsnt__UnacceptableTerminationTimeFaultType_FaultCause **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__UnacceptableTerminationTimeFaultType_FaultCause **)soap_malloc(soap, sizeof(struct _wsnt__UnacceptableTerminationTimeFaultType_FaultCause *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__UnacceptableTerminationTimeFaultType_FaultCause(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__UnacceptableTerminationTimeFaultType_FaultCause **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__UnacceptableTerminationTimeFaultType_FaultCause, sizeof(struct _wsnt__UnacceptableTerminationTimeFaultType_FaultCause), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__UnacceptableTerminationTimeFaultType_FaultCause(struct soap *soap, struct _wsnt__UnacceptableTerminationTimeFaultType_FaultCause *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsnt__UnacceptableTerminationTimeFaultType_FaultCause);
	if (soap_out_PointerTo_wsnt__UnacceptableTerminationTimeFaultType_FaultCause(soap, tag?tag:"wsnt:UnacceptableTerminationTimeFaultType-FaultCause", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnacceptableTerminationTimeFaultType_FaultCause ** SOAP_FMAC4 soap_get_PointerTo_wsnt__UnacceptableTerminationTimeFaultType_FaultCause(struct soap *soap, struct _wsnt__UnacceptableTerminationTimeFaultType_FaultCause **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__UnacceptableTerminationTimeFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__UnacceptableTerminationTimeFaultType_Description(struct soap *soap, struct _wsnt__UnacceptableTerminationTimeFaultType_Description *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__UnacceptableTerminationTimeFaultType_Description))
		soap_serialize__wsnt__UnacceptableTerminationTimeFaultType_Description(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__UnacceptableTerminationTimeFaultType_Description(struct soap *soap, const char *tag, int id, struct _wsnt__UnacceptableTerminationTimeFaultType_Description *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__UnacceptableTerminationTimeFaultType_Description);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__UnacceptableTerminationTimeFaultType_Description(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__UnacceptableTerminationTimeFaultType_Description ** SOAP_FMAC4 soap_in_PointerTo_wsnt__UnacceptableTerminationTimeFaultType_Description(struct soap *soap, const char *tag, struct _wsnt__UnacceptableTerminationTimeFaultType_Description **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__UnacceptableTerminationTimeFaultType_Description **)soap_malloc(soap, sizeof(struct _wsnt__UnacceptableTerminationTimeFaultType_Description *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__UnacceptableTerminationTimeFaultType_Description(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__UnacceptableTerminationTimeFaultType_Description **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__UnacceptableTerminationTimeFaultType_Description, sizeof(struct _wsnt__UnacceptableTerminationTimeFaultType_Description), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__UnacceptableTerminationTimeFaultType_Description(struct soap *soap, struct _wsnt__UnacceptableTerminationTimeFaultType_Description *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsnt__UnacceptableTerminationTimeFaultType_Description);
	if (soap_out_PointerTo_wsnt__UnacceptableTerminationTimeFaultType_Description(soap, tag?tag:"wsnt:UnacceptableTerminationTimeFaultType-Description", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnacceptableTerminationTimeFaultType_Description ** SOAP_FMAC4 soap_get_PointerTo_wsnt__UnacceptableTerminationTimeFaultType_Description(struct soap *soap, struct _wsnt__UnacceptableTerminationTimeFaultType_Description **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__UnacceptableTerminationTimeFaultType_Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__UnacceptableTerminationTimeFaultType_ErrorCode(struct soap *soap, struct _wsnt__UnacceptableTerminationTimeFaultType_ErrorCode *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__UnacceptableTerminationTimeFaultType_ErrorCode))
		soap_serialize__wsnt__UnacceptableTerminationTimeFaultType_ErrorCode(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__UnacceptableTerminationTimeFaultType_ErrorCode(struct soap *soap, const char *tag, int id, struct _wsnt__UnacceptableTerminationTimeFaultType_ErrorCode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__UnacceptableTerminationTimeFaultType_ErrorCode);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__UnacceptableTerminationTimeFaultType_ErrorCode(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__UnacceptableTerminationTimeFaultType_ErrorCode ** SOAP_FMAC4 soap_in_PointerTo_wsnt__UnacceptableTerminationTimeFaultType_ErrorCode(struct soap *soap, const char *tag, struct _wsnt__UnacceptableTerminationTimeFaultType_ErrorCode **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__UnacceptableTerminationTimeFaultType_ErrorCode **)soap_malloc(soap, sizeof(struct _wsnt__UnacceptableTerminationTimeFaultType_ErrorCode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__UnacceptableTerminationTimeFaultType_ErrorCode(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__UnacceptableTerminationTimeFaultType_ErrorCode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__UnacceptableTerminationTimeFaultType_ErrorCode, sizeof(struct _wsnt__UnacceptableTerminationTimeFaultType_ErrorCode), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__UnacceptableTerminationTimeFaultType_ErrorCode(struct soap *soap, struct _wsnt__UnacceptableTerminationTimeFaultType_ErrorCode *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsnt__UnacceptableTerminationTimeFaultType_ErrorCode);
	if (soap_out_PointerTo_wsnt__UnacceptableTerminationTimeFaultType_ErrorCode(soap, tag?tag:"wsnt:UnacceptableTerminationTimeFaultType-ErrorCode", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnacceptableTerminationTimeFaultType_ErrorCode ** SOAP_FMAC4 soap_get_PointerTo_wsnt__UnacceptableTerminationTimeFaultType_ErrorCode(struct soap *soap, struct _wsnt__UnacceptableTerminationTimeFaultType_ErrorCode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__UnacceptableTerminationTimeFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__UnableToCreatePullPointFaultType_FaultCause(struct soap *soap, struct _wsnt__UnableToCreatePullPointFaultType_FaultCause *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__UnableToCreatePullPointFaultType_FaultCause))
		soap_serialize__wsnt__UnableToCreatePullPointFaultType_FaultCause(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__UnableToCreatePullPointFaultType_FaultCause(struct soap *soap, const char *tag, int id, struct _wsnt__UnableToCreatePullPointFaultType_FaultCause *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__UnableToCreatePullPointFaultType_FaultCause);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__UnableToCreatePullPointFaultType_FaultCause(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__UnableToCreatePullPointFaultType_FaultCause ** SOAP_FMAC4 soap_in_PointerTo_wsnt__UnableToCreatePullPointFaultType_FaultCause(struct soap *soap, const char *tag, struct _wsnt__UnableToCreatePullPointFaultType_FaultCause **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__UnableToCreatePullPointFaultType_FaultCause **)soap_malloc(soap, sizeof(struct _wsnt__UnableToCreatePullPointFaultType_FaultCause *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__UnableToCreatePullPointFaultType_FaultCause(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__UnableToCreatePullPointFaultType_FaultCause **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__UnableToCreatePullPointFaultType_FaultCause, sizeof(struct _wsnt__UnableToCreatePullPointFaultType_FaultCause), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__UnableToCreatePullPointFaultType_FaultCause(struct soap *soap, struct _wsnt__UnableToCreatePullPointFaultType_FaultCause *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsnt__UnableToCreatePullPointFaultType_FaultCause);
	if (soap_out_PointerTo_wsnt__UnableToCreatePullPointFaultType_FaultCause(soap, tag?tag:"wsnt:UnableToCreatePullPointFaultType-FaultCause", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnableToCreatePullPointFaultType_FaultCause ** SOAP_FMAC4 soap_get_PointerTo_wsnt__UnableToCreatePullPointFaultType_FaultCause(struct soap *soap, struct _wsnt__UnableToCreatePullPointFaultType_FaultCause **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__UnableToCreatePullPointFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__UnableToCreatePullPointFaultType_Description(struct soap *soap, struct _wsnt__UnableToCreatePullPointFaultType_Description *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__UnableToCreatePullPointFaultType_Description))
		soap_serialize__wsnt__UnableToCreatePullPointFaultType_Description(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__UnableToCreatePullPointFaultType_Description(struct soap *soap, const char *tag, int id, struct _wsnt__UnableToCreatePullPointFaultType_Description *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__UnableToCreatePullPointFaultType_Description);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__UnableToCreatePullPointFaultType_Description(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__UnableToCreatePullPointFaultType_Description ** SOAP_FMAC4 soap_in_PointerTo_wsnt__UnableToCreatePullPointFaultType_Description(struct soap *soap, const char *tag, struct _wsnt__UnableToCreatePullPointFaultType_Description **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__UnableToCreatePullPointFaultType_Description **)soap_malloc(soap, sizeof(struct _wsnt__UnableToCreatePullPointFaultType_Description *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__UnableToCreatePullPointFaultType_Description(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__UnableToCreatePullPointFaultType_Description **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__UnableToCreatePullPointFaultType_Description, sizeof(struct _wsnt__UnableToCreatePullPointFaultType_Description), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__UnableToCreatePullPointFaultType_Description(struct soap *soap, struct _wsnt__UnableToCreatePullPointFaultType_Description *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsnt__UnableToCreatePullPointFaultType_Description);
	if (soap_out_PointerTo_wsnt__UnableToCreatePullPointFaultType_Description(soap, tag?tag:"wsnt:UnableToCreatePullPointFaultType-Description", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnableToCreatePullPointFaultType_Description ** SOAP_FMAC4 soap_get_PointerTo_wsnt__UnableToCreatePullPointFaultType_Description(struct soap *soap, struct _wsnt__UnableToCreatePullPointFaultType_Description **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__UnableToCreatePullPointFaultType_Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__UnableToCreatePullPointFaultType_ErrorCode(struct soap *soap, struct _wsnt__UnableToCreatePullPointFaultType_ErrorCode *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__UnableToCreatePullPointFaultType_ErrorCode))
		soap_serialize__wsnt__UnableToCreatePullPointFaultType_ErrorCode(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__UnableToCreatePullPointFaultType_ErrorCode(struct soap *soap, const char *tag, int id, struct _wsnt__UnableToCreatePullPointFaultType_ErrorCode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__UnableToCreatePullPointFaultType_ErrorCode);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__UnableToCreatePullPointFaultType_ErrorCode(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__UnableToCreatePullPointFaultType_ErrorCode ** SOAP_FMAC4 soap_in_PointerTo_wsnt__UnableToCreatePullPointFaultType_ErrorCode(struct soap *soap, const char *tag, struct _wsnt__UnableToCreatePullPointFaultType_ErrorCode **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__UnableToCreatePullPointFaultType_ErrorCode **)soap_malloc(soap, sizeof(struct _wsnt__UnableToCreatePullPointFaultType_ErrorCode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__UnableToCreatePullPointFaultType_ErrorCode(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__UnableToCreatePullPointFaultType_ErrorCode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__UnableToCreatePullPointFaultType_ErrorCode, sizeof(struct _wsnt__UnableToCreatePullPointFaultType_ErrorCode), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__UnableToCreatePullPointFaultType_ErrorCode(struct soap *soap, struct _wsnt__UnableToCreatePullPointFaultType_ErrorCode *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsnt__UnableToCreatePullPointFaultType_ErrorCode);
	if (soap_out_PointerTo_wsnt__UnableToCreatePullPointFaultType_ErrorCode(soap, tag?tag:"wsnt:UnableToCreatePullPointFaultType-ErrorCode", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnableToCreatePullPointFaultType_ErrorCode ** SOAP_FMAC4 soap_get_PointerTo_wsnt__UnableToCreatePullPointFaultType_ErrorCode(struct soap *soap, struct _wsnt__UnableToCreatePullPointFaultType_ErrorCode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__UnableToCreatePullPointFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__UnableToDestroyPullPointFaultType_FaultCause(struct soap *soap, struct _wsnt__UnableToDestroyPullPointFaultType_FaultCause *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__UnableToDestroyPullPointFaultType_FaultCause))
		soap_serialize__wsnt__UnableToDestroyPullPointFaultType_FaultCause(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__UnableToDestroyPullPointFaultType_FaultCause(struct soap *soap, const char *tag, int id, struct _wsnt__UnableToDestroyPullPointFaultType_FaultCause *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__UnableToDestroyPullPointFaultType_FaultCause);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__UnableToDestroyPullPointFaultType_FaultCause(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__UnableToDestroyPullPointFaultType_FaultCause ** SOAP_FMAC4 soap_in_PointerTo_wsnt__UnableToDestroyPullPointFaultType_FaultCause(struct soap *soap, const char *tag, struct _wsnt__UnableToDestroyPullPointFaultType_FaultCause **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__UnableToDestroyPullPointFaultType_FaultCause **)soap_malloc(soap, sizeof(struct _wsnt__UnableToDestroyPullPointFaultType_FaultCause *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__UnableToDestroyPullPointFaultType_FaultCause(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__UnableToDestroyPullPointFaultType_FaultCause **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__UnableToDestroyPullPointFaultType_FaultCause, sizeof(struct _wsnt__UnableToDestroyPullPointFaultType_FaultCause), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__UnableToDestroyPullPointFaultType_FaultCause(struct soap *soap, struct _wsnt__UnableToDestroyPullPointFaultType_FaultCause *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsnt__UnableToDestroyPullPointFaultType_FaultCause);
	if (soap_out_PointerTo_wsnt__UnableToDestroyPullPointFaultType_FaultCause(soap, tag?tag:"wsnt:UnableToDestroyPullPointFaultType-FaultCause", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnableToDestroyPullPointFaultType_FaultCause ** SOAP_FMAC4 soap_get_PointerTo_wsnt__UnableToDestroyPullPointFaultType_FaultCause(struct soap *soap, struct _wsnt__UnableToDestroyPullPointFaultType_FaultCause **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__UnableToDestroyPullPointFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__UnableToDestroyPullPointFaultType_Description(struct soap *soap, struct _wsnt__UnableToDestroyPullPointFaultType_Description *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__UnableToDestroyPullPointFaultType_Description))
		soap_serialize__wsnt__UnableToDestroyPullPointFaultType_Description(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__UnableToDestroyPullPointFaultType_Description(struct soap *soap, const char *tag, int id, struct _wsnt__UnableToDestroyPullPointFaultType_Description *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__UnableToDestroyPullPointFaultType_Description);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__UnableToDestroyPullPointFaultType_Description(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__UnableToDestroyPullPointFaultType_Description ** SOAP_FMAC4 soap_in_PointerTo_wsnt__UnableToDestroyPullPointFaultType_Description(struct soap *soap, const char *tag, struct _wsnt__UnableToDestroyPullPointFaultType_Description **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__UnableToDestroyPullPointFaultType_Description **)soap_malloc(soap, sizeof(struct _wsnt__UnableToDestroyPullPointFaultType_Description *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__UnableToDestroyPullPointFaultType_Description(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__UnableToDestroyPullPointFaultType_Description **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__UnableToDestroyPullPointFaultType_Description, sizeof(struct _wsnt__UnableToDestroyPullPointFaultType_Description), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__UnableToDestroyPullPointFaultType_Description(struct soap *soap, struct _wsnt__UnableToDestroyPullPointFaultType_Description *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsnt__UnableToDestroyPullPointFaultType_Description);
	if (soap_out_PointerTo_wsnt__UnableToDestroyPullPointFaultType_Description(soap, tag?tag:"wsnt:UnableToDestroyPullPointFaultType-Description", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnableToDestroyPullPointFaultType_Description ** SOAP_FMAC4 soap_get_PointerTo_wsnt__UnableToDestroyPullPointFaultType_Description(struct soap *soap, struct _wsnt__UnableToDestroyPullPointFaultType_Description **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__UnableToDestroyPullPointFaultType_Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__UnableToDestroyPullPointFaultType_ErrorCode(struct soap *soap, struct _wsnt__UnableToDestroyPullPointFaultType_ErrorCode *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__UnableToDestroyPullPointFaultType_ErrorCode))
		soap_serialize__wsnt__UnableToDestroyPullPointFaultType_ErrorCode(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__UnableToDestroyPullPointFaultType_ErrorCode(struct soap *soap, const char *tag, int id, struct _wsnt__UnableToDestroyPullPointFaultType_ErrorCode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__UnableToDestroyPullPointFaultType_ErrorCode);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__UnableToDestroyPullPointFaultType_ErrorCode(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__UnableToDestroyPullPointFaultType_ErrorCode ** SOAP_FMAC4 soap_in_PointerTo_wsnt__UnableToDestroyPullPointFaultType_ErrorCode(struct soap *soap, const char *tag, struct _wsnt__UnableToDestroyPullPointFaultType_ErrorCode **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__UnableToDestroyPullPointFaultType_ErrorCode **)soap_malloc(soap, sizeof(struct _wsnt__UnableToDestroyPullPointFaultType_ErrorCode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__UnableToDestroyPullPointFaultType_ErrorCode(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__UnableToDestroyPullPointFaultType_ErrorCode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__UnableToDestroyPullPointFaultType_ErrorCode, sizeof(struct _wsnt__UnableToDestroyPullPointFaultType_ErrorCode), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__UnableToDestroyPullPointFaultType_ErrorCode(struct soap *soap, struct _wsnt__UnableToDestroyPullPointFaultType_ErrorCode *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsnt__UnableToDestroyPullPointFaultType_ErrorCode);
	if (soap_out_PointerTo_wsnt__UnableToDestroyPullPointFaultType_ErrorCode(soap, tag?tag:"wsnt:UnableToDestroyPullPointFaultType-ErrorCode", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnableToDestroyPullPointFaultType_ErrorCode ** SOAP_FMAC4 soap_get_PointerTo_wsnt__UnableToDestroyPullPointFaultType_ErrorCode(struct soap *soap, struct _wsnt__UnableToDestroyPullPointFaultType_ErrorCode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__UnableToDestroyPullPointFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__UnableToGetMessagesFaultType_FaultCause(struct soap *soap, struct _wsnt__UnableToGetMessagesFaultType_FaultCause *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__UnableToGetMessagesFaultType_FaultCause))
		soap_serialize__wsnt__UnableToGetMessagesFaultType_FaultCause(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__UnableToGetMessagesFaultType_FaultCause(struct soap *soap, const char *tag, int id, struct _wsnt__UnableToGetMessagesFaultType_FaultCause *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__UnableToGetMessagesFaultType_FaultCause);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__UnableToGetMessagesFaultType_FaultCause(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__UnableToGetMessagesFaultType_FaultCause ** SOAP_FMAC4 soap_in_PointerTo_wsnt__UnableToGetMessagesFaultType_FaultCause(struct soap *soap, const char *tag, struct _wsnt__UnableToGetMessagesFaultType_FaultCause **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__UnableToGetMessagesFaultType_FaultCause **)soap_malloc(soap, sizeof(struct _wsnt__UnableToGetMessagesFaultType_FaultCause *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__UnableToGetMessagesFaultType_FaultCause(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__UnableToGetMessagesFaultType_FaultCause **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__UnableToGetMessagesFaultType_FaultCause, sizeof(struct _wsnt__UnableToGetMessagesFaultType_FaultCause), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__UnableToGetMessagesFaultType_FaultCause(struct soap *soap, struct _wsnt__UnableToGetMessagesFaultType_FaultCause *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsnt__UnableToGetMessagesFaultType_FaultCause);
	if (soap_out_PointerTo_wsnt__UnableToGetMessagesFaultType_FaultCause(soap, tag?tag:"wsnt:UnableToGetMessagesFaultType-FaultCause", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnableToGetMessagesFaultType_FaultCause ** SOAP_FMAC4 soap_get_PointerTo_wsnt__UnableToGetMessagesFaultType_FaultCause(struct soap *soap, struct _wsnt__UnableToGetMessagesFaultType_FaultCause **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__UnableToGetMessagesFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__UnableToGetMessagesFaultType_Description(struct soap *soap, struct _wsnt__UnableToGetMessagesFaultType_Description *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__UnableToGetMessagesFaultType_Description))
		soap_serialize__wsnt__UnableToGetMessagesFaultType_Description(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__UnableToGetMessagesFaultType_Description(struct soap *soap, const char *tag, int id, struct _wsnt__UnableToGetMessagesFaultType_Description *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__UnableToGetMessagesFaultType_Description);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__UnableToGetMessagesFaultType_Description(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__UnableToGetMessagesFaultType_Description ** SOAP_FMAC4 soap_in_PointerTo_wsnt__UnableToGetMessagesFaultType_Description(struct soap *soap, const char *tag, struct _wsnt__UnableToGetMessagesFaultType_Description **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__UnableToGetMessagesFaultType_Description **)soap_malloc(soap, sizeof(struct _wsnt__UnableToGetMessagesFaultType_Description *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__UnableToGetMessagesFaultType_Description(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__UnableToGetMessagesFaultType_Description **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__UnableToGetMessagesFaultType_Description, sizeof(struct _wsnt__UnableToGetMessagesFaultType_Description), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__UnableToGetMessagesFaultType_Description(struct soap *soap, struct _wsnt__UnableToGetMessagesFaultType_Description *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsnt__UnableToGetMessagesFaultType_Description);
	if (soap_out_PointerTo_wsnt__UnableToGetMessagesFaultType_Description(soap, tag?tag:"wsnt:UnableToGetMessagesFaultType-Description", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnableToGetMessagesFaultType_Description ** SOAP_FMAC4 soap_get_PointerTo_wsnt__UnableToGetMessagesFaultType_Description(struct soap *soap, struct _wsnt__UnableToGetMessagesFaultType_Description **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__UnableToGetMessagesFaultType_Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__UnableToGetMessagesFaultType_ErrorCode(struct soap *soap, struct _wsnt__UnableToGetMessagesFaultType_ErrorCode *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__UnableToGetMessagesFaultType_ErrorCode))
		soap_serialize__wsnt__UnableToGetMessagesFaultType_ErrorCode(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__UnableToGetMessagesFaultType_ErrorCode(struct soap *soap, const char *tag, int id, struct _wsnt__UnableToGetMessagesFaultType_ErrorCode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__UnableToGetMessagesFaultType_ErrorCode);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__UnableToGetMessagesFaultType_ErrorCode(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__UnableToGetMessagesFaultType_ErrorCode ** SOAP_FMAC4 soap_in_PointerTo_wsnt__UnableToGetMessagesFaultType_ErrorCode(struct soap *soap, const char *tag, struct _wsnt__UnableToGetMessagesFaultType_ErrorCode **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__UnableToGetMessagesFaultType_ErrorCode **)soap_malloc(soap, sizeof(struct _wsnt__UnableToGetMessagesFaultType_ErrorCode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__UnableToGetMessagesFaultType_ErrorCode(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__UnableToGetMessagesFaultType_ErrorCode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__UnableToGetMessagesFaultType_ErrorCode, sizeof(struct _wsnt__UnableToGetMessagesFaultType_ErrorCode), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__UnableToGetMessagesFaultType_ErrorCode(struct soap *soap, struct _wsnt__UnableToGetMessagesFaultType_ErrorCode *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsnt__UnableToGetMessagesFaultType_ErrorCode);
	if (soap_out_PointerTo_wsnt__UnableToGetMessagesFaultType_ErrorCode(soap, tag?tag:"wsnt:UnableToGetMessagesFaultType-ErrorCode", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnableToGetMessagesFaultType_ErrorCode ** SOAP_FMAC4 soap_get_PointerTo_wsnt__UnableToGetMessagesFaultType_ErrorCode(struct soap *soap, struct _wsnt__UnableToGetMessagesFaultType_ErrorCode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__UnableToGetMessagesFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__NoCurrentMessageOnTopicFaultType_FaultCause(struct soap *soap, struct _wsnt__NoCurrentMessageOnTopicFaultType_FaultCause *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__NoCurrentMessageOnTopicFaultType_FaultCause))
		soap_serialize__wsnt__NoCurrentMessageOnTopicFaultType_FaultCause(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__NoCurrentMessageOnTopicFaultType_FaultCause(struct soap *soap, const char *tag, int id, struct _wsnt__NoCurrentMessageOnTopicFaultType_FaultCause *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__NoCurrentMessageOnTopicFaultType_FaultCause);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__NoCurrentMessageOnTopicFaultType_FaultCause(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__NoCurrentMessageOnTopicFaultType_FaultCause ** SOAP_FMAC4 soap_in_PointerTo_wsnt__NoCurrentMessageOnTopicFaultType_FaultCause(struct soap *soap, const char *tag, struct _wsnt__NoCurrentMessageOnTopicFaultType_FaultCause **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__NoCurrentMessageOnTopicFaultType_FaultCause **)soap_malloc(soap, sizeof(struct _wsnt__NoCurrentMessageOnTopicFaultType_FaultCause *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__NoCurrentMessageOnTopicFaultType_FaultCause(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__NoCurrentMessageOnTopicFaultType_FaultCause **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__NoCurrentMessageOnTopicFaultType_FaultCause, sizeof(struct _wsnt__NoCurrentMessageOnTopicFaultType_FaultCause), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__NoCurrentMessageOnTopicFaultType_FaultCause(struct soap *soap, struct _wsnt__NoCurrentMessageOnTopicFaultType_FaultCause *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsnt__NoCurrentMessageOnTopicFaultType_FaultCause);
	if (soap_out_PointerTo_wsnt__NoCurrentMessageOnTopicFaultType_FaultCause(soap, tag?tag:"wsnt:NoCurrentMessageOnTopicFaultType-FaultCause", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__NoCurrentMessageOnTopicFaultType_FaultCause ** SOAP_FMAC4 soap_get_PointerTo_wsnt__NoCurrentMessageOnTopicFaultType_FaultCause(struct soap *soap, struct _wsnt__NoCurrentMessageOnTopicFaultType_FaultCause **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__NoCurrentMessageOnTopicFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__NoCurrentMessageOnTopicFaultType_Description(struct soap *soap, struct _wsnt__NoCurrentMessageOnTopicFaultType_Description *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__NoCurrentMessageOnTopicFaultType_Description))
		soap_serialize__wsnt__NoCurrentMessageOnTopicFaultType_Description(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__NoCurrentMessageOnTopicFaultType_Description(struct soap *soap, const char *tag, int id, struct _wsnt__NoCurrentMessageOnTopicFaultType_Description *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__NoCurrentMessageOnTopicFaultType_Description);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__NoCurrentMessageOnTopicFaultType_Description(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__NoCurrentMessageOnTopicFaultType_Description ** SOAP_FMAC4 soap_in_PointerTo_wsnt__NoCurrentMessageOnTopicFaultType_Description(struct soap *soap, const char *tag, struct _wsnt__NoCurrentMessageOnTopicFaultType_Description **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__NoCurrentMessageOnTopicFaultType_Description **)soap_malloc(soap, sizeof(struct _wsnt__NoCurrentMessageOnTopicFaultType_Description *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__NoCurrentMessageOnTopicFaultType_Description(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__NoCurrentMessageOnTopicFaultType_Description **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__NoCurrentMessageOnTopicFaultType_Description, sizeof(struct _wsnt__NoCurrentMessageOnTopicFaultType_Description), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__NoCurrentMessageOnTopicFaultType_Description(struct soap *soap, struct _wsnt__NoCurrentMessageOnTopicFaultType_Description *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsnt__NoCurrentMessageOnTopicFaultType_Description);
	if (soap_out_PointerTo_wsnt__NoCurrentMessageOnTopicFaultType_Description(soap, tag?tag:"wsnt:NoCurrentMessageOnTopicFaultType-Description", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__NoCurrentMessageOnTopicFaultType_Description ** SOAP_FMAC4 soap_get_PointerTo_wsnt__NoCurrentMessageOnTopicFaultType_Description(struct soap *soap, struct _wsnt__NoCurrentMessageOnTopicFaultType_Description **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__NoCurrentMessageOnTopicFaultType_Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode(struct soap *soap, struct _wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode))
		soap_serialize__wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode(struct soap *soap, const char *tag, int id, struct _wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode ** SOAP_FMAC4 soap_in_PointerTo_wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode(struct soap *soap, const char *tag, struct _wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode **)soap_malloc(soap, sizeof(struct _wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode, sizeof(struct _wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode(struct soap *soap, struct _wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode);
	if (soap_out_PointerTo_wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode(soap, tag?tag:"wsnt:NoCurrentMessageOnTopicFaultType-ErrorCode", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode ** SOAP_FMAC4 soap_get_PointerTo_wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode(struct soap *soap, struct _wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause(struct soap *soap, struct _wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause))
		soap_serialize__wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause(struct soap *soap, const char *tag, int id, struct _wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause ** SOAP_FMAC4 soap_in_PointerTo_wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause(struct soap *soap, const char *tag, struct _wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause **)soap_malloc(soap, sizeof(struct _wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause, sizeof(struct _wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause(struct soap *soap, struct _wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause);
	if (soap_out_PointerTo_wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause(soap, tag?tag:"wsnt:UnacceptableInitialTerminationTimeFaultType-FaultCause", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause ** SOAP_FMAC4 soap_get_PointerTo_wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause(struct soap *soap, struct _wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__UnacceptableInitialTerminationTimeFaultType_Description(struct soap *soap, struct _wsnt__UnacceptableInitialTerminationTimeFaultType_Description *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__UnacceptableInitialTerminationTimeFaultType_Description))
		soap_serialize__wsnt__UnacceptableInitialTerminationTimeFaultType_Description(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__UnacceptableInitialTerminationTimeFaultType_Description(struct soap *soap, const char *tag, int id, struct _wsnt__UnacceptableInitialTerminationTimeFaultType_Description *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__UnacceptableInitialTerminationTimeFaultType_Description);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__UnacceptableInitialTerminationTimeFaultType_Description(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__UnacceptableInitialTerminationTimeFaultType_Description ** SOAP_FMAC4 soap_in_PointerTo_wsnt__UnacceptableInitialTerminationTimeFaultType_Description(struct soap *soap, const char *tag, struct _wsnt__UnacceptableInitialTerminationTimeFaultType_Description **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__UnacceptableInitialTerminationTimeFaultType_Description **)soap_malloc(soap, sizeof(struct _wsnt__UnacceptableInitialTerminationTimeFaultType_Description *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__UnacceptableInitialTerminationTimeFaultType_Description(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__UnacceptableInitialTerminationTimeFaultType_Description **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__UnacceptableInitialTerminationTimeFaultType_Description, sizeof(struct _wsnt__UnacceptableInitialTerminationTimeFaultType_Description), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__UnacceptableInitialTerminationTimeFaultType_Description(struct soap *soap, struct _wsnt__UnacceptableInitialTerminationTimeFaultType_Description *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsnt__UnacceptableInitialTerminationTimeFaultType_Description);
	if (soap_out_PointerTo_wsnt__UnacceptableInitialTerminationTimeFaultType_Description(soap, tag?tag:"wsnt:UnacceptableInitialTerminationTimeFaultType-Description", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnacceptableInitialTerminationTimeFaultType_Description ** SOAP_FMAC4 soap_get_PointerTo_wsnt__UnacceptableInitialTerminationTimeFaultType_Description(struct soap *soap, struct _wsnt__UnacceptableInitialTerminationTimeFaultType_Description **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__UnacceptableInitialTerminationTimeFaultType_Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode(struct soap *soap, struct _wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode))
		soap_serialize__wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode(struct soap *soap, const char *tag, int id, struct _wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode ** SOAP_FMAC4 soap_in_PointerTo_wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode(struct soap *soap, const char *tag, struct _wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode **)soap_malloc(soap, sizeof(struct _wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode, sizeof(struct _wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode(struct soap *soap, struct _wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode);
	if (soap_out_PointerTo_wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode(soap, tag?tag:"wsnt:UnacceptableInitialTerminationTimeFaultType-ErrorCode", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode ** SOAP_FMAC4 soap_get_PointerTo_wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode(struct soap *soap, struct _wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__NotifyMessageNotSupportedFaultType_FaultCause(struct soap *soap, struct _wsnt__NotifyMessageNotSupportedFaultType_FaultCause *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__NotifyMessageNotSupportedFaultType_FaultCause))
		soap_serialize__wsnt__NotifyMessageNotSupportedFaultType_FaultCause(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__NotifyMessageNotSupportedFaultType_FaultCause(struct soap *soap, const char *tag, int id, struct _wsnt__NotifyMessageNotSupportedFaultType_FaultCause *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__NotifyMessageNotSupportedFaultType_FaultCause);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__NotifyMessageNotSupportedFaultType_FaultCause(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__NotifyMessageNotSupportedFaultType_FaultCause ** SOAP_FMAC4 soap_in_PointerTo_wsnt__NotifyMessageNotSupportedFaultType_FaultCause(struct soap *soap, const char *tag, struct _wsnt__NotifyMessageNotSupportedFaultType_FaultCause **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__NotifyMessageNotSupportedFaultType_FaultCause **)soap_malloc(soap, sizeof(struct _wsnt__NotifyMessageNotSupportedFaultType_FaultCause *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__NotifyMessageNotSupportedFaultType_FaultCause(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__NotifyMessageNotSupportedFaultType_FaultCause **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__NotifyMessageNotSupportedFaultType_FaultCause, sizeof(struct _wsnt__NotifyMessageNotSupportedFaultType_FaultCause), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__NotifyMessageNotSupportedFaultType_FaultCause(struct soap *soap, struct _wsnt__NotifyMessageNotSupportedFaultType_FaultCause *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsnt__NotifyMessageNotSupportedFaultType_FaultCause);
	if (soap_out_PointerTo_wsnt__NotifyMessageNotSupportedFaultType_FaultCause(soap, tag?tag:"wsnt:NotifyMessageNotSupportedFaultType-FaultCause", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__NotifyMessageNotSupportedFaultType_FaultCause ** SOAP_FMAC4 soap_get_PointerTo_wsnt__NotifyMessageNotSupportedFaultType_FaultCause(struct soap *soap, struct _wsnt__NotifyMessageNotSupportedFaultType_FaultCause **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__NotifyMessageNotSupportedFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__NotifyMessageNotSupportedFaultType_Description(struct soap *soap, struct _wsnt__NotifyMessageNotSupportedFaultType_Description *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__NotifyMessageNotSupportedFaultType_Description))
		soap_serialize__wsnt__NotifyMessageNotSupportedFaultType_Description(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__NotifyMessageNotSupportedFaultType_Description(struct soap *soap, const char *tag, int id, struct _wsnt__NotifyMessageNotSupportedFaultType_Description *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__NotifyMessageNotSupportedFaultType_Description);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__NotifyMessageNotSupportedFaultType_Description(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__NotifyMessageNotSupportedFaultType_Description ** SOAP_FMAC4 soap_in_PointerTo_wsnt__NotifyMessageNotSupportedFaultType_Description(struct soap *soap, const char *tag, struct _wsnt__NotifyMessageNotSupportedFaultType_Description **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__NotifyMessageNotSupportedFaultType_Description **)soap_malloc(soap, sizeof(struct _wsnt__NotifyMessageNotSupportedFaultType_Description *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__NotifyMessageNotSupportedFaultType_Description(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__NotifyMessageNotSupportedFaultType_Description **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__NotifyMessageNotSupportedFaultType_Description, sizeof(struct _wsnt__NotifyMessageNotSupportedFaultType_Description), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__NotifyMessageNotSupportedFaultType_Description(struct soap *soap, struct _wsnt__NotifyMessageNotSupportedFaultType_Description *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsnt__NotifyMessageNotSupportedFaultType_Description);
	if (soap_out_PointerTo_wsnt__NotifyMessageNotSupportedFaultType_Description(soap, tag?tag:"wsnt:NotifyMessageNotSupportedFaultType-Description", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__NotifyMessageNotSupportedFaultType_Description ** SOAP_FMAC4 soap_get_PointerTo_wsnt__NotifyMessageNotSupportedFaultType_Description(struct soap *soap, struct _wsnt__NotifyMessageNotSupportedFaultType_Description **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__NotifyMessageNotSupportedFaultType_Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__NotifyMessageNotSupportedFaultType_ErrorCode(struct soap *soap, struct _wsnt__NotifyMessageNotSupportedFaultType_ErrorCode *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__NotifyMessageNotSupportedFaultType_ErrorCode))
		soap_serialize__wsnt__NotifyMessageNotSupportedFaultType_ErrorCode(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__NotifyMessageNotSupportedFaultType_ErrorCode(struct soap *soap, const char *tag, int id, struct _wsnt__NotifyMessageNotSupportedFaultType_ErrorCode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__NotifyMessageNotSupportedFaultType_ErrorCode);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__NotifyMessageNotSupportedFaultType_ErrorCode(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__NotifyMessageNotSupportedFaultType_ErrorCode ** SOAP_FMAC4 soap_in_PointerTo_wsnt__NotifyMessageNotSupportedFaultType_ErrorCode(struct soap *soap, const char *tag, struct _wsnt__NotifyMessageNotSupportedFaultType_ErrorCode **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__NotifyMessageNotSupportedFaultType_ErrorCode **)soap_malloc(soap, sizeof(struct _wsnt__NotifyMessageNotSupportedFaultType_ErrorCode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__NotifyMessageNotSupportedFaultType_ErrorCode(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__NotifyMessageNotSupportedFaultType_ErrorCode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__NotifyMessageNotSupportedFaultType_ErrorCode, sizeof(struct _wsnt__NotifyMessageNotSupportedFaultType_ErrorCode), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__NotifyMessageNotSupportedFaultType_ErrorCode(struct soap *soap, struct _wsnt__NotifyMessageNotSupportedFaultType_ErrorCode *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsnt__NotifyMessageNotSupportedFaultType_ErrorCode);
	if (soap_out_PointerTo_wsnt__NotifyMessageNotSupportedFaultType_ErrorCode(soap, tag?tag:"wsnt:NotifyMessageNotSupportedFaultType-ErrorCode", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__NotifyMessageNotSupportedFaultType_ErrorCode ** SOAP_FMAC4 soap_get_PointerTo_wsnt__NotifyMessageNotSupportedFaultType_ErrorCode(struct soap *soap, struct _wsnt__NotifyMessageNotSupportedFaultType_ErrorCode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__NotifyMessageNotSupportedFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__UnsupportedPolicyRequestFaultType_FaultCause(struct soap *soap, struct _wsnt__UnsupportedPolicyRequestFaultType_FaultCause *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__UnsupportedPolicyRequestFaultType_FaultCause))
		soap_serialize__wsnt__UnsupportedPolicyRequestFaultType_FaultCause(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__UnsupportedPolicyRequestFaultType_FaultCause(struct soap *soap, const char *tag, int id, struct _wsnt__UnsupportedPolicyRequestFaultType_FaultCause *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__UnsupportedPolicyRequestFaultType_FaultCause);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__UnsupportedPolicyRequestFaultType_FaultCause(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__UnsupportedPolicyRequestFaultType_FaultCause ** SOAP_FMAC4 soap_in_PointerTo_wsnt__UnsupportedPolicyRequestFaultType_FaultCause(struct soap *soap, const char *tag, struct _wsnt__UnsupportedPolicyRequestFaultType_FaultCause **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__UnsupportedPolicyRequestFaultType_FaultCause **)soap_malloc(soap, sizeof(struct _wsnt__UnsupportedPolicyRequestFaultType_FaultCause *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__UnsupportedPolicyRequestFaultType_FaultCause(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__UnsupportedPolicyRequestFaultType_FaultCause **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__UnsupportedPolicyRequestFaultType_FaultCause, sizeof(struct _wsnt__UnsupportedPolicyRequestFaultType_FaultCause), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__UnsupportedPolicyRequestFaultType_FaultCause(struct soap *soap, struct _wsnt__UnsupportedPolicyRequestFaultType_FaultCause *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsnt__UnsupportedPolicyRequestFaultType_FaultCause);
	if (soap_out_PointerTo_wsnt__UnsupportedPolicyRequestFaultType_FaultCause(soap, tag?tag:"wsnt:UnsupportedPolicyRequestFaultType-FaultCause", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnsupportedPolicyRequestFaultType_FaultCause ** SOAP_FMAC4 soap_get_PointerTo_wsnt__UnsupportedPolicyRequestFaultType_FaultCause(struct soap *soap, struct _wsnt__UnsupportedPolicyRequestFaultType_FaultCause **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__UnsupportedPolicyRequestFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__UnsupportedPolicyRequestFaultType_Description(struct soap *soap, struct _wsnt__UnsupportedPolicyRequestFaultType_Description *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__UnsupportedPolicyRequestFaultType_Description))
		soap_serialize__wsnt__UnsupportedPolicyRequestFaultType_Description(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__UnsupportedPolicyRequestFaultType_Description(struct soap *soap, const char *tag, int id, struct _wsnt__UnsupportedPolicyRequestFaultType_Description *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__UnsupportedPolicyRequestFaultType_Description);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__UnsupportedPolicyRequestFaultType_Description(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__UnsupportedPolicyRequestFaultType_Description ** SOAP_FMAC4 soap_in_PointerTo_wsnt__UnsupportedPolicyRequestFaultType_Description(struct soap *soap, const char *tag, struct _wsnt__UnsupportedPolicyRequestFaultType_Description **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__UnsupportedPolicyRequestFaultType_Description **)soap_malloc(soap, sizeof(struct _wsnt__UnsupportedPolicyRequestFaultType_Description *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__UnsupportedPolicyRequestFaultType_Description(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__UnsupportedPolicyRequestFaultType_Description **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__UnsupportedPolicyRequestFaultType_Description, sizeof(struct _wsnt__UnsupportedPolicyRequestFaultType_Description), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__UnsupportedPolicyRequestFaultType_Description(struct soap *soap, struct _wsnt__UnsupportedPolicyRequestFaultType_Description *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsnt__UnsupportedPolicyRequestFaultType_Description);
	if (soap_out_PointerTo_wsnt__UnsupportedPolicyRequestFaultType_Description(soap, tag?tag:"wsnt:UnsupportedPolicyRequestFaultType-Description", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnsupportedPolicyRequestFaultType_Description ** SOAP_FMAC4 soap_get_PointerTo_wsnt__UnsupportedPolicyRequestFaultType_Description(struct soap *soap, struct _wsnt__UnsupportedPolicyRequestFaultType_Description **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__UnsupportedPolicyRequestFaultType_Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__UnsupportedPolicyRequestFaultType_ErrorCode(struct soap *soap, struct _wsnt__UnsupportedPolicyRequestFaultType_ErrorCode *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__UnsupportedPolicyRequestFaultType_ErrorCode))
		soap_serialize__wsnt__UnsupportedPolicyRequestFaultType_ErrorCode(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__UnsupportedPolicyRequestFaultType_ErrorCode(struct soap *soap, const char *tag, int id, struct _wsnt__UnsupportedPolicyRequestFaultType_ErrorCode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__UnsupportedPolicyRequestFaultType_ErrorCode);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__UnsupportedPolicyRequestFaultType_ErrorCode(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__UnsupportedPolicyRequestFaultType_ErrorCode ** SOAP_FMAC4 soap_in_PointerTo_wsnt__UnsupportedPolicyRequestFaultType_ErrorCode(struct soap *soap, const char *tag, struct _wsnt__UnsupportedPolicyRequestFaultType_ErrorCode **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__UnsupportedPolicyRequestFaultType_ErrorCode **)soap_malloc(soap, sizeof(struct _wsnt__UnsupportedPolicyRequestFaultType_ErrorCode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__UnsupportedPolicyRequestFaultType_ErrorCode(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__UnsupportedPolicyRequestFaultType_ErrorCode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__UnsupportedPolicyRequestFaultType_ErrorCode, sizeof(struct _wsnt__UnsupportedPolicyRequestFaultType_ErrorCode), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__UnsupportedPolicyRequestFaultType_ErrorCode(struct soap *soap, struct _wsnt__UnsupportedPolicyRequestFaultType_ErrorCode *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsnt__UnsupportedPolicyRequestFaultType_ErrorCode);
	if (soap_out_PointerTo_wsnt__UnsupportedPolicyRequestFaultType_ErrorCode(soap, tag?tag:"wsnt:UnsupportedPolicyRequestFaultType-ErrorCode", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnsupportedPolicyRequestFaultType_ErrorCode ** SOAP_FMAC4 soap_get_PointerTo_wsnt__UnsupportedPolicyRequestFaultType_ErrorCode(struct soap *soap, struct _wsnt__UnsupportedPolicyRequestFaultType_ErrorCode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__UnsupportedPolicyRequestFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__UnrecognizedPolicyRequestFaultType_FaultCause(struct soap *soap, struct _wsnt__UnrecognizedPolicyRequestFaultType_FaultCause *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__UnrecognizedPolicyRequestFaultType_FaultCause))
		soap_serialize__wsnt__UnrecognizedPolicyRequestFaultType_FaultCause(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__UnrecognizedPolicyRequestFaultType_FaultCause(struct soap *soap, const char *tag, int id, struct _wsnt__UnrecognizedPolicyRequestFaultType_FaultCause *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__UnrecognizedPolicyRequestFaultType_FaultCause);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__UnrecognizedPolicyRequestFaultType_FaultCause(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__UnrecognizedPolicyRequestFaultType_FaultCause ** SOAP_FMAC4 soap_in_PointerTo_wsnt__UnrecognizedPolicyRequestFaultType_FaultCause(struct soap *soap, const char *tag, struct _wsnt__UnrecognizedPolicyRequestFaultType_FaultCause **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__UnrecognizedPolicyRequestFaultType_FaultCause **)soap_malloc(soap, sizeof(struct _wsnt__UnrecognizedPolicyRequestFaultType_FaultCause *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__UnrecognizedPolicyRequestFaultType_FaultCause(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__UnrecognizedPolicyRequestFaultType_FaultCause **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__UnrecognizedPolicyRequestFaultType_FaultCause, sizeof(struct _wsnt__UnrecognizedPolicyRequestFaultType_FaultCause), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__UnrecognizedPolicyRequestFaultType_FaultCause(struct soap *soap, struct _wsnt__UnrecognizedPolicyRequestFaultType_FaultCause *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsnt__UnrecognizedPolicyRequestFaultType_FaultCause);
	if (soap_out_PointerTo_wsnt__UnrecognizedPolicyRequestFaultType_FaultCause(soap, tag?tag:"wsnt:UnrecognizedPolicyRequestFaultType-FaultCause", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnrecognizedPolicyRequestFaultType_FaultCause ** SOAP_FMAC4 soap_get_PointerTo_wsnt__UnrecognizedPolicyRequestFaultType_FaultCause(struct soap *soap, struct _wsnt__UnrecognizedPolicyRequestFaultType_FaultCause **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__UnrecognizedPolicyRequestFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__UnrecognizedPolicyRequestFaultType_Description(struct soap *soap, struct _wsnt__UnrecognizedPolicyRequestFaultType_Description *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__UnrecognizedPolicyRequestFaultType_Description))
		soap_serialize__wsnt__UnrecognizedPolicyRequestFaultType_Description(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__UnrecognizedPolicyRequestFaultType_Description(struct soap *soap, const char *tag, int id, struct _wsnt__UnrecognizedPolicyRequestFaultType_Description *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__UnrecognizedPolicyRequestFaultType_Description);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__UnrecognizedPolicyRequestFaultType_Description(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__UnrecognizedPolicyRequestFaultType_Description ** SOAP_FMAC4 soap_in_PointerTo_wsnt__UnrecognizedPolicyRequestFaultType_Description(struct soap *soap, const char *tag, struct _wsnt__UnrecognizedPolicyRequestFaultType_Description **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__UnrecognizedPolicyRequestFaultType_Description **)soap_malloc(soap, sizeof(struct _wsnt__UnrecognizedPolicyRequestFaultType_Description *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__UnrecognizedPolicyRequestFaultType_Description(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__UnrecognizedPolicyRequestFaultType_Description **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__UnrecognizedPolicyRequestFaultType_Description, sizeof(struct _wsnt__UnrecognizedPolicyRequestFaultType_Description), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__UnrecognizedPolicyRequestFaultType_Description(struct soap *soap, struct _wsnt__UnrecognizedPolicyRequestFaultType_Description *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsnt__UnrecognizedPolicyRequestFaultType_Description);
	if (soap_out_PointerTo_wsnt__UnrecognizedPolicyRequestFaultType_Description(soap, tag?tag:"wsnt:UnrecognizedPolicyRequestFaultType-Description", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnrecognizedPolicyRequestFaultType_Description ** SOAP_FMAC4 soap_get_PointerTo_wsnt__UnrecognizedPolicyRequestFaultType_Description(struct soap *soap, struct _wsnt__UnrecognizedPolicyRequestFaultType_Description **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__UnrecognizedPolicyRequestFaultType_Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode(struct soap *soap, struct _wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode))
		soap_serialize__wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode(struct soap *soap, const char *tag, int id, struct _wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode ** SOAP_FMAC4 soap_in_PointerTo_wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode(struct soap *soap, const char *tag, struct _wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode **)soap_malloc(soap, sizeof(struct _wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode, sizeof(struct _wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode(struct soap *soap, struct _wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode);
	if (soap_out_PointerTo_wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode(soap, tag?tag:"wsnt:UnrecognizedPolicyRequestFaultType-ErrorCode", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode ** SOAP_FMAC4 soap_get_PointerTo_wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode(struct soap *soap, struct _wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__InvalidMessageContentExpressionFaultType_FaultCause(struct soap *soap, struct _wsnt__InvalidMessageContentExpressionFaultType_FaultCause *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__InvalidMessageContentExpressionFaultType_FaultCause))
		soap_serialize__wsnt__InvalidMessageContentExpressionFaultType_FaultCause(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__InvalidMessageContentExpressionFaultType_FaultCause(struct soap *soap, const char *tag, int id, struct _wsnt__InvalidMessageContentExpressionFaultType_FaultCause *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__InvalidMessageContentExpressionFaultType_FaultCause);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__InvalidMessageContentExpressionFaultType_FaultCause(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__InvalidMessageContentExpressionFaultType_FaultCause ** SOAP_FMAC4 soap_in_PointerTo_wsnt__InvalidMessageContentExpressionFaultType_FaultCause(struct soap *soap, const char *tag, struct _wsnt__InvalidMessageContentExpressionFaultType_FaultCause **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__InvalidMessageContentExpressionFaultType_FaultCause **)soap_malloc(soap, sizeof(struct _wsnt__InvalidMessageContentExpressionFaultType_FaultCause *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__InvalidMessageContentExpressionFaultType_FaultCause(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__InvalidMessageContentExpressionFaultType_FaultCause **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__InvalidMessageContentExpressionFaultType_FaultCause, sizeof(struct _wsnt__InvalidMessageContentExpressionFaultType_FaultCause), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__InvalidMessageContentExpressionFaultType_FaultCause(struct soap *soap, struct _wsnt__InvalidMessageContentExpressionFaultType_FaultCause *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsnt__InvalidMessageContentExpressionFaultType_FaultCause);
	if (soap_out_PointerTo_wsnt__InvalidMessageContentExpressionFaultType_FaultCause(soap, tag?tag:"wsnt:InvalidMessageContentExpressionFaultType-FaultCause", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__InvalidMessageContentExpressionFaultType_FaultCause ** SOAP_FMAC4 soap_get_PointerTo_wsnt__InvalidMessageContentExpressionFaultType_FaultCause(struct soap *soap, struct _wsnt__InvalidMessageContentExpressionFaultType_FaultCause **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__InvalidMessageContentExpressionFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__InvalidMessageContentExpressionFaultType_Description(struct soap *soap, struct _wsnt__InvalidMessageContentExpressionFaultType_Description *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__InvalidMessageContentExpressionFaultType_Description))
		soap_serialize__wsnt__InvalidMessageContentExpressionFaultType_Description(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__InvalidMessageContentExpressionFaultType_Description(struct soap *soap, const char *tag, int id, struct _wsnt__InvalidMessageContentExpressionFaultType_Description *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__InvalidMessageContentExpressionFaultType_Description);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__InvalidMessageContentExpressionFaultType_Description(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__InvalidMessageContentExpressionFaultType_Description ** SOAP_FMAC4 soap_in_PointerTo_wsnt__InvalidMessageContentExpressionFaultType_Description(struct soap *soap, const char *tag, struct _wsnt__InvalidMessageContentExpressionFaultType_Description **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__InvalidMessageContentExpressionFaultType_Description **)soap_malloc(soap, sizeof(struct _wsnt__InvalidMessageContentExpressionFaultType_Description *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__InvalidMessageContentExpressionFaultType_Description(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__InvalidMessageContentExpressionFaultType_Description **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__InvalidMessageContentExpressionFaultType_Description, sizeof(struct _wsnt__InvalidMessageContentExpressionFaultType_Description), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__InvalidMessageContentExpressionFaultType_Description(struct soap *soap, struct _wsnt__InvalidMessageContentExpressionFaultType_Description *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsnt__InvalidMessageContentExpressionFaultType_Description);
	if (soap_out_PointerTo_wsnt__InvalidMessageContentExpressionFaultType_Description(soap, tag?tag:"wsnt:InvalidMessageContentExpressionFaultType-Description", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__InvalidMessageContentExpressionFaultType_Description ** SOAP_FMAC4 soap_get_PointerTo_wsnt__InvalidMessageContentExpressionFaultType_Description(struct soap *soap, struct _wsnt__InvalidMessageContentExpressionFaultType_Description **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__InvalidMessageContentExpressionFaultType_Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__InvalidMessageContentExpressionFaultType_ErrorCode(struct soap *soap, struct _wsnt__InvalidMessageContentExpressionFaultType_ErrorCode *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__InvalidMessageContentExpressionFaultType_ErrorCode))
		soap_serialize__wsnt__InvalidMessageContentExpressionFaultType_ErrorCode(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__InvalidMessageContentExpressionFaultType_ErrorCode(struct soap *soap, const char *tag, int id, struct _wsnt__InvalidMessageContentExpressionFaultType_ErrorCode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__InvalidMessageContentExpressionFaultType_ErrorCode);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__InvalidMessageContentExpressionFaultType_ErrorCode(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__InvalidMessageContentExpressionFaultType_ErrorCode ** SOAP_FMAC4 soap_in_PointerTo_wsnt__InvalidMessageContentExpressionFaultType_ErrorCode(struct soap *soap, const char *tag, struct _wsnt__InvalidMessageContentExpressionFaultType_ErrorCode **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__InvalidMessageContentExpressionFaultType_ErrorCode **)soap_malloc(soap, sizeof(struct _wsnt__InvalidMessageContentExpressionFaultType_ErrorCode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__InvalidMessageContentExpressionFaultType_ErrorCode(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__InvalidMessageContentExpressionFaultType_ErrorCode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__InvalidMessageContentExpressionFaultType_ErrorCode, sizeof(struct _wsnt__InvalidMessageContentExpressionFaultType_ErrorCode), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__InvalidMessageContentExpressionFaultType_ErrorCode(struct soap *soap, struct _wsnt__InvalidMessageContentExpressionFaultType_ErrorCode *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsnt__InvalidMessageContentExpressionFaultType_ErrorCode);
	if (soap_out_PointerTo_wsnt__InvalidMessageContentExpressionFaultType_ErrorCode(soap, tag?tag:"wsnt:InvalidMessageContentExpressionFaultType-ErrorCode", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__InvalidMessageContentExpressionFaultType_ErrorCode ** SOAP_FMAC4 soap_get_PointerTo_wsnt__InvalidMessageContentExpressionFaultType_ErrorCode(struct soap *soap, struct _wsnt__InvalidMessageContentExpressionFaultType_ErrorCode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__InvalidMessageContentExpressionFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause(struct soap *soap, struct _wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause))
		soap_serialize__wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause(struct soap *soap, const char *tag, int id, struct _wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause ** SOAP_FMAC4 soap_in_PointerTo_wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause(struct soap *soap, const char *tag, struct _wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause **)soap_malloc(soap, sizeof(struct _wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause, sizeof(struct _wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause(struct soap *soap, struct _wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause);
	if (soap_out_PointerTo_wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause(soap, tag?tag:"wsnt:InvalidProducerPropertiesExpressionFaultType-FaultCause", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause ** SOAP_FMAC4 soap_get_PointerTo_wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause(struct soap *soap, struct _wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__InvalidProducerPropertiesExpressionFaultType_Description(struct soap *soap, struct _wsnt__InvalidProducerPropertiesExpressionFaultType_Description *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__InvalidProducerPropertiesExpressionFaultType_Description))
		soap_serialize__wsnt__InvalidProducerPropertiesExpressionFaultType_Description(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__InvalidProducerPropertiesExpressionFaultType_Description(struct soap *soap, const char *tag, int id, struct _wsnt__InvalidProducerPropertiesExpressionFaultType_Description *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__InvalidProducerPropertiesExpressionFaultType_Description);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__InvalidProducerPropertiesExpressionFaultType_Description(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__InvalidProducerPropertiesExpressionFaultType_Description ** SOAP_FMAC4 soap_in_PointerTo_wsnt__InvalidProducerPropertiesExpressionFaultType_Description(struct soap *soap, const char *tag, struct _wsnt__InvalidProducerPropertiesExpressionFaultType_Description **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__InvalidProducerPropertiesExpressionFaultType_Description **)soap_malloc(soap, sizeof(struct _wsnt__InvalidProducerPropertiesExpressionFaultType_Description *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__InvalidProducerPropertiesExpressionFaultType_Description(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__InvalidProducerPropertiesExpressionFaultType_Description **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__InvalidProducerPropertiesExpressionFaultType_Description, sizeof(struct _wsnt__InvalidProducerPropertiesExpressionFaultType_Description), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__InvalidProducerPropertiesExpressionFaultType_Description(struct soap *soap, struct _wsnt__InvalidProducerPropertiesExpressionFaultType_Description *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsnt__InvalidProducerPropertiesExpressionFaultType_Description);
	if (soap_out_PointerTo_wsnt__InvalidProducerPropertiesExpressionFaultType_Description(soap, tag?tag:"wsnt:InvalidProducerPropertiesExpressionFaultType-Description", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__InvalidProducerPropertiesExpressionFaultType_Description ** SOAP_FMAC4 soap_get_PointerTo_wsnt__InvalidProducerPropertiesExpressionFaultType_Description(struct soap *soap, struct _wsnt__InvalidProducerPropertiesExpressionFaultType_Description **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__InvalidProducerPropertiesExpressionFaultType_Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode(struct soap *soap, struct _wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode))
		soap_serialize__wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode(struct soap *soap, const char *tag, int id, struct _wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode ** SOAP_FMAC4 soap_in_PointerTo_wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode(struct soap *soap, const char *tag, struct _wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode **)soap_malloc(soap, sizeof(struct _wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode, sizeof(struct _wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode(struct soap *soap, struct _wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode);
	if (soap_out_PointerTo_wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode(soap, tag?tag:"wsnt:InvalidProducerPropertiesExpressionFaultType-ErrorCode", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode ** SOAP_FMAC4 soap_get_PointerTo_wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode(struct soap *soap, struct _wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__MultipleTopicsSpecifiedFaultType_FaultCause(struct soap *soap, struct _wsnt__MultipleTopicsSpecifiedFaultType_FaultCause *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__MultipleTopicsSpecifiedFaultType_FaultCause))
		soap_serialize__wsnt__MultipleTopicsSpecifiedFaultType_FaultCause(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__MultipleTopicsSpecifiedFaultType_FaultCause(struct soap *soap, const char *tag, int id, struct _wsnt__MultipleTopicsSpecifiedFaultType_FaultCause *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__MultipleTopicsSpecifiedFaultType_FaultCause);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__MultipleTopicsSpecifiedFaultType_FaultCause(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__MultipleTopicsSpecifiedFaultType_FaultCause ** SOAP_FMAC4 soap_in_PointerTo_wsnt__MultipleTopicsSpecifiedFaultType_FaultCause(struct soap *soap, const char *tag, struct _wsnt__MultipleTopicsSpecifiedFaultType_FaultCause **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__MultipleTopicsSpecifiedFaultType_FaultCause **)soap_malloc(soap, sizeof(struct _wsnt__MultipleTopicsSpecifiedFaultType_FaultCause *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__MultipleTopicsSpecifiedFaultType_FaultCause(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__MultipleTopicsSpecifiedFaultType_FaultCause **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__MultipleTopicsSpecifiedFaultType_FaultCause, sizeof(struct _wsnt__MultipleTopicsSpecifiedFaultType_FaultCause), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__MultipleTopicsSpecifiedFaultType_FaultCause(struct soap *soap, struct _wsnt__MultipleTopicsSpecifiedFaultType_FaultCause *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsnt__MultipleTopicsSpecifiedFaultType_FaultCause);
	if (soap_out_PointerTo_wsnt__MultipleTopicsSpecifiedFaultType_FaultCause(soap, tag?tag:"wsnt:MultipleTopicsSpecifiedFaultType-FaultCause", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__MultipleTopicsSpecifiedFaultType_FaultCause ** SOAP_FMAC4 soap_get_PointerTo_wsnt__MultipleTopicsSpecifiedFaultType_FaultCause(struct soap *soap, struct _wsnt__MultipleTopicsSpecifiedFaultType_FaultCause **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__MultipleTopicsSpecifiedFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__MultipleTopicsSpecifiedFaultType_Description(struct soap *soap, struct _wsnt__MultipleTopicsSpecifiedFaultType_Description *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__MultipleTopicsSpecifiedFaultType_Description))
		soap_serialize__wsnt__MultipleTopicsSpecifiedFaultType_Description(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__MultipleTopicsSpecifiedFaultType_Description(struct soap *soap, const char *tag, int id, struct _wsnt__MultipleTopicsSpecifiedFaultType_Description *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__MultipleTopicsSpecifiedFaultType_Description);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__MultipleTopicsSpecifiedFaultType_Description(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__MultipleTopicsSpecifiedFaultType_Description ** SOAP_FMAC4 soap_in_PointerTo_wsnt__MultipleTopicsSpecifiedFaultType_Description(struct soap *soap, const char *tag, struct _wsnt__MultipleTopicsSpecifiedFaultType_Description **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__MultipleTopicsSpecifiedFaultType_Description **)soap_malloc(soap, sizeof(struct _wsnt__MultipleTopicsSpecifiedFaultType_Description *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__MultipleTopicsSpecifiedFaultType_Description(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__MultipleTopicsSpecifiedFaultType_Description **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__MultipleTopicsSpecifiedFaultType_Description, sizeof(struct _wsnt__MultipleTopicsSpecifiedFaultType_Description), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__MultipleTopicsSpecifiedFaultType_Description(struct soap *soap, struct _wsnt__MultipleTopicsSpecifiedFaultType_Description *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsnt__MultipleTopicsSpecifiedFaultType_Description);
	if (soap_out_PointerTo_wsnt__MultipleTopicsSpecifiedFaultType_Description(soap, tag?tag:"wsnt:MultipleTopicsSpecifiedFaultType-Description", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__MultipleTopicsSpecifiedFaultType_Description ** SOAP_FMAC4 soap_get_PointerTo_wsnt__MultipleTopicsSpecifiedFaultType_Description(struct soap *soap, struct _wsnt__MultipleTopicsSpecifiedFaultType_Description **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__MultipleTopicsSpecifiedFaultType_Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode(struct soap *soap, struct _wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode))
		soap_serialize__wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode(struct soap *soap, const char *tag, int id, struct _wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode ** SOAP_FMAC4 soap_in_PointerTo_wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode(struct soap *soap, const char *tag, struct _wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode **)soap_malloc(soap, sizeof(struct _wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode, sizeof(struct _wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode(struct soap *soap, struct _wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode);
	if (soap_out_PointerTo_wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode(soap, tag?tag:"wsnt:MultipleTopicsSpecifiedFaultType-ErrorCode", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode ** SOAP_FMAC4 soap_get_PointerTo_wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode(struct soap *soap, struct _wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__TopicNotSupportedFaultType_FaultCause(struct soap *soap, struct _wsnt__TopicNotSupportedFaultType_FaultCause *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__TopicNotSupportedFaultType_FaultCause))
		soap_serialize__wsnt__TopicNotSupportedFaultType_FaultCause(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__TopicNotSupportedFaultType_FaultCause(struct soap *soap, const char *tag, int id, struct _wsnt__TopicNotSupportedFaultType_FaultCause *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__TopicNotSupportedFaultType_FaultCause);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__TopicNotSupportedFaultType_FaultCause(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__TopicNotSupportedFaultType_FaultCause ** SOAP_FMAC4 soap_in_PointerTo_wsnt__TopicNotSupportedFaultType_FaultCause(struct soap *soap, const char *tag, struct _wsnt__TopicNotSupportedFaultType_FaultCause **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__TopicNotSupportedFaultType_FaultCause **)soap_malloc(soap, sizeof(struct _wsnt__TopicNotSupportedFaultType_FaultCause *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__TopicNotSupportedFaultType_FaultCause(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__TopicNotSupportedFaultType_FaultCause **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__TopicNotSupportedFaultType_FaultCause, sizeof(struct _wsnt__TopicNotSupportedFaultType_FaultCause), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__TopicNotSupportedFaultType_FaultCause(struct soap *soap, struct _wsnt__TopicNotSupportedFaultType_FaultCause *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsnt__TopicNotSupportedFaultType_FaultCause);
	if (soap_out_PointerTo_wsnt__TopicNotSupportedFaultType_FaultCause(soap, tag?tag:"wsnt:TopicNotSupportedFaultType-FaultCause", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__TopicNotSupportedFaultType_FaultCause ** SOAP_FMAC4 soap_get_PointerTo_wsnt__TopicNotSupportedFaultType_FaultCause(struct soap *soap, struct _wsnt__TopicNotSupportedFaultType_FaultCause **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__TopicNotSupportedFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__TopicNotSupportedFaultType_Description(struct soap *soap, struct _wsnt__TopicNotSupportedFaultType_Description *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__TopicNotSupportedFaultType_Description))
		soap_serialize__wsnt__TopicNotSupportedFaultType_Description(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__TopicNotSupportedFaultType_Description(struct soap *soap, const char *tag, int id, struct _wsnt__TopicNotSupportedFaultType_Description *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__TopicNotSupportedFaultType_Description);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__TopicNotSupportedFaultType_Description(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__TopicNotSupportedFaultType_Description ** SOAP_FMAC4 soap_in_PointerTo_wsnt__TopicNotSupportedFaultType_Description(struct soap *soap, const char *tag, struct _wsnt__TopicNotSupportedFaultType_Description **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__TopicNotSupportedFaultType_Description **)soap_malloc(soap, sizeof(struct _wsnt__TopicNotSupportedFaultType_Description *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__TopicNotSupportedFaultType_Description(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__TopicNotSupportedFaultType_Description **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__TopicNotSupportedFaultType_Description, sizeof(struct _wsnt__TopicNotSupportedFaultType_Description), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__TopicNotSupportedFaultType_Description(struct soap *soap, struct _wsnt__TopicNotSupportedFaultType_Description *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsnt__TopicNotSupportedFaultType_Description);
	if (soap_out_PointerTo_wsnt__TopicNotSupportedFaultType_Description(soap, tag?tag:"wsnt:TopicNotSupportedFaultType-Description", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__TopicNotSupportedFaultType_Description ** SOAP_FMAC4 soap_get_PointerTo_wsnt__TopicNotSupportedFaultType_Description(struct soap *soap, struct _wsnt__TopicNotSupportedFaultType_Description **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__TopicNotSupportedFaultType_Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__TopicNotSupportedFaultType_ErrorCode(struct soap *soap, struct _wsnt__TopicNotSupportedFaultType_ErrorCode *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__TopicNotSupportedFaultType_ErrorCode))
		soap_serialize__wsnt__TopicNotSupportedFaultType_ErrorCode(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__TopicNotSupportedFaultType_ErrorCode(struct soap *soap, const char *tag, int id, struct _wsnt__TopicNotSupportedFaultType_ErrorCode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__TopicNotSupportedFaultType_ErrorCode);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__TopicNotSupportedFaultType_ErrorCode(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__TopicNotSupportedFaultType_ErrorCode ** SOAP_FMAC4 soap_in_PointerTo_wsnt__TopicNotSupportedFaultType_ErrorCode(struct soap *soap, const char *tag, struct _wsnt__TopicNotSupportedFaultType_ErrorCode **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__TopicNotSupportedFaultType_ErrorCode **)soap_malloc(soap, sizeof(struct _wsnt__TopicNotSupportedFaultType_ErrorCode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__TopicNotSupportedFaultType_ErrorCode(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__TopicNotSupportedFaultType_ErrorCode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__TopicNotSupportedFaultType_ErrorCode, sizeof(struct _wsnt__TopicNotSupportedFaultType_ErrorCode), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__TopicNotSupportedFaultType_ErrorCode(struct soap *soap, struct _wsnt__TopicNotSupportedFaultType_ErrorCode *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsnt__TopicNotSupportedFaultType_ErrorCode);
	if (soap_out_PointerTo_wsnt__TopicNotSupportedFaultType_ErrorCode(soap, tag?tag:"wsnt:TopicNotSupportedFaultType-ErrorCode", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__TopicNotSupportedFaultType_ErrorCode ** SOAP_FMAC4 soap_get_PointerTo_wsnt__TopicNotSupportedFaultType_ErrorCode(struct soap *soap, struct _wsnt__TopicNotSupportedFaultType_ErrorCode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__TopicNotSupportedFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__InvalidTopicExpressionFaultType_FaultCause(struct soap *soap, struct _wsnt__InvalidTopicExpressionFaultType_FaultCause *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__InvalidTopicExpressionFaultType_FaultCause))
		soap_serialize__wsnt__InvalidTopicExpressionFaultType_FaultCause(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__InvalidTopicExpressionFaultType_FaultCause(struct soap *soap, const char *tag, int id, struct _wsnt__InvalidTopicExpressionFaultType_FaultCause *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__InvalidTopicExpressionFaultType_FaultCause);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__InvalidTopicExpressionFaultType_FaultCause(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__InvalidTopicExpressionFaultType_FaultCause ** SOAP_FMAC4 soap_in_PointerTo_wsnt__InvalidTopicExpressionFaultType_FaultCause(struct soap *soap, const char *tag, struct _wsnt__InvalidTopicExpressionFaultType_FaultCause **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__InvalidTopicExpressionFaultType_FaultCause **)soap_malloc(soap, sizeof(struct _wsnt__InvalidTopicExpressionFaultType_FaultCause *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__InvalidTopicExpressionFaultType_FaultCause(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__InvalidTopicExpressionFaultType_FaultCause **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__InvalidTopicExpressionFaultType_FaultCause, sizeof(struct _wsnt__InvalidTopicExpressionFaultType_FaultCause), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__InvalidTopicExpressionFaultType_FaultCause(struct soap *soap, struct _wsnt__InvalidTopicExpressionFaultType_FaultCause *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsnt__InvalidTopicExpressionFaultType_FaultCause);
	if (soap_out_PointerTo_wsnt__InvalidTopicExpressionFaultType_FaultCause(soap, tag?tag:"wsnt:InvalidTopicExpressionFaultType-FaultCause", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__InvalidTopicExpressionFaultType_FaultCause ** SOAP_FMAC4 soap_get_PointerTo_wsnt__InvalidTopicExpressionFaultType_FaultCause(struct soap *soap, struct _wsnt__InvalidTopicExpressionFaultType_FaultCause **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__InvalidTopicExpressionFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__InvalidTopicExpressionFaultType_Description(struct soap *soap, struct _wsnt__InvalidTopicExpressionFaultType_Description *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__InvalidTopicExpressionFaultType_Description))
		soap_serialize__wsnt__InvalidTopicExpressionFaultType_Description(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__InvalidTopicExpressionFaultType_Description(struct soap *soap, const char *tag, int id, struct _wsnt__InvalidTopicExpressionFaultType_Description *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__InvalidTopicExpressionFaultType_Description);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__InvalidTopicExpressionFaultType_Description(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__InvalidTopicExpressionFaultType_Description ** SOAP_FMAC4 soap_in_PointerTo_wsnt__InvalidTopicExpressionFaultType_Description(struct soap *soap, const char *tag, struct _wsnt__InvalidTopicExpressionFaultType_Description **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__InvalidTopicExpressionFaultType_Description **)soap_malloc(soap, sizeof(struct _wsnt__InvalidTopicExpressionFaultType_Description *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__InvalidTopicExpressionFaultType_Description(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__InvalidTopicExpressionFaultType_Description **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__InvalidTopicExpressionFaultType_Description, sizeof(struct _wsnt__InvalidTopicExpressionFaultType_Description), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__InvalidTopicExpressionFaultType_Description(struct soap *soap, struct _wsnt__InvalidTopicExpressionFaultType_Description *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsnt__InvalidTopicExpressionFaultType_Description);
	if (soap_out_PointerTo_wsnt__InvalidTopicExpressionFaultType_Description(soap, tag?tag:"wsnt:InvalidTopicExpressionFaultType-Description", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__InvalidTopicExpressionFaultType_Description ** SOAP_FMAC4 soap_get_PointerTo_wsnt__InvalidTopicExpressionFaultType_Description(struct soap *soap, struct _wsnt__InvalidTopicExpressionFaultType_Description **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__InvalidTopicExpressionFaultType_Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__InvalidTopicExpressionFaultType_ErrorCode(struct soap *soap, struct _wsnt__InvalidTopicExpressionFaultType_ErrorCode *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__InvalidTopicExpressionFaultType_ErrorCode))
		soap_serialize__wsnt__InvalidTopicExpressionFaultType_ErrorCode(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__InvalidTopicExpressionFaultType_ErrorCode(struct soap *soap, const char *tag, int id, struct _wsnt__InvalidTopicExpressionFaultType_ErrorCode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__InvalidTopicExpressionFaultType_ErrorCode);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__InvalidTopicExpressionFaultType_ErrorCode(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__InvalidTopicExpressionFaultType_ErrorCode ** SOAP_FMAC4 soap_in_PointerTo_wsnt__InvalidTopicExpressionFaultType_ErrorCode(struct soap *soap, const char *tag, struct _wsnt__InvalidTopicExpressionFaultType_ErrorCode **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__InvalidTopicExpressionFaultType_ErrorCode **)soap_malloc(soap, sizeof(struct _wsnt__InvalidTopicExpressionFaultType_ErrorCode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__InvalidTopicExpressionFaultType_ErrorCode(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__InvalidTopicExpressionFaultType_ErrorCode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__InvalidTopicExpressionFaultType_ErrorCode, sizeof(struct _wsnt__InvalidTopicExpressionFaultType_ErrorCode), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__InvalidTopicExpressionFaultType_ErrorCode(struct soap *soap, struct _wsnt__InvalidTopicExpressionFaultType_ErrorCode *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsnt__InvalidTopicExpressionFaultType_ErrorCode);
	if (soap_out_PointerTo_wsnt__InvalidTopicExpressionFaultType_ErrorCode(soap, tag?tag:"wsnt:InvalidTopicExpressionFaultType-ErrorCode", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__InvalidTopicExpressionFaultType_ErrorCode ** SOAP_FMAC4 soap_get_PointerTo_wsnt__InvalidTopicExpressionFaultType_ErrorCode(struct soap *soap, struct _wsnt__InvalidTopicExpressionFaultType_ErrorCode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__InvalidTopicExpressionFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__TopicExpressionDialectUnknownFaultType_FaultCause(struct soap *soap, struct _wsnt__TopicExpressionDialectUnknownFaultType_FaultCause *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__TopicExpressionDialectUnknownFaultType_FaultCause))
		soap_serialize__wsnt__TopicExpressionDialectUnknownFaultType_FaultCause(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__TopicExpressionDialectUnknownFaultType_FaultCause(struct soap *soap, const char *tag, int id, struct _wsnt__TopicExpressionDialectUnknownFaultType_FaultCause *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__TopicExpressionDialectUnknownFaultType_FaultCause);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__TopicExpressionDialectUnknownFaultType_FaultCause(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__TopicExpressionDialectUnknownFaultType_FaultCause ** SOAP_FMAC4 soap_in_PointerTo_wsnt__TopicExpressionDialectUnknownFaultType_FaultCause(struct soap *soap, const char *tag, struct _wsnt__TopicExpressionDialectUnknownFaultType_FaultCause **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__TopicExpressionDialectUnknownFaultType_FaultCause **)soap_malloc(soap, sizeof(struct _wsnt__TopicExpressionDialectUnknownFaultType_FaultCause *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__TopicExpressionDialectUnknownFaultType_FaultCause(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__TopicExpressionDialectUnknownFaultType_FaultCause **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__TopicExpressionDialectUnknownFaultType_FaultCause, sizeof(struct _wsnt__TopicExpressionDialectUnknownFaultType_FaultCause), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__TopicExpressionDialectUnknownFaultType_FaultCause(struct soap *soap, struct _wsnt__TopicExpressionDialectUnknownFaultType_FaultCause *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsnt__TopicExpressionDialectUnknownFaultType_FaultCause);
	if (soap_out_PointerTo_wsnt__TopicExpressionDialectUnknownFaultType_FaultCause(soap, tag?tag:"wsnt:TopicExpressionDialectUnknownFaultType-FaultCause", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__TopicExpressionDialectUnknownFaultType_FaultCause ** SOAP_FMAC4 soap_get_PointerTo_wsnt__TopicExpressionDialectUnknownFaultType_FaultCause(struct soap *soap, struct _wsnt__TopicExpressionDialectUnknownFaultType_FaultCause **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__TopicExpressionDialectUnknownFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__TopicExpressionDialectUnknownFaultType_Description(struct soap *soap, struct _wsnt__TopicExpressionDialectUnknownFaultType_Description *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__TopicExpressionDialectUnknownFaultType_Description))
		soap_serialize__wsnt__TopicExpressionDialectUnknownFaultType_Description(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__TopicExpressionDialectUnknownFaultType_Description(struct soap *soap, const char *tag, int id, struct _wsnt__TopicExpressionDialectUnknownFaultType_Description *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__TopicExpressionDialectUnknownFaultType_Description);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__TopicExpressionDialectUnknownFaultType_Description(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__TopicExpressionDialectUnknownFaultType_Description ** SOAP_FMAC4 soap_in_PointerTo_wsnt__TopicExpressionDialectUnknownFaultType_Description(struct soap *soap, const char *tag, struct _wsnt__TopicExpressionDialectUnknownFaultType_Description **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__TopicExpressionDialectUnknownFaultType_Description **)soap_malloc(soap, sizeof(struct _wsnt__TopicExpressionDialectUnknownFaultType_Description *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__TopicExpressionDialectUnknownFaultType_Description(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__TopicExpressionDialectUnknownFaultType_Description **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__TopicExpressionDialectUnknownFaultType_Description, sizeof(struct _wsnt__TopicExpressionDialectUnknownFaultType_Description), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__TopicExpressionDialectUnknownFaultType_Description(struct soap *soap, struct _wsnt__TopicExpressionDialectUnknownFaultType_Description *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsnt__TopicExpressionDialectUnknownFaultType_Description);
	if (soap_out_PointerTo_wsnt__TopicExpressionDialectUnknownFaultType_Description(soap, tag?tag:"wsnt:TopicExpressionDialectUnknownFaultType-Description", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__TopicExpressionDialectUnknownFaultType_Description ** SOAP_FMAC4 soap_get_PointerTo_wsnt__TopicExpressionDialectUnknownFaultType_Description(struct soap *soap, struct _wsnt__TopicExpressionDialectUnknownFaultType_Description **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__TopicExpressionDialectUnknownFaultType_Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode(struct soap *soap, struct _wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode))
		soap_serialize__wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode(struct soap *soap, const char *tag, int id, struct _wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode ** SOAP_FMAC4 soap_in_PointerTo_wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode(struct soap *soap, const char *tag, struct _wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode **)soap_malloc(soap, sizeof(struct _wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode, sizeof(struct _wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode(struct soap *soap, struct _wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode);
	if (soap_out_PointerTo_wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode(soap, tag?tag:"wsnt:TopicExpressionDialectUnknownFaultType-ErrorCode", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode ** SOAP_FMAC4 soap_get_PointerTo_wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode(struct soap *soap, struct _wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__InvalidFilterFaultType_FaultCause(struct soap *soap, struct _wsnt__InvalidFilterFaultType_FaultCause *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__InvalidFilterFaultType_FaultCause))
		soap_serialize__wsnt__InvalidFilterFaultType_FaultCause(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__InvalidFilterFaultType_FaultCause(struct soap *soap, const char *tag, int id, struct _wsnt__InvalidFilterFaultType_FaultCause *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__InvalidFilterFaultType_FaultCause);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__InvalidFilterFaultType_FaultCause(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__InvalidFilterFaultType_FaultCause ** SOAP_FMAC4 soap_in_PointerTo_wsnt__InvalidFilterFaultType_FaultCause(struct soap *soap, const char *tag, struct _wsnt__InvalidFilterFaultType_FaultCause **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__InvalidFilterFaultType_FaultCause **)soap_malloc(soap, sizeof(struct _wsnt__InvalidFilterFaultType_FaultCause *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__InvalidFilterFaultType_FaultCause(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__InvalidFilterFaultType_FaultCause **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__InvalidFilterFaultType_FaultCause, sizeof(struct _wsnt__InvalidFilterFaultType_FaultCause), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__InvalidFilterFaultType_FaultCause(struct soap *soap, struct _wsnt__InvalidFilterFaultType_FaultCause *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsnt__InvalidFilterFaultType_FaultCause);
	if (soap_out_PointerTo_wsnt__InvalidFilterFaultType_FaultCause(soap, tag?tag:"wsnt:InvalidFilterFaultType-FaultCause", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__InvalidFilterFaultType_FaultCause ** SOAP_FMAC4 soap_get_PointerTo_wsnt__InvalidFilterFaultType_FaultCause(struct soap *soap, struct _wsnt__InvalidFilterFaultType_FaultCause **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__InvalidFilterFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__InvalidFilterFaultType_Description(struct soap *soap, struct _wsnt__InvalidFilterFaultType_Description *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__InvalidFilterFaultType_Description))
		soap_serialize__wsnt__InvalidFilterFaultType_Description(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__InvalidFilterFaultType_Description(struct soap *soap, const char *tag, int id, struct _wsnt__InvalidFilterFaultType_Description *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__InvalidFilterFaultType_Description);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__InvalidFilterFaultType_Description(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__InvalidFilterFaultType_Description ** SOAP_FMAC4 soap_in_PointerTo_wsnt__InvalidFilterFaultType_Description(struct soap *soap, const char *tag, struct _wsnt__InvalidFilterFaultType_Description **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__InvalidFilterFaultType_Description **)soap_malloc(soap, sizeof(struct _wsnt__InvalidFilterFaultType_Description *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__InvalidFilterFaultType_Description(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__InvalidFilterFaultType_Description **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__InvalidFilterFaultType_Description, sizeof(struct _wsnt__InvalidFilterFaultType_Description), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__InvalidFilterFaultType_Description(struct soap *soap, struct _wsnt__InvalidFilterFaultType_Description *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsnt__InvalidFilterFaultType_Description);
	if (soap_out_PointerTo_wsnt__InvalidFilterFaultType_Description(soap, tag?tag:"wsnt:InvalidFilterFaultType-Description", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__InvalidFilterFaultType_Description ** SOAP_FMAC4 soap_get_PointerTo_wsnt__InvalidFilterFaultType_Description(struct soap *soap, struct _wsnt__InvalidFilterFaultType_Description **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__InvalidFilterFaultType_Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__InvalidFilterFaultType_ErrorCode(struct soap *soap, struct _wsnt__InvalidFilterFaultType_ErrorCode *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__InvalidFilterFaultType_ErrorCode))
		soap_serialize__wsnt__InvalidFilterFaultType_ErrorCode(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__InvalidFilterFaultType_ErrorCode(struct soap *soap, const char *tag, int id, struct _wsnt__InvalidFilterFaultType_ErrorCode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__InvalidFilterFaultType_ErrorCode);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__InvalidFilterFaultType_ErrorCode(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__InvalidFilterFaultType_ErrorCode ** SOAP_FMAC4 soap_in_PointerTo_wsnt__InvalidFilterFaultType_ErrorCode(struct soap *soap, const char *tag, struct _wsnt__InvalidFilterFaultType_ErrorCode **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__InvalidFilterFaultType_ErrorCode **)soap_malloc(soap, sizeof(struct _wsnt__InvalidFilterFaultType_ErrorCode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__InvalidFilterFaultType_ErrorCode(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__InvalidFilterFaultType_ErrorCode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__InvalidFilterFaultType_ErrorCode, sizeof(struct _wsnt__InvalidFilterFaultType_ErrorCode), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__InvalidFilterFaultType_ErrorCode(struct soap *soap, struct _wsnt__InvalidFilterFaultType_ErrorCode *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsnt__InvalidFilterFaultType_ErrorCode);
	if (soap_out_PointerTo_wsnt__InvalidFilterFaultType_ErrorCode(soap, tag?tag:"wsnt:InvalidFilterFaultType-ErrorCode", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__InvalidFilterFaultType_ErrorCode ** SOAP_FMAC4 soap_get_PointerTo_wsnt__InvalidFilterFaultType_ErrorCode(struct soap *soap, struct _wsnt__InvalidFilterFaultType_ErrorCode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__InvalidFilterFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__SubscribeCreationFailedFaultType_FaultCause(struct soap *soap, struct _wsnt__SubscribeCreationFailedFaultType_FaultCause *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__SubscribeCreationFailedFaultType_FaultCause))
		soap_serialize__wsnt__SubscribeCreationFailedFaultType_FaultCause(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__SubscribeCreationFailedFaultType_FaultCause(struct soap *soap, const char *tag, int id, struct _wsnt__SubscribeCreationFailedFaultType_FaultCause *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__SubscribeCreationFailedFaultType_FaultCause);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__SubscribeCreationFailedFaultType_FaultCause(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__SubscribeCreationFailedFaultType_FaultCause ** SOAP_FMAC4 soap_in_PointerTo_wsnt__SubscribeCreationFailedFaultType_FaultCause(struct soap *soap, const char *tag, struct _wsnt__SubscribeCreationFailedFaultType_FaultCause **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__SubscribeCreationFailedFaultType_FaultCause **)soap_malloc(soap, sizeof(struct _wsnt__SubscribeCreationFailedFaultType_FaultCause *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__SubscribeCreationFailedFaultType_FaultCause(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__SubscribeCreationFailedFaultType_FaultCause **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__SubscribeCreationFailedFaultType_FaultCause, sizeof(struct _wsnt__SubscribeCreationFailedFaultType_FaultCause), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__SubscribeCreationFailedFaultType_FaultCause(struct soap *soap, struct _wsnt__SubscribeCreationFailedFaultType_FaultCause *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsnt__SubscribeCreationFailedFaultType_FaultCause);
	if (soap_out_PointerTo_wsnt__SubscribeCreationFailedFaultType_FaultCause(soap, tag?tag:"wsnt:SubscribeCreationFailedFaultType-FaultCause", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__SubscribeCreationFailedFaultType_FaultCause ** SOAP_FMAC4 soap_get_PointerTo_wsnt__SubscribeCreationFailedFaultType_FaultCause(struct soap *soap, struct _wsnt__SubscribeCreationFailedFaultType_FaultCause **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__SubscribeCreationFailedFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__SubscribeCreationFailedFaultType_Description(struct soap *soap, struct _wsnt__SubscribeCreationFailedFaultType_Description *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__SubscribeCreationFailedFaultType_Description))
		soap_serialize__wsnt__SubscribeCreationFailedFaultType_Description(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__SubscribeCreationFailedFaultType_Description(struct soap *soap, const char *tag, int id, struct _wsnt__SubscribeCreationFailedFaultType_Description *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__SubscribeCreationFailedFaultType_Description);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__SubscribeCreationFailedFaultType_Description(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__SubscribeCreationFailedFaultType_Description ** SOAP_FMAC4 soap_in_PointerTo_wsnt__SubscribeCreationFailedFaultType_Description(struct soap *soap, const char *tag, struct _wsnt__SubscribeCreationFailedFaultType_Description **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__SubscribeCreationFailedFaultType_Description **)soap_malloc(soap, sizeof(struct _wsnt__SubscribeCreationFailedFaultType_Description *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__SubscribeCreationFailedFaultType_Description(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__SubscribeCreationFailedFaultType_Description **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__SubscribeCreationFailedFaultType_Description, sizeof(struct _wsnt__SubscribeCreationFailedFaultType_Description), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__SubscribeCreationFailedFaultType_Description(struct soap *soap, struct _wsnt__SubscribeCreationFailedFaultType_Description *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsnt__SubscribeCreationFailedFaultType_Description);
	if (soap_out_PointerTo_wsnt__SubscribeCreationFailedFaultType_Description(soap, tag?tag:"wsnt:SubscribeCreationFailedFaultType-Description", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__SubscribeCreationFailedFaultType_Description ** SOAP_FMAC4 soap_get_PointerTo_wsnt__SubscribeCreationFailedFaultType_Description(struct soap *soap, struct _wsnt__SubscribeCreationFailedFaultType_Description **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__SubscribeCreationFailedFaultType_Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__SubscribeCreationFailedFaultType_ErrorCode(struct soap *soap, struct _wsnt__SubscribeCreationFailedFaultType_ErrorCode *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__SubscribeCreationFailedFaultType_ErrorCode))
		soap_serialize__wsnt__SubscribeCreationFailedFaultType_ErrorCode(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__SubscribeCreationFailedFaultType_ErrorCode(struct soap *soap, const char *tag, int id, struct _wsnt__SubscribeCreationFailedFaultType_ErrorCode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__SubscribeCreationFailedFaultType_ErrorCode);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__SubscribeCreationFailedFaultType_ErrorCode(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__SubscribeCreationFailedFaultType_ErrorCode ** SOAP_FMAC4 soap_in_PointerTo_wsnt__SubscribeCreationFailedFaultType_ErrorCode(struct soap *soap, const char *tag, struct _wsnt__SubscribeCreationFailedFaultType_ErrorCode **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__SubscribeCreationFailedFaultType_ErrorCode **)soap_malloc(soap, sizeof(struct _wsnt__SubscribeCreationFailedFaultType_ErrorCode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__SubscribeCreationFailedFaultType_ErrorCode(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__SubscribeCreationFailedFaultType_ErrorCode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__SubscribeCreationFailedFaultType_ErrorCode, sizeof(struct _wsnt__SubscribeCreationFailedFaultType_ErrorCode), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__SubscribeCreationFailedFaultType_ErrorCode(struct soap *soap, struct _wsnt__SubscribeCreationFailedFaultType_ErrorCode *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsnt__SubscribeCreationFailedFaultType_ErrorCode);
	if (soap_out_PointerTo_wsnt__SubscribeCreationFailedFaultType_ErrorCode(soap, tag?tag:"wsnt:SubscribeCreationFailedFaultType-ErrorCode", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__SubscribeCreationFailedFaultType_ErrorCode ** SOAP_FMAC4 soap_get_PointerTo_wsnt__SubscribeCreationFailedFaultType_ErrorCode(struct soap *soap, struct _wsnt__SubscribeCreationFailedFaultType_ErrorCode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__SubscribeCreationFailedFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__MetadataInput(struct soap *soap, struct tt__MetadataInput *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__MetadataInput))
		soap_serialize_tt__MetadataInput(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__MetadataInput(struct soap *soap, const char *tag, int id, struct tt__MetadataInput *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__MetadataInput);
	if (id < 0)
		return soap->error;
	return soap_out_tt__MetadataInput(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__MetadataInput ** SOAP_FMAC4 soap_in_PointerTott__MetadataInput(struct soap *soap, const char *tag, struct tt__MetadataInput **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__MetadataInput **)soap_malloc(soap, sizeof(struct tt__MetadataInput *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__MetadataInput(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__MetadataInput **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__MetadataInput, sizeof(struct tt__MetadataInput), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__MetadataInput(struct soap *soap, struct tt__MetadataInput *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__MetadataInput);
	if (soap_out_PointerTott__MetadataInput(soap, tag?tag:"tt:MetadataInput", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__MetadataInput ** SOAP_FMAC4 soap_get_PointerTott__MetadataInput(struct soap *soap, struct tt__MetadataInput **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__MetadataInput(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__SourceIdentification(struct soap *soap, struct tt__SourceIdentification *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__SourceIdentification))
		soap_serialize_tt__SourceIdentification(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__SourceIdentification(struct soap *soap, const char *tag, int id, struct tt__SourceIdentification *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__SourceIdentification);
	if (id < 0)
		return soap->error;
	return soap_out_tt__SourceIdentification(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__SourceIdentification ** SOAP_FMAC4 soap_in_PointerTott__SourceIdentification(struct soap *soap, const char *tag, struct tt__SourceIdentification **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__SourceIdentification **)soap_malloc(soap, sizeof(struct tt__SourceIdentification *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__SourceIdentification(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__SourceIdentification **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__SourceIdentification, sizeof(struct tt__SourceIdentification), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__SourceIdentification(struct soap *soap, struct tt__SourceIdentification *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__SourceIdentification);
	if (soap_out_PointerTott__SourceIdentification(soap, tag?tag:"tt:SourceIdentification", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__SourceIdentification ** SOAP_FMAC4 soap_get_PointerTott__SourceIdentification(struct soap *soap, struct tt__SourceIdentification **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__SourceIdentification(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__AnalyticsDeviceEngineConfiguration(struct soap *soap, struct tt__AnalyticsDeviceEngineConfiguration *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__AnalyticsDeviceEngineConfiguration))
		soap_serialize_tt__AnalyticsDeviceEngineConfiguration(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__AnalyticsDeviceEngineConfiguration(struct soap *soap, const char *tag, int id, struct tt__AnalyticsDeviceEngineConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__AnalyticsDeviceEngineConfiguration);
	if (id < 0)
		return soap->error;
	return soap_out_tt__AnalyticsDeviceEngineConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__AnalyticsDeviceEngineConfiguration ** SOAP_FMAC4 soap_in_PointerTott__AnalyticsDeviceEngineConfiguration(struct soap *soap, const char *tag, struct tt__AnalyticsDeviceEngineConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__AnalyticsDeviceEngineConfiguration **)soap_malloc(soap, sizeof(struct tt__AnalyticsDeviceEngineConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__AnalyticsDeviceEngineConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__AnalyticsDeviceEngineConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AnalyticsDeviceEngineConfiguration, sizeof(struct tt__AnalyticsDeviceEngineConfiguration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__AnalyticsDeviceEngineConfiguration(struct soap *soap, struct tt__AnalyticsDeviceEngineConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__AnalyticsDeviceEngineConfiguration);
	if (soap_out_PointerTott__AnalyticsDeviceEngineConfiguration(soap, tag?tag:"tt:AnalyticsDeviceEngineConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AnalyticsDeviceEngineConfiguration ** SOAP_FMAC4 soap_get_PointerTott__AnalyticsDeviceEngineConfiguration(struct soap *soap, struct tt__AnalyticsDeviceEngineConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__AnalyticsDeviceEngineConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ObjectExtension(struct soap *soap, struct tt__ObjectExtension *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ObjectExtension))
		soap_serialize_tt__ObjectExtension(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ObjectExtension(struct soap *soap, const char *tag, int id, struct tt__ObjectExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ObjectExtension);
	if (id < 0)
		return soap->error;
	return soap_out_tt__ObjectExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__ObjectExtension ** SOAP_FMAC4 soap_in_PointerTott__ObjectExtension(struct soap *soap, const char *tag, struct tt__ObjectExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__ObjectExtension **)soap_malloc(soap, sizeof(struct tt__ObjectExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__ObjectExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__ObjectExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ObjectExtension, sizeof(struct tt__ObjectExtension), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ObjectExtension(struct soap *soap, struct tt__ObjectExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__ObjectExtension);
	if (soap_out_PointerTott__ObjectExtension(soap, tag?tag:"tt:ObjectExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ObjectExtension ** SOAP_FMAC4 soap_get_PointerTott__ObjectExtension(struct soap *soap, struct tt__ObjectExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ObjectExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Behaviour(struct soap *soap, struct tt__Behaviour *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Behaviour))
		soap_serialize_tt__Behaviour(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Behaviour(struct soap *soap, const char *tag, int id, struct tt__Behaviour *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Behaviour);
	if (id < 0)
		return soap->error;
	return soap_out_tt__Behaviour(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__Behaviour ** SOAP_FMAC4 soap_in_PointerTott__Behaviour(struct soap *soap, const char *tag, struct tt__Behaviour **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__Behaviour **)soap_malloc(soap, sizeof(struct tt__Behaviour *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__Behaviour(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__Behaviour **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Behaviour, sizeof(struct tt__Behaviour), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Behaviour(struct soap *soap, struct tt__Behaviour *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__Behaviour);
	if (soap_out_PointerTott__Behaviour(soap, tag?tag:"tt:Behaviour", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Behaviour ** SOAP_FMAC4 soap_get_PointerTott__Behaviour(struct soap *soap, struct tt__Behaviour **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Behaviour(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Appearance(struct soap *soap, struct tt__Appearance *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Appearance))
		soap_serialize_tt__Appearance(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Appearance(struct soap *soap, const char *tag, int id, struct tt__Appearance *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Appearance);
	if (id < 0)
		return soap->error;
	return soap_out_tt__Appearance(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__Appearance ** SOAP_FMAC4 soap_in_PointerTott__Appearance(struct soap *soap, const char *tag, struct tt__Appearance **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__Appearance **)soap_malloc(soap, sizeof(struct tt__Appearance *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__Appearance(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__Appearance **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Appearance, sizeof(struct tt__Appearance), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Appearance(struct soap *soap, struct tt__Appearance *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__Appearance);
	if (soap_out_PointerTott__Appearance(soap, tag?tag:"tt:Appearance", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Appearance ** SOAP_FMAC4 soap_get_PointerTott__Appearance(struct soap *soap, struct tt__Appearance **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Appearance(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PTZConfigurationExtension(struct soap *soap, struct tt__PTZConfigurationExtension *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PTZConfigurationExtension))
		soap_serialize_tt__PTZConfigurationExtension(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PTZConfigurationExtension(struct soap *soap, const char *tag, int id, struct tt__PTZConfigurationExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PTZConfigurationExtension);
	if (id < 0)
		return soap->error;
	return soap_out_tt__PTZConfigurationExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__PTZConfigurationExtension ** SOAP_FMAC4 soap_in_PointerTott__PTZConfigurationExtension(struct soap *soap, const char *tag, struct tt__PTZConfigurationExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__PTZConfigurationExtension **)soap_malloc(soap, sizeof(struct tt__PTZConfigurationExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__PTZConfigurationExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__PTZConfigurationExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTZConfigurationExtension, sizeof(struct tt__PTZConfigurationExtension), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PTZConfigurationExtension(struct soap *soap, struct tt__PTZConfigurationExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__PTZConfigurationExtension);
	if (soap_out_PointerTott__PTZConfigurationExtension(soap, tag?tag:"tt:PTZConfigurationExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PTZConfigurationExtension ** SOAP_FMAC4 soap_get_PointerTott__PTZConfigurationExtension(struct soap *soap, struct tt__PTZConfigurationExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PTZConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ZoomLimits(struct soap *soap, struct tt__ZoomLimits *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ZoomLimits))
		soap_serialize_tt__ZoomLimits(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ZoomLimits(struct soap *soap, const char *tag, int id, struct tt__ZoomLimits *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ZoomLimits);
	if (id < 0)
		return soap->error;
	return soap_out_tt__ZoomLimits(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__ZoomLimits ** SOAP_FMAC4 soap_in_PointerTott__ZoomLimits(struct soap *soap, const char *tag, struct tt__ZoomLimits **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__ZoomLimits **)soap_malloc(soap, sizeof(struct tt__ZoomLimits *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__ZoomLimits(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__ZoomLimits **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ZoomLimits, sizeof(struct tt__ZoomLimits), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ZoomLimits(struct soap *soap, struct tt__ZoomLimits *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__ZoomLimits);
	if (soap_out_PointerTott__ZoomLimits(soap, tag?tag:"tt:ZoomLimits", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ZoomLimits ** SOAP_FMAC4 soap_get_PointerTott__ZoomLimits(struct soap *soap, struct tt__ZoomLimits **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ZoomLimits(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PanTiltLimits(struct soap *soap, struct tt__PanTiltLimits *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PanTiltLimits))
		soap_serialize_tt__PanTiltLimits(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PanTiltLimits(struct soap *soap, const char *tag, int id, struct tt__PanTiltLimits *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PanTiltLimits);
	if (id < 0)
		return soap->error;
	return soap_out_tt__PanTiltLimits(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__PanTiltLimits ** SOAP_FMAC4 soap_in_PointerTott__PanTiltLimits(struct soap *soap, const char *tag, struct tt__PanTiltLimits **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__PanTiltLimits **)soap_malloc(soap, sizeof(struct tt__PanTiltLimits *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__PanTiltLimits(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__PanTiltLimits **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PanTiltLimits, sizeof(struct tt__PanTiltLimits), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PanTiltLimits(struct soap *soap, struct tt__PanTiltLimits *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__PanTiltLimits);
	if (soap_out_PointerTott__PanTiltLimits(soap, tag?tag:"tt:PanTiltLimits", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PanTiltLimits ** SOAP_FMAC4 soap_get_PointerTott__PanTiltLimits(struct soap *soap, struct tt__PanTiltLimits **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PanTiltLimits(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PTZNodeExtension(struct soap *soap, struct tt__PTZNodeExtension *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PTZNodeExtension))
		soap_serialize_tt__PTZNodeExtension(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PTZNodeExtension(struct soap *soap, const char *tag, int id, struct tt__PTZNodeExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PTZNodeExtension);
	if (id < 0)
		return soap->error;
	return soap_out_tt__PTZNodeExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__PTZNodeExtension ** SOAP_FMAC4 soap_in_PointerTott__PTZNodeExtension(struct soap *soap, const char *tag, struct tt__PTZNodeExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__PTZNodeExtension **)soap_malloc(soap, sizeof(struct tt__PTZNodeExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__PTZNodeExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__PTZNodeExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTZNodeExtension, sizeof(struct tt__PTZNodeExtension), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PTZNodeExtension(struct soap *soap, struct tt__PTZNodeExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__PTZNodeExtension);
	if (soap_out_PointerTott__PTZNodeExtension(soap, tag?tag:"tt:PTZNodeExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PTZNodeExtension ** SOAP_FMAC4 soap_get_PointerTott__PTZNodeExtension(struct soap *soap, struct tt__PTZNodeExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PTZNodeExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__NetworkInterfaceExtension(struct soap *soap, struct tt__NetworkInterfaceExtension *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__NetworkInterfaceExtension))
		soap_serialize_tt__NetworkInterfaceExtension(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__NetworkInterfaceExtension(struct soap *soap, const char *tag, int id, struct tt__NetworkInterfaceExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__NetworkInterfaceExtension);
	if (id < 0)
		return soap->error;
	return soap_out_tt__NetworkInterfaceExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__NetworkInterfaceExtension ** SOAP_FMAC4 soap_in_PointerTott__NetworkInterfaceExtension(struct soap *soap, const char *tag, struct tt__NetworkInterfaceExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__NetworkInterfaceExtension **)soap_malloc(soap, sizeof(struct tt__NetworkInterfaceExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__NetworkInterfaceExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__NetworkInterfaceExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__NetworkInterfaceExtension, sizeof(struct tt__NetworkInterfaceExtension), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__NetworkInterfaceExtension(struct soap *soap, struct tt__NetworkInterfaceExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__NetworkInterfaceExtension);
	if (soap_out_PointerTott__NetworkInterfaceExtension(soap, tag?tag:"tt:NetworkInterfaceExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__NetworkInterfaceExtension ** SOAP_FMAC4 soap_get_PointerTott__NetworkInterfaceExtension(struct soap *soap, struct tt__NetworkInterfaceExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__NetworkInterfaceExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__IPv6NetworkInterface(struct soap *soap, struct tt__IPv6NetworkInterface *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__IPv6NetworkInterface))
		soap_serialize_tt__IPv6NetworkInterface(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__IPv6NetworkInterface(struct soap *soap, const char *tag, int id, struct tt__IPv6NetworkInterface *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__IPv6NetworkInterface);
	if (id < 0)
		return soap->error;
	return soap_out_tt__IPv6NetworkInterface(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__IPv6NetworkInterface ** SOAP_FMAC4 soap_in_PointerTott__IPv6NetworkInterface(struct soap *soap, const char *tag, struct tt__IPv6NetworkInterface **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__IPv6NetworkInterface **)soap_malloc(soap, sizeof(struct tt__IPv6NetworkInterface *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__IPv6NetworkInterface(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__IPv6NetworkInterface **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__IPv6NetworkInterface, sizeof(struct tt__IPv6NetworkInterface), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__IPv6NetworkInterface(struct soap *soap, struct tt__IPv6NetworkInterface *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__IPv6NetworkInterface);
	if (soap_out_PointerTott__IPv6NetworkInterface(soap, tag?tag:"tt:IPv6NetworkInterface", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__IPv6NetworkInterface ** SOAP_FMAC4 soap_get_PointerTott__IPv6NetworkInterface(struct soap *soap, struct tt__IPv6NetworkInterface **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__IPv6NetworkInterface(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__IPv4NetworkInterface(struct soap *soap, struct tt__IPv4NetworkInterface *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__IPv4NetworkInterface))
		soap_serialize_tt__IPv4NetworkInterface(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__IPv4NetworkInterface(struct soap *soap, const char *tag, int id, struct tt__IPv4NetworkInterface *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__IPv4NetworkInterface);
	if (id < 0)
		return soap->error;
	return soap_out_tt__IPv4NetworkInterface(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__IPv4NetworkInterface ** SOAP_FMAC4 soap_in_PointerTott__IPv4NetworkInterface(struct soap *soap, const char *tag, struct tt__IPv4NetworkInterface **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__IPv4NetworkInterface **)soap_malloc(soap, sizeof(struct tt__IPv4NetworkInterface *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__IPv4NetworkInterface(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__IPv4NetworkInterface **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__IPv4NetworkInterface, sizeof(struct tt__IPv4NetworkInterface), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__IPv4NetworkInterface(struct soap *soap, struct tt__IPv4NetworkInterface *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__IPv4NetworkInterface);
	if (soap_out_PointerTott__IPv4NetworkInterface(soap, tag?tag:"tt:IPv4NetworkInterface", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__IPv4NetworkInterface ** SOAP_FMAC4 soap_get_PointerTott__IPv4NetworkInterface(struct soap *soap, struct tt__IPv4NetworkInterface **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__IPv4NetworkInterface(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__NetworkInterfaceLink(struct soap *soap, struct tt__NetworkInterfaceLink *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__NetworkInterfaceLink))
		soap_serialize_tt__NetworkInterfaceLink(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__NetworkInterfaceLink(struct soap *soap, const char *tag, int id, struct tt__NetworkInterfaceLink *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__NetworkInterfaceLink);
	if (id < 0)
		return soap->error;
	return soap_out_tt__NetworkInterfaceLink(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__NetworkInterfaceLink ** SOAP_FMAC4 soap_in_PointerTott__NetworkInterfaceLink(struct soap *soap, const char *tag, struct tt__NetworkInterfaceLink **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__NetworkInterfaceLink **)soap_malloc(soap, sizeof(struct tt__NetworkInterfaceLink *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__NetworkInterfaceLink(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__NetworkInterfaceLink **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__NetworkInterfaceLink, sizeof(struct tt__NetworkInterfaceLink), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__NetworkInterfaceLink(struct soap *soap, struct tt__NetworkInterfaceLink *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__NetworkInterfaceLink);
	if (soap_out_PointerTott__NetworkInterfaceLink(soap, tag?tag:"tt:NetworkInterfaceLink", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__NetworkInterfaceLink ** SOAP_FMAC4 soap_get_PointerTott__NetworkInterfaceLink(struct soap *soap, struct tt__NetworkInterfaceLink **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__NetworkInterfaceLink(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__NetworkInterfaceInfo(struct soap *soap, struct tt__NetworkInterfaceInfo *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__NetworkInterfaceInfo))
		soap_serialize_tt__NetworkInterfaceInfo(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__NetworkInterfaceInfo(struct soap *soap, const char *tag, int id, struct tt__NetworkInterfaceInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__NetworkInterfaceInfo);
	if (id < 0)
		return soap->error;
	return soap_out_tt__NetworkInterfaceInfo(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__NetworkInterfaceInfo ** SOAP_FMAC4 soap_in_PointerTott__NetworkInterfaceInfo(struct soap *soap, const char *tag, struct tt__NetworkInterfaceInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__NetworkInterfaceInfo **)soap_malloc(soap, sizeof(struct tt__NetworkInterfaceInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__NetworkInterfaceInfo(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__NetworkInterfaceInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__NetworkInterfaceInfo, sizeof(struct tt__NetworkInterfaceInfo), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__NetworkInterfaceInfo(struct soap *soap, struct tt__NetworkInterfaceInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__NetworkInterfaceInfo);
	if (soap_out_PointerTott__NetworkInterfaceInfo(soap, tag?tag:"tt:NetworkInterfaceInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__NetworkInterfaceInfo ** SOAP_FMAC4 soap_get_PointerTott__NetworkInterfaceInfo(struct soap *soap, struct tt__NetworkInterfaceInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__NetworkInterfaceInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__VideoOutputExtension(struct soap *soap, struct tt__VideoOutputExtension *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__VideoOutputExtension))
		soap_serialize_tt__VideoOutputExtension(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__VideoOutputExtension(struct soap *soap, const char *tag, int id, struct tt__VideoOutputExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__VideoOutputExtension);
	if (id < 0)
		return soap->error;
	return soap_out_tt__VideoOutputExtension(soap, tag, id, *a, type);
}


#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of soapC.c */
